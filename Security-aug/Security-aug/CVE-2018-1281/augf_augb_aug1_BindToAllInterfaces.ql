/**
 * @name Socket binding to all network interfaces
 * @description Binding sockets to wildcard addresses (0.0.0.0, ::) exposes services to all network interfaces,
 * increasing attack surface and violating security best practices.
 * @kind problem
 * @tags security
 *       external/cwe/cwe-200
 * @problem.severity error
 * @security-severity 6.5
 * @sub-severity low
 * @precision high
 * @id py/bind-socket-all-network-interfaces
 */

import python
import semmle.python.dataflow.new.DataFlow
import semmle.python.ApiGraphs

/** Defines all wildcard addresses representing universal network interfaces */
private string universalAddressValue() {
  result in [
      // IPv4 universal addresses
      "0.0.0.0", "",
      // IPv6 universal addresses
      "::", "::0"
    ]
}

/** Tracks wildcard address propagation through data flow paths */
private DataFlow::TypeTrackingNode trackAddressFlow(DataFlow::TypeTracker flowTracker, string wildcardAddr) {
  // Base case: Direct string literals
  flowTracker.start() and
  exists(StringLiteral addressLiteral | 
    wildcardAddr = universalAddressValue() and
    addressLiteral.getText() = wildcardAddr and
    result.asExpr() = addressLiteral
  )
  or
  // Recursive case: Flow propagation
  exists(DataFlow::TypeTracker priorTracker | 
    result = trackAddressFlow(priorTracker, wildcardAddr).track(priorTracker, flowTracker)
  )
}

/** Retrieves data flow nodes containing wildcard addresses */
DataFlow::Node addressNode(string wildcardAddr) {
  trackAddressFlow(DataFlow::TypeTracker::end(), wildcardAddr).flowsTo(result)
}

/** Tracks address tuples containing wildcard addresses as first element */
private DataFlow::TypeTrackingNode trackAddressTupleFlow(DataFlow::TypeTracker flowTracker, string wildcardAddr) {
  // Base case: Direct tuple construction
  flowTracker.start() and
  exists(Tuple addressTuple | 
    addressTuple.getElt(0) = addressNode(wildcardAddr).asExpr() and
    result.asExpr() = addressTuple
  )
  or
  // Recursive case: Flow propagation
  exists(DataFlow::TypeTracker priorTracker | 
    result = trackAddressTupleFlow(priorTracker, wildcardAddr).track(priorTracker, flowTracker)
  )
}

/** Retrieves data flow nodes containing address tuples with wildcard addresses */
DataFlow::Node addressTupleNode(string wildcardAddr) {
  trackAddressTupleFlow(DataFlow::TypeTracker::end(), wildcardAddr).flowsTo(result)
}

/**
 * Identifies socket constructor instances.
 * 
 * Reference: https://docs.python.org/3/library/socket.html
 */
API::Node socketConstructor() { 
  result = API::moduleImport("socket").getMember("socket").getReturn() 
}

from DataFlow::CallCfgNode socketBindCall, DataFlow::Node addressArgument, string wildcardAddr
where
  // Identify socket.bind() calls
  socketBindCall = socketConstructor().getMember("bind").getACall() and
  // Get first argument (address parameter)
  addressArgument = socketBindCall.getArg(0) and
  // Check if address contains wildcard
  addressArgument = addressTupleNode(wildcardAddr)
select socketBindCall.asExpr(), "Socket bound to all interfaces using wildcard address '" + wildcardAddr + "'."