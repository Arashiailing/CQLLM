[
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Importing value of mutable attribute\n * @description Detects when a mutable attribute is imported from a module, \n *              which prevents local observation of changes made to that attribute\n *              in the source module.\n * @kind problem\n * @tags reliability\n *       maintainability\n_______________ // 补全条件\n * @problem.severity warning\n * @sub-severity high\n * @precision medium\n * @id py/import-of-mutable-attribute\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom ImportMember importedAttribute, ModuleValue sourceMod, AttrNode modifiedAttribute, string attributeName\nwhere\n  // Attribute name consistency: imported and modified attributes share the same name\n  importedAttribute.getName() = attributeName and\n  \n  // Module relationship: source module is properly imported via import expression\n  sourceMod.importedAs(importedAttribute.getModule().(ImportExpr).getImportedModuleName()) and\n  \n  // Modification operation: attribute is being stored/modified in source module context\n  modifiedAttribute.isStore() and\n  modifiedAttribute.getObject(attributeName).pointsTo(sourceMod) and\n  \n  // Scope constraints: import occurs at module level, modification within function scope\n  not importedAttribute.getScope() instanceof Function and\n  modifiedAttribute.getScope() instanceof Function and\n  \n  // Module isolation: import and modification occur in different modules\n  not importedAttribute.getEnclosingModule() = modifiedAttribute.getScope().getEnclosingModule() and\n  \n  // Test exclusion: modification doesn't occur in test code\n  not modifiedAttribute.getScope().getScope*() instanceof TestScope\nselect importedAttribute,\n  \"Importing the value of '\" + attributeName +\n    \"' from $@ means that any change made to $@ will not be observed locally.\", sourceMod,\n  \"module \" + sourceMod.getName(), modifiedAttribute, sourceMod.getName() + \".\" + modifiedAttribute.getName()",
    "output": "*       modularity"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incorrect argument count for percent formatting\n * @description Identifies string formatting operations using % operator where the number of \n *              format specifiers doesn't match the number of provided arguments. \n *              This mismatch causes a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/percent-format/wrong-arguments\n */\n\nimport python\nimport semmle.python.strings\n\n/**\n * Detects string formatting operations using the % operator.\n * @param expr - Binary expression representing the formatting operation\n * @param formatStr - Format string literal\n * @param argsVal - Values to be formatted\n * @param argsSrc - AST node containing the arguments\n */\npredicate isPercentFormatExpr(BinaryExpr expr, StringLiteral formatStr, Value argsVal, AstNode argsSrc) {\n  // Verify modulo operator usage\n  expr.getOp() instanceof Mod and\n  exists(Context ctx |\n    // Resolve left operand to format string\n    expr.getLeft().pointsTo(ctx, _, formatStr) and\n    // Resolve right operand to argument values\n    expr.getRight().pointsTo(ctx, argsVal, argsSrc)\n  )\n}\n\n/**\n * Calculates the number of arguments in the provided value.\n_______________ // 补全条件\n * @return Count of arguments in the sequence\n */\nint countArguments(Value argsVal) {\n  // Handle tuple arguments (excluding starred expressions)\n  exists(Tuple argTuple | argTuple.pointsTo(argsVal, _) |\n    result = strictcount(argTuple.getAnElt()) and\n    not argTuple.getAnElt() instanceof Starred\n  )\n  or\n  // Handle single literal arguments\n  exists(ImmutableLiteral literal | literal.getLiteralValue() = argsVal | result = 1)\n}\n\nfrom\n  BinaryExpr formatExpr, StringLiteral formatString, Value argsValue, \n  int providedArgsCount, int expectedArgsCount, AstNode argsSource, string msgSuffix\nwhere\n  // Identify percent-style formatting operations\n  isPercentFormatExpr(formatExpr, formatString, argsValue, argsSource) and\n  // Calculate provided argument count\n  providedArgsCount = countArguments(argsValue) and\n  // Count format specifiers in the string\n  expectedArgsCount = format_items(formatString) and\n  // Detect mismatch between arguments and format specifiers\n  providedArgsCount != expectedArgsCount and\n  // Generate appropriate message suffix\n  (if providedArgsCount = 1 then msgSuffix = \" is provided.\" else msgSuffix = \" are provided.\")\nselect formatExpr,\n  \"Incorrect number of $@ for string formatting. Format $@ expects \" + \n    expectedArgsCount.toString() + \" values, but \" + providedArgsCount.toString() + msgSuffix, \n  argsSource, \"arguments\", formatString, formatString.getText()",
    "output": "* @param argsVal - Value representing the arguments"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-exception in 'except' clause\n * @description An exception handler specifying a non-exception type will never handle any exception.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python  // 导入python库，用于分析Python代码\n\n// 定义一个查询，从ExceptFlowNode、Value、ClassValue、ControlFlowNode和string类型的变量中进行选择\nfrom ExceptFlowNode ex, Value t, ClassValue c, ControlFlowNode origin, string what\nwhere\n  // 条件1：ex处理了类型为t的异常，并且该异常来源于origin节点\n  ex.handledException(t, c, origin) and\n  (\n    // 子条件1：存在一个ClassValue类型的x，使得x等于t，并且x不是一个合法的异常类型，且没有失败的推断\n_______________ // 补全条件\n      not x.isLegalExceptionType() and  // x不是一个合法的异常类型\n      not x.failedInference(_) and  // 没有失败的推断\n      what = \"class '\" + x.getName() + \"'\"  // 设置what字符串为异常类的名称\n    )\n    or\n    // 子条件2：t不是ClassValue的实例，并且设置what字符串为c的名称\n    not t instanceof ClassValue and\n    what = \"instance of '\" + c.getName() + \"'\"\n  )\nselect ex.getNode(),  // 选择要报告的节点\n  \"Non-exception $@ in exception handler which will never match raised exception.\", origin, what  // 生成报告信息，包括异常处理器中的非异常类型、来源节点和异常类型描述",
    "output": "exists(ClassValue x | x = t |"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cryptographic operations using elliptic curve algorithms that are either unrecognized or classified as weak/insecure",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak elliptic curve detection\n * @description Detects cryptographic operations using elliptic curve algorithms that are either unrecognized or classified as weak/insecure\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm ellipticCurveOp, string securityAlert, string curveName\nwhere\n  // Extract the curve name from the elliptic curve cryptographic operation\n  curveName = ellipticCurveOp.getCurveName() and\n  (\n    // Condition 1: The curve algorithm is not recognized\n    curveName = unknownAlgorithm() and\n    securityAlert = \"Use of unrecognized curve algorithm.\"\n    or\n    // Condition 2: The curve algorithm is recognized but considered weak\n    curveName != unknownAlgorithm() and\n    not curveName in [\n      \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n      \"SECP384R1\",              // P-384 curve\n      \"SECP521R1\",              // P-521 curve\n      \"ED25519\",                // Ed25519 curve\n      \"X25519\"                  // X25519 curve\n    ] and\n    securityAlert = \"Use of weak curve algorithm \" + curveName + \".\"\n  )\nselect ellipticCurveOp, securityAlert"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-code-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates and displays the number of lines of code for each function in a Python codebase.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lines of code in functions\n * @description Calculates and displays the number of lines of code for each function in a Python codebase.\n * @kind treemap\n * @id py/lines-of-code-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python // Import the Python module for analyzing Python source code\n\n// Query to retrieve all Python functions and their corresponding line counts\nfrom Function pythonFunction, int lineCount\nwhere \n  lineCount = pythonFunction.getMetrics().getNumberOfLinesOfCode()\nselect \n  pythonFunction, \n  lineCount \norder by \n  lineCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Classes per file\n * @description Measures the number of classes in a file\n * @kind treemap\n_______________ // 补全条件\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python\n\n// 从源代码模块中识别每个文件及其包含的类数量\nfrom Module sourceFile, int numberOfClasses\n\n// 计算每个源文件中定义的类的总数\nwhere numberOfClasses = count(Class cls | cls.getEnclosingModule() = sourceFile)\n\n// 输出结果：文件模块和对应的类数量，并按类数量降序排列\nselect sourceFile, numberOfClasses order by numberOfClasses desc",
    "output": "* @id py/classes-per-file"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mostly-similar-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies modules with significant code overlap, disregarding variable names and types. Merging such modules can enhance maintainability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Substantial module similarity detection\n * @description Identifies modules with significant code overlap, disregarding variable names and types. Merging such modules can enhance maintainability.\n * @kind problem\n * @problem.severity recommendation\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @sub-severity low\n * @precision high\n * @id py/mostly-similar-file\n */\n\nimport python\n\n// Define source and target modules for similarity analysis\nfrom Module sourceModule, \n     Module targetModule, \n     string similarityInfo\nwhere \n  // Placeholder condition (no actual similarity comparison implemented)\n  none()\nselect \n  sourceModule, \n  similarityInfo, \n  targetModule, \n  targetModule.getName()  // Output name of the target module"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-authors]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Number of distinct authors for each file",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of authors\n * @description Number of distinct authors for each file\n * @kind treemap\n * @id py/historical-number-of-authors\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\n// Import Python language module for code parsing and analysis capabilities\nimport python\n// Import external version control system (VCS) module to access commit history and author information\nimport external.VCS\n\n// Define the query source: select file modules from the codebase\nfrom Module fileModule\n// Apply filter condition: only consider modules that have lines of code metrics available\nwhere exists(fileModule.getMetrics().getNumberOfLinesOfCode())\n// Select the file module and count the number of distinct authors who have contributed to it\nselect fileModule, count(Author fileAuthor | fileAuthor.getAnEditedFile() = fileModule.getFile())"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of a print statement at module level\n * @description Detects print statements at module scope that are not guarded by `if __name__ == '__main__'`.\n *              Such statements can cause unexpected output when the module is imported.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n_______________ // 补全条件\n * @sub-severity high\n * @precision high\n * @id py/print-during-import\n */\n\nimport python\n\n/**\n * Identifies if statements with the condition `__name__ == \"__main__\"`.\n * This pattern guards code that should only execute when the module is run directly,\n * preventing execution during import operations.\n */\npredicate isMainGuardCondition(If ifNode) {\n  exists(Name nameNode, StringLiteral mainLiteral, Compare compareNode |\n    ifNode.getTest() = compareNode and\n    compareNode.getLeft() = nameNode and\n    compareNode.getAComparator() = mainLiteral and\n    nameNode.getId() = \"__name__\" and\n    mainLiteral.getText() = \"__main__\"\n  )\n}\n\n/**\n * Determines if a statement is a print operation.\n * Covers both Python 2 print statements and Python 3 print() function calls.\n */\npredicate isPrintStatement(Stmt stmt) {\n  stmt instanceof Print\n  or\n  exists(ExprStmt exprNode, Call callNode, Name funcNode |\n    exprNode = stmt and\n    callNode = exprNode.getValue() and\n    funcNode = callNode.getFunc() and\n    funcNode.getId() = \"print\"\n  )\n}\n\n/**\n * Locates unguarded print statements at module level.\n * These statements execute during module import, potentially causing unintended side effects.\n */\nfrom Stmt printNode\nwhere\n  isPrintStatement(printNode) and\n  // Verify the statement exists in an importable module\n  exists(ModuleValue moduleNode | \n    moduleNode.getScope() = printNode.getScope() and \n    moduleNode.isUsedAsModule()\n  ) and\n  // Ensure the print is not protected by a main guard\n  not exists(If ifNode | \n    isMainGuardCondition(ifNode) and \n    ifNode.getASubStatement().getASubStatement*() = printNode\n  )\nselect printNode, \"Print statement may execute during import.\"",
    "output": "* @problem.severity recommendation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/external-dependencies]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：统计Python源文件中引用的外部包依赖数量",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name 外部依赖关系\n * @description 统计Python源文件中引用的外部包依赖数量\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType externalDependency\n * @id py/external-dependencies\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 此查询用于分析Python代码库中的外部包依赖分布，提供关键指标：\n *\n * 分析维度：\n * 1. 源文件定位 - 标识包含外部依赖的Python源文件\n * 2. 包依赖识别 - 确定来自PyPI或其他外部仓库的具体包\n * 3. 版本追踪 - 捕获并记录包的版本约束信息（如适用）\n * 4. 引用频率统计 - 计算源文件中对外部包的引用次数\n *\n * 技术说明：\n * - 查询输出为两列格式，但实际包含上述四类信息\n * - 此设计确保与现有仪表板数据库架构的兼容性\n * - 修改列数需要同步更新仪表板数据库和提取器配置\n * - 文件路径添加前缀'/'以匹配仪表板数据库的相对路径标准\n */\n\n// 查询流程：识别源文件-外部包关系并量化依赖强度\nfrom File sourceFile, int dependencyCount, string dependencySignature, ExternalPackage externalPackage\nwhere\n  // 计算源文件中引用特定外部包的频次\n  dependencyCount =\n    strictcount(AstNode astNode |\n      // 验证AST节点是否引用了指定的外部包\n      dependency(astNode, externalPackage) and\n      // 确保AST节点隶属于当前分析的源文件\n      astNode.getLocation().getFile() = sourceFile\n    ) and\n  // 构造统一的依赖签名，整合源文件和包信息\n  dependencySignature = munge(sourceFile, externalPackage)\n// 结果输出：按依赖频次降序排列的依赖签名及其计数\nselect dependencySignature, dependencyCount order by dependencyCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Total lines of Python code in the database\n * @description Calculates the aggregate count of non-empty, non-comment lines across all\n_______________ // 补全条件\n *   dependencies, providing a comprehensive measure of the codebase size.\n * @kind metric\n * @tags summary\n *       telemetry\n * @id py/summary/lines-of-code\n */\n\nimport python\n\n// For each Python module, get its line count and sum them all\nselect sum(Module pyModule | | pyModule.getMetrics().getNumberOfLinesOfCode())",
    "output": "*   Python files in the database. This metric includes both application code and external"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Overly permissive file permissions\n_______________ // 补全条件\n * @kind problem\n * @id py/overly-permissive-file\n * @problem.severity warning\n * @security-severity 7.8\n * @sub-severity high\n * @precision medium\n * @tags external/cwe/cwe-732\n *       security\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Extracts world-readable/writable permission bits from octal mode\nbindingset[modeValue]\nint extract_world_permission(int modeValue) { \n  result = modeValue % 8 \n}\n\n// Extracts group-readable/writable permission bits from octal mode\nbindingset[modeValue]\nint extract_group_permission(int modeValue) { \n  result = (modeValue / 8) % 8 \n}\n\n// Converts permission bits to human-readable access type\nbindingset[permissionBits]\nstring describe_access(int permissionBits) {\n  permissionBits % 4 >= 2 and result = \"writable\"  // Writeable when last 2 bits >= 2\n  or\n  permissionBits % 4 < 2 and permissionBits != 0 and result = \"readable\"  // Readable when non-zero but not writable\n}\n\n// Generates description for overly permissive permission components\nbindingset[modeValue]\nstring identify_permissive_permission(int modeValue) {\n  result = \"world \" + describe_access(extract_world_permission(modeValue))  // Prioritize world permissions\n  or\n  extract_world_permission(modeValue) = 0 and result = \"group \" + describe_access(extract_group_permission(modeValue))  // Fallback to group permissions\n}\n\n// Unified predicate for file permission operations\npredicate file_permission_operation(API::CallNode apiCall, string operationType, int permissionMode) {\n  (operationType = \"chmod\" and \n    apiCall = API::moduleImport(\"os\").getMember(\"chmod\").getACall() and\n    permissionMode = apiCall.getParameter(1, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue())\n  or\n  (operationType = \"open\" and \n    apiCall = API::moduleImport(\"os\").getMember(\"open\").getACall() and\n    permissionMode = apiCall.getParameter(2, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue())\n}\n\n// Main query detecting overly permissive file operations\nfrom API::CallNode apiCall, string operationType, int permissionMode, string permissionDescription\nwhere\n  file_permission_operation(apiCall, operationType, permissionMode) and\n  permissionDescription = identify_permissive_permission(permissionMode)\nselect apiCall, \"Overly permissive mask in \" + operationType + \" sets file to \" + permissionDescription + \".\"",
    "output": "* @description Detects file operations with excessive read/write permissions for non-owner users"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/encoding-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies encoding-related problems in Python code that can cause runtime failures",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Encoding issue\n * @description Identifies encoding-related problems in Python code that can cause runtime failures\n *              and impede static analysis.\n * @kind problem\n * @id py/encoding-error\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n */\n\nimport python\n\n// Locate all encoding-related issues in the codebase\nfrom EncodingError encodingIssue\n// Report each issue with its location and diagnostic message\nselect encodingIssue, encodingIssue.getMessage()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/simple-xml-rpc-server-dos]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：SimpleXMLRPCServer is vulnerable to denial of service attacks from untrusted user input",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name SimpleXMLRPCServer denial of service\n * @description SimpleXMLRPCServer is vulnerable to denial of service attacks from untrusted user input\n * @kind problem\n * @problem.severity warning\n * @precision high\n * @id py/simple-xml-rpc-server-dos\n * @tags security\n *       experimental\n *       external/cwe/cwe-776\n */\n\n// 导入Python库，用于分析Python代码\nprivate import python\n\n// 导入Semmle Python概念库，提供Python语言的抽象和模式\nprivate import semmle.python.Concepts\n\n// 导入Semmle API图，用于数据流分析\nprivate import semmle.python.ApiGraphs\n\n// 从DataFlow命名空间中引入CallCfgNode类，表示调用配置节点\nfrom DataFlow::CallCfgNode call\nwhere\n  // 查找对SimpleXMLRPCServer类的调用，该类位于xmlrpc模块中\n  call = API::moduleImport(\"xmlrpc\").getMember(\"server\").getMember(\"SimpleXMLRPCServer\").getACall()\nselect call, \"SimpleXMLRPCServer is vulnerable to XML bombs.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of parameters without defaults\n * @description The number of parameters in a function that are not defined with default values.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // 导入Python模块，支持Python代码的静态分析\n\n// 查询所有Python函数\nfrom FunctionMetrics functionObj\n// 计算每个函数中无默认值的参数数量\nselect functionObj, \n_______________ // 补全条件\n// 按无默认值参数数量降序排列结果\norder by paramCount desc",
    "output": "functionObj.getNumberOfParametersWithoutDefault() as paramCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure randomness\n * @description Detects security-critical operations utilizing cryptographically weak \n *              pseudo-random number generators, which allows adversaries to forecast \n *              generated values and undermine system security.\n_______________ // 补全条件\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// Fundamental Python analysis framework\nimport python\n\n// Specialized security module for identifying weak random patterns\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Data flow propagation mechanism\nimport semmle.python.dataflow.new.DataFlow\n\n// Path visualization infrastructure for data flow\nimport InsecureRandomness::Flow::PathGraph\n\n// Query detecting insecure random value propagation\nfrom \n  InsecureRandomness::Flow::PathNode weakRandomSource,    // Origin of weak random value\n  InsecureRandomness::Flow::PathNode securityCriticalSink  // Security-sensitive consumption point\nwhere \n  // Validate data flow path from weak random source to critical sink\n  InsecureRandomness::Flow::flowPath(weakRandomSource, securityCriticalSink)\nselect \n  securityCriticalSink.getNode(),                      // Target location of insecure usage\n  weakRandomSource,                                    // Origin node for path tracking\n  securityCriticalSink,                                // Sink node for visualization\n  \"Cryptographically insecure $@ in security context.\", // Alert description\n  weakRandomSource.getNode(),                          // Reference node for alert message\n  \"random value\"                                      // Description of vulnerable element",
    "output": "* @kind path-problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/points-to-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Expression does not \"point-to\" an object which prevents type inference.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name points-to fails for expression.\n * @description Expression does not \"point-to\" an object which prevents type inference.\n * @kind problem\n * @id py/points-to-failure\n * @problem.severity info\n * @tags debug\n * @deprecated\n */\n\n// Import the Python module to enable code analysis capabilities\nimport python\n\n// Identify expressions that fail to point-to any object during analysis\nfrom Expr problematicExpr, ControlFlowNode correspondingFlowNode\nwhere \n  // Establish the relationship between the expression and its control flow node\n  correspondingFlowNode = problematicExpr.getAFlowNode() and\n  // Ensure that the control flow node does not reference any object\n  not correspondingFlowNode.refersTo(_)\n// Report the problematic expression with an informative message\nselect problematicExpr, \"Expression does not 'point-to' any object.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/all-cryptographic-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all potential cryptographic algorithm implementations across supported libraries",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name All Cryptographic Algorithms\n * @description Identifies all potential cryptographic algorithm implementations across supported libraries\n * @kind problem\n * @id py/quantum-readiness/cbom/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python analysis module\nimport python\n// Import experimental cryptography concepts for algorithm detection\nimport experimental.cryptography.Concepts\n\n// Retrieve all cryptographic algorithm instances\nfrom CryptographicAlgorithm cryptoAlgorithm\n// Generate alert with algorithm name\nselect cryptoAlgorithm, \"Use of algorithm \" + cryptoAlgorithm.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects security vulnerabilities in regular expressions used for URL or hostname matching.\n *              Specifically identifies patterns containing unescaped dots ('.') which can match any character,\n *              potentially allowing unauthorized hostname access beyond the intended scope.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-hostname-regexp\n * @tags correctness\n *       security\n *       external/cwe/cwe-020\n */\n\n// Import the specialized library for analyzing security vulnerabilities in hostname regular expressions\nprivate import semmle.python.security.regexp.HostnameRegex as HostnameSecurityAnalyzer\n\n// Define the main query predicate to identify security issues in hostname regular expressions\n// This predicate serves as the entry point for the core analysis logic within the HostnameSecurityAnalyzer module\nquery predicate problems = HostnameSecurityAnalyzer::incompleteHostnameRegExp/4;",
    "output": "* @name Incomplete regular expression for hostnames"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inconsistent-mro]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent method resolution order\n * @description Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n// Retrieves the immediate left base class of a specified base in the inheritance hierarchy\nClassObject getImmediateLeftBase(ClassObject targetClass, ClassObject baseClass) {\n  // Find the position of the base class in the inheritance list\n  exists(int baseIndex | \n    baseIndex > 0 and \n    targetClass.getBaseType(baseIndex) = baseClass\n  |\n    // Return the base class at the preceding position\n    result = targetClass.getBaseType(baseIndex - 1)\n  )\n}\n\n// Query classes with invalid method resolution order\nfrom ClassObject problematicClass, ClassObject leftBaseClass, ClassObject rightBaseClass\nwhere \n  // Verify that the target class is new-style\n  problematicClass.isNewStyle() and\n  // Check if there's a problematic inheritance structure\n  leftBaseClass = getImmediateLeftBase(problematicClass, rightBaseClass) and\n  // Verify that the left base is an improper super type of the right base\n  leftBaseClass = rightBaseClass.getAnImproperSuperType()\nselect problematicClass,\n  \"Construction of class \" + problematicClass.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", leftBaseClass,\n  leftBaseClass.getName(), rightBaseClass, rightBaseClass.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-crypto-key]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies cryptographic keys with inadequate bit length that are susceptible to brute-force attacks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak cryptographic key usage\n * @description Identifies cryptographic keys with inadequate bit length that are susceptible to brute-force attacks.\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/weak-crypto-key\n * @tags security\n *       external/cwe/cwe-326\n */\n\nimport python\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.filters.Tests\n\nfrom Cryptography::PublicKey::KeyGeneration cryptoKeyGen, DataFlow::Node keySizeOrigin\nwhere\n  // Extract cryptographic key length from generation context and source node\n  exists(int keySizeBits |\n    keySizeBits = cryptoKeyGen.getKeySizeWithOrigin(keySizeOrigin) and\n    // Verify key length meets minimum security requirements\n    keySizeBits < cryptoKeyGen.minimumSecureKeySize() and\n    // Exclude test code from security analysis scope\n    not keySizeOrigin.getScope().getScope*() instanceof TestScope\n  )\nselect cryptoKeyGen,\n  \"Creation of $@ key uses \" + \n    cryptoKeyGen.getKeySizeWithOrigin(keySizeOrigin).toString() + \n    \" bits, which is below \" + cryptoKeyGen.minimumSecureKeySize() + \n    \" and considered breakable.\", \n  keySizeOrigin, cryptoKeyGen.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Import of deprecated module\n * @description Identifies Python imports of modules deprecated in specific versions\n * @kind problem\n * @tags maintainability\n *       external/cwe/cwe-477\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/import-deprecated-module\n */\n\n// Core Python analysis library import\nimport python\n\n/**\n * Checks if a module was deprecated in a specific Python version\n *\n * @param deprecatedModName Name of the deprecated module\n * @param replacementMod Recommended replacement module or \"no replacement\"\n * @param majorVer Major Python version where deprecation occurred\n * @param minorVer Minor Python version where deprecation occurred\n * @return True if module was deprecated in specified version\n */\npredicate isDeprecatedModule(string deprecatedModName, string replacementMod, int majorVer, int minorVer) {\n  // Python 1.x deprecated modules\n  (\n    deprecatedModName = \"posixfile\" and replacementMod = \"fcntl\" and majorVer = 1 and minorVer = 5\n    or\n    deprecatedModName = \"pre\" and replacementMod = \"re\" and majorVer = 1 and minorVer = 5\n  )\n  or\n  // Python 2.0-2.2 deprecated modules\n  (\n    deprecatedModName = \"whrandom\" and replacementMod = \"random\" and majorVer = 2 and minorVer = 1\n    or\n    deprecatedModName = \"statcache\" and replacementMod = \"no replacement\" and majorVer = 2 and minorVer = 2\n    or\n    deprecatedModName = \"mpz\" and replacementMod = \"a third party\" and majorVer = 2 and minorVer = 2\n  )\n  or\n  // Python 2.3-2.4 deprecated modules\n  (\n    deprecatedModName = \"rfc822\" and replacementMod = \"email\" and majorVer = 2 and minorVer = 3\n    or\n    deprecatedModName = \"mimetools\" and replacementMod = \"email\" and majorVer = 2 and minorVer = 3\n    or\n    deprecatedModName = \"MimeWriter\" and replacementMod = \"email\" and majorVer = 2 and minorVer = 3\n    or\n    deprecatedModName = \"mimify\" and replacementMod = \"email\" and majorVer = 2 and minorVer = 3\n    or\n    deprecatedModName = \"xreadlines\" and replacementMod = \"no replacement\" and majorVer = 2 and minorVer = 3\n    or\n    deprecatedModName = \"rotor\" and replacementMod = \"no replacement\" and majorVer = 2 and minorVer = 4\n  )\n  or\n  // Python 2.5-2.6 deprecated modules\n  (\n    deprecatedModName = \"gopherlib\" and replacementMod = \"no replacement\" and majorVer = 2 and minorVer = 5\n    or\n    deprecatedModName = \"rgbimgmodule\" and replacementMod = \"no replacement\" and majorVer = 2 and minorVer = 5\n    or\n    deprecatedModName = \"multifile\" and replacementMod = \"email\" and majorVer = 2 and minorVer = 5\n    or\n    deprecatedModName = \"sets\" and replacementMod = \"builtins\" and majorVer = 2 and minorVer = 6\n  )\n  or\n  // Additional deprecated modules\n  (\n    deprecatedModName = \"buildtools\" and replacementMod = \"no replacement\" and majorVer = 2 and minorVer = 3\n    or\n    deprecatedModName = \"cfmfile\" and replacementMod = \"no replacement\" and majorVer = 2 and minorVer = 4\n    or\n    deprecatedModName = \"macfs\" and replacementMod = \"no replacement\" and majorVer = 2 and minorVer = 3\n    or\n    deprecatedModName = \"md5\" and replacementMod = \"hashlib\" and majorVer = 2 and minorVer = 5\n    or\n    deprecatedModName = \"sha\" and replacementMod = \"hashlib\" and majorVer = 2 and minorVer = 5\n  )\n}\n\n/**\n * Creates deprecation warning message for a module\n *\n * @param deprecatedModName Name of the deprecated module\n * @return Formatted warning message with deprecation version\n */\nstring getDeprecationWarning(string deprecatedModName) {\n_______________ // 补全条件\n    isDeprecatedModule(deprecatedModName, _, majorVer, minorVer)\n  |\n    result =\n      \"Module \" + deprecatedModName + \" was deprecated in Python \" + \n      majorVer.toString() + \".\" + minorVer.toString() + \".\"\n  )\n}\n\n/**\n * Provides replacement suggestion for deprecated module\n *\n * @param deprecatedModName Name of the deprecated module\n * @return Replacement suggestion or empty string if no replacement\n */\nstring getReplacementSuggestion(string deprecatedModName) {\n  exists(string replacementMod | \n    isDeprecatedModule(deprecatedModName, replacementMod, _, _)\n  |\n    (result = \" Consider using \" + replacementMod + \" instead.\" and \n     not replacementMod = \"no replacement\")\n    or\n    (result = \"\" and replacementMod = \"no replacement\")\n  )\n}\n\n/**\n * Detects ImportError exception handling for an import\n *\n * @param importExpr Import expression to evaluate\n * @return True if ImportError exception handling is present\n */\npredicate hasImportErrorHandling(ImportExpr importExpr) {\n  exists(Try tryStmt, ExceptStmt exceptStmt | \n    exceptStmt = tryStmt.getAHandler() and\n    exceptStmt.getType().pointsTo(ClassValue::importError()) and\n    exceptStmt.containsInScope(importExpr)\n  )\n}\n\n// Main query: Find deprecated module imports without error handling\nfrom ImportExpr importExpr, string deprecatedModName, string replacementMod\nwhere\n  deprecatedModName = importExpr.getName() and\n  isDeprecatedModule(deprecatedModName, replacementMod, _, _) and\n  not hasImportErrorHandling(importExpr)\nselect importExpr, getDeprecationWarning(deprecatedModName) + getReplacementSuggestion(deprecatedModName)",
    "output": "exists(int majorVer, int minorVer |"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name CORS Misconfiguration with Credentials\n * @description Disabling or weakening Same-Origin Policy (SOP) protection may expose\n *              the application to CORS attacks when credentials are allowed.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n// 检查来源配置是否包含通配符或空值\npredicate hasWildcardOrigin(DataFlow::Node originSetting) {\n  exists(StringLiteral stringLiteral |\n_______________ // 补全条件\n    (originSetting.asExpr() instanceof List and\n     stringLiteral = originSetting.asExpr().getASubExpression() and\n     stringLiteral.getText() in [\"*\", \"null\"])\n    or\n    // 情况2：来源配置直接是 \"*\" 或 \"null\" 字符串\n    (stringLiteral = originSetting.asExpr() and\n     stringLiteral.getText() in [\"*\", \"null\"])\n  )\n}\n\n// 验证中间件是否为 CORS 类型\npredicate isCorsMiddlewareType(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n// 检查中间件是否启用了凭证支持\npredicate supportsCredentials(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getCredentialsAllowed().asExpr() instanceof True\n}\n\n// 查询存在安全风险的 CORS 中间件配置\nfrom Http::Server::CorsMiddleware middleware\nwhere\n  // 条件组合：启用凭证 + 使用通配符来源 + 确认中间件类型\n  supportsCredentials(middleware) and\n  hasWildcardOrigin(middleware.getOrigins().getALocalSource()) and\n  isCorsMiddlewareType(middleware)\nselect middleware,\n  // 安全风险说明：允许任意来源的认证请求可能导致敏感数据泄露\n  \"This CORS middleware configuration allows authenticated cross-origin requests from any source, potentially exposing sensitive data\"",
    "output": "// 情况1：来源配置是列表且包含 \"*\" 或 \"null\" 元素"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Iteration over both string and sequence types\n * @description Identifies for-loops that iterate over values which can be either strings or sequences (like lists).\n * This pattern is problematic because strings iterate over individual characters while sequences iterate over elements,\n_______________ // 补全条件\n * @kind problem\n * @tags reliability\n *       maintainability\n *       non-local\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iteration-string-and-sequence\n */\n\nimport python\nimport semmle.python.filters.Tests\n\n// Determines if a value is of string type (str or Python 2 unicode)\npredicate isStringValueType(Value value) {\n  value.getClass() = ClassValue::str() \n  or \n  value.getClass() = ClassValue::unicode() and major_version() = 2\n}\n\nfrom \n  For problematicLoop, \n  ControlFlowNode iterNode, \n  Value stringValue, \n  Value sequenceValue, \n  ControlFlowNode sequenceOrigin,\n  ControlFlowNode stringOrigin\nwhere \n  // The iterator node in the for-loop points to both string and sequence values\n  problematicLoop.getIter().getAFlowNode() = iterNode and\n  iterNode.pointsTo(stringValue, stringOrigin) and\n  iterNode.pointsTo(sequenceValue, sequenceOrigin) and\n  \n  // Type validation: one value is a string, the other is a non-string iterable\n  isStringValueType(stringValue) and\n  sequenceValue.getClass().isIterable() and\n  not isStringValueType(sequenceValue) and\n  \n  // Exclude test code from the analysis\n  not sequenceOrigin.getScope().getScope*() instanceof TestScope and\n  not stringOrigin.getScope().getScope*() instanceof TestScope\nselect problematicLoop,\n  \"Iteration over $@, of class \" + sequenceValue.getClass().getName() + \n  \", may also iterate over $@.\",\n  sequenceOrigin, \"sequence\", stringOrigin, \"string\"",
    "output": "* leading to inconsistent behavior and potential runtime errors."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'super' in old style class\n * @description Detects super() calls in old-style classes where they are unsupported.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n_______________ // 补全条件\n * @id py/super-in-old-style\n */\n\nimport python\n\n// Identifies invocations of super() within old-style class contexts\npredicate superInvocationInOldStyleClass(Call superInvocation) {\n  exists(Function parentFunction, ClassObject parentClass |\n    // Check if the call is to the 'super' built-in function\n    superInvocation.getFunc().(Name).getId() = \"super\" and\n    // Ensure the super call is within a function/method\n    superInvocation.getScope() = parentFunction and\n    // Verify the function is a member of a class\n    parentFunction.getScope() = parentClass.getPyClass() and\n    // Confirm the class was successfully analyzed\n    not parentClass.failedInference() and\n    // Identify old-style classes (those not inheriting from object or other new-style classes)\n    not parentClass.isNewStyle()\n  )\n}\n\n// Query to find all problematic super() calls in old-style classes\nfrom Call invalidSuperCall\nwhere superInvocationInOldStyleClass(invalidSuperCall)\nselect invalidSuperCall, \"'super()' will not work in old-style classes.\"",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Overly complex `__del__` method\n_______________ // 补全条件\n *              excessive cyclomatic complexity. Destructor methods in Python are executed\n *              during object cleanup, a process that can happen unpredictably or may be\n *              bypassed under certain conditions. Destructors with high complexity can\n *              lead to performance degradation and unpredictable behavior during garbage\n *              collection. It's recommended to keep these special methods as simple as possible.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python  // 导入Python分析库，用于代码分析\n\nfrom FunctionValue destructorFunc, ClassValue ownerClass\nwhere\n  // 确认该函数是类的析构方法\n  ownerClass.declaredAttribute(\"__del__\") = destructorFunc\n  and\n  // 检查析构方法的圈复杂度是否超过阈值3\n  destructorFunc.getScope().getMetrics().getCyclomaticComplexity() > 3\nselect destructorFunc, \"Overly complex '__del__' method.\"  // 选择符合条件的destructorFunc并标记为\"过于复杂的`__del__`方法\"",
    "output": "* @description Detects Python classes containing destructor methods (`__del__`) with"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/points-to-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Expression does not \"point-to\" an object which prevents type inference.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name points-to fails for expression.\n * @description Expression does not \"point-to\" an object which prevents type inference.\n * @kind problem\n * @id py/points-to-failure\n * @problem.severity info\n * @tags debug\n * @deprecated\n */\n\n// 导入Python代码静态分析所需的基础库\nimport python\n\n// 识别无法指向任何对象的Python表达式，这会影响类型推断系统的正常工作\nfrom Expr problematicExpr\nwhere \n    // 表达式在控制流图中存在节点，且至少有一个节点不引用任何对象\n    exists(ControlFlowNode cfgNode | \n        cfgNode = problematicExpr.getAFlowNode() and \n        not cfgNode.refersTo(_)\n    )\n// 输出问题表达式及其诊断信息\nselect problematicExpr, \"Expression does not 'point-to' any object.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/unmatchable-caret]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects regular expressions containing a caret '^' in non-starting positions, making them impossible to match without MULTILINE/VERBOSE modes.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unmatchable caret in regular expression\n * @description Detects regular expressions containing a caret '^' in non-starting positions, making them impossible to match without MULTILINE/VERBOSE modes.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/regex/unmatchable-caret\n */\n\nimport python\nimport semmle.python.regex\n\n// Identify regular expression patterns with misplaced caret characters\n// that cannot match any input when not in MULTILINE/VERBOSE modes\nfrom RegExp regexPattern, int caretPosition\nwhere \n  // Exclude patterns with MULTILINE mode enabled (where ^ matches line start)\n  not regexPattern.getAMode() = \"MULTILINE\" and\n  // Exclude patterns with VERBOSE mode enabled (where whitespace is ignored)\n  not regexPattern.getAMode() = \"VERBOSE\" and\n  // Confirm caret character is present at the specified position\n  regexPattern.specialCharacter(caretPosition, caretPosition + 1, \"^\") and\n  // Ensure caret is not at the beginning of the regex pattern\n  not regexPattern.firstItem(caretPosition, caretPosition + 1)\nselect regexPattern,\n  \"This regular expression includes an unmatchable caret at offset \" + caretPosition.toString() + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies instances where '\\b' is used to represent a backspace character",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Backspace escape in regular expression\n * @description Identifies instances where '\\b' is used to represent a backspace character\n *              within regular expressions, which can be confusing as '\\b' typically\n *              denotes a word boundary assertion in regex patterns.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp pattern, int escapePos\nwhere\n  // Check for an escape character followed by 'b'\n  pattern.escapingChar(escapePos) and\n  pattern.getChar(escapePos + 1) = \"b\" and\n  // Verify the escape sequence is within a character set\n  exists(int charSetStart, int charSetEnd | \n    charSetStart < escapePos and \n    charSetEnd > escapePos and \n    pattern.charSet(charSetStart, charSetEnd)\n  )\nselect pattern, \"Backspace escape in regular expression at offset \" + escapePos + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name points-to fails for expression.\n * @description Identifies expressions that fail to point-to any object, which prevents type inference.\n * @kind problem\n * @id py/points-to-failure\n * @problem.severity info\n * @tags debug\n * @deprecated\n */\n\n// Import the Python analysis library\nimport python\n\n_______________ // 补全条件\nfrom Expr exprWithFailedPointTo\nwhere \n  // Check if there exists a control flow node associated with the expression that does not refer to any object\n  exists(ControlFlowNode cfNode | \n    cfNode = exprWithFailedPointTo.getAFlowNode() and\n    not cfNode.refersTo(_)\n  )\n// Report the expression with an informative message\nselect exprWithFailedPointTo, \"Expression does not 'point-to' any object.\"",
    "output": "// Find expressions that have at least one control flow node which does not refer to any object"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Co-committed Files Analysis\n * @description Calculates the average number of additional files modified in commits \n *              that also change a specific file. This metric identifies files that \n *              are frequently altered together, indicating potential relationships \n *              or dependencies between them.\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Helper function that calculates the number of files modified in a specific commit\nint calculateFilesModifiedInCommit(Commit commitRecord) { \n    result = count(commitRecord.getAnAffectedFile()) \n}\n\n_______________ // 补全条件\nfrom Module targetModule\nwhere exists(targetModule.getMetrics().getNumberOfLinesOfCode())\nselect targetModule,\n  // Compute the average number of files modified together with the target module\n  avg(Commit commitRecord, int coModifiedFilesCount |\n    // Check if the commit affects the target module\n    commitRecord.getAnAffectedFile() = targetModule.getFile() and \n    // Calculate the number of co-modified files (excluding the target module)\n    coModifiedFilesCount = calculateFilesModifiedInCommit(commitRecord) - 1\n  |\n    coModifiedFilesCount\n  )",
    "output": "// Main analysis: evaluate modules with line count metrics"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of re-commits for each file\n * @description Quantifies re-commits where a file undergoes modifications again within a 5-day window after a previous commit\n * @kind treemap\n * @id py/historical-number-of-re-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Predicate to evaluate if two commits fall within the defined re-commit timeframe\npredicate commitsWithinWindow(Commit initialCommit, Commit subsequentCommit) {\n_______________ // 补全条件\n  initialCommit != subsequentCommit and\n  initialCommit.getAnAffectedFile() = subsequentCommit.getAnAffectedFile() and\n  // Compute the temporal gap between commits and verify it's within the 0-4 day range\n  exists(int temporalGap | \n    temporalGap = initialCommit.getDate().daysTo(subsequentCommit.getDate()) and\n    temporalGap >= 0 and temporalGap < 5\n  )\n}\n\n// Determine the aggregate count of re-commits for a given file\nint getRecommitCount(File fileOfInterest) {\n  result = count(Commit analyzedCommit |\n    // The analyzed commit must involve the file of interest\n    fileOfInterest = analyzedCommit.getAnAffectedFile() and\n    // There must exist a preceding commit within the re-commit window\n    exists(Commit precedingCommit | commitsWithinWindow(precedingCommit, analyzedCommit))\n  )\n}\n\n// Retrieve modules with LOC metrics along with their corresponding re-commit frequencies\nfrom Module moduleOfInterest\nwhere exists(moduleOfInterest.getMetrics().getNumberOfLinesOfCode())\nselect moduleOfInterest, getRecommitCount(moduleOfInterest.getFile())",
    "output": "// Commits must refer to distinct revisions but impact the same file"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete task indicators in code annotations\n * @description Detects code annotations that include 'TODO' or 'TO DO' indicators,\n *              signifying unfinished code sections that might build up progressively\n *              and affect code maintenance.\n_______________ // 补全条件\n * @tags maintainability\n *       readability\n *       documentation\n *       external/cwe/cwe-546\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/todo-comment\n */\n\nimport python  // Python language library for code analysis\n\nfrom Comment incompleteTaskAnnotation  // Source annotation nodes\nwhere \n  // Extract and analyze annotation text content\n  incompleteTaskAnnotation.getText().matches(\"%TODO%\") or \n  incompleteTaskAnnotation.getText().matches(\"%TO DO%\")\nselect incompleteTaskAnnotation, incompleteTaskAnnotation.getText()  // Output matching annotations and their content",
    "output": "* @kind problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-padding]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Identifies asymmetric encryption padding implementations that utilize",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Vulnerable asymmetric encryption padding\n * @description\n * Identifies asymmetric encryption padding implementations that utilize\n * cryptographically insecure or non-standardized padding algorithms.\n * The query filters out industry-approved secure padding techniques (OAEP, KEM, PSS)\n * and highlights all remaining padding methods as potential security risks.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify asymmetric padding implementations using insecure algorithms\nfrom AsymmetricPadding asymmetricPadding, string paddingAlgorithm\nwhere\n  // Extract padding algorithm name from implementation\n  paddingAlgorithm = asymmetricPadding.getPaddingName()\n  // Filter out secure padding algorithms (OAEP, KEM, PSS)\n  and not paddingAlgorithm = [\"OAEP\", \"KEM\", \"PSS\"]\nselect asymmetricPadding, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + paddingAlgorithm"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects import statements that cannot be resolved to any module,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unresolved import\n * @description Detects import statements that cannot be resolved to any module,\n *              which may indicate missing dependencies or platform-specific code.\n * @kind problem\n * @problem.severity info\n * @id py/import-failure\n */\n\n// Import the Python analysis library\nimport python\n\n/**\n * Retrieves the current operating system platform identifier from the Python interpreter.\n * Used to determine if platform-specific imports should be considered unresolved.\n */\nstring getCurrentPlatform() { \n  py_flags_versioned(\"sys.platform\", result, major_version().toString()) \n}\n\n/**\n * Identifies platform-specific imports and returns their corresponding platform name.\n * Returns the platform identifier if the import is platform-specific.\n */\nstring identifyOSSpecificImport(ImportExpr importExpr) {\n  exists(string moduleName | moduleName = importExpr.getImportedModuleName() |\n    // Java platform imports\n    (moduleName.matches(\"org.python.%\") or moduleName.matches(\"java.%\")) and \n    result = \"java\"\n    or\n    // macOS platform imports\n    moduleName.matches(\"Carbon.%\") and result = \"darwin\"\n    or\n    // Windows platform imports\n    result = \"win32\" and\n    (\n      moduleName = \"_winapi\" or\n      moduleName = \"_win32api\" or\n      moduleName = \"_winreg\" or\n      moduleName = \"nt\" or\n      moduleName.matches(\"win32%\") or\n      moduleName = \"ntpath\"\n    )\n    or\n    // Linux platform imports\n    result = \"linux2\" and\n    (moduleName = \"posix\" or moduleName = \"posixpath\")\n    or\n    // Unsupported platform imports\n    result = \"unsupported\" and\n    (moduleName = \"__pypy__\" or moduleName = \"ce\" or moduleName.matches(\"riscos%\"))\n  )\n}\n\n/**\n * Locates alternative import expressions used as fallbacks in conditional structures.\n * Identifies imports in if/else branches or try/except blocks that serve as alternatives.\n */\nImportExpr findAlternativeImport(ImportExpr primaryImport) {\n  exists(Alias primaryAlias, Alias alternativeAlias |\n    // Primary alias mapping\n    (primaryAlias.getValue() = primaryImport or primaryAlias.getValue().(ImportMember).getModule() = primaryImport) and\n    // Fallback alias mapping\n    (alternativeAlias.getValue() = result or alternativeAlias.getValue().(ImportMember).getModule() = result) and\n    (\n      // Check conditional branches for alternative imports\n      exists(If ifStmt | \n        (ifStmt.getBody().contains(primaryImport) and ifStmt.getOrelse().contains(result)) or\n        (ifStmt.getBody().contains(result) and ifStmt.getOrelse().contains(primaryImport))\n      )\n      or\n      // Check exception handling blocks for alternative imports\n      exists(Try tryStmt | \n        (tryStmt.getBody().contains(primaryImport) and tryStmt.getAHandler().contains(result)) or\n        (tryStmt.getBody().contains(result) and tryStmt.getAHandler().contains(primaryImport))\n      )\n    )\n  )\n}\n\n/**\n * Determines if an unresolved import should be considered acceptable.\n * An import is acceptable if it has a working alternative or is platform-specific\n * for a different platform than the current one.\n */\npredicate isImportFailureAcceptable(ImportExpr importExpr) {\n  // Check for valid alternative imports\n  findAlternativeImport(importExpr).refersTo(_)\n  or\n  // Check for platform-specific imports on different platforms\n  identifyOSSpecificImport(importExpr) != getCurrentPlatform()\n}\n\n/**\n * Represents control flow nodes that check Python interpreter version.\n * Typically used for version-specific conditional imports.\n */\nclass VersionCheckNode extends ControlFlowNode {\n  VersionCheckNode() {\n    exists(string versionAttrName |\n      versionAttrName.matches(\"%version%\") and\n      this.(CompareNode).getAChild+().pointsTo(Module::named(\"sys\").attr(versionAttrName))\n    )\n  }\n\n  override string toString() { result = \"VersionTest\" }\n}\n\n/**\n * Represents conditional blocks guarded by version checks.\n * Used to identify version-specific imports that should not be flagged.\n */\nclass VersionGuardBlock extends ConditionBlock {\n  VersionGuardBlock() { this.getLastNode() instanceof VersionCheckNode }\n}\n\n// Main query: Identify problematic unresolved imports\nfrom ImportExpr unresolvedImport\nwhere\n  not unresolvedImport.refersTo(_) and // Import cannot be resolved\n  exists(Context context | context.appliesTo(unresolvedImport.getAFlowNode())) and // Import is in valid context\n  not isImportFailureAcceptable(unresolvedImport) and // Import failure is not acceptable\n  not exists(VersionGuardBlock versionGuard | versionGuard.controls(unresolvedImport.getAFlowNode().getBasicBlock(), _)) // Not version-guarded\nselect unresolvedImport, \"Unable to resolve import of '\" + unresolvedImport.getImportedModuleName() + \"'.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Except block handles 'BaseException'\n * @description Detects exception handlers that catch BaseException without re-raising,\n *              which may improperly handle system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n_______________ // 补全条件\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Determines if an exception handler suppresses exceptions without re-raising\npredicate suppressesException(ExceptStmt handler) {\n  handler.getAFlowNode().getBasicBlock().reachesExit()\n}\n\n// Identifies exception handlers that catch BaseException or use bare except clauses\npredicate handlesBaseException(ExceptStmt handler) {\n  // Explicit BaseException handling\n  handler.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  // Bare except clause (catches all exceptions including BaseException)\n  not exists(handler.getType())\n}\n\n// Main query: Find problematic exception handlers\nfrom ExceptStmt handler\nwhere\n  handlesBaseException(handler) and  // Catches BaseException or all exceptions\n  suppressesException(handler)      // Suppresses exceptions without re-raising\nselect handler, \"Except block directly handles BaseException.\"",
    "output": "*       external/cwe/cwe-396"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/duplicate-key-dict-literal]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies dictionary literals containing duplicate keys where initial values are silently replaced by subsequent ones.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Duplicate key in dict literal\n * @description Identifies dictionary literals containing duplicate keys where initial values are silently replaced by subsequent ones.\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/duplicate-key-dict-literal\n */\n\nimport python\nimport semmle.python.strings\n\n// Normalize dictionary keys to string representations for comparison\n// Handles numeric values (direct conversion) and string literals (with type prefixes)\npredicate keyNormalization(Dict dictionary, Expr keyExpr, string normalizedKey) {\n  keyExpr = dictionary.getAKey() and\n  (\n    // Convert numeric keys to string representation\n    normalizedKey = keyExpr.(Num).getN()\n    or\n    // Process string literals with appropriate type prefixes\n    exists(StringLiteral strLiteral | \n      strLiteral = keyExpr and\n      (\n        // Unicode strings receive 'u\"' prefix\n        normalizedKey = \"u\\\"\" + strLiteral.getText() + \"\\\"\" and strLiteral.isUnicode()\n        or\n        // Byte strings receive 'b\"' prefix\n        normalizedKey = \"b\\\"\" + strLiteral.getText() + \"\\\"\" and not strLiteral.isUnicode()\n      )\n    )\n  )\n}\n\n// Helper predicate to verify temporal ordering of keys in code flow\npredicate temporalKeyOrder(Expr firstKey, Expr secondKey) {\n  // Case 1: Keys exist in same basic block with first appearing earlier\n  exists(BasicBlock basicBlock, int firstPos, int secondPos |\n    firstKey.getAFlowNode() = basicBlock.getNode(firstPos) and\n    secondKey.getAFlowNode() = basicBlock.getNode(secondPos) and\n    firstPos < secondPos\n  )\n  or\n  // Case 2: First key's basic block strictly dominates second key's basic block\n  firstKey.getAFlowNode().getBasicBlock().strictlyDominates(\n    secondKey.getAFlowNode().getBasicBlock()\n  )\n}\n\n// Identify dictionary literals containing duplicate keys\nfrom Dict dictionary, Expr firstKey, Expr secondKey\nwhere\n  // Keys must have identical normalized representations but be different expressions\n  exists(string keySignature | \n    keyNormalization(dictionary, firstKey, keySignature) and \n    keyNormalization(dictionary, secondKey, keySignature) and \n    firstKey != secondKey\n  ) and\n  // Verify proper temporal ordering of key occurrences\n  temporalKeyOrder(firstKey, secondKey)\n// Report the overwritten key with location of the overwriting duplicate\nselect firstKey, \n       \"Dictionary key \" + repr(firstKey) + \" is subsequently $@.\", \n       secondKey, \n       \"overwritten\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-global]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies instances where 'global' statements are used within non-module scopes,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Usage of 'global' keyword in Python code.\n * @description Identifies instances where 'global' statements are used within non-module scopes,\n *              which can lead to code that is difficult to maintain and understand due to\n *              implicit dependencies between function code and global state.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/use-of-global\n */\n\nimport python\n\n// Find all global variable declarations in the Python codebase\nfrom Global globalDecl\n// Exclude global declarations that are at the module level, as these represent\n// proper module initialization patterns which are acceptable\nwhere not globalDecl.getScope() instanceof Module\n// Report global declarations found within functions or other non-module scopes,\n// as they may indicate poor encapsulation and make code harder to reason about\nselect globalDecl, \"Usage of 'global' keyword in non-module scope can reduce code maintainability and clarity.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-parameters-without-default-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query identifies and counts function parameters that do not have default value assignments.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-default Parameter Count Analysis\n * @description This query identifies and counts function parameters that do not have default value assignments.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // 导入Python模块，用于支持Python代码的静态分析功能\n\n// 定义函数对象作为分析目标\nfrom FunctionMetrics functionObj\n// 确保函数具有可分析的参数结构\nwhere exists(functionObj.getNumberOfParametersWithoutDefault())\n// 选择函数及其无默认值参数数量统计\nselect functionObj, \n       functionObj.getNumberOfParametersWithoutDefault() as paramCountNoDefault \n// 按无默认值参数数量降序排列结果\norder by paramCountNoDefault desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/old-style-octal-literal]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Octal literal with a leading 0 is easily misread as a decimal value",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Confusing octal literal\n * @description Octal literal with a leading 0 is easily misread as a decimal value\n * @kind problem\n * @tags readability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/old-style-octal-literal\n */\n\nimport python\n\n// 定义一个谓词函数，用于判断是否为旧式八进制字面量\npredicate is_old_octal(IntegerLiteral i) {\n  // 检查是否存在满足以下条件的字符串文本\n  exists(string text | text = i.getText() |\n    text.charAt(0) = \"0\" and // 第一个字符是'0'\n    not text = \"00\" and // 排除掉\"00\"这种情况\n    exists(text.charAt(1).toInt()) and // 第二个字符是一个数字\n    /* Do not flag file permission masks */\n    // 检查文本长度不是4、5或7（排除文件权限掩码）\n    exists(int len | len = text.length() |\n      len != 4 and\n      len != 5 and\n      len != 7\n    )\n  )\n}\n\n// 从所有整数字面量中选择符合条件的旧式八进制字面量\nfrom IntegerLiteral i\nwhere is_old_octal(i)\nselect i, \"Confusing octal literal, use 0o\" + i.getText().suffix(1) + \" instead.\" // 选择并提示应使用0o前缀的八进制表示法"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-shadowed-loop-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a loop variable shadows an imported module or name.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Import shadowed by loop variable\n * @description Detects when a loop variable shadows an imported module or name.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/import-shadowed-loop-variable\n */\n\n// Import the Python analysis library to enable code examination capabilities\nimport python\n\n// Define a predicate that identifies when a variable shadows an imported name\npredicate shadowsImport(Variable iterationVar) {\n  exists(Import importedModule, Name obscuredName |\n    // The obscured name corresponds to an alias of an imported module\n    obscuredName = importedModule.getAName().getAsname() and\n    // The obscured name shares the same identifier as the iteration variable\n    obscuredName.getId() = iterationVar.getId() and\n    // The scope of the import includes the scope of the iteration variable\n    importedModule.getScope() = iterationVar.getScope().getScope*()\n  )\n}\n\n// Check if a name definition corresponds to a for loop target\npredicate isForLoopTarget(Name nameDefn) {\n  exists(For loopStatement | nameDefn = loopStatement.getTarget())\n}\n\n// Query to find all relevant variables and name definitions matching our criteria\nfrom Variable iterationVar, Name varDefinition\n// Combine conditions: variable shadows import, is defined by the name, and is a for loop target\nwhere shadowsImport(iterationVar) and\n      varDefinition.defines(iterationVar) and\n      isForLoopTarget(varDefinition)\n// Output the name definition with a warning about the shadowed import\nselect varDefinition, \"Loop variable '\" + iterationVar.getId() + \"' shadows an import.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all cryptographic algorithm usage patterns across supported libraries.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name All Cryptographic Algorithms\n * @description Identifies all cryptographic algorithm usage patterns across supported libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import required Python and Semmle libraries\nimport python\nimport semmle.python.Concepts\n\n// Identify cryptographic operations and their associated algorithm identifiers\nfrom Cryptography::CryptographicOperation cryptoOp, string algorithmName\nwhere\n  // Extract algorithm name from cryptographic operation\n  algorithmName = cryptoOp.getAlgorithm().getName()\n  or\n  // Extract block mode identifier from cryptographic operation\n  algorithmName = cryptoOp.getBlockMode()\nselect cryptoOp, \"Use of algorithm \" + algorithmName"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-star-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using import * prevents some analysis",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' used\n * @description Using import * prevents some analysis\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// 引入Python代码分析模块，提供基础解析和分析能力\nimport python\n\n// 识别所有采用通配符导入语法的代码位置\nfrom ImportStar wildcardImport\n\n// 输出检测结果：标记每个通配符导入实例并提供相关警告信息\nselect wildcardImport, \"Using 'from ... import *' pollutes the namespace and may hinder code analysis.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Detects cryptographic operations using elliptic curve algorithms that are either \n *              unrecognized or considered cryptographically weak, potentially leading to security vulnerabilities.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm ellipticCurveOp, string alertMessage, string curveIdentifier\nwhere\n  // Define cryptographically approved elliptic curves\n  curveIdentifier = ellipticCurveOp.getCurveName() and\n  (\n    // Case 1: Handle unrecognized curve algorithms\n_______________ // 补全条件\n    alertMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: Handle recognized but weak curve algorithms\n    curveIdentifier != unknownAlgorithm() and\n    not curveIdentifier in [\n      \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n      \"SECP384R1\",              // P-384 curve\n      \"SECP521R1\",              // P-521 curve\n      \"ED25519\",                // Ed25519 curve\n      \"X25519\"                  // X25519 curve\n    ] and\n    alertMessage = \"Use of weak curve algorithm \" + curveIdentifier + \".\"\n  )\nselect ellipticCurveOp, alertMessage",
    "output": "curveIdentifier = unknownAlgorithm() and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python Syntax Error Detection\n * @description Detects Python code containing syntax errors that lead to runtime failures and obstruct code analysis\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error */\n\nimport python\n\n// Locate syntax errors while filtering out encoding-related problems\n_______________ // 补全条件\nwhere not syntaxErr instanceof EncodingError\n// Provide error details with Python version information\nselect syntaxErr, syntaxErr.getMessage() + \" (in Python \" + major_version() + \").\"",
    "output": "from SyntaxError syntaxErr"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects instances where an attribute set in a superclass constructor",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description Detects instances where an attribute set in a superclass constructor\n *              hides a method implemented in a subclass, which may result in runtime errors\n *              or unintended behavior during program execution.\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * This analysis identifies methods within subclasses that become inaccessible due to\n * instance variables with matching names being initialized in the superclass constructor.\n * This scenario can cause method invocations to unexpectedly reference attribute values\n * rather than executing the intended method logic.\n */\n\nimport python\n\n// Predicate that identifies subclass methods hidden by superclass attributes\npredicate isMethodObscuredBySuperclassAttribute(\n  ClassObject derivedClass, ClassObject baseClass, Assign attributeAssignment, FunctionObject maskedMethod\n) {\n  // Establish inheritance relationship between the classes\n  derivedClass.getASuperType() = baseClass and\n  // Verify that the subclass contains the method that gets hidden\n  derivedClass.declaredAttribute(_) = maskedMethod and\n  // Find the superclass constructor where the hiding attribute is defined\n  exists(FunctionObject baseClassInit |\n    baseClass.declaredAttribute(\"__init__\") = baseClassInit and\n    // Identify the attribute assignment responsible for the hiding effect\n    exists(Attribute targetAttribute |\n      targetAttribute = attributeAssignment.getATarget() and\n      // Confirm the attribute is assigned to 'self' (instance variable)\n      targetAttribute.getObject().(Name).getId() = \"self\" and\n      // Ensure the attribute name matches the hidden method name\n      targetAttribute.getName() = maskedMethod.getName() and\n      // Verify the assignment happens within the constructor's scope\n      attributeAssignment.getScope() = baseClassInit.getOrigin().(FunctionExpr).getInnerScope()\n    )\n  ) and\n  // Exclude scenarios where the superclass defines a method with the same name\n  not baseClass.hasAttribute(maskedMethod.getName())\n}\n\n// Primary query to identify and report hidden methods\nfrom ClassObject derivedClass, ClassObject baseClass, Assign attributeAssignment, FunctionObject maskedMethod\nwhere isMethodObscuredBySuperclassAttribute(derivedClass, baseClass, attributeAssignment, maskedMethod)\n// Output: location of hidden method, detailed message, and location of hiding attribute\nselect maskedMethod.getOrigin(),\n  \"Method \" + maskedMethod.getName() + \" is obscured by an $@ in superclass '\" + baseClass.getName() +\n    \"'.\", attributeAssignment, \"attribute\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/direct-imports-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The number of modules directly imported by this file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Direct imports per file\n * @description The number of modules directly imported by this file.\n * @kind treemap\n * @id py/direct-imports-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg max\n * @tags modularity\n *       maintainability\n */\n\n// 引入Python分析库，提供代码解析和分析功能\nimport python\n\n// 遍历所有模块对象，并统计其直接导入的模块数量\nfrom ModuleValue moduleObj, int importCount\n// 筛选条件：importCount等于当前模块直接导入的模块总数\nwhere importCount = count(ModuleValue importedModule | importedModule = moduleObj.getAnImportedModule())\n// 输出结果：模块的作用域范围及其直接导入的模块数量\nselect moduleObj.getScope(), importCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-standard exception raised in special method\n * @description Raising a non-standard exception in a special method alters the expected interface of that method.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/unexpected-raise-in-special-method\n */\n\nimport python\n\n// Identifies attribute-related special methods\nprivate predicate isAttributeMethod(string methodNameStr) {\n  methodNameStr = \"__getattribute__\" or \n  methodNameStr = \"__getattr__\" or \n  methodNameStr = \"__setattr__\"\n}\n\n// Identifies indexing-related special methods\nprivate predicate isIndexingMethod(string methodNameStr) {\n  methodNameStr = \"__getitem__\" or \n  methodNameStr = \"__setitem__\" or \n  methodNameStr = \"__delitem__\"\n}\n\n// Identifies arithmetic operation special methods\nprivate predicate isArithmeticMethod(string methodNameStr) {\n  methodNameStr in [\n      \"__add__\", \"__sub__\", \"__or__\", \"__xor__\", \"__rshift__\", \"__pow__\", \"__mul__\", \"__neg__\",\n      \"__radd__\", \"__rsub__\", \"__rdiv__\", \"__rfloordiv__\", \"__div__\", \"__rdiv__\", \"__rlshift__\",\n      \"__rand__\", \"__ror__\", \"__rxor__\", \"__rrshift__\", \"__rpow__\", \"__rmul__\", \"__truediv__\",\n      \"__rtruediv__\", \"__pos__\", \"__iadd__\", \"__isub__\", \"__idiv__\", \"__ifloordiv__\", \"__idiv__\",\n      \"__ilshift__\", \"__iand__\", \"__ior__\", \"__ixor__\", \"__irshift__\", \"__abs__\", \"__ipow__\",\n      \"__imul__\", \"__itruediv__\", \"__floordiv__\", \"__div__\", \"__divmod__\", \"__lshift__\", \"__and__\"\n    ]\n}\n\n// Identifies ordering comparison special methods\nprivate predicate isOrderingMethod(string methodNameStr) {\n  (methodNameStr = \"__lt__\" or \n   methodNameStr = \"__le__\" or \n   methodNameStr = \"__gt__\" or \n   methodNameStr = \"__ge__\") \n  or \n  (methodNameStr = \"__cmp__\" and major_version() = 2)\n}\n\n// Identifies type conversion special methods\nprivate predicate isCastMethod(string methodNameStr) {\n  (methodNameStr = \"__nonzero__\" and major_version() = 2)\n  or\n  methodNameStr = \"__int__\" or \n  methodNameStr = \"__float__\" or \n  methodNameStr = \"__long__\" or \n  methodNameStr = \"__trunc__\" or \n  methodNameStr = \"__complex__\"\n}\n\n// Determines if exception type is appropriate for the special method\npredicate isCorrectExceptionType(string methodNameStr, ClassObject exceptionType) {\n  // Check for TypeError compatibility with specific method categories\n  exceptionType.getAnImproperSuperType() = theTypeErrorType() and\n  (\n    methodNameStr = \"__copy__\" or \n    methodNameStr = \"__deepcopy__\" or \n    methodNameStr = \"__call__\" or \n    isIndexingMethod(methodNameStr) or \n    isAttributeMethod(methodNameStr)\n  )\n  or\n  // Check against preferred exception types\n  isPreferredExceptionType(methodNameStr, exceptionType)\n  or\n  // Check against parent exception types\n  isPreferredExceptionType(methodNameStr, exceptionType.getASuperType())\n}\n\n// Determines preferred exception types for special methods\npredicate isPreferredExceptionType(string methodNameStr, ClassObject exceptionType) {\n  // Attribute methods should raise AttributeError\n  isAttributeMethod(methodNameStr) and exceptionType = theAttributeErrorType()\n  or\n  // Indexing methods should raise LookupError\n  isIndexingMethod(methodNameStr) and exceptionType = Object::builtin(\"LookupError\")\n  or\n  // Ordering methods should raise TypeError\n  isOrderingMethod(methodNameStr) and exceptionType = theTypeErrorType()\n  or\n  // Arithmetic methods should raise ArithmeticError\n  isArithmeticMethod(methodNameStr) and exceptionType = Object::builtin(\"ArithmeticError\")\n  or\n  // __bool__ method should raise TypeError\n  methodNameStr = \"__bool__\" and exceptionType = theTypeErrorType()\n}\n\n// Identifies cases where exception raising is unnecessary\npredicate isUnnecessaryRaise(string methodNameStr, string suggestionMessage) {\n  // Hash method should use __hash__ = None instead\n  methodNameStr = \"__hash__\" and suggestionMessage = \"use __hash__ = None instead\"\n  or\n  // Cast methods don't need implementation\n  isCastMethod(methodNameStr) and suggestionMessage = \"there is no need to implement the method at all.\"\n}\n\n_______________ // 补全条件\npredicate isAbstractFunction(FunctionObject specialMethod) {\n  // Check for decorators containing \"abstract\"\n  specialMethod.getFunction().getADecorator().(Name).getId().matches(\"%abstract%\")\n}\n\n// Identifies functions that always raise a specific exception\npredicate alwaysRaisesException(FunctionObject specialMethod, ClassObject exceptionType) {\n  // Function raises exactly one exception type with no normal exits\n  exceptionType = specialMethod.getARaisedType() and\n  strictcount(specialMethod.getARaisedType()) = 1 and\n  not exists(specialMethod.getFunction().getANormalExit()) and\n  /* raising StopIteration is equivalent to a return in a generator */\n  not exceptionType = theStopIterationType()\n}\n\n// Main query to identify special methods with non-standard exception handling\nfrom FunctionObject specialMethod, ClassObject exceptionClass, string suggestionMessage\nwhere\n  // Filter for special methods that aren't abstract\n  specialMethod.getFunction().isSpecialMethod() and\n  not isAbstractFunction(specialMethod) and\n  alwaysRaisesException(specialMethod, exceptionClass) and\n  (\n    // Check for unnecessary exception cases\n    isUnnecessaryRaise(specialMethod.getName(), suggestionMessage) and \n    not exceptionClass.getName() = \"NotImplementedError\"\n    or\n    // Check for incorrect exception types\n    not isCorrectExceptionType(specialMethod.getName(), exceptionClass) and\n    not exceptionClass.getName() = \"NotImplementedError\" and\n    exists(ClassObject preferredException | \n      isPreferredExceptionType(specialMethod.getName(), preferredException) |\n      suggestionMessage = \"raise \" + preferredException.getName() + \" instead\"\n    )\n  )\nselect specialMethod, \"Function always raises $@; \" + suggestionMessage, exceptionClass, exceptionClass.toString()",
    "output": "// Identifies abstract functions"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-number-class-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别在类实例化过程中传递给构造函数的参数数量与预期不符的情况。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 类实例化参数数量不匹配\n * @description 识别在类实例化过程中传递给构造函数的参数数量与预期不符的情况。\n *              当调用类的初始化方法 `__init__` 时，如果提供的参数数量不正确，\n *              将会在运行时引发 TypeError 异常。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstantiation, ClassValue targetClass, string errorMsg, string paramConstraint, int expectedParamCount, FunctionValue initializerMethod\nwhere\n  (\n    // 检测参数数量超过预期的情况\n    too_many_args(classInstantiation, targetClass, expectedParamCount) and\n    errorMsg = \"too many arguments\" and\n    paramConstraint = \"no more than \"\n    or\n    // 检测参数数量不足的情况\n    too_few_args(classInstantiation, targetClass, expectedParamCount) and\n    errorMsg = \"too few arguments\" and\n    paramConstraint = \"no fewer than \"\n  ) and\n  // 获取目标类的构造函数或初始化方法\n  initializerMethod = get_function_or_initializer(targetClass)\nselect classInstantiation, \n  \"Call to $@ with \" + errorMsg + \"; should be \" + paramConstraint + expectedParamCount.toString() + \".\", \n  initializerMethod,\n  initializerMethod.getQualifiedName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Identification of insecure asymmetric cryptographic padding\n * @description\n * This query identifies asymmetric cryptographic padding schemes that are considered insecure,\n * deprecated, or lacking proper security validation. It flags padding algorithms that do not\n * conform to established security standards, specifically targeting schemes other than the\n * recommended OAEP (Optimal Asymmetric Encryption Padding), KEM (Key Encapsulation Mechanism),\n * and PSS (Probabilistic Signature Scheme) methods. Using non-standard padding can lead to\n * vulnerabilities including malleability, chosen ciphertext attacks, or insufficient entropy,\n * which may compromise the confidentiality and integrity of cryptographic operations.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Locate asymmetric padding implementations that use non-approved algorithms\nfrom AsymmetricPadding weakPadding, string algorithmName\nwhere \n  // Retrieve the name of the padding algorithm in use\n  algorithmName = weakPadding.getPaddingName()\n  // Filter out results that use approved secure padding methods\n_______________ // 补全条件\nselect weakPadding, \"Use of unapproved, weak, or unknown asymmetric padding algorithm or API: \" + algorithmName",
    "output": "and not algorithmName = [\"OAEP\", \"KEM\", \"PSS\"]"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of an undefined global variable\n * @description Using a global variable before it is initialized causes an exception.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision low\n * @id py/undefined-global-variable\n */\n\nimport python\nimport Variables.MonkeyPatched\nimport semmle.python.pointsto.PointsTo\n\n// Check if variable usage is protected by NameError handling\npredicate is_name_error_guarded(Name variableAccess) {\n  // Protection via try-except block catching NameError\n  exists(Try tryBlock | tryBlock.getBody().getAnItem().contains(variableAccess) |\n    tryBlock.getAHandler().getType().(Name).getId() = \"NameError\"\n  )\n  or\n  // Protection via conditional block controlling globals() check\n  exists(ConditionBlock guardBlock, BasicBlock controlledBlock, Call globalsCall |\n    guardBlock.getLastNode().getNode().contains(globalsCall) or\n    guardBlock.getLastNode().getNode() = globalsCall\n  |\n    globalsCall.getFunc().(Name).getId() = \"globals\" and\n    guardBlock.controls(controlledBlock, _) and\n    controlledBlock.contains(variableAccess.getAFlowNode())\n  )\n}\n\n// Check if module contains unresolved star imports\npredicate has_unresolved_star_import(Module mod) {\n  exists(ImportStar starImport | starImport.getScope() = mod |\n    exists(ModuleValue importedModule | \n      importedModule.importedAs(starImport.getImportedModuleName()) and\n      not importedModule.hasCompleteExportInfo()\n    )\n  )\n}\n\n// Check for undefined global usage within function scope\npredicate is_undefined_in_function_context(Name variableAccess) {\n  exists(Function enclosingFunction |\n    variableAccess.getScope().getScope*() = enclosingFunction and\n    // Verify function is method/nested or module-initialized\n    (\n      not enclosingFunction.getScope() = variableAccess.getEnclosingModule() or\n      variableAccess.getEnclosingModule().(ImportTimeScope).definesName(enclosingFunction.getName())\n    ) and\n    // Identify undefined global variable\n    exists(GlobalVariable globalVar | variableAccess.uses(globalVar) |\n      not exists(Assign assignment, Scope definitionScope |\n        assignment.getATarget() = globalVar.getAnAccess() and assignment.getScope() = definitionScope\n      |\n        definitionScope = enclosingFunction\n        or\n        // Exclude modules (handled separately)\n        (definitionScope = enclosingFunction.getScope().getScope*() and \n         not definitionScope instanceof Module)\n      )\n    )\n  ) and\n  // Ensure no module-level definition\n  not variableAccess.getEnclosingModule().(ImportTimeScope).definesName(variableAccess.getId()) and\n  not exists(ModuleValue moduleVal | moduleVal.getScope() = variableAccess.getEnclosingModule() | \n    moduleVal.hasAttribute(variableAccess.getId())) and\n  not globallyDefinedName(variableAccess.getId()) and\n  not exists(SsaVariable ssaVar | ssaVar.getAUse().getNode() = variableAccess and \n    not ssaVar.maybeUndefined()) and\n  not is_name_error_guarded(variableAccess) and\n  not (variableAccess.getEnclosingModule().isPackageInit() and variableAccess.getId() = \"__path__\")\n}\n\n// Check for undefined global usage within class/module scope\npredicate is_undefined_in_class_or_module(Name variableAccess) {\n  exists(GlobalVariable globalVar | variableAccess.uses(globalVar)) and\n  not variableAccess.getScope().getScope*() instanceof Function and\n  exists(SsaVariable ssaVar | ssaVar.getAUse().getNode() = variableAccess and \n    ssaVar.maybeUndefined()) and\n  not is_name_error_guarded(variableAccess) and\n  not exists(ModuleValue moduleVal | moduleVal.getScope() = variableAccess.getEnclosingModule() | \n    moduleVal.hasAttribute(variableAccess.getId())) and\n  not (variableAccess.getEnclosingModule().isPackageInit() and variableAccess.getId() = \"__path__\") and\n  not globallyDefinedName(variableAccess.getId())\n}\n\n// Check if module uses dynamic exec() functions\npredicate uses_dynamic_execution(Module mod) {\n  exists(Exec execStatement | execStatement.getScope() = mod)\n_______________ // 补全条件\n  exists(CallNode callNode, FunctionValue execFunction | \n    execFunction.getACall() = callNode and callNode.getScope() = mod and\n    (execFunction.getName() = \"exec\" or execFunction.getName() = \"execfile\")\n  )\n}\n\n// Main predicate for undefined global variable usage\npredicate is_undefined_global_usage(Name variableAccess) {\n  // Combine context checks with exclusions\n  (\n    is_undefined_in_class_or_module(variableAccess)\n    or\n    is_undefined_in_function_context(variableAccess)\n  ) and\n  // Apply exclusions\n  not monkey_patched_builtin(variableAccess.getId()) and\n  not has_unresolved_star_import(variableAccess.getEnclosingModule()) and\n  not uses_dynamic_execution(variableAccess.getEnclosingModule()) and\n  not exists(variableAccess.getVariable().getAStore()) and\n  not variableAccess.pointsTo(_)\n}\n\n// Check for first occurrence in a basic block\nprivate predicate is_first_usage_in_block(Name variableUsage) {\n  exists(GlobalVariable globalVar, BasicBlock block, int nodeIndex |\n    nodeIndex = min(int index | block.getNode(index).getNode() = globalVar.getALoad()) and \n    block.getNode(nodeIndex) = variableUsage.getAFlowNode()\n  )\n}\n\n// Identify first undefined usage in control flow\npredicate is_first_undefined_usage(Name variableUsage) {\n  is_undefined_global_usage(variableUsage) and\n  exists(GlobalVariable globalVar | globalVar.getALoad() = variableUsage |\n    is_first_usage_in_block(variableUsage) and\n    not exists(ControlFlowNode otherNode |\n      otherNode.getNode() = globalVar.getALoad() and\n      otherNode.getBasicBlock().strictlyDominates(variableUsage.getAFlowNode().getBasicBlock())\n    )\n  )\n}\n\n// Query: Find first undefined global variable usages\nfrom Name variableAccess\nwhere is_first_undefined_usage(variableAccess)\nselect variableAccess, \"This use of global variable '\" + variableAccess.getId() + \"' may be undefined.\"",
    "output": "or"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description A navigation utility that maps code references to their \n *              corresponding source definitions within Python codebases.\n * @kind definitions\n * @id py/source-definition-locator\n */\n\n// Core Python analysis library for examining Python source code structures\nimport python\n\n// Definition tracking module to enable tracing of variables, functions, and class declarations\nimport analysis.DefinitionTracking\n\n// Identify code references with location information, their associated definitions,\n// and the classification of those definitions\nfrom NiceLocationExpr refLocation, \n     Definition defTarget, \n     string defType\n// Establish the relationship between references and their corresponding definitions\n// ensuring type consistency is maintained\nwhere defTarget = definitionOf(refLocation, defType)\n// Display the reference location, definition location, and definition type to support navigation\nselect refLocation, defTarget, defType",
    "output": "* @name Source Definition Locator"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of co-committed files\n * @description Calculates the average number of files modified together when a specific file is changed in a commit.\n *              This metric identifies files frequently modified together, indicating potential dependencies.\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Helper function: Computes the total count of files affected by a given commit\n_______________ // 补全条件\n    result = count(commitObj.getAnAffectedFile()) \n}\n\n// Main analysis: Examines co-modification patterns across different modules\nfrom Module analyzedModule\n// Filtering condition: Only include modules that have available lines of code metrics\nwhere exists(analyzedModule.getMetrics().getNumberOfLinesOfCode())\nselect analyzedModule,\n  // Determine the average count of files modified together with files in this module\n  avg(Commit commitObj, int coChangedFilesNumber |\n    // Condition: The commit affects a file within the analyzed module\n    commitObj.getAnAffectedFile() = analyzedModule.getFile() and \n    // Calculate the number of additional files modified in the same commit\n    coChangedFilesNumber = calculateTotalFilesInCommit(commitObj) - 1\n  |\n    coChangedFilesNumber\n  )",
    "output": "int calculateTotalFilesInCommit(Commit commitObj) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Identical Value Comparison Detection\n * @description This query identifies locations in Python code where identical values are compared,\n *              which could indicate unclear programming logic or potential bugs.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n_______________ // 补全条件\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\nimport python\nimport Expressions.RedundantComparison\n\n/* \n * Find redundant comparisons that are:\n * 1. Not constant (to avoid flagging intentional constant comparisons)\n * 2. Not potentially missing 'self' (to avoid false positives in class methods)\n */\nfrom RedundantComparison identicalValueComparison\nwhere \n  not identicalValueComparison.isConstant() and \n  not identicalValueComparison.maybeMissingSelf()\n\n/* Report findings with remediation guidance for floating-point NaN checks */\nselect identicalValueComparison, \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\"",
    "output": "*       external/cwe/cwe-570"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Comprehensive Cryptographic Algorithm Detection\n * @description Discovers and catalogs all cryptographic algorithm implementations \n *              across supported libraries in the codebase.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import required modules for Python code analysis and cryptographic concept detection\nimport python\nimport semmle.python.Concepts\n\n// Main query to identify cryptographic operations and extract their algorithm details\nfrom Cryptography::CryptographicOperation cryptoOp, string algoName\nwhere \n  // First condition: Direct extraction of the algorithm name from the cryptographic operation\n  algoName = cryptoOp.getAlgorithm().getName()\n  or\n  // Second condition: Extraction of block mode information when available\n  algoName = cryptoOp.getBlockMode()\nselect cryptoOp, \"Use of algorithm \" + algoName",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure randomness\n * @description Identifies security-sensitive operations that employ \n *              cryptographically weak pseudo-random number generators, \n *              enabling attackers to predict generated values and \n *              compromise system security.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// Core Python language analysis framework\nimport python\n\n// Security analysis module specialized for detecting weak random number generation\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Data flow tracking and propagation engine\nimport semmle.python.dataflow.new.DataFlow\n\n// Visualization components for data flow paths\nimport InsecureRandomness::Flow::PathGraph\n\n// Query for detecting propagation of insecure random values\nfrom \n  InsecureRandomness::Flow::PathNode insecureRndSrc,    // Starting point of insecure random value\n  InsecureRandomness::Flow::PathNode sensitiveUsePoint  // Security-sensitive destination\nwhere \n  // Establish data flow connection between source and sink\n  InsecureRandomness::Flow::flowPath(insecureRndSrc, sensitiveUsePoint)\nselect \n  sensitiveUsePoint.getNode(),                      // Target location of insecure usage\n_______________ // 补全条件\n  sensitiveUsePoint,                                // Sink node for visualization\n  \"Cryptographically insecure $@ in security context.\", // Alert description\n  insecureRndSrc.getNode(),                         // Reference node for alert message\n  \"random value\"                                    // Description of vulnerable element",
    "output": "insecureRndSrc,                                    // Origin node for path tracking"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Conflicting attributes in base classes\n * @description Detects when a class inherits multiple base classes defining the same attribute, \n *              which may lead to unexpected behavior due to attribute overriding.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n/**\n * Determines if a function contains only pass statements and a docstring.\n */\n_______________ // 补全条件\n  not exists(Stmt statement | statement.getScope() = func.getFunction() |\n    not statement instanceof Pass and \n    not statement.(ExprStmt).getValue() = func.getFunction().getDocString()\n  )\n}\n\n/**\n * Checks if a function invokes a parent class method using super().\n */\npredicate has_super_call(FunctionObject func) {\n  exists(Call superCall, Call methodCall, Attribute attr, GlobalVariable superVar |\n    methodCall.getScope() = func.getFunction() and\n    methodCall.getFunc() = attr and\n    attr.getObject() = superCall and\n    attr.getName() = func.getName() and\n    superCall.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/**\n * Identifies attribute names excluded from conflict detection.\n */\npredicate is_exempt_attribute(string attributeName) {\n  /*\n   * Exemption for standard library recommendation:\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   */\n  attributeName = \"process_request\"\n}\n\nfrom\n  ClassObject childClass, ClassObject baseClass1, ClassObject baseClass2, \n  string attributeName, int index1, int index2, \n  Object attribute1, Object attribute2\nwhere\n  // Ensure distinct base classes with ordered inheritance\n  childClass.getBaseType(index1) = baseClass1 and\n  childClass.getBaseType(index2) = baseClass2 and\n  index1 < index2 and\n  \n  // Locate conflicting attributes in base classes\n  attribute1 = baseClass1.lookupAttribute(attributeName) and\n  attribute2 = baseClass2.lookupAttribute(attributeName) and\n  attribute1 != attribute2 and\n  \n  // Filter special methods (dunder methods)\n  not attributeName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  \n  // Exclude safe overriding cases\n  not has_super_call(attribute1) and\n  \n  // Ignore empty implementations in second base\n  not is_empty_function(attribute2) and\n  \n  // Skip exempted attribute names\n  not is_exempt_attribute(attributeName) and\n  \n  // Verify no override relationship exists\n  not attribute1.overrides(attribute2) and\n  not attribute2.overrides(attribute1) and\n  \n  // Ensure child class doesn't explicitly declare the attribute\n  not childClass.declaresAttribute(attributeName)\nselect childClass, \n  \"Base classes have conflicting values for attribute '\" + attributeName + \"': $@ and $@.\", \n  attribute1, attribute1.toString(), \n  attribute2, attribute2.toString()",
    "output": "predicate is_empty_function(PyFunctionObject func) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-exception in 'except' clause\n * @description Identifies exception handlers that specify non-exception types,\n *              which are ineffective at catching actual runtime exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Analyze exception handling constructs for invalid exception types\nfrom ExceptFlowNode exceptHandler, Value caughtType, ClassValue raisedClass, \n     ControlFlowNode raiseLocation, string typeDesc\nwhere\n  // Verify the handler processes a specific exception type from the source\n  exceptHandler.handledException(caughtType, raisedClass, raiseLocation) and\n  (\n    // Case 1: Exception type is a class but not a valid exception class\n    exists(ClassValue invalidClass | \n      invalidClass = caughtType and\n      not invalidClass.isLegalExceptionType() and\n      not invalidClass.failedInference(_) and\n      typeDesc = \"class '\" + invalidClass.getName() + \"'\"\n    )\n    or\n_______________ // 补全条件\n    not caughtType instanceof ClassValue and\n    typeDesc = \"instance of '\" + raisedClass.getName() + \"'\"\n  )\nselect exceptHandler.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  raiseLocation, typeDesc",
    "output": "// Case 2: Exception type is not a class at all"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/afferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This analysis measures the afferent coupling of classes,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class dependency impact analysis\n * @description This analysis measures the afferent coupling of classes,\n *              which represents the count of external classes that depend on a specific class.\n *              Classes with higher afferent coupling values are considered more\n *              architecturally significant and changes to them may have broader impact.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// Define the main analysis query for class coupling\nfrom ClassMetrics targetClass, int couplingCount\nwhere \n  // Calculate the afferent coupling for each class\n  couplingCount = targetClass.getAfferentCoupling() and\n  // Ensure the coupling count exists and is measurable\n  exists(couplingCount)\nselect \n  targetClass, \n  couplingCount \norder by \n  couplingCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raise-not-implemented]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code that incorrectly raises 'NotImplemented'",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name NotImplemented is not an Exception\n * @description Identifies code that incorrectly raises 'NotImplemented' \n *              instead of the proper 'NotImplementedError' exception.\n *              This pattern leads to type errors because NotImplemented is designed \n *              for comparison method return values, not as an exception.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Import Python analysis framework\nimport python\n\n// Import module for handling NotImplemented-related exception analysis\nimport Exceptions.NotImplemented\n\n// Identify raise statements that incorrectly use NotImplemented instead of NotImplementedError\nfrom Expr erroneousRaiseExpression\nwhere \n  // The following predicate detects expressions where NotImplemented is misused in raise statements\n  use_of_not_implemented_in_raise(_, erroneousRaiseExpression)\n// Report the problematic expression with a suggested correction\nselect erroneousRaiseExpression, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Empty except\n * @description Detects except clauses that do nothing without explanatory comments\n * @kind problem\n * @tags reliability\n *       maintainability\n * @external/cwe/cwe-390\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/empty-except\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Determines if an except block contains only pass statements\npredicate isEmptyExcept(ExceptStmt handler) {\n  // Verify absence of non-pass statements in the except block\n  not exists(Stmt s | s = handler.getAStmt() and not s instanceof Pass)\n}\n\n// Checks if an except statement lacks an else clause\npredicate lacksElseClause(ExceptStmt handler) { \n  // Confirm the absence of an else block in the try statement\n  not exists(handler.getTry().getOrelse()) \n}\n\n// Identifies except blocks without associated comments\npredicate hasNoComment(ExceptStmt handler) {\n  // Verify no comments exist within the except block's range\n  not exists(Comment c |\n    c.getLocation().getFile() = handler.getLocation().getFile() and\n_______________ // 补全条件\n    c.getLocation().getEndLine() <= handler.getBody().getLastItem().getLocation().getEndLine()\n  )\n}\n\n// Detects except handlers for non-local control flow exceptions\npredicate handlesNonLocalControlFlow(ExceptStmt handler) {\n  // Check if the exception type is StopIteration\n  handler.getType() = API::builtin(\"StopIteration\").getAValueReachableFromSource().asExpr()\n}\n\n// Verifies if a try block has normal execution paths\npredicate hasNormalExitPath(Try tryBlock) {\n  // Look for non-exceptional control flow transitions\n  exists(ControlFlowNode predecessor, ControlFlowNode successor |\n    /* Valid non-exceptional edge exists */\n    predecessor.getASuccessor() = successor and\n    not predecessor.getAnExceptionalSuccessor() = successor\n  |\n    /* Successor isn't a return node */\n    not exists(Scope s | s.getReturnNode() = successor) and\n    /* Predecessor is in try block, successor is outside */\n    predecessor.getNode().getParentNode*() = tryBlock.getAStmt() and\n    not successor.getNode().getParentNode*() = tryBlock.getAStmt()\n  )\n}\n\n// Checks if a statement involves attribute access\npredicate involvesAttributeAccess(Stmt statement) {\n  // Attribute access in expression statements\n  statement.(ExprStmt).getValue() instanceof Attribute\n  or\n  // Attribute access via built-in functions\n  exists(string name | statement.(ExprStmt).getValue().(Call).getFunc().(Name).getId() = name |\n    name in [\"getattr\", \"setattr\", \"delattr\"]\n  )\n  or\n  // Attribute deletion\n  statement.(Delete).getATarget() instanceof Attribute\n}\n\n// Identifies subscript operations in statements\npredicate involvesSubscriptOperation(Stmt statement) {\n  // Subscript access in expressions\n  statement.(ExprStmt).getValue() instanceof Subscript\n  or\n  // Subscript deletion\n  statement.(Delete).getATarget() instanceof Subscript\n}\n\n// Detects encoding/decoding operations with specific exception types\npredicate isEncodeOrDecodeCall(Call operation, Expr exceptionType) {\n  // Verify function name and match corresponding exception type\n  exists(string methodName | operation.getFunc().(Attribute).getName() = methodName |\n    (methodName = \"encode\" and\n     exceptionType = API::builtin(\"UnicodeEncodeError\").getAValueReachableFromSource().asExpr())\n    or\n    (methodName = \"decode\" and\n     exceptionType = API::builtin(\"UnicodeDecodeError\").getAValueReachableFromSource().asExpr())\n  )\n}\n\n// Identifies handlers targeting specific exception types with minimal handling\npredicate isMinimalExceptionHandler(ExceptStmt handler, Stmt statement, Expr exceptionType) {\n  // Single-statement try block with specific exception type\n  not exists(handler.getTry().getStmt(1)) and\n  statement = handler.getTry().getStmt(0) and\n  handler.getType() = exceptionType\n}\n\n// Detects focused exception handlers for specific error scenarios\npredicate isFocusedHandler(ExceptStmt handler) {\n  // Check for targeted exception handling patterns\n  exists(Stmt statement, Expr exceptionType | isMinimalExceptionHandler(handler, statement, exceptionType) |\n    // IndexError for subscript operations\n    (involvesSubscriptOperation(statement) and\n     exceptionType = API::builtin(\"IndexError\").getASubclass*().getAValueReachableFromSource().asExpr())\n    or\n    // AttributeError for attribute access\n    (involvesAttributeAccess(statement) and\n     exceptionType = API::builtin(\"AttributeError\").getAValueReachableFromSource().asExpr())\n    or\n    // NameError for name references\n    (statement.(ExprStmt).getValue() instanceof Name and\n     exceptionType = API::builtin(\"NameError\").getAValueReachableFromSource().asExpr())\n    or\n    // Encoding/decoding errors\n    isEncodeOrDecodeCall(statement.(ExprStmt).getValue(), exceptionType)\n  )\n}\n\n// Identifies try blocks that contain return statements\npredicate tryReturn(Try tryBlock) {\n  exists(Return returnStmt | returnStmt.getParentNode*() = tryBlock)\n}\n\n// Main query for detecting problematic empty except blocks\nfrom ExceptStmt handler\nwhere\n  // Identify empty except blocks without explanations\n  isEmptyExcept(handler) and\n  lacksElseClause(handler) and\n  hasNoComment(handler) and\n  // Exclude non-local control flow handlers\n  not handlesNonLocalControlFlow(handler) and\n  // Exclude try-return constructs\n  not tryReturn(handler.getTry()) and\n  // Verify normal execution paths exist\n  hasNormalExitPath(handler.getTry()) and\n  // Exclude focused exception handlers\n  not isFocusedHandler(handler)\nselect handler, \"'except' clause does nothing but pass and there is no explanatory comment.\"",
    "output": "c.getLocation().getStartLine() >= handler.getLocation().getStartLine() and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python source file comment density analysis\n * @description Calculates the ratio of comment lines to total lines in Python source files.\n *              This metric focuses exclusively on standard comments (lines starting with #),\n *              deliberately excluding docstrings which are considered separate documentation entities.\n * @kind treemap\n * @id py/comment-density-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n_______________ // 补全条件\nfrom Module sourceModule\nwhere sourceModule.getMetrics().getNumberOfLines() > 0\nselect sourceModule,\n       100.0 * sourceModule.getMetrics().getNumberOfLinesOfComments() / sourceModule.getMetrics().getNumberOfLines() as commentDensity\norder by commentDensity desc",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Comment line percentage analysis\n * @description This analysis calculates the percentage of comment lines relative to the total lines in a Python file.\n *              Note that docstrings are excluded from this calculation and are processed as a separate metric.\n * @kind treemap\n * @id py/comment-ratio-per-file\n_______________ // 补全条件\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\nfrom Module pyModule\nwhere pyModule.getMetrics().getNumberOfLines() > 0\nselect pyModule, \n       100.0 * pyModule.getMetrics().getNumberOfLinesOfComments() / pyModule.getMetrics().getNumberOfLines() as commentRatio\norder by commentRatio desc",
    "output": "* @treemap.warnOn lowValues"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Quantifies different categories of type annotations in Python code",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Quantifies different categories of type annotations in Python code\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Core Python built-in types for type annotation analysis\nclass CoreBuiltinType extends Name {\n  CoreBuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements supporting type annotations\nnewtype TypeAnnotatableElement =\n  TFunctionWithReturnType(FunctionExpr functionExpr) { exists(functionExpr.getReturns()) } or \n  TParameterWithTypeAnnotation(Parameter parameter) { exists(parameter.getAnnotation()) } or \n  TAssignmentWithTypeAnnotation(AnnAssign annotatedAssignment) { exists(annotatedAssignment.getAnnotation()) }\n\n// Base class for elements that can have type annotations\nabstract class BaseAnnotatable extends TypeAnnotatableElement {\n  string toString() { result = \"BaseAnnotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Represents functions with return type annotations\nclass FunctionWithReturnType extends TFunctionWithReturnType, BaseAnnotatable {\n  FunctionExpr functionExpr;\n  FunctionWithReturnType() { this = TFunctionWithReturnType(functionExpr) }\n  override Expr getAnnotation() { result = functionExpr.getReturns() }\n}\n\n// Represents parameters with type annotations\nclass ParameterWithTypeAnnotation extends TParameterWithTypeAnnotation, BaseAnnotatable {\n  Parameter parameter;\n  ParameterWithTypeAnnotation() { this = TParameterWithTypeAnnotation(parameter) }\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\n// Represents assignments with type annotations\nclass AssignmentWithTypeAnnotation extends TAssignmentWithTypeAnnotation, BaseAnnotatable {\n  AnnAssign annotatedAssignment;\n  AssignmentWithTypeAnnotation() { this = TAssignmentWithTypeAnnotation(annotatedAssignment) }\n  override Expr getAnnotation() { result = annotatedAssignment.getAnnotation() }\n}\n\n// Type classification predicates\n/** Identifies forward-declared types (string literals) */\npredicate is_forward_declaration(Expr typeAnnotation) { \n  typeAnnotation instanceof StringLiteral \n}\n\n/** Identifies complex type structures */\npredicate is_complex_type(Expr typeAnnotation) {\n  (typeAnnotation instanceof Subscript and not is_optional_type(typeAnnotation))\n  or\n  typeAnnotation instanceof Tuple\n  or\n  typeAnnotation instanceof List\n}\n\n/** Identifies Optional types */\npredicate is_optional_type(Subscript typeAnnotation) { \n  typeAnnotation.getObject().(Name).getId() = \"Optional\" \n}\n\n/** Identifies simple user-defined types */\npredicate is_simple_type(Expr typeAnnotation) {\n  (typeAnnotation instanceof Name and not typeAnnotation instanceof CoreBuiltinType)\n  or\n  is_simple_type(typeAnnotation.(Attribute).getObject())\n}\n\n/** Identifies built-in types */\npredicate is_builtin_type(Expr typeAnnotation) { \n  typeAnnotation instanceof CoreBuiltinType \n}\n\n// Computes type annotation metrics for different annotation categories\npredicate type_count(\n  string annotationCategory, int totalAnnotations, int builtinTypeCount, int forwardDeclarationCount, \n  int simpleUserTypeCount, int complexTypeStructureCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  annotationCategory = \"Parameter annotation\" and\n  totalAnnotations = count(ParameterWithTypeAnnotation annotatedParameter) and\n  builtinTypeCount = count(ParameterWithTypeAnnotation annotatedParameter | is_builtin_type(annotatedParameter.getAnnotation())) and\n  forwardDeclarationCount = count(ParameterWithTypeAnnotation annotatedParameter | is_forward_declaration(annotatedParameter.getAnnotation())) and\n  simpleUserTypeCount = count(ParameterWithTypeAnnotation annotatedParameter | is_simple_type(annotatedParameter.getAnnotation())) and\n  complexTypeStructureCount = count(ParameterWithTypeAnnotation annotatedParameter | is_complex_type(annotatedParameter.getAnnotation())) and\n  optionalTypeCount = count(ParameterWithTypeAnnotation annotatedParameter | is_optional_type(annotatedParameter.getAnnotation()))\n  or\n  // Return type annotation metrics\n  annotationCategory = \"Return type annotation\" and\n  totalAnnotations = count(FunctionWithReturnType annotatedFunction) and\n  builtinTypeCount = count(FunctionWithReturnType annotatedFunction | is_builtin_type(annotatedFunction.getAnnotation())) and\n  forwardDeclarationCount = count(FunctionWithReturnType annotatedFunction | is_forward_declaration(annotatedFunction.getAnnotation())) and\n  simpleUserTypeCount = count(FunctionWithReturnType annotatedFunction | is_simple_type(annotatedFunction.getAnnotation())) and\n  complexTypeStructureCount = count(FunctionWithReturnType annotatedFunction | is_complex_type(annotatedFunction.getAnnotation())) and\n  optionalTypeCount = count(FunctionWithReturnType annotatedFunction | is_optional_type(annotatedFunction.getAnnotation()))\n  or\n  // Annotated assignment metrics\n  annotationCategory = \"Annotated assignment\" and\n  totalAnnotations = count(AssignmentWithTypeAnnotation annotatedAssignmentExpr) and\n  builtinTypeCount = count(AssignmentWithTypeAnnotation annotatedAssignmentExpr | is_builtin_type(annotatedAssignmentExpr.getAnnotation())) and\n  forwardDeclarationCount = count(AssignmentWithTypeAnnotation annotatedAssignmentExpr | is_forward_declaration(annotatedAssignmentExpr.getAnnotation())) and\n  simpleUserTypeCount = count(AssignmentWithTypeAnnotation annotatedAssignmentExpr | is_simple_type(annotatedAssignmentExpr.getAnnotation())) and\n  complexTypeStructureCount = count(AssignmentWithTypeAnnotation annotatedAssignmentExpr | is_complex_type(annotatedAssignmentExpr.getAnnotation())) and\n  optionalTypeCount = count(AssignmentWithTypeAnnotation annotatedAssignmentExpr | is_optional_type(annotatedAssignmentExpr.getAnnotation()))\n}\n\n// Query execution and result projection\nfrom\n  string annotationCategory, int totalAnnotations, int builtinTypeCount, int forwardDeclarationCount, \n  int simpleUserTypeCount, int complexTypeStructureCount, int optionalTypeCount\nwhere \n  type_count(annotationCategory, totalAnnotations, builtinTypeCount, forwardDeclarationCount, simpleUserTypeCount, complexTypeStructureCount, optionalTypeCount)\nselect \n  annotationCategory, totalAnnotations, builtinTypeCount, forwardDeclarationCount, \n  simpleUserTypeCount, complexTypeStructureCount, optionalTypeCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Timing attack against Hash\n * @description 验证消息哈希值时必须使用恒定时间算法。\n *              攻击者可通过响应时间差异伪造有效哈希值，\n *              导致身份验证机制被绕过。\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/possible-timing-attack-against-hash\n * @tags security\n *       external/cwe/cwe-208\n *       experimental\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * 配置定义：用于追踪从加密操作到非恒定时间比较操作的数据流\n */\nprivate module TimingAttackConfig implements DataFlow::ConfigSig {\n  // 源节点：加密操作调用（例如哈希生成函数）\n  predicate isSource(DataFlow::Node cryptoOperation) { \n    cryptoOperation instanceof ProduceCryptoCall \n  }\n\n  // 汇节点：非恒定时间比较操作\n  predicate isSink(DataFlow::Node comparisonOperation) { \n    comparisonOperation instanceof NonConstantTimeComparisonSink \n  }\n}\n\n// 全局污点跟踪模块（基于上述配置）\nmodule TimingAttackFlow = TaintTracking::Global<TimingAttackConfig>;\nimport TimingAttackFlow::PathGraph\n\n// 主查询：识别从加密操作到非恒定时间比较的数据流路径\nfrom\n  TimingAttackFlow::PathNode hashSourceNode,      // 哈希源节点\n_______________ // 补全条件\nwhere \n  TimingAttackFlow::flowPath(hashSourceNode, comparisonSinkNode)\nselect \n  comparisonSinkNode.getNode(), \n  hashSourceNode, \n  comparisonSinkNode, \n  \"针对$@验证的时间攻击风险\",\n  hashSourceNode.getNode().(ProduceCryptoCall).getResultType(), \n  \"message\"",
    "output": "TimingAttackFlow::PathNode comparisonSinkNode   // 比较汇节点"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Detection of vulnerable or unverified asymmetric cryptographic padding schemes\n * @description\n * This security analysis identifies the use of asymmetric cryptographic padding algorithms\n * that are known to be vulnerable, not approved for security-sensitive applications,\n * or lack adequate security verification. For asymmetric cryptographic operations,\n * the only recommended padding methodologies are OAEP (Optimal Asymmetric Encryption Padding),\n * KEM (Key Encapsulation Mechanism), and PSS (Probabilistic Signature Scheme). Any other\n * padding technique may introduce security vulnerabilities and should be replaced with\n * one of the explicitly recommended approaches.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify asymmetric padding algorithms that are not in the approved secure set\nfrom AsymmetricPadding vulnerablePadding, string paddingSchemeName\n_______________ // 补全条件\n  // Retrieve the name of the padding algorithm being used\n  paddingSchemeName = vulnerablePadding.getPaddingName()\n  // Ensure the padding algorithm is not one of the approved secure schemes\n  and paddingSchemeName != \"OAEP\"\n  and paddingSchemeName != \"KEM\"\n  and paddingSchemeName != \"PSS\"\nselect vulnerablePadding, \"Use of unapproved, weak, or unknown asymmetric padding algorithm or API: \" + paddingSchemeName",
    "output": "where"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-parameters-without-default-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Counts the parameters in a function that lack default value assignments.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of parameters without defaults\n * @description Counts the parameters in a function that lack default value assignments.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // 导入Python模块，提供分析Python代码的基础功能\n\n// 获取所有函数指标\nfrom FunctionMetrics functionMetric\n// 计算每个函数的无默认值参数数量\nselect functionMetric, \n       functionMetric.getNumberOfParametersWithoutDefault() as paramCount \n// 按参数数量降序排序\norder by paramCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comment-density-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the ratio of comment lines to total lines in Python source files.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python source file comment density analysis\n * @description Calculates the ratio of comment lines to total lines in Python source files.\n *              This metric helps assess code documentation quality. Note that docstrings\n *              are excluded from this calculation and are handled separately.\n * @kind treemap\n * @id py/comment-density-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\nfrom Module sourceFile\nwhere sourceFile.getMetrics().getNumberOfLines() > 0\nselect sourceFile, 100.0 * sourceFile.getMetrics().getNumberOfLinesOfComments() / sourceFile.getMetrics().getNumberOfLines() as densityValue\norder by densityValue desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/polynomial-redos]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Regular expressions requiring polynomial matching time",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Polynomial regular expression used on uncontrolled data\n * @description Regular expressions requiring polynomial matching time\n *              may cause denial-of-service vulnerabilities.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @id py/polynomial-redos\n * @tags security\n *       external/cwe/cwe-1333\n *       external/cwe/cwe-730\n *       external/cwe/cwe-400\n */\n\n// Import Python analysis framework\nimport python\n// Import polynomial-time ReDoS detection module\nimport semmle.python.security.dataflow.PolynomialReDoSQuery\n// Import data flow path tracking utilities\nimport PolynomialReDoSFlow::PathGraph\n\n// Identify vulnerable regex patterns applied to uncontrolled data\nfrom\n  // Starting point of untrusted input in the data flow\n  PolynomialReDoSFlow::PathNode inputSource, \n  // Endpoint where data reaches regex processing\n  PolynomialReDoSFlow::PathNode regexEndpoint,\n  // Location where regex is executed\n  Sink regexExecutionSite,\n  // Regex pattern with potential for exponential backtracking\n  PolynomialBackTrackingTerm vulnerableRegexPattern\nwhere\n  // Verify complete data flow path exists from source to sink\n  PolynomialReDoSFlow::flowPath(inputSource, regexEndpoint) and\n  // Connect endpoint to actual regex execution site\n  regexExecutionSite = regexEndpoint.getNode() and\n  // Extract vulnerable regex pattern from execution site\n  vulnerableRegexPattern = regexExecutionSite.getABacktrackingTerm()\n// Disabled filter: Exclude URL sources with end-of-line patterns\n//   not (\n//     inputSource.getNode().(Source).getKind() = \"url\" and\n//     vulnerableRegexPattern.isAtEndLine()\n//   )\nselect\n  // Highlight vulnerable regex usage location\n  regexExecutionSite.getHighlight(), inputSource, regexEndpoint,\n  // Generate vulnerability description with technical details\n  \"This $@ processing a $@ may exhibit slow performance \" + vulnerableRegexPattern.getPrefixMessage() +\n    \"when encountering repeated instances of '\" + vulnerableRegexPattern.getPumpString() + \"'.\",\n  // Identify the problematic regex pattern\n  vulnerableRegexPattern, \"regular expression\",\n  // Identify the uncontrolled data source\n  inputSource.getNode(), \"user-provided input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies invocations of the built-in 'super' function within old-style classes, which lack support for this mechanism.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of 'super' in old-style class\n * @description Identifies invocations of the built-in 'super' function within old-style classes, which lack support for this mechanism.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n// Detects super() function calls within old-style class contexts where such functionality is not supported\npredicate superCallInOldStyleClass(Call superInvocation) {\n  exists(Function parentMethod, ClassObject targetClass |\n    // The call must be to the built-in 'super' function\n    superInvocation.getFunc().(Name).getId() = \"super\" and\n    \n    // The super() call must be inside a method/function\n    superInvocation.getScope() = parentMethod and\n    \n    // The enclosing function must be a method of a class\n    parentMethod.getScope() = targetClass.getPyClass() and\n    \n    // Ensure class analysis was successful\n    not targetClass.failedInference() and\n    \n    // Confirm the class is old-style (does not inherit from 'object')\n    not targetClass.isNewStyle()\n  )\n}\n\n// Find all super() calls that violate old-style class constraints\nfrom Call invalidSuperCall\nwhere superCallInOldStyleClass(invalidSuperCall)\nselect invalidSuperCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of commits\n * @description Counts the number of commits in the repository, excluding artificial changes\n * @kind treemap\n * @id py/historical-number-of-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n_______________ // 补全条件\n// Import Python language support for analysis\nimport python\n// Import Version Control System (VCS) libraries to access commit history\nimport external.VCS\n\n// Define the source of data: all commit records\nfrom Commit commitEntry\n// Filter condition: exclude commits that represent artificial changes\nwhere not artificialChange(commitEntry)\n// Selection: retrieve the revision name of each commit and count it as 1 for aggregation\nselect commitEntry.getRevisionName(), 1",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name First argument to super() is not enclosing class\n * @description Detects super() calls where the first parameter doesn't reference \n *              the immediate containing class, which may lead to incorrect \n *              inheritance chain initialization.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-687\n_______________ // 补全条件\n * @sub-severity low\n * @precision high\n * @id py/super-not-enclosing-class\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode superInvocation, string enclosingClassName\nwhere\n  // Identify all super() function calls in the codebase\n  superInvocation = API::builtin(\"super\").getACall() and\n  // Traverse scope hierarchy to find the immediate containing class name\n  enclosingClassName = superInvocation.getScope().getScope().(Class).getName() and\n  // Verify first argument exists and doesn't match the containing class\n  exists(DataFlow::Node firstArgument |\n    firstArgument = superInvocation.getArg(0) and\n    // Compare argument's identifier against the containing class name\n    firstArgument.getALocalSource().asExpr().(Name).getId() != enclosingClassName\n  )\nselect superInvocation.getNode(), \n       \"First argument to super() should be \" + enclosingClassName + \".\"",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/syntax-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Syntax errors cause failures at runtime and prevent analysis of the code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Syntax error\n * @description Syntax errors cause failures at runtime and prevent analysis of the code.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// 导入Python库，用于处理Python代码的查询和分析\nimport python\n\n// 从SyntaxError类中选择错误实例，但不包括EncodingError类型的错误\nfrom SyntaxError error\nwhere not error instanceof EncodingError\nselect error, error.getMessage() + \" (in Python \" + major_version() + \").\"\n// 选择语法错误实例以及错误信息，并附加当前Python主版本号"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unsafe usage of v1 version of Azure Storage client-side encryption.\n * @description Using version v1 of Azure Storage client-side encryption is insecure, and may enable an attacker to decrypt encrypted data\n * @kind path-problem\n * @tags security\n *       experimental\n *       cryptography\n *       external/cwe/cwe-327\n * @id py/azure-storage/unsafe-client-side-encryption-in-use\n * @problem.severity error\n * @precision medium\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Azure Storage BlobServiceClient initialization patterns\nAPI::Node getBlobServiceClientNode(boolean isSource) {\n  // Direct BlobServiceClient instantiation\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getReturn()\n  or\n  // BlobServiceClient from connection string\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getMember(\"from_connection_string\")\n        .getReturn()\n}\n\n// Client transitions to ContainerClient\nAPI::CallNode getContainerClientTransitionCall() {\n  // Transition from BlobServiceClient to ContainerClient\n  result = getBlobServiceClientNode(_).getMember(\"get_container_client\").getACall()\n  or\n  // Transition from BlobClient to ContainerClient\n  result = getBlobClientNode(_).getMember(\"_get_container_client\").getACall()\n}\n\n// Azure Storage ContainerClient initialization patterns\nAPI::Node getContainerClientNode(boolean isSource) {\n  // ContainerClient obtained through transition\n  isSource = false and\n  result = getContainerClientTransitionCall().getReturn()\n  or\n  // Direct ContainerClient instantiation\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getReturn()\n  or\n  // ContainerClient from connection string or URL\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getMember([\"from_connection_string\", \"from_container_url\"])\n        .getReturn()\n}\n\n// Client transitions to BlobClient\nAPI::CallNode getBlobClientTransitionCall() {\n  // Transition from BlobServiceClient or ContainerClient to BlobClient\n  result = [getBlobServiceClientNode(_), getContainerClientNode(_)]\n        .getMember(\"get_blob_client\")\n        .getACall()\n}\n\n// Azure Storage BlobClient initialization patterns\nAPI::Node getBlobClientNode(boolean isSource) {\n  // BlobClient obtained through transition\n  isSource = false and\n  result = getBlobClientTransitionCall().getReturn()\n  or\n  // Direct BlobClient instantiation\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getReturn()\n  or\n  // BlobClient from connection string or URL\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getMember([\"from_connection_string\", \"from_blob_url\"])\n        .getReturn()\n}\n\n// Unified representation of all Azure Storage client types\nAPI::Node getAzureStorageClientNode(boolean isSource) {\n  result in [getBlobServiceClientNode(isSource), getContainerClientNode(isSource), getBlobClientNode(isSource)]\n}\n\n// Encryption state definitions for data flow tracking\nnewtype EncryptionState =\n  V1EncryptionState() or\n  NoEncryptionState()\n\n// Data flow configuration with encryption state tracking\nprivate module EncryptionConfig implements DataFlow::StateConfigSig {\n  class FlowState = EncryptionState;\n\n  // Source nodes: uninitialized clients (no encryption configured)\n  predicate isSource(DataFlow::Node node, FlowState state) {\n    state = NoEncryptionState() and\n    node = getAzureStorageClientNode(true).asSource()\n  }\n\n  // Barrier nodes: clients explicitly configured with v2 encryption\n  predicate isBarrier(DataFlow::Node node, FlowState state) {\n    exists(DataFlow::AttrWrite encryptionAttrWrite |\n      node = getAzureStorageClientNode(_).getAValueReachableFromSource() and\n      encryptionAttrWrite.accesses(node, \"encryption_version\") and\n      encryptionAttrWrite.getValue().asExpr().(StringLiteral).getText() in [\"'2.0'\", \"2.0\"]\n    )\n    or\n    // Barrier for state transition when encryption is configured\n    isAdditionalFlowStep(_, NoEncryptionState(), node, V1EncryptionState()) and\n    state = NoEncryptionState()\n  }\n\n  // Flow transitions between client objects\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(DataFlow::MethodCallNode transitionCall |\n      transitionCall in [getContainerClientTransitionCall(), getBlobClientTransitionCall()] and\n      node1 = transitionCall.getObject() and\n      node2 = transitionCall\n    )\n  }\n_______________ // 补全条件\n  // State transition when encryption configuration is applied\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    node1 = node2.(DataFlow::PostUpdateNode).getPreUpdateNode() and\n    state1 = NoEncryptionState() and\n    state2 = V1EncryptionState() and\n    exists(DataFlow::AttrWrite encryptionAttrWrite |\n      node1 = getAzureStorageClientNode(_).getAValueReachableFromSource() and\n      encryptionAttrWrite.accesses(node1, [\"key_encryption_key\", \"key_resolver_function\"])\n    )\n  }\n\n  // Sink nodes: v1 encrypted blob upload operations\n  predicate isSink(DataFlow::Node node, FlowState state) {\n    state = V1EncryptionState() and\n    exists(DataFlow::MethodCallNode uploadCall |\n      uploadCall = getBlobClientNode(_).getMember(\"upload_blob\").getACall() and\n      node = uploadCall.getObject()\n    )\n  }\n\n  // No restrictions on incremental mode\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global data flow analysis with encryption state tracking\nmodule EncryptionDataFlow = DataFlow::GlobalWithState<EncryptionConfig>;\n\nimport EncryptionDataFlow::PathGraph\n\n// Query: Identify unsafe v1 encryption usage paths\nfrom EncryptionDataFlow::PathNode sourceNode, EncryptionDataFlow::PathNode sinkNode\nwhere EncryptionDataFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode, sourceNode, sinkNode, \"Unsafe usage of v1 version of Azure Storage client-side encryption\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Superclass attribute shadows subclass method\n * @description Detects when an attribute defined in a superclass's __init__ method \n *              shadows a method with the same name in a subclass.\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * This query identifies methods in subclasses that are shadowed by attributes \n * defined in the superclass's __init__ method. The detection criteria are:\n * 1. A method is declared in a subclass\n * 2. An attribute with the same name is defined in the superclass's __init__ method\n_______________ // 补全条件\n */\n\nimport python\n\n// Predicate to determine if a subclass method is shadowed by a superclass attribute\npredicate isShadowedBySuperclassAttribute(\n  ClassObject subclass, ClassObject superclass, Assign attributeAssignment, FunctionObject shadowedMethod\n) {\n  // Establish inheritance relationship between subclass and superclass\n  subclass.getASuperType() = superclass and\n  // Confirm that the subclass declares the target method\n  subclass.declaredAttribute(_) = shadowedMethod and\n  // Verify attribute definition in superclass's __init__ method\n  exists(FunctionObject initializer, Attribute targetAttribute |\n    // Superclass contains an __init__ method\n    superclass.declaredAttribute(\"__init__\") = initializer and\n    // The target of the assignment is a self member\n    targetAttribute = attributeAssignment.getATarget() and\n    // Ensure the assignment target is a self instance\n    targetAttribute.getObject().(Name).getId() = \"self\" and\n    // Attribute name matches the subclass method name\n    targetAttribute.getName() = shadowedMethod.getName() and\n    // Assignment occurs within the scope of the superclass's __init__ method\n    attributeAssignment.getScope() = initializer.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  // Exclude cases where the superclass already defines a method with the same name\n  not superclass.hasAttribute(shadowedMethod.getName())\n}\n\n// Query for shadowed methods and their related elements\nfrom ClassObject subclass, ClassObject superclass, Assign attributeAssignment, FunctionObject shadowedMethod\n// Apply the shadowing detection predicate\nwhere isShadowedBySuperclassAttribute(subclass, superclass, attributeAssignment, shadowedMethod)\n// Output results: method location, descriptive message, attribute assignment location, and type label\nselect shadowedMethod.getOrigin(),\n  \"Method '\" + shadowedMethod.getName() + \"' is shadowed by $@ in superclass '\" + superclass.getName() + \n    \"'.\", attributeAssignment, \"attribute definition\"",
    "output": "* 3. The superclass does not define a method with the same name"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Symmetric Padding Schemes Detection\n_______________ // 补全条件\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify all symmetric padding scheme implementations in the codebase\nfrom SymmetricPadding symPaddingScheme\n\n// Generate results with algorithm identification\nselect symPaddingScheme,\n  \"Symmetric algorithm detected: \" + symPaddingScheme.getPaddingName()",
    "output": "* @description Identifies all potential implementations of padding schemes used with symmetric encryption algorithms."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name JWT missing secret or public key verification\n * @description The application does not verify the JWT payload with a cryptographic secret or public key.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-missing-verification\n * @tags security\n *       experimental\n *       external/cwe/cwe-347\n */\n\n// 导入Python库，用于处理Python代码的解析和分析\nimport python\nimport experimental.semmle.python.Concepts\n\n// 从JWT解码的概念中获取数据流信息\nfrom JwtDecoding jwtDecoding\n// 过滤条件：选择那些没有验证签名的JWT解码实例\nwhere not jwtDecoding.verifiesSignature()\n// 选择JWT的有效载荷，并附加问题描述\nselect jwtDecoding.getPayload(), \"is not verified with a cryptographic secret or public key.\"",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python 模块传出耦合分析\n * @description 分析每个 Python 模块所依赖的其他模块数量，用于评估模块间的耦合程度。\n * @kind 树状图\n * @id py/efferent-coupling-per-file\n * @treemap.warnOn 高值警告\n * @metricType 文件\n * @metricAggregate 平均值 最大值\n_______________ // 补全条件\n *       模块化\n */\n\nimport python // 导入Python语言库\n\nfrom ModuleMetrics moduleMetrics // 从ModuleMetrics类中选择变量moduleMetrics\nselect moduleMetrics, moduleMetrics.getEfferentCoupling() as couplingCount order by couplingCount desc // 选择模块和其传出耦合度，并按降序排列",
    "output": "* @tags 可测试性"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description 当提取tar存档中的文件时，若未验证目标文件路径是否在目标目录范围内，\n *              可能导致目录遍历攻击，允许覆盖目标目录外的任意文件。\n * @kind path-problem\n * @id py/tarslip\n * @problem.severity error\n_______________ // 补全条件\n * @precision medium\n * @tags security\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\n// 识别潜在受污染的数据源和文件提取操作点\nfrom TarSlipFlow::PathNode taintedSource, TarSlipFlow::PathNode extractionSink\n// 验证从受污染源到提取操作点的数据流传播路径\nwhere TarSlipFlow::flowPath(taintedSource, extractionSink)\n// 输出分析结果：提取点、污染源、路径节点及安全警告\nselect extractionSink.getNode(), taintedSource, extractionSink, \n  \"This file extraction depends on a $@.\", taintedSource.getNode(),\n  \"tainted source\"",
    "output": "* @security-severity 7.5"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects incorrect usage of 'NotImplemented' in raise statements.\n *              This pattern causes a type error because NotImplemented is not an exception class.\n *              The correct exception class to use is NotImplementedError.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\nimport python\nimport Exceptions.NotImplemented\n\n// Define a variable to capture expressions where NotImplemented is incorrectly used in raise statements\nfrom Expr erroneousNotImplementedUsage\nwhere \n  // Identify instances where NotImplemented appears in a raise statement context\n  use_of_not_implemented_in_raise(_, erroneousNotImplementedUsage)\nselect erroneousNotImplementedUsage, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\"",
    "output": "* @name NotImplemented is not an Exception"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-use-with]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code patterns where a 'try-finally' block is used only to ensure",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Should use a 'with' statement\n * @description Detects code patterns where a 'try-finally' block is used only to ensure \n *              resource cleanup, which could be simplified with a 'with' statement.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/should-use-with\n */\n\nimport python\n\n// 判断调用是否为close方法\npredicate isCloseMethodCall(Call methodCall) { \n    exists(Attribute attribute | methodCall.getFunc() = attribute and attribute.getName() = \"close\") \n}\n\n// 判断try块的finally块中是否只有一条语句且该语句是close方法的调用\npredicate hasOnlyCloseInFinally(Try tryStmt, Call closeCall) {\n    exists(ExprStmt statement |\n        tryStmt.getAFinalstmt() = statement and statement.getValue() = closeCall and strictcount(tryStmt.getAFinalstmt()) = 1\n    )\n}\n\n// 判断控制流节点是否指向上下文管理器类的实例\npredicate refersToContextManager(ControlFlowNode flowNode, ClassValue contextManagerClass) {\n    forex(Value value | flowNode.pointsTo(value) | value.getClass() = contextManagerClass) and\n    contextManagerClass.isContextManager()\n}\n\n// 查找所有在finally块中仅包含close方法调用的代码，并建议使用'with'语句\nfrom Call closeCall, Try tryStmt, ClassValue contextManagerClass\nwhere\n    hasOnlyCloseInFinally(tryStmt, closeCall) and // 检查finally块中是否只有一条语句且该语句是close方法的调用\n    isCloseMethodCall(closeCall) and // 检查调用是否为close方法\n    exists(ControlFlowNode flowNode | \n        flowNode = closeCall.getFunc().getAFlowNode().(AttrNode).getObject() and\n        refersToContextManager(flowNode, contextManagerClass) // 检查控制流节点是否指向上下文管理器类的实例\n    )\nselect closeCall,\n    \"Instance of context-manager class $@ is closed in a finally block. Consider using 'with' statement.\", // 提示信息\n    contextManagerClass, contextManagerClass.getName() // 选择上下文管理器类及其名称"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/functions-and-methods-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides a statistical breakdown of the number of functions and methods",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Functions and methods per file\n * @description Provides a statistical breakdown of the number of functions and methods\n *              contained within each Python source file, excluding anonymous lambda functions.\n * @kind treemap\n * @id py/functions-and-methods-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python // Import Python module for code structure analysis\n\n// Analyze Python source files to calculate the total number of named functions and methods\n// Lambda expressions are excluded from this count as they are anonymous functions typically\n// used for short, inline operations rather than named reusable code blocks.\nfrom Module sourceFile, int functionMethodTotal\nwhere \n  // Compute the aggregate count by considering only those callable entities that:\n  // 1. Are defined within the current source file being analyzed\n  // 2. Have a proper name (i.e., not lambda expressions)\n  functionMethodTotal = count(Function callableEntity | \n    callableEntity.getEnclosingModule() = sourceFile and \n    not callableEntity.getName().matches(\"lambda\")\n  )\n// Present the analysis results with source files sorted in descending order\n// based on their function and method count\nselect sourceFile, functionMethodTotal order by functionMethodTotal desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Deleted lines per file\n * @description Calculates the total number of lines deleted per file throughout \n *              the entire revision history stored in the database.\n * @kind treemap\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python // Python模块，提供Python代码分析功能\nimport external.VCS // 外部版本控制模块，用于访问代码版本历史数据\n\n// 从源文件和删除行数计数中提取数据\nfrom Module sourceFile, int deletedLinesCount\nwhere\n  // 计算每个源文件在所有提交中的删除行数总和\n  deletedLinesCount =\n    sum(Commit commitRecord, int deletedLines |\n      // 获取每个提交记录中对应文件的删除行数，并过滤掉非人工变更\n      deletedLines = commitRecord.getRecentDeletionsForFile(sourceFile.getFile()) \n      and not artificialChange(commitRecord)\n    |\n      deletedLines // 聚合每个提交的删除行数\n    ) and\n_______________ // 补全条件\n  exists(sourceFile.getMetrics().getNumberOfLinesOfCode())\nselect sourceFile, deletedLinesCount order by deletedLinesCount desc // 按删除行数降序排列结果",
    "output": "// 确保源文件具有有效的代码行数度量数据"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-misconfiguration-with-credentials]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies CORS middleware configurations that permit authenticated requests",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name CORS misconfiguration with credentials enabled\n * @description Identifies CORS middleware configurations that permit authenticated requests\n *              from any origin, which could lead to cross-site request forgery attacks.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n/**\n * Checks if a node represents an unsafe origin configuration.\n * An origin is considered unsafe if it contains wildcard (*) or null values,\n * which allows requests from any source.\n */\npredicate hasUnsafeOriginSetting(DataFlow::Node originValueNode) {\n  // Direct string literals with wildcard or null\n  exists(StringLiteral literal | \n    literal = originValueNode.asExpr() and \n    literal.getText() in [\"*\", \"null\"]\n  )\n  or\n  // Lists containing wildcard or null elements\n  exists(List listExpr | \n    listExpr = originValueNode.asExpr() and\n    exists(StringLiteral listElement | \n      listElement = listExpr.getASubExpression() and\n      listElement.getText() in [\"*\", \"null\"]\n    )\n  )\n}\n\n/**\n * Determines if the given middleware is a CORS middleware.\n * This is identified by checking the middleware name.\n */\npredicate isCorsConfig(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n/**\n * Verifies if credentials are explicitly enabled in the CORS configuration.\n * This is a security-sensitive setting that should not be combined with wildcard origins.\n */\npredicate hasCredentialsEnabled(Http::Server::CorsMiddleware corsMiddleware) {\n  exists(True literal | literal = corsMiddleware.getCredentialsAllowed().asExpr())\n}\n\nfrom Http::Server::CorsMiddleware vulnerableCorsConfig\nwhere\n  // Confirm it's a CORS middleware\n  isCorsConfig(vulnerableCorsConfig) and\n  // Check if credentials are enabled\n  hasCredentialsEnabled(vulnerableCorsConfig) and\n  // Verify the origin configuration is unsafe\n  hasUnsafeOriginSetting(vulnerableCorsConfig.getOrigins().getALocalSource())\nselect vulnerableCorsConfig,\n  \"This CORS middleware uses a vulnerable configuration that allows arbitrary websites to make authenticated cross-site requests\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure temporary file\n * @description Detects the use of deprecated functions for creating temporary files, \n *              which may lead to security vulnerabilities due to predictable file names.\n * @kind problem\n * @id py/insecure-temporary-file\n * @problem.severity error\n * @security-severity 7.0\n * @sub-severity high\n * @precision high\n * @tags external/cwe/cwe-377\n *       security\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n/**\n * Identifies API nodes for functions that create temporary files in an insecure manner.\n * These functions are considered unsafe because they create predictable temporary file names\n * that could lead to race conditions or other security vulnerabilities.\n * \n * @param moduleName - The name of the module containing the insecure function\n * @param funcName - The name of the insecure function\n * @returns An API node representing the insecure temporary file creation function\n */\nAPI::Node insecureTempFileFunction(string moduleName, string funcName) {\n  // Check if the module and function combination represents an insecure temporary file function\n  (\n    // Case 1: tempfile.mktemp function\n    (moduleName = \"tempfile\" and funcName = \"mktemp\")\n    or\n    // Case 2: os.tmpnam function\n    (moduleName = \"os\" and funcName = \"tmpnam\")\n    or\n    // Case 3: os.tempnam function\n    (moduleName = \"os\" and funcName = \"tempnam\")\n  ) and\n  // Resolve the module and get the specified function member\n  result = API::moduleImport(moduleName).getMember(funcName)\n}\n\n/**\n * Main query to detect calls to insecure temporary file creation functions.\n * Finds all call sites where a potentially insecure temporary file function is used.\n_______________ // 补全条件\nfrom Call insecureCall, string moduleName, string funcName\nwhere \n  // Check if the call corresponds to an insecure temporary file function\n  insecureTempFileFunction(moduleName, funcName).getACall().asExpr() = insecureCall\n// Select the problematic call node with an appropriate warning message\nselect insecureCall, \"Call to deprecated function \" + moduleName + \".\" + funcName + \" may be insecure.\"",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/all-asymmetric-encryption-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：查找所有使用受支持库的潜在非对称密钥进行加密或密钥交换的用法。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 非对称加密算法\n * @description 查找所有使用受支持库的潜在非对称密钥进行加密或密钥交换的用法。\n * @kind 问题\n * @id py/quantum-readiness/cbom/all-asymmetric-encryption-algorithms\n * @problem.severity 错误\n * @tags cbom\n *       密码学\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 从 AsymmetricEncryptionAlgorithm 类中选择算法实例 alg\nfrom AsymmetricEncryptionAlgorithm alg\n// 选择 alg 和 \"Use of algorithm \" + alg.getEncryptionName() 作为查询结果\nselect alg, \"Use of algorithm \" + alg.getEncryptionName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-co-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the average count of additional files altered in commits",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Co-committed Files Count\n * @description Measures the average count of additional files altered in commits \n *              that also touch a particular file. This metric identifies files \n *              often modified together, suggesting possible coupling or dependencies.\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Helper function that determines the total number of files affected in a given commit\nint countFilesInCommit(Commit c) { \n    result = count(c.getAnAffectedFile()) \n}\n\n// Main analysis: examine modules with line count metrics\nfrom Module analyzedModule\nwhere exists(analyzedModule.getMetrics().getNumberOfLinesOfCode())\nselect analyzedModule,\n  // Compute the average number of co-committed files for each module\n  avg(Commit commit, int coChangedFilesCount |\n    // Focus on commits that affect the module's file and calculate co-commit count\n    commit.getAnAffectedFile() = analyzedModule.getFile() and \n    coChangedFilesCount = countFilesInCommit(commit) - 1\n  |\n    coChangedFilesCount\n  )"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/empty-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies except clauses that contain only pass statements without explanatory comments",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Empty except\n * @description Identifies except clauses that contain only pass statements without explanatory comments\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-390\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/empty-except\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Predicate to determine if except block contains exclusively pass statements\npredicate containsOnlyPassStatements(ExceptStmt exceptClause) {\n  // Confirm all statements within the except block are pass statements\n  forall(Stmt statement | statement = exceptClause.getAStmt() | statement instanceof Pass)\n}\n\n// Predicate to verify absence of else clause in try-except construct\npredicate lacksElseClause(ExceptStmt exceptClause) { \n  // Ensure the try statement does not have an associated else block\n  not exists(exceptClause.getTry().getOrelse()) \n}\n\n// Predicate to check for missing explanatory comments within except block\npredicate hasNoExplanatoryComment(ExceptStmt exceptClause) {\n  // Verify no comments exist within the except block's code boundaries\n  not exists(Comment comment |\n    comment.getLocation().getFile() = exceptClause.getLocation().getFile() and\n    comment.getLocation().getStartLine() >= exceptClause.getLocation().getStartLine() and\n    comment.getLocation().getEndLine() <= exceptClause.getBody().getLastItem().getLocation().getEndLine()\n  )\n}\n\n// Predicate to identify handlers for non-local control flow exceptions\npredicate handlesNonLocalFlowException(ExceptStmt exceptClause) {\n  // Check if the except clause handles StopIteration exceptions\n  exceptClause.getType() = API::builtin(\"StopIteration\").getAValueReachableFromSource().asExpr()\n}\n\n// Predicate to verify normal execution exits from try block\npredicate hasNormalExitPath(Try tryStatement) {\n  // Find non-exceptional control flow transitions exiting the try block\n  exists(ControlFlowNode predecessor, ControlFlowNode successor |\n    /* Normal (non-exceptional) control flow edge */\n    predecessor.getASuccessor() = successor and\n    not predecessor.getAnExceptionalSuccessor() = successor\n  |\n    /* Valid successor: not a return node */\n    not exists(Scope scope | scope.getReturnNode() = successor) and\n    /* Predecessor in try body, successor outside */\n    predecessor.getNode().getParentNode*() = tryStatement.getAStmt() and\n    not successor.getNode().getParentNode*() = tryStatement.getAStmt()\n  )\n}\n\n// Predicate to detect attribute access operations in statements\npredicate involvesAttributeAccess(Stmt codeStatement) {\n  // Direct attribute access or getattr/setattr/delattr function calls\n  codeStatement.(ExprStmt).getValue() instanceof Attribute\n  or\n  exists(string functionName | \n    codeStatement.(ExprStmt).getValue().(Call).getFunc().(Name).getId() = functionName |\n    functionName = \"getattr\" or functionName = \"setattr\" or functionName = \"delattr\"\n  )\n  or\n  codeStatement.(Delete).getATarget() instanceof Attribute\n}\n\n// Predicate to detect subscript operations in statements\npredicate involvesSubscriptOperation(Stmt codeStatement) {\n  // Subscript access or deletion operations\n  codeStatement.(ExprStmt).getValue() instanceof Subscript\n  or\n  codeStatement.(Delete).getATarget() instanceof Subscript\n}\n\n// Predicate to identify encode/decode operations with corresponding exceptions\npredicate isEncodingDecodingCall(Call functionCall, Expr exceptionType) {\n  // Match encode/decode method calls with corresponding exception types\n  exists(string methodName | \n    functionCall.getFunc().(Attribute).getName() = methodName |\n    (methodName = \"encode\" and\n     exceptionType = API::builtin(\"UnicodeEncodeError\").getAValueReachableFromSource().asExpr())\n    or\n    (methodName = \"decode\" and\n     exceptionType = API::builtin(\"UnicodeDecodeError\").getAValueReachableFromSource().asExpr())\n  )\n}\n\n// Predicate to identify single-statement exception handlers\npredicate isSingleStatementHandler(ExceptStmt exceptClause, Stmt handledStatement, Expr caughtException) {\n  // Verify the try block contains exactly one statement\n  not exists(exceptClause.getTry().getStmt(1)) and\n  handledStatement = exceptClause.getTry().getStmt(0) and\n  exceptClause.getType() = caughtException\n}\n\n// Predicate to detect focused exception handlers for specific operations\npredicate isFocusedExceptionHandler(ExceptStmt exceptClause) {\n  // Check for specific exception handling patterns tied to particular operations\n  exists(Stmt operationStatement, Expr exceptionType | \n    isSingleStatementHandler(exceptClause, operationStatement, exceptionType) |\n    // Subscript operations with IndexError\n    (involvesSubscriptOperation(operationStatement) and\n     exceptionType = API::builtin(\"IndexError\").getASubclass*().getAValueReachableFromSource().asExpr())\n    or\n    // Attribute access with AttributeError\n    (involvesAttributeAccess(operationStatement) and\n     exceptionType = API::builtin(\"AttributeError\").getAValueReachableFromSource().asExpr())\n    or\n    // Name access with NameError\n    (operationStatement.(ExprStmt).getValue() instanceof Name and\n     exceptionType = API::builtin(\"NameError\").getAValueReachableFromSource().asExpr())\n    or\n    // Encoding/decoding operations with corresponding exceptions\n    isEncodingDecodingCall(operationStatement.(ExprStmt).getValue(), exceptionType)\n  )\n}\n\n// Main query to identify problematic empty except blocks\nfrom ExceptStmt exceptClause\nwhere\n  // Core conditions: empty except block without else clause or explanatory comments\n  containsOnlyPassStatements(exceptClause) and\n  lacksElseClause(exceptClause) and\n  hasNoExplanatoryComment(exceptClause) and\n  // Exclude handlers for non-local control flow exceptions\n  not handlesNonLocalFlowException(exceptClause) and\n  // Ensure the try block has a normal execution exit path\n  hasNormalExitPath(exceptClause.getTry()) and\n  // Exclude focused exception handlers for specific operations\n  not isFocusedExceptionHandler(exceptClause)\nselect exceptClause, \"'except' clause does nothing but pass and there is no explanatory comment.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__init__` 方法调用被重写的方法\n * @description 在父类 `__init__` 方法中调用被子类重写的方法可能导致观察到部分初始化的实例。\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n_______________ // 补全条件\n */\n\nimport python\n\nfrom ClassObject superClass, string methodName, Call problematicCall, FunctionObject childMethod, FunctionObject parentMethod\nwhere\n  // 确保父类存在 `__init__` 方法\n  exists(FunctionObject parentInit |\n    superClass.declaredAttribute(\"__init__\") = parentInit and\n    // 方法调用发生在父类的 `__init__` 方法作用域内\n    problematicCall.getScope() = parentInit.getFunction()\n  |\n    // 方法调用通过 self 属性进行\n    exists(SelfAttribute selfAttr |\n      problematicCall.getFunc() = selfAttr and\n      // 获取被调用方法的名称\n      selfAttr.getName() = methodName and\n      // 确认该方法在父类中声明\n      parentMethod = superClass.declaredAttribute(methodName) and\n      // 验证该方法被子类重写\n      childMethod.overrides(parentMethod)\n    )\n  )\nselect problematicCall, \"Call to self.$@ in __init__ method, which is overridden by $@.\", parentMethod, methodName, childMethod, childMethod.descriptiveString()",
    "output": "* @id py/init-calls-subclass"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'exec' used\n * @description Detects usage of the 'exec' statement or function which can lead to arbitrary code execution.\n * @kind problem\n * @tags security\n *       correctness\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec\n */\n\n// Import Python library for code parsing and analysis\nimport python\n\n// Generates version-specific error message for exec usage\nstring generateExecVersionSpecificMessage() {\n  // For Python 2 where exec is a statement\n  major_version() = 2 and result = \"The 'exec' statement is used.\"\n  // For Python 3 where exec is a function\n  or\n  major_version() = 3 and result = \"The 'exec' function is used.\"\n}\n\n// Identifies calls to the exec function in the code\npredicate identifyExecFunctionCall(Call invocation) {\n  // Check if the invocation references a global variable named 'exec'\n  exists(GlobalVariable execGlobalVar | \n    execGlobalVar = invocation.getFunc().(Name).getVariable() and \n    execGlobalVar.getId() = \"exec\"\n  )\n}\n\n// Select all AST nodes representing dangerous exec usage\nfrom AstNode dangerousExecUsage\n// Check if the node represents either an exec function call or an exec statement\nwhere \n  identifyExecFunctionCall(dangerousExecUsage) \n  or \n_______________ // 补全条件\n// Output the exec usage node with appropriate version-specific error message\nselect dangerousExecUsage, generateExecVersionSpecificMessage()",
    "output": "dangerousExecUsage instanceof Exec"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python extraction warnings\n * @description Identifies and reports extraction warnings for Python files in the source code directory.\n * @kind diagnostic\n_______________ // 补全条件\n */\n\nimport python\n\n/**\n * Determines the SARIF severity level for warnings.\n *\n * Reference: https://docs.oasis-open.org/sarif/sarif/v2.1.0/csprd01/sarif-v2.1.0-csprd01.html#_Toc10541338\n */\nint determineWarningSeverity() { result = 1 }\n\n// According to the SARIF specification (https://docs.oasis-open.org/sarif/sarif/v2.1.0/csprd01/sarif-v2.1.0-csprd01.html#_Toc10541338),\n// errors and warnings are defined as:\n//\n// \"error\": A serious problem was found. The tool encountered a condition that caused the analysis to be aborted\n// or the results to be incorrect or incomplete.\n//\n// \"warning\": A problem was found that is not considered serious. The tool encountered a condition where it is\n// uncertain whether a problem occurred, or the analysis may be incomplete but the generated results may be valid.\n//\n// Therefore, SyntaxErrors are reported at the warning level because the analysis may be incomplete but the generated\n// results are potentially valid.\nfrom SyntaxError syntaxErr, File sourceFile\nwhere\n  sourceFile = syntaxErr.getFile() and // Retrieve the file where the error occurred\n  exists(sourceFile.getRelativePath()) // Ensure the file has a relative path\nselect syntaxErr, \"Python extraction failed in \" + sourceFile + \" due to syntax error: \" + syntaxErr.getMessage(), // Select and format the error message\n  determineWarningSeverity() // Set the warning severity level",
    "output": "* @id py/diagnostics/extraction-warnings"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-recent-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：评估过去180天内有效代码提交的频率分布，过滤掉自动化或人为干预的提交记录",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 近期代码提交活动分析\n * @description 评估过去180天内有效代码提交的频率分布，过滤掉自动化或人为干预的提交记录\n * @kind treemap\n * @id py/historical-number-of-recent-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\nimport python // Python语言分析支持库\nimport external.VCS // 版本控制系统外部集成模块\n\n// 主查询：识别并统计符合特定条件的代码提交记录\nfrom Commit validCommit\nwhere \n  // 时间范围约束：仅分析最近半年内的提交活动\n  validCommit.daysToNow() <= 180\n  and\n  // 提交质量过滤：排除非人工编写的代码变更\n  not artificialChange(validCommit)\n\n// 输出结果：以提交修订ID为标识，每条有效提交计为1个单位\nselect validCommit.getRevisionName(), 1"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Concurrent File Modifications Analysis\n * @description Identifies architectural connections by calculating the average number \n_______________ // 补全条件\n *              reveals code dependencies through co-modification patterns in commits.\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Helper function: computes total file modifications in a given commit\nint countFilesInCommit(Commit commit) { \n    result = count(commit.getAnAffectedFile()) \n}\n\n// Primary analysis: evaluate modules with available line metrics\nfrom Module moduleOfInterest\nwhere exists(moduleOfInterest.getMetrics().getNumberOfLinesOfCode())\nselect moduleOfInterest,\n  // Compute average co-modified files per module\n  avg(Commit commit, int coChangeCount |\n    // Filter commits affecting target module and calculate co-change metrics\n    commit.getAnAffectedFile() = moduleOfInterest.getFile() and \n    coChangeCount = countFilesInCommit(commit) - 1\n  |\n    coChangeCount\n  )",
    "output": "*              of files modified together with a specific target file. This metric"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/afferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Quantifies the number of external classes that depend on each target class.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Analysis of incoming class dependencies\n * @description Quantifies the number of external classes that depend on each target class.\n *              Higher values indicate classes with more incoming dependencies, which can impact modularity.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// Identify classes for dependency analysis\nfrom ClassMetrics analyzedClass\n// Filter to include only classes that have measurable incoming dependencies\nwhere exists(analyzedClass.getAfferentCoupling())\n// Output the class and its incoming dependency count, sorted by highest dependency count\nselect analyzedClass, \n       analyzedClass.getAfferentCoupling() as dependencyInflowCount \norder by dependencyInflowCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/function-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：此查询用于识别Python代码中的所有函数定义，并建立函数实体与其源文件位置之间的映射关系。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python函数定义源码映射\n * @description 此查询用于识别Python代码中的所有函数定义，并建立函数实体与其源文件位置之间的映射关系。\n *              通过分析每个函数定义的位置信息，可以快速定位到源代码中的具体实现。\n * @kind source-link\n * @id py/function-source-links\n * @metricType callable\n */\n\nimport python\n\n// 从函数定义和其源码位置信息中选择，确保位置信息与函数定义的位置相匹配\nfrom Function funcDef, Location sourceLocation\nwhere sourceLocation = funcDef.getLocation()\nselect funcDef, sourceLocation.getFile()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * 计算边际增加的调用图事实、调用关系的总体大小以及两者相对于上下文深度的比例。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义查询结果变量：total_facts（总事实数）、total_size（总大小）、depth（深度）和efficiency（效率）\nfrom int total_facts, int total_size, int depth, float efficiency\nwhere\n  // 计算总事实数，即在给定深度下唯一的调用节点数量\n  total_facts =\n    strictcount(ControlFlowNode call, CallableValue func |\n      exists(PointsToContext ctx |\n        call = func.getACall(ctx) and // 获取函数在特定上下文中的调用节点\n        depth = ctx.getDepth() and // 获取上下文的深度\n        not exists(PointsToContext shallower |\n          call = func.getACall(shallower) and // 确保没有更浅的上下文包含相同的调用节点\n          shallower.getDepth() < depth\n        )\n      )\n    ) and\n  // 计算调用关系的总体大小，即所有上下文中调用节点的数量\n  total_size =\n    strictcount(ControlFlowNode call, CallableValue func, PointsToContext ctx |\n      call = func.getACall(ctx) and // 获取函数在任意上下文中的调用节点\n      depth = ctx.getDepth() // 获取上下文的深度\n    ) and\n  // 计算效率，即总事实数与总大小的比例\n  efficiency = 100.0 * total_facts / total_size\nselect depth, total_facts, total_size, efficiency // 选择要显示的结果字段"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies the usage of cryptographic hash algorithms that are either unapproved or considered weak.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import necessary Python libraries and experimental cryptography concepts\nimport python\nimport experimental.cryptography.Concepts\n\n// Extract hash operation details including the algorithm name and corresponding warning message\nfrom HashAlgorithm hashOp, string hashAlgoName, string warningMsg\nwhere\n  // Retrieve the name of the hash algorithm being used\n  hashAlgoName = hashOp.getHashName() and\n  // Exclude strong, approved hash algorithms from detection\n  not hashAlgoName = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // Generate appropriate warning message based on whether the algorithm is recognized\n  (\n    // Case for algorithms that are recognized but unapproved\n    hashAlgoName != \"\" and\n    warningMsg = \"Use of unapproved hash algorithm or API \" + hashAlgoName + \".\"\n  )\n  or\n  (\n    // Case for unrecognized algorithms\n    hashAlgoName = \"\" and\n    warningMsg = \"Use of unrecognized hash algorithm.\"\n  )\nselect hashOp, warningMsg",
    "output": "* @name Weak hashes"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raise-not-implemented]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code that raises 'NotImplemented' instead of 'NotImplementedError'.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name NotImplemented is not an Exception\n * @description Detects code that raises 'NotImplemented' instead of 'NotImplementedError'.\n *              This leads to runtime type errors since NotImplemented is not an exception class.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Core Python language analysis components\nimport python\n\n// Module for detecting NotImplemented misuse in exception handling\nimport Exceptions.NotImplemented\n\n// Identify expressions where NotImplemented is incorrectly raised as an exception\nfrom Expr misusedNotImplemented\nwhere \n    // Locate raise statements that improperly use NotImplemented\n    // instead of the correct exception class NotImplementedError\n    use_of_not_implemented_in_raise(_, misusedNotImplemented)\nselect \n    // Report the problematic expression with remediation guidance\n    misusedNotImplemented, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Documentation coverage ratio\n * @description Calculates the percentage of docstring lines relative to total lines in Python source files.\n *              Higher values indicate better documentation coverage. Empty files are excluded from analysis.\n * @kind treemap\n * @id py/doc-string-ratio-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n_______________ // 补全条件\n */\n\nimport python\n\n// Analyze Python modules with their metrics, excluding empty files\nfrom Module sourceModule, ModuleMetrics moduleMetrics\nwhere \n  moduleMetrics = sourceModule.getMetrics() and \n  moduleMetrics.getNumberOfLines() > 0\nselect \n  sourceModule,\n  // Compute documentation coverage: (docstring lines / total lines) * 100\n  (100.0 * \n    (moduleMetrics.getNumberOfLinesOfDocStrings().(float) / \n     moduleMetrics.getNumberOfLines().(float))) as documentationPercentage\norder by \n  documentationPercentage desc",
    "output": "*       documentation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Binding a socket to all network interfaces\n * @description Detects when a socket is bound to all network interfaces, which exposes it to traffic from any IPv4/IPv6 address,\n * posing significant security risks.\n * @kind problem\n * @tags security\n *       external/cwe/cwe-200\n * @problem.severity error\n * @security-severity 6.5\n * @sub-severity low\n * @precision high\n * @id py/bind-socket-all-network-interfaces\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n/** Defines all possible wildcard addresses that indicate binding to all network interfaces */\nprivate string isWildcardAddress() {\n  result in [\n      // IPv4 wildcard addresses\n      \"0.0.0.0\", \"\",\n      // IPv6 wildcard addresses\n      \"::\", \"::0\"\n    ]\n}\n\n/** Tracks the flow of wildcard address references through type propagation */\nprivate DataFlow::TypeTrackingNode wildcardAddressFlow(DataFlow::TypeTracker tracker, string addr) {\n  tracker.start() and\n  exists(StringLiteral addrLiteral | addr = isWildcardAddress() |\n    addrLiteral.getText() = addr and\n    result.asExpr() = addrLiteral\n  )\n  or\n  exists(DataFlow::TypeTracker prevTracker | \n    result = wildcardAddressFlow(prevTracker, addr).track(prevTracker, tracker)\n  )\n}\n\n/** Obtains data flow nodes containing wildcard address references */\nDataFlow::Node wildcardAddressNode(string addr) {\n  wildcardAddressFlow(DataFlow::TypeTracker::end(), addr).flowsTo(result)\n}\n\n/** Tracks address tuples containing wildcard addresses as their first element */\nprivate DataFlow::TypeTrackingNode addressTupleWithWildcardFlow(DataFlow::TypeTracker tracker, string addr) {\n  tracker.start() and\n  result.asExpr() = any(Tuple addrTuple | \n    addrTuple.getElt(0) = wildcardAddressNode(addr).asExpr()\n  )\n  or\n  exists(DataFlow::TypeTracker prevTracker | \n    result = addressTupleWithWildcardFlow(prevTracker, addr).track(prevTracker, tracker)\n  )\n}\n\n/** Obtains data flow nodes containing address tuples with wildcard addresses */\nDataFlow::Node addressTupleWithWildcardNode(string addr) {\n  addressTupleWithWildcardFlow(DataFlow::TypeTracker::end(), addr).flowsTo(result)\n}\n\n/**\n_______________ // 补全条件\n * \n * Reference: https://docs.python.org/3/library/socket.html\n */\nAPI::Node socketInstance() { \n  result = API::moduleImport(\"socket\").getMember(\"socket\").getReturn() \n}\n\nfrom DataFlow::CallCfgNode bindOperation, DataFlow::Node addrParam, string wildcardAddr\nwhere\n  bindOperation = socketInstance().getMember(\"bind\").getACall() and\n  addrParam = bindOperation.getArg(0) and\n  addrParam = addressTupleWithWildcardNode(wildcardAddr)\nselect bindOperation.asExpr(), \"Socket bound to all interfaces using '\" + wildcardAddr + \"'.\"",
    "output": "* Retrieves socket instances created with specific address families."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/explicit-return-in-init]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects non-None return values in Python `__init__` methods, which lead to runtime TypeErrors.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Explicit value return in `__init__` method\n * @description Detects non-None return values in Python `__init__` methods, which lead to runtime TypeErrors.\n *              This query filters out returns of None, calls to functions that never return, and nested\n *              `__init__` calls to reduce false positives and focus on actual issues.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/explicit-return-in-init\n */\n\nimport python\n\nfrom Return initReturnStmt, Expr returnedValue\nwhere\n  // Condition 1: Return statement is inside an __init__ method\n  initReturnStmt.getScope().(Function).isInitMethod() and\n  // Condition 2: Return statement has a value expression\n  initReturnStmt.getValue() = returnedValue and\n  // Condition 3: Filter out None returns\n  not returnedValue.pointsTo(Value::none_()) and\n  // Condition 4: Exclude never-returning function calls\n  not exists(FunctionValue nonReturningFunc |\n    nonReturningFunc.getACall() = returnedValue.getAFlowNode() and\n    nonReturningFunc.neverReturns()\n  ) and\n  // Condition 5: Avoid nested __init__ method calls\n  not exists(Attribute initAttrAccess |\n    initAttrAccess = returnedValue.(Call).getFunc() and\n    initAttrAccess.getName() = \"__init__\"\n  )\nselect initReturnStmt, \"Explicit return in __init__ method.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/afferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query calculates the afferent coupling for each class, which is the count of classes that depend on it.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class Afferent Coupling Analysis\n * @description This query calculates the afferent coupling for each class, which is the count of classes that depend on it.\n *              It helps in assessing modularity by identifying classes with high incoming dependencies.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\nfrom ClassMetrics targetClass\nwhere exists(targetClass.getAfferentCoupling())\nselect \n  targetClass,\n  targetClass.getAfferentCoupling() as dependencyCount\norder by dependencyCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称密钥生成中的未知密钥大小\n * @description 检测在非对称加密算法生成密钥时，无法在静态分析阶段确定密钥长度的情况\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n_______________ // 补全条件\n// 查找非对称密钥生成操作中密钥大小无法静态确认的情况\nfrom AsymmetricKeyGen keyGenOp, DataFlow::Node keyConfigSource, string cryptoAlgorithm\nwhere\n  // 获取密钥配置的源节点\n  keyConfigSource = keyGenOp.getKeyConfigSrc() and\n  // 获取所使用的加密算法名称\n  cryptoAlgorithm = keyGenOp.getAlgorithm().getName() and\n  // 确认密钥生成操作没有静态验证的密钥大小参数\n  not keyGenOp.hasKeySize(keyConfigSource)\nselect keyGenOp,\n  // 生成问题报告，包含算法信息和配置源\n  \"用于算法 \" + cryptoAlgorithm.toString() + \" 的密钥生成使用了无法静态验证的密钥大小，在配置源 $@\", keyConfigSource, keyConfigSource.toString()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称密钥生成中使用未知密钥大小\n * @description 检测在非对称密钥生成过程中使用了无法静态验证的密钥大小的安全漏洞。\n *              这种做法可能导致使用弱密钥或不符合安全标准的密钥，从而增加系统被攻击的风险。\n * @id py/unknown-asymmetric-key-gen-size\n_______________ // 补全条件\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找非对称密钥生成操作，其中密钥大小无法通过静态分析确定\nfrom AsymmetricKeyGen keyGeneration, DataFlow::Node configSource, string algorithmName\nwhere\n  // 确定密钥配置的来源节点\n  configSource = keyGeneration.getKeyConfigSrc()\n  and\n  // 获取加密算法的名称\n  algorithmName = keyGeneration.getAlgorithm().getName()\n  and\n  // 检查密钥生成操作是否缺少静态可验证的密钥大小\n  not keyGeneration.hasKeySize(configSource)\nselect keyGeneration,\n  // 构建告警消息，指出特定算法的密钥生成使用了无法静态验证的密钥大小\n  \"算法 \" + algorithmName.toString() + \" 的密钥生成使用了无法静态验证的密钥大小，配置源位于 $@\", configSource, configSource.toString()",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Membership test with a non-container\n * @description Detects membership operations ('in'/'not in') where the right-hand operand \n *              is not a container type, which can cause a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n_______________ // 补全条件\n * @param operandNode - Control flow node being evaluated\n * @param comparisonNode - Comparison expression containing the membership test\n */\npredicate isRightOperandOfMembershipTest(ControlFlowNode operandNode, Compare comparisonNode) {\n  exists(Cmpop operation, int index |\n    comparisonNode.getOp(index) = operation and \n    comparisonNode.getComparator(index) = operandNode.getNode() and\n    (operation instanceof In or operation instanceof NotIn)\n  )\n}\n\nfrom \n  ControlFlowNode rightHandOperand, \n  Compare membershipComparison, \n  Value pointedValue, \n  ClassValue nonContainerClass, \n  ControlFlowNode sourceNode\nwhere\n  // Verify node is right operand of membership test\n  isRightOperandOfMembershipTest(rightHandOperand, membershipComparison) and\n  \n  // Resolve pointed value and class information\n  rightHandOperand.pointsTo(_, pointedValue, sourceNode) and\n  pointedValue.getClass() = nonContainerClass and\n  \n  // Exclude cases with failed type inference\n  not Types::failedInference(nonContainerClass, _) and\n  \n  // Confirm class lacks container interface methods\n  not nonContainerClass.hasAttribute(\"__contains__\") and\n  not nonContainerClass.hasAttribute(\"__iter__\") and\n  not nonContainerClass.hasAttribute(\"__getitem__\") and\n  \n  // Exclude special pseudo-container types\n  not nonContainerClass = ClassValue::nonetype() and\n  not nonContainerClass = Value::named(\"types.MappingProxyType\")\nselect \n  membershipComparison, \n  \"This test may raise an Exception as the $@ may be of non-container class $@.\", \n  sourceNode, \"target\", nonContainerClass, nonContainerClass.getName()",
    "output": "* Identifies nodes serving as the right operand in membership tests."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/functions-and-methods-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides a statistical overview of function and method density across Python source files.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Functions and methods per file\n * @description Provides a statistical overview of function and method density across Python source files.\n * @kind treemap\n * @id py/functions-and-methods-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python // Import Python module for code structure analysis\n\n// This query examines Python modules to quantify the number of defined functions and methods\n// Note: Anonymous lambda functions are excluded from this calculation\nfrom Module pyModule, int functionCount\nwhere \n    // Calculate the total count of functions within each module\n    functionCount = count(Function method | \n        // Ensure the function is defined in the current module being processed\n        method.getEnclosingModule() = pyModule and \n        // Exclude lambda functions from the count as they are anonymous constructs\n        method.getName() != \"lambda\")\n// Output the module and its corresponding function count, sorted in descending order\nselect pyModule, functionCount order by functionCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Co-committed Files Count\n * @description This query determines the average quantity of extra files that are \n *              modified alongside a particular file in the same commits. The metric \n *              serves to identify files that often undergo changes together, which \n *              suggests possible code coupling or interdependencies.\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n_______________ // 补全条件\nimport python\nimport external.VCS\n\n// Main analysis: examine modules that have line count metrics available\nfrom Module analyzedModule\nwhere exists(analyzedModule.getMetrics().getNumberOfLinesOfCode())\nselect analyzedModule,\n  // Compute the mean number of files that are co-committed with each module\n  avg(Commit commit, int relatedFilesCount |\n    // Consider commits that modify the module's file and calculate the count of related files\n    commit.getAnAffectedFile() = analyzedModule.getFile() and \n    relatedFilesCount = count(commit.getAnAffectedFile()) - 1\n  |\n    relatedFilesCount\n  )",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-complex-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python classes containing destructors (`__del__` methods) with",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly complex `__del__` method\n * @description Detects Python classes containing destructors (`__del__` methods) with \n *              excessive cyclomatic complexity. Destructor methods in Python are called\n *              during object cleanup, which happens at unpredictable times or may be\n *              bypassed in certain conditions. Excessively complex destructors can lead\n *              to performance degradation and unpredictable behavior during garbage\n *              collection. It's recommended to keep these special methods as simple as possible.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python  // 导入Python分析库，用于代码分析\n\nfrom FunctionValue delMethod,  // 从FunctionValue类中获取delMethod对象\n      ClassValue ownerClass  // 获取拥有该方法的类\nwhere\n  // 确认当前方法是某个类的__del__方法\n  ownerClass.declaredAttribute(\"__del__\") = delMethod\n  and\n  // 检查析构方法的圈复杂度是否超过阈值3\n  delMethod.getScope().getMetrics().getCyclomaticComplexity() > 3\nselect delMethod, \"Overly complex '__del__' method.\"  // 选择符合条件的delMethod并标记为\"过于复杂的`__del__`方法\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/bind-socket-all-network-interfaces]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects sockets bound to all network interfaces (0.0.0.0, ::, etc.),",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Socket bound to all network interfaces\n * @description Detects sockets bound to all network interfaces (0.0.0.0, ::, etc.),\n * which exposes services to all network traffic and creates significant security risks.\n * @kind problem\n * @tags security\n *       external/cwe/cwe-200\n * @problem.severity error\n * @security-severity 6.5\n * @sub-severity low\n * @precision high\n * @id py/bind-socket-all-network-interfaces\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n/** Defines all wildcard addresses representing all network interfaces */\nprivate string getWildcardAddress() {\n  result in [\n      // IPv4 wildcards\n      \"0.0.0.0\", \"\",\n      // IPv6 wildcards\n      \"::\", \"::0\"\n    ]\n}\n\n/**\n * Tracks wildcard address propagation through data flow.\n * Handles both literal values and propagated references.\n */\nprivate DataFlow::TypeTrackingNode trackWildcardAddress(DataFlow::TypeTracker t, string wildcard) {\n  // Base case: Match literal wildcard addresses\n  t.start() and\n  exists(StringLiteral addrLiteral | \n    wildcard = getWildcardAddress() and\n    addrLiteral.getText() = wildcard and\n    result.asExpr() = addrLiteral\n  )\n  or\n  // Recursive case: Track through data flow\n  exists(DataFlow::TypeTracker prev | \n    result = trackWildcardAddress(prev, wildcard).track(prev, t)\n  )\n}\n\n/** Retrieves data flow nodes containing wildcard address references */\nDataFlow::Node getWildcardNode(string wildcard) {\n  trackWildcardAddress(DataFlow::TypeTracker::end(), wildcard).flowsTo(result)\n}\n\n/**\n * Tracks address tuples containing wildcard addresses as first element.\n * Handles both direct tuples and propagated references.\n */\nprivate DataFlow::TypeTrackingNode trackWildcardTuple(DataFlow::TypeTracker t, string wildcard) {\n  // Base case: Match tuples with wildcard at first position\n  t.start() and\n  exists(Tuple addrTuple | \n    addrTuple.getElt(0) = getWildcardNode(wildcard).asExpr() and\n    result.asExpr() = addrTuple\n  )\n  or\n  // Recursive case: Track through data flow\n  exists(DataFlow::TypeTracker prev | \n    result = trackWildcardTuple(prev, wildcard).track(prev, t)\n  )\n}\n\n/** Retrieves data flow nodes containing address tuples with wildcard addresses */\nDataFlow::Node getWildcardTupleNode(string wildcard) {\n  trackWildcardTuple(DataFlow::TypeTracker::end(), wildcard).flowsTo(result)\n}\n\n/**\n * Identifies socket creation nodes for specific address families.\n * Reference: https://docs.python.org/3/library/socket.html\n */\nAPI::Node getSocketCreationNode() { \n  result = API::moduleImport(\"socket\").getMember(\"socket\").getReturn() \n}\n\nfrom DataFlow::CallCfgNode bindCall, DataFlow::Node addressArg, string wildcard\nwhere\n  // Match socket.bind() calls\n  bindCall = getSocketCreationNode().getMember(\"bind\").getACall() and\n  // First argument is the address tuple\n  addressArg = bindCall.getArg(0) and\n  // Address tuple contains wildcard address\n  addressArg = getWildcardTupleNode(wildcard)\nselect bindCall.asExpr(), \"Socket bound to all interfaces using '\" + wildcard + \"'.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/alerts/remote-flow-sources-reach]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies nodes reachable via taint tracking from remote user input sources.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Remote flow sources reach\n * @description Identifies nodes reachable via taint tracking from remote user input sources.\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/alerts/remote-flow-sources-reach\n * @tags meta\n * @precision very-low\n */\n\n// Import Python language support\nprivate import python\n// Import data flow analysis framework\nprivate import semmle.python.dataflow.new.DataFlow\n// Import taint tracking capabilities\nprivate import semmle.python.dataflow.new.TaintTracking\n// Import remote flow source definitions\nprivate import semmle.python.dataflow.new.RemoteFlowSources\n// Import meta metrics utilities\nprivate import meta.MetaMetrics\n// Import internal print node support\nprivate import semmle.python.dataflow.new.internal.PrintNode\n\n// Configuration for tracking reachability from remote flow sources\nmodule RemoteFlowReachConfig implements DataFlow::ConfigSig {\n  /**\n   * Sink definition: All nodes not in ignored files.\n   * Note: Sink scope could be reduced by limiting to nodes involved in\n   * localFlowStep/readStep/storeStep operations. However, this approach\n   * is fragile and would require constant maintenance as the data flow\n   * library evolves. Testing shows only ~40% reduction in scope,\n   * which isn't sufficient justification for meta queries.\n   */\n  predicate isSink(DataFlow::Node targetNode) {\n    not targetNode.getLocation().getFile() instanceof IgnoredFile\n  }\n\n  // Source definition: Remote inputs not in ignored files\n  predicate isSource(DataFlow::Node originNode) {\n    originNode instanceof RemoteFlowSource and\n    not originNode.getLocation().getFile() instanceof IgnoredFile\n  }\n}\n\n// Global taint tracking module using the defined configuration\nmodule RemoteFlowReachFlow = TaintTracking::Global<RemoteFlowReachConfig>;\n\n// Query: Find all nodes tainted by remote flow sources\nfrom DataFlow::Node contaminatedNode\nwhere RemoteFlowReachFlow::flow(_, contaminatedNode)\nselect contaminatedNode, prettyNode(contaminatedNode)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Provides detailed analysis of alert suppression mechanisms in Python code\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL alert suppression utilities for managing suppression logic\nprivate import codeql.util.suppression.AlertSuppression as AlertSuppUtil\n// Import Python comment processing utilities for comment analysis\nprivate import semmle.python.Comment as PyComment\n\n// Defines AST nodes with precise location tracking capabilities\nclass TrackedAstNode instanceof PyComment::AstNode {\n  // Validate if node matches specified location coordinates\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginCol, endLine, endCol)\n  }\n\n  // Generate textual representation of the AST node\n  string toString() { result = super.toString() }\n}\n\n// Represents single-line comments with detailed location tracking\nclass TrackedSingleLineComment instanceof PyComment::Comment {\n  // Determine if comment matches provided location coordinates\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginCol, endLine, endCol)\n  }\n\n  // Extract the textual content from the comment\n  string getText() { result = super.getContents() }\n\n  // Generate textual representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Establish suppression relationship using AlertSuppUtil template\nimport AlertSuppUtil::Make<TrackedAstNode, TrackedSingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Identifies suppression comments following the noqa standard\nclass NoqaSuppressionComment extends SuppressionComment instanceof TrackedSingleLineComment {\n  // Constructor that recognizes noqa comment patterns\n  NoqaSuppressionComment() {\n    this.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Provide the identifier for this suppression annotation\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define the coverage scope for this suppression annotation\n  override predicate covers(\n    string sourceFile, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n_______________ // 补全条件\n    this.hasLocationInfo(sourceFile, beginLine, _, endLine, endCol) and\n    beginCol = 1\n  }\n}",
    "output": "// Verify comment location alignment and enforce line-start positioning"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import AlertSuppression utilities for handling suppression mechanisms\nprivate import codeql.util.suppression.AlertSuppression as AlertSuppression\n// Import Python comment processing utilities\nprivate import semmle.python.Comment as PythonComment\n\n// AST node wrapper extending PythonComment::AstNode functionality\nclass AstNode instanceof PythonComment::AstNode {\n  /**\n   * Provides location details for this AST node.\n   * @param file - Path to the file containing the node\n   * @param startLine - Starting line number of the node\n   * @param startCol - Starting column number of the node\n   * @param endLine - Ending line number of the node\n   * @param endCol - Ending column number of the node\n   */\n  predicate hasLocationInfo(\n    string file, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Delegate location retrieval to parent class\n    super.getLocation().hasLocationInfo(file, startLine, startCol, endLine, endCol)\n  }\n\n  /**\n   * Returns string representation of this AST node.\n   * @returns Descriptive string for the node\n   */\n  string toString() { result = super.toString() }\n}\n\n// Single-line comment wrapper extending PythonComment::Comment functionality\nclass SingleLineComment instanceof PythonComment::Comment {\n  /**\n   * Provides location details for this comment.\n   * @param file - Path to the file containing the comment\n   * @param startLine - Starting line number of the comment\n   * @param startCol - Starting column number of the comment\n   * @param endLine - Ending line number of the comment\n   * @param endCol - Ending column number of the comment\n   */\n  predicate hasLocationInfo(\n    string file, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Delegate location retrieval to parent class\n    super.getLocation().hasLocationInfo(file, startLine, startCol, endLine, endCol)\n  }\n\n  /**\n   * Returns the text content of this comment.\n   * @returns String content of the comment\n   */\n  string getText() { result = super.getContents() }\n\n  /**\n   * Returns string representation of this comment.\n   * @returns Descriptive string for the comment\n   */\n  string toString() { result = super.toString() }\n}\n\n// Establish alert suppression relationship between nodes and comments\nimport AlertSuppression::Make<AstNode, SingleLineComment>\n\n/**\n * Represents a noqa suppression comment. Recognized by both pylint and pyflakes,\n * and should be respected by LGTM analysis.\n */\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  /**\n   * Constructor validating noqa comment format.\n   * The noqa keyword is case-insensitive and may include trailing content.\n   */\n  NoqaSuppressionComment() {\n    // Validate comment matches noqa pattern (case-insensitive)\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  /**\n   * Returns the annotation identifier for this suppression.\n   * @returns \"lgtm\" as the annotation identifier\n   */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /**\n   * Defines the code range covered by this suppression.\n   * @param file - Path to the file containing the comment\n   * @param startLine - Starting line of the covered range\n_______________ // 补全条件\n   * @param endLine - Ending line of the covered range\n   * @param endCol - Ending column of the covered range\n   */\n  override predicate covers(\n    string file, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Verify comment location and line-start positioning\n    this.hasLocationInfo(file, startLine, _, endLine, endCol) and\n    startCol = 1\n  }\n}",
    "output": "* @param startCol - Starting column of the covered range"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/reflective-xss]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects security vulnerabilities where untrusted user input",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Reflected server-side cross-site scripting\n * @description Detects security vulnerabilities where untrusted user input\n *              is directly rendered in web responses without sanitization,\n *              allowing attackers to inject malicious scripts via XSS attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @sub-severity high\n * @precision high\n * @id py/reflective-xss\n * @tags security\n *       external/cwe/cwe-079\n *       external/cwe/cwe-116\n */\n\n// Import Python language analysis framework\nimport python\n// Import specialized module for detecting reflected cross-site scripting vulnerabilities\nimport semmle.python.security.dataflow.ReflectedXssQuery\n// Import path graph module for visualizing data flow paths\nimport ReflectedXssFlow::PathGraph\n\n// Identify vulnerable data flows from untrusted inputs to web outputs\nfrom ReflectedXssFlow::PathNode untrustedInputSource, ReflectedXssFlow::PathNode vulnerableOutputSink\nwhere ReflectedXssFlow::flowPath(untrustedInputSource, vulnerableOutputSink)\n// Report vulnerable output with source context and flow path details\nselect vulnerableOutputSink.getNode(), untrustedInputSource, vulnerableOutputSink, \n       \"Cross-site scripting vulnerability originating from a $@.\",\n       untrustedInputSource.getNode(), \"user-provided value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/utils/modeleditor/framework-mode-endpoints]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Catalogs accessible endpoints (methods/attributes) in the model editor's",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Framework-mode endpoint catalog for model editor\n * @description Catalogs accessible endpoints (methods/attributes) in the model editor's \n *              framework mode, excluding test code and generated artifacts from results.\n * @kind table\n * @id py/utils/modeleditor/framework-mode-endpoints\n * @tags modeleditor endpoints framework-mode\n */\n\nimport modeling.ModelEditor\n\nfrom Endpoint frameworkEndpoint\nselect \n  frameworkEndpoint,  // Primary endpoint object\n  frameworkEndpoint.getNamespace(),  // Namespace containing the endpoint\n  frameworkEndpoint.getClass(),  // Parent class defining the endpoint\n  frameworkEndpoint.getFunctionName(),  // Method/function identifier\n  frameworkEndpoint.getParameters(),  // Parameter signature details\n  frameworkEndpoint.getSupportedStatus(),  // Supported HTTP status codes\n  frameworkEndpoint.getFileName(),  // Source file location\n  frameworkEndpoint.getSupportedType(),  // Supported data types\n  frameworkEndpoint.getKind()  // Endpoint classification (method/attribute)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/catch-base-exception]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects exception handlers that catch BaseException without re-raising,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Exception block catches 'BaseException'\n * @description Detects exception handlers that catch BaseException without re-raising,\n *              which can lead to improper handling of system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Determines if an exception handler does not re-raise the caught exception\npredicate noReraiseInHandler(ExceptStmt exceptionBlock) { \n  // Check if the basic block containing the exception handler reaches program exit\n  exceptionBlock.getAFlowNode().getBasicBlock().reachesExit() \n}\n\n// Checks if an exception handler catches BaseException or has no exception type specified\npredicate catchesBaseException(ExceptStmt exceptionBlock) {\n  // Verify if the exception type is BaseException or if no type is defined\n  exceptionBlock.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  not exists(exceptionBlock.getType())\n}\n\n// Main query: Identify exception handlers that catch BaseException without re-raising it\nfrom ExceptStmt exceptionBlock\nwhere\n  // Conditions: Catches BaseException and lacks re-raise mechanism\n  catchesBaseException(exceptionBlock) and\n  noReraiseInHandler(exceptionBlock)\nselect exceptionBlock, \"Except block directly handles BaseException.\" // Output selection with description"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Descriptor objects are shared across instances. Mutating them may cause unexpected side effects or race conditions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Identify classes implementing descriptor protocol and their mutation operations\nfrom ClassObject descriptorClass, SelfAttributeStore mutationOperation\nwhere \n  // Verify class implements descriptor protocol\n  descriptorClass.isDescriptorType() and\n  // Find descriptor methods and their call chains\n  exists(PyFunctionObject descriptorMethod, string protocolMethod, PyFunctionObject invokedFunction |\n    // Identify descriptor protocol methods (__get__/__set__/__delete__)\n    descriptorClass.lookupAttribute(protocolMethod) = descriptorMethod and\n    (protocolMethod = \"__get__\" or protocolMethod = \"__set__\" or protocolMethod = \"__delete__\") and\n    // Locate class member functions called by descriptor methods\n    descriptorClass.lookupAttribute(_) = invokedFunction and\n    // Exclude initialization methods and validate call relationship\n_______________ // 补全条件\n    descriptorMethod.getACallee*() = invokedFunction and\n    // Confirm mutation occurs within invoked function's scope\n    mutationOperation.getScope() = invokedFunction.getFunction()\n  )\n// Output mutation location, warning message, related class and its name\nselect mutationOperation,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorClass, descriptorClass.getName()",
    "output": "not invokedFunction.getName() = \"__init__\" and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Log Injection Vulnerability\n * @description Identifies potential log injection vulnerabilities where untrusted user input\n *              is directly embedded into log entries without sanitization, enabling\n *              attackers to forge log entries or manipulate log content.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.8\n * @precision medium\n_______________ // 补全条件\n * @tags security\n *       external/cwe/cwe-117\n */\n\n// Import Python analysis library for source code parsing and processing\nimport python\n\n// Import security data flow module specialized in log injection detection\nimport semmle.python.security.dataflow.LogInjectionQuery\n\n// Import path graph modeling class for log injection data flow analysis\nimport LogInjectionFlow::PathGraph\n\n// Identify vulnerable log injection paths from untrusted sources to log sinks\nfrom LogInjectionFlow::PathNode sourceNode, LogInjectionFlow::PathNode sinkNode\nwhere LogInjectionFlow::flowPath(sourceNode, sinkNode)\n// Output vulnerable log entry with source-to-sink path and contextual message\nselect sinkNode.getNode(), sourceNode, sinkNode, \n       \"This log entry incorporates a $@.\", sourceNode.getNode(), \n       \"user-provided value\"",
    "output": "* @id py/log-injection"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/doc-string-ratio-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the ratio of docstring lines to total lines in each Python file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Docstring Coverage Percentage\n * @description Measures the ratio of docstring lines to total lines in each Python file.\n * @kind treemap\n * @id py/doc-string-ratio-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\n// Query all non-empty Python modules and calculate their docstring coverage\nfrom Module pythonModule, ModuleMetrics moduleMetrics\nwhere \n  // Associate each module with its corresponding metrics\n  moduleMetrics = pythonModule.getMetrics() and \n  // Filter out empty modules (modules with no lines of code)\n  moduleMetrics.getNumberOfLines() > 0\nselect pythonModule,\n  // Calculate docstring coverage as a percentage\n  100.0 * (moduleMetrics.getNumberOfLinesOfDocStrings().(float) / moduleMetrics.getNumberOfLines().(float)) as docstringCoveragePercentage\norder by docstringCoveragePercentage desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Mostly similar module detection\n * @description Identifies modules with substantial code similarity. Note that variable names and types may differ between modules. Consolidation is recommended for maintainability.\n * @kind problem\n * @problem.severity recommendation\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @sub-severity low\n * @precision high\n * @id py/mostly-similar-file\n */\n\nimport python\n_______________ // 补全条件\n// Define source modules and similarity description\nfrom Module sourceMod, \n     Module targetMod, \n     string similarityDesc\nwhere \n  // Placeholder condition - no actual filtering implemented\n  none()\nselect \n  sourceMod, \n  similarityDesc, \n  targetMod, \n  targetMod.getName()  // Output target module name",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies the use of cryptographic elliptic curve algorithms that are either unapproved or considered weak.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak elliptic curve\n * @description Identifies the use of cryptographic elliptic curve algorithms that are either unapproved or considered weak.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm cryptoOperation, string alertMessage, string curveIdentifier\nwhere\n  // Case 1: The curve identifier is an unknown algorithm\n  (\n    curveIdentifier = cryptoOperation.getCurveName() and\n    curveIdentifier = unknownAlgorithm() and\n    alertMessage = \"Use of unrecognized curve algorithm.\"\n  )\n  or\n  // Case 2: The curve identifier is known but not in the approved list\n  (\n    curveIdentifier != unknownAlgorithm() and\n    curveIdentifier = cryptoOperation.getCurveName() and\n    not curveIdentifier =\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    alertMessage = \"Use of weak curve algorithm \" + curveIdentifier + \".\"\n  )\nselect cryptoOperation, alertMessage"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak elliptic curve detection\n * @description Detects cryptographic operations utilizing elliptic curve algorithms that are either not recognized or classified as weak/insufficiently secure\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm ellipticCurveUsage, string securityAlert, string curveName\nwhere\n_______________ // 补全条件\n  curveName = ellipticCurveUsage.getCurveName() and\n  (\n    // Scenario 1: Algorithm is not recognized\n    curveName = unknownAlgorithm() and\n    securityAlert = \"Use of unrecognized curve algorithm.\"\n    or\n    // Scenario 2: Algorithm is recognized but considered weak\n    curveName != unknownAlgorithm() and\n    not curveName in [\n      \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n      \"SECP384R1\",              // P-384 curve\n      \"SECP521R1\",              // P-521 curve\n      \"ED25519\",                // Ed25519 curve\n      \"X25519\"                  // X25519 curve\n    ] and\n    securityAlert = \"Use of weak curve algorithm \" + curveName + \".\"\n  )\nselect ellipticCurveUsage, securityAlert",
    "output": "// Extract curve identifier from the cryptographic operation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-padding]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Detects asymmetric encryption padding schemes that are either cryptographically weak",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Detects asymmetric encryption padding schemes that are either cryptographically weak\n * or not explicitly recognized as secure. This analysis excludes approved padding methods\n * (OAEP, KEM, PSS) and flags all other padding schemes as potential security vulnerabilities.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define secure padding schemes that should be excluded from detection\nstring securePaddingScheme() {\n  result = [\"OAEP\", \"KEM\", \"PSS\"]\n}\n\n// Identify all asymmetric padding implementations and analyze their security\nfrom AsymmetricPadding paddingImpl, string paddingScheme\nwhere\n  // Extract the padding algorithm name from the implementation\n  paddingScheme = paddingImpl.getPaddingName()\n  // Filter out known secure padding algorithms\n  and not paddingScheme = securePaddingScheme()\nselect paddingImpl, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + paddingScheme"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Comparison of identical values\n * @description Identifies logical flaws where values are compared against themselves,\n *              which always evaluate to true/false. Such comparisons typically indicate\n *              programming errors or ambiguous intentions. For NaN verification,\n *              use cmath.isnan() instead.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n *       external/cwe/cwe-570\n_______________ // 补全条件\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\nimport python  // Core Python library for code analysis\nimport Expressions.RedundantComparison  // Module for detecting redundant comparison expressions\n\n// Main detection logic for problematic self-comparisons\nfrom RedundantComparison redundantComparison\nwhere \n  // Filter out intentional constant comparisons\n  not redundantComparison.isConstant() and\n  // Exclude cases where 'self' might be missing to reduce false positives\n  not redundantComparison.maybeMissingSelf()\n// Report findings with remediation guidance\nselect redundantComparison, \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\"",
    "output": "*       external/cwe/cwe-571"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call-to-non-callable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies invocations of objects that cannot be called,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-callable invoked\n * @description Identifies invocations of objects that cannot be called,\n *              resulting in runtime TypeError exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom \n  Call invocationSite, \n  Expr invokedExpression, \n  Value calledValue, \n  ClassValue calledClass, \n  AstNode sourceNode\nwhere\n  // Extract the expression being invoked from the function call\n  invokedExpression = invocationSite.getFunc() and\n  \n  // Trace the called expression to its resolved value and origin point\n  invokedExpression.pointsTo(calledValue, sourceNode) and\n  \n  // Retrieve the class type of the target object\n  calledClass = calledValue.getClass() and\n  \n  // Verify the object's class is not callable\n  not calledClass.isCallable() and\n  \n  // Ensure type inference was successful for accurate analysis\n  not calledClass.failedInference(_) and\n  \n  // Exclude descriptor objects that implement __get__ method\n  // These objects might be callable through the descriptor protocol\n  not calledClass.hasAttribute(\"__get__\") and\n  \n  // Filter out None values as they are explicitly non-callable\n  not calledValue = Value::named(\"None\") and\n  \n  // Special case: exclude NotImplemented when used in raise statements\n  not use_of_not_implemented_in_raise(_, invokedExpression)\nselect \n  invocationSite, \n  \"Call to a $@ of $@.\", \n  sourceNode, \n  \"non-callable\", \n  calledClass, \n  calledClass.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/explicit-return-in-init]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Explicitly returning a value from an `__init__` method will raise a TypeError.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__init__` method returns a value\n * @description Explicitly returning a value from an `__init__` method will raise a TypeError.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/explicit-return-in-init\n */\n\nimport python\n\nfrom Return r, Expr rv\nwhere\n  // Identify return statements within __init__ methods\n  exists(Function initMethod | \n    initMethod.isInitMethod() and \n    r.getScope() = initMethod\n  ) and\n  // Match return value to the expression\n  r.getValue() = rv and\n  // Exclude None returns (allowed in __init__)\n  not rv.pointsTo(Value::none_()) and\n  // Filter out non-returning function calls\n  not exists(FunctionValue funcValue | \n    funcValue.getACall() = rv.getAFlowNode() | \n    funcValue.neverReturns()\n  ) and\n  // Prevent duplicate reports for nested __init__ calls\n  not exists(Attribute methodAttr | \n    methodAttr = rv.(Call).getFunc() | \n    methodAttr.getName() = \"__init__\"\n  )\nselect r, \"Explicit return in __init__ method.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jwt-empty-secret-or-algorithm]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies JWT token encoding operations utilizing empty cryptographic keys or algorithms,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name JWT encoding with empty key or algorithm\n * @description Identifies JWT token encoding operations utilizing empty cryptographic keys or algorithms,\n *              which could compromise token validation security.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-empty-secret-or-algorithm\n * @tags security\n *       experimental\n */\n\n// Import core Python analysis libraries\nimport python\nimport experimental.semmle.python.Concepts\nimport experimental.semmle.python.frameworks.JWT\n\n// Detect JWT encoding operations with vulnerable parameter configurations\nfrom JwtEncoding jwtOperation, string vulnerableParameter\nwhere\n  // First vulnerability case: Empty algorithm specification\n  (\n    vulnerableParameter = \"algorithm\" and\n    isEmptyOrNone(jwtOperation.getAlgorithm())\n  )\n  or\n  // Second vulnerability case: Empty key specification\n  (\n    vulnerableParameter = \"key\" and\n    isEmptyOrNone(jwtOperation.getKey())\n  )\nselect jwtOperation, \"This JWT encoding uses an empty \" + vulnerableParameter + \" parameter.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-use-with]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code patterns where a 'try-finally' block is exclusively used",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Should use a 'with' statement\n * @description Identifies code patterns where a 'try-finally' block is exclusively used \n *              for resource cleanup, which could be simplified using a 'with' statement.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/should-use-with\n */\n\nimport python\n\n// 检查给定的方法调用是否为资源关闭操作（即close方法）\npredicate isCloseMethodCall(Call resourceCloseCall) { \n    exists(Attribute attribute | resourceCloseCall.getFunc() = attribute and attribute.getName() = \"close\") \n}\n\n// 检查try-finally块的finally部分是否仅包含一个资源关闭调用\npredicate hasOnlyCloseInFinally(Try tryFinallyBlock, Call resourceCloseCall) {\n    exists(ExprStmt statement |\n        tryFinallyBlock.getAFinalstmt() = statement and \n        statement.getValue() = resourceCloseCall and \n        strictcount(tryFinallyBlock.getAFinalstmt()) = 1\n    )\n}\n\n// 检查控制流节点是否引用了一个上下文管理器类的实例\npredicate refersToContextManager(ControlFlowNode resourceFlowNode, ClassValue contextManagerClass) {\n    forex(Value value | resourceFlowNode.pointsTo(value) | value.getClass() = contextManagerClass) and\n    contextManagerClass.isContextManager()\n}\n\n// 查找所有在finally块中仅包含close方法调用的代码，并建议使用'with'语句\nfrom Call resourceCloseCall, Try tryFinallyBlock, ClassValue contextManagerClass\nwhere\n    // 确保finally块中只有一个close调用\n    hasOnlyCloseInFinally(tryFinallyBlock, resourceCloseCall) and \n    // 确保该调用确实是close方法\n    isCloseMethodCall(resourceCloseCall) and \n    // 确保close方法是在上下文管理器实例上调用\n    exists(ControlFlowNode resourceFlowNode | \n        resourceFlowNode = resourceCloseCall.getFunc().getAFlowNode().(AttrNode).getObject() and\n        refersToContextManager(resourceFlowNode, contextManagerClass)\n    )\nselect resourceCloseCall,\n    \"Instance of context-manager class $@ is closed in a finally block. Consider using 'with' statement.\",\n    contextManagerClass, contextManagerClass.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name 外部依赖关系\n * @description 计算一个Python源文件对外部包的依赖数量。\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType externalDependency\n * @id py/external-dependencies\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 本查询用于分析Python源文件与外部包之间的依赖关系，量化每个文件对外部包的依赖程度。\n * \n * 查询核心要素：\n_______________ // 补全条件\n * - 外部包对象（PyPI或类似外部源提供的包）\n * - 包版本信息（如果可用）\n * - 源文件对该包的依赖数量统计\n * \n * 输出格式：\n * - 第一列：依赖实体标识符（文件路径和外部包的组合）\n * - 第二列：依赖计数\n * \n * 注意：文件路径前添加'/'前缀，以与仪表板数据库中的相对文件路径格式保持一致。\n */\n\n// 定义查询变量：源文件、外部包、依赖计数和依赖实体\nfrom File codeFile, ExternalPackage externalPkg, int dependencyCount, string dependencyId\nwhere\n  // 计算源文件对特定外部包的依赖数量\n  dependencyCount =\n    strictcount(AstNode syntaxNode |\n      // 检查AST节点是否依赖于指定的外部包\n      dependency(syntaxNode, externalPkg) and\n      // 确保AST节点位于指定的源文件中\n      syntaxNode.getLocation().getFile() = codeFile\n    ) and\n  // 将源文件和外部包信息合并为单个实体标识符\n  dependencyId = munge(codeFile, externalPkg)\n// 输出结果：依赖实体和依赖计数，按依赖数量降序排列\nselect dependencyId, dependencyCount order by dependencyCount desc",
    "output": "* - 源代码文件路径（依赖关系主体）"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/str-format/missing-named-argument]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A string formatting operation, such as '\"{name}\".format(key=b)',",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Missing named arguments in formatting call\n * @description A string formatting operation, such as '\"{name}\".format(key=b)',\n *              where the names of format items in the format string differs from the names of the values to be formatted will raise a KeyError.\n * @kind problem\n * @problem.severity error\n * @tags reliability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/str-format/missing-named-argument\n */\n\nimport python // 导入python库，用于处理Python代码的查询\nimport AdvancedFormatting // 导入AdvancedFormatting库，用于高级格式化操作的处理\n\n// 从AdvancedFormattingCall和AdvancedFormatString中提取call、fmt和name\nfrom AdvancedFormattingCall call, AdvancedFormatString fmt, string name\nwhere\n  call.getAFormat() = fmt and // 确保调用的格式化对象与格式字符串匹配\n  not name = call.getAKeyword().getArg() and // 检查名称是否与关键字参数不匹配\n  fmt.getFieldName(_, _) = name and // 检查格式字符串中的字段名称是否与给定的名称匹配\n  not exists(call.getKwargs()) // 确保没有其他关键字参数存在\nselect call, // 选择调用点\n  \"Missing named argument for string format. Format $@ requires '\" + name + \"', but it is omitted.\", // 生成错误信息，指出缺少的命名参数\n  fmt, \"\\\"\" + fmt.getText() + \"\\\"\" // 显示相关的格式字符串"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Regular expression injection vulnerability\n * @description Constructing regular expressions using unescaped user input may allow injection attacks.\n *              Attackers can craft patterns that cause exponential runtime (ReDoS) on specific inputs,\n *              potentially leading to denial of service.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n_______________ // 补全条件\n * @tags security\n *       external/cwe/cwe-730\n *       external/cwe/cwe-400\n */\n\nimport python\nprivate import semmle.python.Concepts\nimport semmle.python.security.dataflow.RegexInjectionQuery\nimport RegexInjectionFlow::PathGraph\n\nfrom\n  RegexInjectionFlow::PathNode inputOrigin, \n  RegexInjectionFlow::PathNode injectionTarget,\n  RegexExecution patternExecution\nwhere\n  RegexInjectionFlow::flowPath(inputOrigin, injectionTarget) and\n  patternExecution = injectionTarget.getNode().(Sink).getRegexExecution()\nselect\n  injectionTarget.getNode(), \n  inputOrigin, \n  injectionTarget,\n  \"This regular expression incorporates a $@ and is processed via $@.\", \n  inputOrigin.getNode(), \n  \"user-provided value\", \n  patternExecution, \n  patternExecution.getName()",
    "output": "* @id py/regex-injection"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Misnamed function\n * @description Identifies functions with names starting with an uppercase letter, which can reduce code readability.\n * @kind problem\n_______________ // 补全条件\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python\n\n// Define a predicate to check if a function name starts with an uppercase letter\npredicate startsWithUppercase(Function fn) {\n  exists(string firstChar |\n    firstChar = fn.getName().prefix(1) and  // Extract the first character of the function name\n    firstChar = firstChar.toUpperCase()  // Check if the first character is uppercase\n  )\n}\n\n// Select functions that meet the specified criteria\nfrom Function targetFn\nwhere\n  targetFn.inSource() and  // Ensure the function is present in the source code\n  startsWithUppercase(targetFn) and  // Function name starts with an uppercase letter\n  not exists(Function otherFn |\n    otherFn != targetFn and  // Exclude other functions with the same name\n    otherFn.getLocation().getFile() = targetFn.getLocation().getFile() and  // Located in the same file\n    startsWithUppercase(otherFn)  // And also starts with an uppercase letter\n  )\nselect targetFn, \"Function names should start in lowercase.\"  // Report these functions with a recommendation",
    "output": "* @problem.severity recommendation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides comprehensive metrics on type annotation usage patterns in Python codebase,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Provides comprehensive metrics on type annotation usage patterns in Python codebase,\n *              categorizing annotations by their structure (simple, complex, optional, forward-declared)\n *              and context (parameters, return types, assignments).\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents built-in Python types like int, float, str, etc.\nclass PythonBuiltinType extends Name {\n  PythonBuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type definition for elements that can have type annotations\nnewtype TypeAnnotatableElement =\n  TFunctionWithAnnotation(FunctionExpr function) { exists(function.getReturns()) } or \n  TParameterWithAnnotation(Parameter parameter) { exists(parameter.getAnnotation()) } or \n  TAssignmentWithAnnotation(AnnAssign assignment) { exists(assignment.getAnnotation()) }\n\n// Abstract base class for all elements that can have type annotations\nabstract class TypeAnnotatedElement extends TypeAnnotatableElement {\n  string toString() { result = \"TypeAnnotatedElement\" }\n  abstract Expr getAnnotation();\n}\n\n// Represents functions with return type annotations\nclass FunctionWithTypeAnnotation extends TFunctionWithAnnotation, TypeAnnotatedElement {\n  FunctionExpr functionExpr;\n  FunctionWithTypeAnnotation() { this = TFunctionWithAnnotation(functionExpr) }\n  override Expr getAnnotation() { result = functionExpr.getReturns() }\n}\n\n// Represents parameters with type annotations\nclass ParameterWithTypeAnnotation extends TParameterWithAnnotation, TypeAnnotatedElement {\n  Parameter parameter;\n  ParameterWithTypeAnnotation() { this = TParameterWithAnnotation(parameter) }\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\n// Represents assignments with type annotations\nclass AssignmentWithTypeAnnotation extends TAssignmentWithAnnotation, TypeAnnotatedElement {\n  AnnAssign assignmentStmt;\n  AssignmentWithTypeAnnotation() { this = TAssignmentWithAnnotation(assignmentStmt) }\n  override Expr getAnnotation() { result = assignmentStmt.getAnnotation() }\n}\n\n// Helper predicates to classify type annotations\n\n/** Determines if an expression is a forward-declared type (string literal) */\npredicate isForwardDeclaredType(Expr expr) { expr instanceof StringLiteral }\n\n/** Determines if an expression represents a complex type structure */\npredicate isComplexTypeStructure(Expr expr) {\n  expr instanceof Subscript and not isOptionalTypeAnnotation(expr)\n  or\n  expr instanceof Tuple\n  or\n  expr instanceof List\n}\n\n/** Determines if an expression is an Optional type */\npredicate isOptionalTypeAnnotation(Subscript expr) { expr.getObject().(Name).getId() = \"Optional\" }\n\n/** Determines if an expression is a simple user-defined type */\npredicate isSimpleUserDefinedType(Expr expr) {\n  expr instanceof Name and not expr instanceof PythonBuiltinType\n  or\n  isSimpleUserDefinedType(expr.(Attribute).getObject())\n}\n\n/** Determines if an expression is a built-in type */\npredicate isPythonBuiltinType(Expr expr) { expr instanceof PythonBuiltinType }\n\n// Computes type annotation metrics for different categories\npredicate calculateTypeAnnotationMetrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Metrics for parameter annotations\n  category = \"Parameter annotation\" and\n  totalCount = count(ParameterWithTypeAnnotation annotatedParam) and\n  builtinCount = count(ParameterWithTypeAnnotation annotatedParam | isPythonBuiltinType(annotatedParam.getAnnotation())) and\n  forwardDeclCount = count(ParameterWithTypeAnnotation annotatedParam | isForwardDeclaredType(annotatedParam.getAnnotation())) and\n  simpleTypeCount = count(ParameterWithTypeAnnotation annotatedParam | isSimpleUserDefinedType(annotatedParam.getAnnotation())) and\n  complexTypeCount = count(ParameterWithTypeAnnotation annotatedParam | isComplexTypeStructure(annotatedParam.getAnnotation())) and\n  optionalTypeCount = count(ParameterWithTypeAnnotation annotatedParam | isOptionalTypeAnnotation(annotatedParam.getAnnotation()))\n  or\n  // Metrics for return type annotations\n  category = \"Return type annotation\" and\n  totalCount = count(FunctionWithTypeAnnotation annotatedFunc) and\n  builtinCount = count(FunctionWithTypeAnnotation annotatedFunc | isPythonBuiltinType(annotatedFunc.getAnnotation())) and\n  forwardDeclCount = count(FunctionWithTypeAnnotation annotatedFunc | isForwardDeclaredType(annotatedFunc.getAnnotation())) and\n  simpleTypeCount = count(FunctionWithTypeAnnotation annotatedFunc | isSimpleUserDefinedType(annotatedFunc.getAnnotation())) and\n  complexTypeCount = count(FunctionWithTypeAnnotation annotatedFunc | isComplexTypeStructure(annotatedFunc.getAnnotation())) and\n  optionalTypeCount = count(FunctionWithTypeAnnotation annotatedFunc | isOptionalTypeAnnotation(annotatedFunc.getAnnotation()))\n  or\n  // Metrics for annotated assignments\n  category = \"Annotated assignment\" and\n  totalCount = count(AssignmentWithTypeAnnotation annotatedAssign) and\n  builtinCount = count(AssignmentWithTypeAnnotation annotatedAssign | isPythonBuiltinType(annotatedAssign.getAnnotation())) and\n  forwardDeclCount = count(AssignmentWithTypeAnnotation annotatedAssign | isForwardDeclaredType(annotatedAssign.getAnnotation())) and\n  simpleTypeCount = count(AssignmentWithTypeAnnotation annotatedAssign | isSimpleUserDefinedType(annotatedAssign.getAnnotation())) and\n  complexTypeCount = count(AssignmentWithTypeAnnotation annotatedAssign | isComplexTypeStructure(annotatedAssign.getAnnotation())) and\n  optionalTypeCount = count(AssignmentWithTypeAnnotation annotatedAssign | isOptionalTypeAnnotation(annotatedAssign.getAnnotation()))\n}\n\n// Query execution and result selection\nfrom\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  calculateTypeAnnotationMetrics(category, totalCount, builtinCount, forwardDeclCount, \n                    simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of a broken or weak cryptographic hashing algorithm on sensitive data\n * @description Identifies instances where sensitive data undergoes processing using weak or broken cryptographic hashing algorithms,\n *              which may introduce security vulnerabilities including hash collisions or preimage attacks.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @id py/weak-sensitive-data-hashing\n * @tags security\n *       external/cwe/cwe-327\n *       external/cwe/cwe-328\n *       external/cwe/cwe-916\n */\n\n// Import required Python analysis libraries\nimport python\n// Import specialized module for analyzing weak cryptographic hashing on sensitive data\nimport semmle.python.security.dataflow.WeakSensitiveDataHashingQuery\n// Import the data flow analysis framework\nimport semmle.python.dataflow.new.DataFlow\n// Import taint tracking framework\nimport semmle.python.dataflow.new.TaintTracking\n// Import path graph visualization for data flow\nimport WeakSensitiveDataHashingFlow::PathGraph\n\nfrom\n  // Define path nodes representing data flow source and target\n  WeakSensitiveDataHashingFlow::PathNode sourceNode, WeakSensitiveDataHashingFlow::PathNode targetNode,\n  // Variables for message suffix, hash algorithm identifier, and data classification\n  string messageSuffix, string algoName, string dataCategory\nwhere\n  // Handle standard hash function flow scenario\n  (\n    normalHashFunctionFlowPath(sourceNode, targetNode) and\n_______________ // 补全条件\n    algoName = targetNode.getNode().(NormalHashFunction::Sink).getAlgorithmName() and\n    // Extract data classification from source node\n    dataCategory = sourceNode.getNode().(NormalHashFunction::Source).getClassification() and\n    // Set default warning suffix\n    messageSuffix = \".\"\n  )\n  or\n  // Handle computationally intensive hash function flow scenario\n  (\n    computationallyExpensiveHashFunctionFlowPath(sourceNode, targetNode) and\n    // Extract hash algorithm name from target node\n    algoName = targetNode.getNode().(ComputationallyExpensiveHashFunction::Sink).getAlgorithmName() and\n    // Extract data classification from source node\n    dataCategory = sourceNode.getNode().(ComputationallyExpensiveHashFunction::Source).getClassification() and\n    // Determine warning suffix based on computational intensity\n    (\n      // Case when hash function is computationally expensive\n      targetNode.getNode().(ComputationallyExpensiveHashFunction::Sink).isComputationallyExpensive() and\n      messageSuffix = \".\"\n      or\n      // Case when hash function is not computationally expensive\n      not targetNode.getNode().(ComputationallyExpensiveHashFunction::Sink).isComputationallyExpensive() and\n      messageSuffix = \" for \" + dataCategory + \" hashing, since it is not a computationally expensive hash function.\"\n    )\n  )\nselect \n  // Output results with target node, source node, target node (for path), warning message, and source node (for message)\n  targetNode.getNode(), sourceNode, targetNode,\n  \"$@ is processed using an insecure hashing algorithm (\" + algoName + \")\" + messageSuffix,\n  sourceNode.getNode(), \"Sensitive data (\" + dataCategory + \")\"",
    "output": "// Extract hash algorithm name from target node"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unreachable-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects exception handlers that can never execute due to being positioned",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unreachable 'except' block\n * @description Detects exception handlers that can never execute due to being positioned\n *              after a more general handler that intercepts exceptions first.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Extracts the exception type handled by an except clause\nClassValue getHandledExceptionType(ExceptStmt handler) { \n  handler.getType().pointsTo(result) \n}\n\n// Identifies when an except handler becomes unreachable due to handler ordering\npredicate hasUnreachableExceptionHandler(ExceptStmt precedingExcept, ClassValue broaderType, \n                                        ExceptStmt succeedingExcept, ClassValue narrowerType) {\n  exists(int precedingIndex, int succeedingIndex, Try tryBlock |\n    // Both handlers belong to the same try statement\n    precedingExcept = tryBlock.getHandler(precedingIndex) and\n    succeedingExcept = tryBlock.getHandler(succeedingIndex) and\n    // Preceding handler appears before succeeding handler in source order\n    precedingIndex < succeedingIndex and\n    // Extract exception types for both handlers\n    broaderType = getHandledExceptionType(precedingExcept) and\n    narrowerType = getHandledExceptionType(succeedingExcept) and\n    // Preceding handler catches a superclass of the succeeding handler's exception\n    broaderType = narrowerType.getASuperType()\n  )\n}\n\n// Main query identifying all unreachable exception handlers\nfrom ExceptStmt precedingExcept, ClassValue broaderType, \n     ExceptStmt succeedingExcept, ClassValue narrowerType\nwhere hasUnreachableExceptionHandler(precedingExcept, broaderType, succeedingExcept, narrowerType)\nselect succeedingExcept,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  narrowerType, narrowerType.getName(), precedingExcept, \"except block\", broaderType, broaderType.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Initializing SECRET_KEY of Flask/Django with Constant Value\n * @description Hardcoded SECRET_KEY values in Flask/Django applications\n * can lead to authentication bypass vulnerabilities\n * @kind path-problem\n * @id py/flask-constant-secret-key\n * @problem.severity error\n * @security-severity 8.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.filters.Tests\n\n// Define web framework types (Flask or Django)\nnewtype WebFramework =\n  Flask() or\n  Django()\n\n// Unified configuration module for constant secret key detection\nprivate module SecretKeyDetectionConfig {\n  import semmle.python.dataflow.new.DataFlow\n\n  // Identify constant string sources that could be secret keys\n  predicate isPotentialSecretSource(DataFlow::Node sourceNode) {\n    exists(string strValue |\n      strValue = sourceNode.asExpr().(StringLiteral).getText() and\n      strValue.length() > 0 and\n      // Exclude common placeholder values\n      not strValue in [\"\", \"changeme\", \"secret\", \"password\", \"default\"]\n    )\n  }\n_______________ // 补全条件\n  // Identify SECRET_KEY assignment sinks\n  predicate isSecretKeyAssignmentSink(DataFlow::Node sinkNode) {\n    exists(DataFlow::Node configAttrNode |\n      configAttrNode.asExpr().(Attribute).getName() = \"SECRET_KEY\" and\n      sinkNode.asExpr() = configAttrNode.asExpr().(Attribute).getObject()\n    )\n  }\n}\n\n// Configuration for data flow analysis with framework state tracking\nprivate module WebAppSecretKeyConfig implements DataFlow::StateConfigSig {\n  // Framework state type definition\n  class FlowState = WebFramework;\n\n  // Identify source nodes based on framework type\n  predicate isSource(DataFlow::Node source, FlowState framework) {\n    framework = Flask() and SecretKeyDetectionConfig::isPotentialSecretSource(source)\n    or\n    framework = Django() and SecretKeyDetectionConfig::isPotentialSecretSource(source)\n  }\n\n  // Define barrier nodes to filter false positives\n  predicate isBarrier(DataFlow::Node node) {\n    // Exclude standard library nodes\n    node.getLocation().getFile().inStdlib()\n    or\n    // Exclude test/demo/example/sample files except specific test cases\n    exists(string relativePath |\n      relativePath = node.getLocation().getFile().getRelativePath() and\n      relativePath.matches([\"%test%\", \"%demo%\", \"%example%\", \"%sample%\"]) and\n      not relativePath.matches(\"%query-tests/Security/CWE-287%\")\n    )\n    or\n    // Exclude nodes that are clearly not secret keys\n    exists(string value |\n      value = node.asExpr().(StringLiteral).getText() and\n      value in [\"\", \"changeme\", \"secret\", \"password\", \"default\"]\n    )\n  }\n\n  // Identify sink nodes based on framework type\n  predicate isSink(DataFlow::Node sink, FlowState framework) {\n    framework = Flask() and SecretKeyDetectionConfig::isSecretKeyAssignmentSink(sink)\n    or\n    framework = Django() and SecretKeyDetectionConfig::isSecretKeyAssignmentSink(sink)\n  }\n\n  // Enable differential analysis in incremental mode\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global taint tracking with framework state\nmodule WebAppSecretKeyFlow = TaintTracking::GlobalWithState<WebAppSecretKeyConfig>;\n\n// Import path graph for flow visualization\nimport WebAppSecretKeyFlow::PathGraph\n\n// Query to detect hardcoded secret key assignments\nfrom WebAppSecretKeyFlow::PathNode source, WebAppSecretKeyFlow::PathNode sink\nwhere WebAppSecretKeyFlow::flowPath(source, sink)\nselect sink, source, sink, \"The SECRET_KEY config variable is assigned by $@.\", source,\n  \" this constant String\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent equality and inequality\n * @description Identifies classes violating Python's object model by implementing only one of the equality comparison methods (__eq__ or __ne__).\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-equality\n */\n\nimport python\n\n// Returns valid equality comparison method names\nstring getEqualityMethodName() { result = \"__eq__\" or result = \"__ne__\" }\n\n// Checks if a class uses the @total_ordering decorator\npredicate isTotalOrderingDecorated(Class cls) {\n  exists(Attribute decoratorAttr | \n    decoratorAttr = cls.getADecorator() | \n    decoratorAttr.getName() = \"total_ordering\"\n  )\n  or\n  exists(Name decoratorName | \n    decoratorName = cls.getADecorator() | \n    decoratorName.getId() = \"total_ordering\"\n  )\n}\n\n// Retrieves an implemented equality method from a class\nCallableValue findEqualityMethod(ClassValue targetClass, string methodName) {\n  result = targetClass.declaredAttribute(methodName) and \n  methodName = getEqualityMethodName()\n}\n\n// Determines which equality method is missing in a class\nstring getMissingEqualityMethod(ClassValue targetClass) {\n  not targetClass.declaresAttribute(result) and \n  result = getEqualityMethodName()\n}\n\n// Identifies classes violating the equality contract\npredicate violatesEqualityContract(\n  ClassValue targetClass, string presentMethod, \n  string missingMethod, CallableValue implementedMethod\n) {\n_______________ // 补全条件\n  missingMethod = getMissingEqualityMethod(targetClass) and\n  // Get implemented equality method\n  implementedMethod = findEqualityMethod(targetClass, presentMethod) and\n  // Exclude classes with failed inference\n  not targetClass.failedInference(_) and\n  // Exclude classes with @total_ordering decorator\n  not isTotalOrderingDecorated(targetClass.getScope()) and\n  // Python 3 auto-implements __ne__ when __eq__ exists\n  not (major_version() = 3 and presentMethod = \"__eq__\" and missingMethod = \"__ne__\")\n}\n\n// Select classes violating equality contract and generate warnings\nfrom ClassValue targetClass, string presentMethod, string missingMethod, CallableValue implementedMethod\nwhere violatesEqualityContract(targetClass, presentMethod, missingMethod, implementedMethod)\nselect implementedMethod, \"Class $@ implements \" + presentMethod + \" but lacks \" + missingMethod + \".\", targetClass,\n  targetClass.getName()",
    "output": "// Get missing equality method"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/external-dependencies]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：统计Python源文件中引用的外部包依赖数量",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name 外部依赖关系\n * @description 统计Python源文件中引用的外部包依赖数量\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType externalDependency\n * @id py/external-dependencies\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 查询结果包含两个输出列，但实际上编码了四个逻辑信息：\n *\n * 1. Python源文件路径 - 标识依赖关系的来源文件\n * 2. 外部包对象 - 通常指PyPI或其他外部仓库提供的包\n * 3. 包版本信息 - 如果能够获取到的话\n * 4. 依赖计数 - 源文件中引用该包的次数\n *\n * 当前查询设计为返回两列数据，这是为了兼容现有的仪表板数据库架构。\n * 如果要返回三列或更多列，需要修改仪表板数据库架构和提取器。\n *\n * 注意：文件路径前添加了'/'前缀，以确保路径格式与仪表板数据库中使用的相对路径一致。\n */\n\n// 主查询：识别源文件与外部包之间的依赖关系并统计数量\nfrom File srcFile, int depCount, string pkgEntity, ExternalPackage extPkg\nwhere\n  // 计算特定源文件对特定外部包的依赖数量\n  depCount =\n    strictcount(AstNode node |\n      dependency(node, extPkg) and // 检查AST节点是否依赖于指定的外部包\n      node.getLocation().getFile() = srcFile // 确保节点位于指定的源文件中\n    ) and\n  // 将源文件和包信息合并为单一实体标识符\n  pkgEntity = munge(srcFile, extPkg)\n// 输出结果：实体标识符和依赖计数，按依赖数量降序排列\nselect pkgEntity, depCount order by depCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Invalid format specifier\n * @description Identifies format strings that use unsupported or invalid conversion specifiers\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/percent-format/unsupported-character\n */\n\n// Import fundamental Python analysis features\nimport python\n// Import string manipulation utilities for validating format strings\nimport semmle.python.strings\n\n// This query detects Python format string expressions that contain invalid conversion specifiers.\n// It pinpoints the exact location of the invalid specifier within the string.\nfrom Expr formatExpression, int badSpecifierPosition\nwhere \n    // Locate invalid conversion specifiers in format strings\n    // Returns the index position of the first invalid specifier encountered\n    badSpecifierPosition = illegal_conversion_specifier(formatExpression)\nselect \n_______________ // 补全条件\n    formatExpression, \n    \"Invalid conversion specifier at index \" + badSpecifierPosition + \" of \" + repr(formatExpression) + \".\"",
    "output": "// Report the problematic expression with detailed error context"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Detects asymmetric encryption padding mechanisms that are either cryptographically \n * insecure or not explicitly recognized by established security standards. This analysis \n * flags padding implementations that deviate from industry best practices, \n * specifically excluding well-vetted secure methods like OAEP (Optimal Asymmetric \n * Encryption Padding), KEM (Key Encapsulation Mechanism), and PSS (Probabilistic \n * Signature Scheme).\n * \n * Padding schemes outside the approved list are flagged as potential security\n * vulnerabilities, which could lead to cryptographic weaknesses including chosen ciphertext\n * attacks, padding oracle attacks, or insufficient randomness in encryption operations.\n * \n * @id py/weak-asymmetric-padding\n * @kind problem\n_______________ // 补全条件\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define cryptographically secure and approved padding schemes\nstring getSecurePaddingMethods() {\n  result = [\"OAEP\", \"KEM\", \"PSS\"]\n}\n\n// Identify padding implementations using unapproved schemes\nfrom AsymmetricPadding paddingImpl, string schemeName\nwhere \n  schemeName = paddingImpl.getPaddingName()\n  and not exists(string secureMethod | \n    secureMethod = getSecurePaddingMethods() \n    and secureMethod = schemeName\n  )\nselect paddingImpl, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + schemeName",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of exit() or quit()\n * @description Detects usage of exit() or quit() functions which might fail when the Python interpreter is run with the -S option.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity low\n_______________ // 补全条件\n * @id py/use-of-exit-or-quit\n */\n\nimport python  // Import Python library for analyzing Python code\n\nfrom CallNode callNode, string functionName  // Obtain function call nodes and their corresponding names\nwhere \n  // Identify calls to functions that point to siteQuitter objects\n  callNode.getFunction().pointsTo(Value::siteQuitter(functionName))\nselect callNode,  // Output the matching function call nodes\n  \"Potential issue: '\" + functionName +\n    \"' is a site.Quitter object that may not exist if the 'site' module is not loaded or has been modified.\"  // Warning about site.Quitter object availability",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Descriptor mutation in accessor methods\n * @description Identifies mutations of descriptor objects within __get__, __set__, or __delete__ methods. \n *              Such mutations can cause unexpected side effects since descriptors are shared across instances.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n/* This predicate identifies descriptor mutations by examining method calls and attribute modifications\n   within descriptor accessor methods. It checks if a class implements the descriptor protocol and\n   detects any mutations that occur within methods called by the descriptor accessors. */\npredicate mutates_descriptor(ClassObject descriptorClass, SelfAttributeStore attributeModification) {\n  // Ensure the class implements the descriptor protocol\n  descriptorClass.isDescriptorType() and\n  \n  // Find descriptor accessor methods (__get__, __set__, or __delete__)\n  exists(PyFunctionObject accessorFunc, string accessorName |\n    // Standard descriptor method names\n    (accessorName = \"__get__\" or \n     accessorName = \"__set__\" or \n     accessorName = \"__delete__\") and\n    // Verify the class has this accessor method\n    descriptorClass.lookupAttribute(accessorName) = accessorFunc and\n    \n    // Identify methods that mutate the descriptor and are called by accessors\n    exists(PyFunctionObject mutationFunc |\n      // Confirm the mutation method belongs to the descriptor class\n      descriptorClass.lookupAttribute(_) = mutationFunc and\n      // Check if the accessor method calls the mutation method\n      accessorFunc.getACallee*() = mutationFunc and\n_______________ // 补全条件\n      not mutationFunc.getName() = \"__init__\" and\n      // Ensure the attribute modification occurs within the mutation method\n      attributeModification.getScope() = mutationFunc.getFunction()\n    )\n  )\n}\n\n// Main query to find descriptor mutations\nfrom ClassObject descriptorClass, SelfAttributeStore attributeModification\nwhere mutates_descriptor(descriptorClass, attributeModification)\nselect attributeModification,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorClass, descriptorClass.getName()",
    "output": "// Exclude initialization methods from consideration"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name 已提取的Python源文件\n * @description 本查询用于检测并展示代码库中所有成功提取的Python源文件。\n *              通过验证文件是否具备有效的相对路径，可以确认该文件是否已从源代码树中正确提取。\n *              这对于确保代码库的完整性以及验证所有Python模块是否被正确处理至关重要。\n * @kind diagnostic\n * @id py/diagnostics/successfully-extracted-files\n * @tags successfully-extracted-files\n */\n\nimport python\n\n// 定义查询范围：遍历所有Python源文件\nfrom File extractedPyFile\nwhere \n    // 筛选条件：文件必须拥有有效的相对路径\n    // 有效相对路径的存在表明文件已成功从源代码树中提取\n    exists(extractedPyFile.getRelativePath())\n// 输出结果：文件对象和空字符串（维持格式一致性）\nselect extractedPyFile, \"\"",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/sql-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Building SQL statements with user-controlled data allows attackers",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name SQL query constructed from user-controlled input\n * @description Building SQL statements with user-controlled data allows attackers\n *              to execute arbitrary SQL commands, leading to SQL injection flaws.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 8.8\n * @precision high\n * @id py/sql-injection\n * @tags security\n *       external/cwe/cwe-089\n */\n\n// 导入Python语言分析的核心组件\nimport python\n\n// 导入SQL注入漏洞的数据流分析模块\nimport semmle.python.security.dataflow.SqlInjectionQuery\n\n// 导入用于路径可视化的图形表示工具\nimport SqlInjectionFlow::PathGraph\n\n// 定义数据流追踪：识别从用户输入到SQL查询构建的完整数据流路径\nfrom \n  SqlInjectionFlow::PathNode taintedSource,       // 表示用户控制的输入源节点\n  SqlInjectionFlow::PathNode vulnerableSink        // 表示存在SQL注入风险的接收点节点\nwhere \n  // 确认存在从用户输入到SQL查询的数据流\n  SqlInjectionFlow::flowPath(taintedSource, vulnerableSink)\nselect \n  vulnerableSink.getNode(),        // 定位SQL注入漏洞的具体代码位置\n  taintedSource,                   // 标识污染数据的来源节点\n  vulnerableSink,                  // 标识数据流的终点（即漏洞点）\n  \"此SQL查询依赖于$@。\",           // 漏洞描述消息模板\n  taintedSource.getNode(),         // 用于消息占位符替换的源节点\n  \"用户提供的输入\"                // 污染源的类别标签"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Elliptic Curve Algorithms Detection\n * @description Identifies and documents the implementation of elliptic curve cryptography \n *              algorithms across multiple cryptographic libraries in Python projects\n * @kind problem\n * @id py/quantum-readiness/cbom/elliptic-curve-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import essential Python language modules for code analysis\nimport python\n// Import experimental cryptographic framework containing algorithm definitions\nimport experimental.cryptography.Concepts\n\n// Primary query logic for locating elliptic curve cryptographic algorithms\nfrom EllipticCurveAlgorithm curveCrypto\n// Generate formatted output containing algorithm specifics\nselect curveCrypto,\n  // Build comprehensive algorithm description string\n_______________ // 补全条件\n  // Include key size details in the result\n  \" | Key Size (bits): \" + curveCrypto.getCurveBitSize().toString()",
    "output": "\"Algorithm: \" + curveCrypto.getCurveName() +"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-use-with]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects 'try-finally' blocks that only close a resource, which could be simplified",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Should use a 'with' statement\n * @description Detects 'try-finally' blocks that only close a resource, which could be simplified\n *              using Python's 'with' statement for better readability and maintainability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/should-use-with\n */\n\nimport python\n\n// 判断调用是否为close方法\npredicate is_close_method_call(Call methodCall) { \n    exists(Attribute attr | methodCall.getFunc() = attr and attr.getName() = \"close\") \n}\n\n// 判断在finally块中是否只有一条语句且该语句是close方法的调用\npredicate is_sole_close_in_finally(Try tryBlock, Call methodCall) {\n    exists(ExprStmt statement |\n        tryBlock.getAFinalstmt() = statement and \n        statement.getValue() = methodCall and \n        strictcount(tryBlock.getAFinalstmt()) = 1\n    )\n}\n\n// 检查控制流节点是否指向上下文管理器类的实例\npredicate refers_to_context_manager(ControlFlowNode flowNode, ClassValue contextManagerClass) {\n    forex(Value pointedValue | flowNode.pointsTo(pointedValue) | pointedValue.getClass() = contextManagerClass) and\n    contextManagerClass.isContextManager()\n}\n\n// 查找所有在finally块中仅包含close方法调用的代码，并建议使用'with'语句\nfrom Call closeCall, Try tryBlock, ClassValue contextManagerClass\nwhere\n    is_sole_close_in_finally(tryBlock, closeCall) and\n    is_close_method_call(closeCall) and\n    exists(ControlFlowNode flowNode | \n        flowNode = closeCall.getFunc().getAFlowNode().(AttrNode).getObject() and\n        refers_to_context_manager(flowNode, contextManagerClass)\n    )\nselect closeCall,\n    \"Instance of context-manager class $@ is closed in a finally block. Consider using 'with' statement.\",\n    contextManagerClass, contextManagerClass.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Detects asymmetric encryption padding mechanisms that are either\n * cryptographically weak or not explicitly confirmed as secure.\n * \n * Asymmetric encryption necessitates appropriate padding for security. This query\n * identifies padding schemes that are recognized as insecure or are not established\n * as secure padding techniques. The analysis specifically excludes approved\n * padding methods (OAEP, KEM, PSS) which are regarded as cryptographically\n * secure, and marks all other padding schemes as possible security threats.\n * \n * Employing weak or unidentified padding schemes can result in vulnerabilities\n_______________ // 补全条件\n * without possessing the private key.\n * \n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define the set of secure padding algorithms considered safe\nstring getSecurePaddingMethods() {\n  result = [\"OAEP\", \"KEM\", \"PSS\"]\n}\n\n// Identify asymmetric padding implementations using non-secure algorithms\nfrom AsymmetricPadding paddingImpl\nwhere\n  // Extract the padding algorithm name from the implementation\n  exists(string paddingMethod |\n    paddingMethod = paddingImpl.getPaddingName()\n    // Verify that the padding algorithm is not among the secure schemes\n    and not paddingMethod = getSecurePaddingMethods()\n  )\nselect paddingImpl, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + paddingImpl.getPaddingName()",
    "output": "* such as padding oracle attacks, enabling attackers to decrypt encrypted data"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-shadowed-loop-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies when a loop variable uses the same name as an imported module alias,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Import shadowed by loop variable\n * @description Identifies when a loop variable uses the same name as an imported module alias,\n *              which can lead to confusion by hiding the imported identifier.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/import-shadowed-loop-variable\n */\n\nimport python\n\nfrom Variable iterationVar, Name varNameNode\nwhere \n  // Ensure the variable is defined as a loop iteration target\n  exists(For forLoopStmt | varNameNode = forLoopStmt.getTarget()) and\n  varNameNode.defines(iterationVar) and\n  // Check for conflicting import alias within the same scope hierarchy\n  exists(Import moduleImport, Name importAlias |\n    // The alias must come from an import statement's 'as' clause\n    importAlias = moduleImport.getAName().getAsname() and\n    // The alias identifier must match the loop variable's identifier\n    importAlias.getId() = iterationVar.getId() and\n    // The import must be accessible within the loop variable's scope\n    moduleImport.getScope() = iterationVar.getScope().getScope*()\n  )\nselect varNameNode, \"Loop variable '\" + iterationVar.getId() + \"' shadows an imported module alias.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary delete statement in function\n * @description Identifies redundant 'delete' operations on local variables. \n *              These deletions are superfluous since local variables are automatically\n *              garbage collected when function scope terminates. The analysis excludes\n *              scenarios where deletion might be required, such as within iterative\n *              constructs or when handling sys.exc_info() operations.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/unnecessary-delete\n */\n\nimport python\n\n// Helper predicate to determine if an AST node resides within loop constructs\npredicate isInLoopEnvironment(AstNode node) {\n  // Direct containment within loop structures\n  node.getParentNode() instanceof While\n  or\n  node.getParentNode() instanceof For\n  // Nested containment through parent-child relationships\n  or\n  exists(AstNode parentNode | \n    isInLoopEnvironment(parentNode) and \n    node = parentNode.getAChildNode()\n  )\n}\n\n// Primary query logic to detect superfluous delete operations\nfrom Delete deletionOperation, Expr variableTarget, Function enclosingFunction\nwhere\n  // Positional verification: Deletion occurs as final statement in function\n  enclosingFunction.getLastStatement() = deletionOperation and\n_______________ // 补全条件\n  variableTarget = deletionOperation.getATarget() and\n  // Scope verification: Target variable exists within function's lexical scope\n  enclosingFunction.containsInScope(variableTarget) and\n  // Exclusion criteria: Skip potentially necessary deletion patterns\n  not variableTarget instanceof Subscript and  // e.g., del collection[key]\n  not variableTarget instanceof Attribute and  // e.g., del object.property\n  // Contextual exclusions: Avoid deletions in specific execution contexts\n  not isInLoopEnvironment(deletionOperation) and  // Exclude loop-contained deletions\n  // Special case handling: Exclude functions utilizing sys.exc_info() (requiring explicit cleanup)\n  not exists(FunctionValue exceptionInfoFunction |\n    exceptionInfoFunction = Value::named(\"sys.exc_info\") and\n    exceptionInfoFunction.getACall().getScope() = enclosingFunction\n  )\nselect deletionOperation, \"Redundant removal of local variable $@ within function $@.\", \n  variableTarget, variableTarget.toString(), enclosingFunction, enclosingFunction.getName()",
    "output": "// Target verification: Expression being deleted is identified"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mostly-duplicate-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes where over 80% of methods are duplicated in another class.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Mostly duplicate class\n * @description Identifies classes where over 80% of methods are duplicated in another class.\n *              This analysis helps identify opportunities for creating common supertypes\n *              to improve code sharing and maintainability.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-class\n * @note Current implementation is a placeholder (no actual logic implemented)\n */\n\nimport python\n\n// Define analysis variables for class duplication detection\nfrom \n    Class primaryClass,    // Main class being analyzed for duplication\n    Class duplicateClass,  // Potential duplicate class for comparison\n    string alertMessage    // Diagnostic message describing findings\n\n// Placeholder condition - no filtering logic implemented\nwhere none()\n\n// Generate results in required format:\n// 1. Primary class (primaryClass)\n// 2. Diagnostic message (alertMessage)\n// 3. Duplicate class (duplicateClass)\n// 4. Name of duplicate class (duplicateClass.getName())\nselect \n    primaryClass, \n    alertMessage, \n    duplicateClass, \n    duplicateClass.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python类定义与源文件关联分析\n * @description 识别Python代码中的所有类定义，并建立类与其所在源文件之间的映射关系\n * @kind source-link\n_______________ // 补全条件\n * @metricType reftype\n */\n\nimport python\n\n// 识别Python代码中的类定义，并确定每个类定义所在的源文件\nfrom Class cls, File file\nwhere file = cls.getLocation().getFile()\n// 输出类定义及其对应的源文件信息\nselect cls, file",
    "output": "* @id py/class-source-links"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/duplicate-block]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies potential code duplication by reporting all basic blocks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Duplicate code block\n * @description Identifies potential code duplication by reporting all basic blocks. \n * This is a statistical check that may include false positives since actual \n * duplicate detection requires additional analysis. All blocks are flagged as \n * potential duplicates without filtering.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @deprecated\n * @precision medium\n * @id py/duplicate-block\n */\n\nimport python\n\n// Query purpose: Identify all basic blocks as potential code duplicates\n// Note: This is a broad statistical check without actual duplication analysis\nfrom BasicBlock codeBlock\nwhere \n  // No filtering criteria applied - all basic blocks are selected\n  none()\n// Alert generation: Create standardized message for each identified block\nselect codeBlock, \n       \"Duplicate code: \" + \"-1\" + \" lines are duplicated at \" + \"<file>\" + \":\" + \"-1\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure randomness\n * @description Detects the use of cryptographically weak pseudo-random number generators\n *              for security-sensitive operations, which could allow attackers to predict\n *              generated values and compromise system security.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n_______________ // 补全条件\n// Import Python core library to enable Python code analysis capabilities\nimport python\n\n// Import experimental security module specifically designed for detecting\n// insecure random number generation patterns\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Import data flow analysis framework to enable tracking of data flow paths\nimport semmle.python.dataflow.new.DataFlow\n\n// Import path graph module for representing data flow path graphs\nimport InsecureRandomness::Flow::PathGraph\n\n// Query definition: Identify data flow paths involving insecure random number generation\nfrom \n  InsecureRandomness::Flow::PathNode sourceNode,  // Source node representing the insecure random value generation\n  InsecureRandomness::Flow::PathNode sinkNode      // Sink node representing security-sensitive usage\nwhere \n  // Condition: Verify there exists a data flow path from source to sink\n  InsecureRandomness::Flow::flowPath(sourceNode, sinkNode)\nselect \n  sinkNode.getNode(),                              // Target node where the insecure value is used\n  sourceNode,                                      // Source node where the insecure value originates\n  sinkNode,                                       // Sink node for path visualization\n  \"Cryptographically insecure $@ in a security context.\", // Alert message\n  sourceNode.getNode(),                           // Source node for message reference\n  \"random value\"                                  // Description of the insecure element",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Overly complex `__del__` method\n * @description Identifies Python classes with destructors (`__del__` methods) that exhibit \n *              high cyclomatic complexity. Python's destructor methods are invoked during\n *              object cleanup, which can occur at non-deterministic times or may be skipped\n *              entirely in specific scenarios. Overly complex destructors can cause performance\n *              issues and erratic behavior during garbage collection cycles. Best practices\n *              suggest maintaining minimal complexity in these special methods.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n_______________ // 补全条件\nimport python  // 导入Python分析库，用于代码分析\n\nfrom FunctionValue destructorMethod  // 从FunctionValue类中获取destructorMethod对象\nwhere\n  // 检查是否存在一个拥有该析构方法的类\n  exists(ClassValue containingClass | \n    containingClass.declaredAttribute(\"__del__\") = destructorMethod\n  )\n  and\n  // 验证析构方法的圈复杂度超过阈值3\n  destructorMethod.getScope().getMetrics().getCyclomaticComplexity() > 3\nselect destructorMethod, \"Overly complex '__del__' method.\"  // 选择符合条件的destructorMethod并标记为\"过于复杂的`__del__`方法\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/ldap-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies LDAP injection vulnerabilities where untrusted user input",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name LDAP query constructed from untrusted input\n * @description Identifies LDAP injection vulnerabilities where untrusted user input\n *              is directly incorporated into LDAP queries without sanitization,\n *              potentially enabling unauthorized LDAP operations.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.8\n * @precision high\n * @id py/ldap-injection\n * @tags security\n *       external/cwe/cwe-090\n */\n\n// Core security modules for analyzing LDAP injection vulnerabilities\nimport python\nimport semmle.python.security.dataflow.LdapInjectionQuery\nimport LdapInjectionFlow::PathGraph\n\nfrom LdapInjectionFlow::PathNode taintedSource, LdapInjectionFlow::PathNode vulnerableSink, string paramType\nwhere\n  // Verify data flow to DN parameter\n  (LdapInjectionDnFlow::flowPath(taintedSource.asPathNode1(), vulnerableSink.asPathNode1()) and \n   paramType = \"DN\")\n  or\n  // Verify data flow to filter parameter\n  (LdapInjectionFilterFlow::flowPath(taintedSource.asPathNode2(), vulnerableSink.asPathNode2()) and \n   paramType = \"filter\")\nselect vulnerableSink.getNode(), taintedSource, vulnerableSink,\n  \"LDAP query parameter (\" + paramType + \") incorporates a $@.\", taintedSource.getNode(),\n  \"user-controlled input\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Assert statement tests the truth value of a literal constant\n * @description Detects assert statements that evaluate literal constants, \n *              which may behave differently under compiler optimizations.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/assert-literal-constant\n */\n\nimport python\nimport semmle.python.filters.Tests\n\n// Identify assert statements with literal constant test expressions\nfrom Assert assertStmt, string constantValue\nwhere\n  /* Exclude assertions within test execution contexts */\n  not assertStmt.getScope().getScope*() instanceof TestScope and\n  /* Extract constant values from different literal types */\n  exists(Expr testExpression | testExpression = assertStmt.getTest() |\n    /* Handle integer literal constants */\n    constantValue = testExpression.(IntegerLiteral).getN()\n    or\n    /* Handle string literal constants with quoted representation */\n    constantValue = \"\\\"\" + testExpression.(StringLiteral).getS() + \"\\\"\"\n    or\n    /* Handle named constants (True/False/None) */\n_______________ // 补全条件\n  ) and\n  /* Exclude assertions at the end of elif statement chains */\n  not exists(If ifStatement | ifStatement.getElif().getAnOrelse() = assertStmt)\nselect assertStmt, \"Assert of literal constant \" + constantValue + \".\"",
    "output": "constantValue = testExpression.(NameConstant).toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/iter-returns-non-iterator]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects classes that are returned by `__iter__` methods but do not properly",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__iter__` method returns a non-iterator\n * @description Detects classes that are returned by `__iter__` methods but do not properly \n *              implement the iterator protocol. These classes will cause a 'TypeError' \n *              when used in iteration contexts such as 'for' loops.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iter-returns-non-iterator\n */\n\nimport python\n\nfrom ClassValue iterableClass, FunctionValue iterMethod, ClassValue returnedType\nwhere\n  // Find classes that implement the __iter__ method\n  iterMethod = iterableClass.lookup(\"__iter__\")\n  and\n  // Extract the return type from the __iter__ method\n  returnedType = iterMethod.getAnInferredReturnType()\n  and\n  // Check if the returned type fails to implement the iterator interface\n  not returnedType.isIterator()\nselect returnedType,\n  \"Class \" + returnedType.getName() + \n    \" is returned as an iterator (by $@) but does not fully implement the iterator interface.\",\n  iterMethod, iterMethod.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Modification of Parameter with Default Value\n * @description Detects code paths where parameters with default values are modified.\n *              Modifying default values can lead to unexpected behavior since they are\n *              instantiated only once when the function is defined.\n * @kind path-problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n_______________ // 补全条件\n * @id py/modification-of-default-value\n */\n\nimport python\nimport semmle.python.functions.ModificationOfParameterWithDefault\nimport ModificationOfParameterWithDefault::Flow::PathGraph\n\nfrom\n  ModificationOfParameterWithDefault::Flow::PathNode defValSourceNode,\n  ModificationOfParameterWithDefault::Flow::PathNode mutationTargetNode\nwhere\n  ModificationOfParameterWithDefault::Flow::flowPath(defValSourceNode, mutationTargetNode)\nselect\n  mutationTargetNode.getNode(), \n  defValSourceNode, \n  mutationTargetNode, \n  \"This expression mutates a $@.\", \n  defValSourceNode.getNode(),\n  \"default value\"",
    "output": "* @precision high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Conflicting attributes in base classes\n * @description Detects classes inheriting from multiple base classes where identical attributes are defined in more than one base. This ambiguity can cause unexpected behavior during attribute resolution.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n// Determines if a Python function contains only trivial implementation elements\npredicate is_empty_implementation(PyFunctionObject functionObj) {\n  // Checks if function body consists solely of pass statements or docstrings\n  not exists(Stmt stmt | stmt.getScope() = functionObj.getFunction() |\n    not stmt instanceof Pass and \n    not stmt.(ExprStmt).getValue() = functionObj.getFunction().getDocString()\n  )\n}\n\n// Checks if a method properly utilizes super() for method resolution order\npredicate invokes_super(FunctionObject functionObj) {\n  // Detects super() calls targeting the current method name\n  exists(Call superCallExpr, Call methodCallExpr, Attribute attrRef, GlobalVariable superVar |\n    methodCallExpr.getScope() = functionObj.getFunction() and\n    methodCallExpr.getFunc() = attrRef and\n    attrRef.getObject() = superCallExpr and\n    attrRef.getName() = functionObj.getName() and\n    superCallExpr.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/** Defines attributes excluded from conflict analysis */\npredicate is_exempt_attribute(string attributeName) {\n  /*\n   * Exemption for process_request per Python socketserver documentation:\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   */\n  attributeName = \"process_request\"\n}\n\n_______________ // 补全条件\n  ClassObject derivedClass, \n  ClassObject baseClass1, \n  ClassObject baseClass2, \n  string attributeName, \n  int baseIndex1, \n  int baseIndex2, \n  Object attrInBase1, \n  Object attrInBase2\nwhere\n  // Establish inheritance relationships with distinct base classes\n  derivedClass.getBaseType(baseIndex1) = baseClass1 and\n  derivedClass.getBaseType(baseIndex2) = baseClass2 and\n  // Ensure base classes are ordered by inheritance position\n  baseIndex1 < baseIndex2 and\n  // Locate identical attributes in different base classes\n  attrInBase1 = baseClass1.lookupAttribute(attributeName) and\n  attrInBase2 = baseClass2.lookupAttribute(attributeName) and\n  // Verify attributes are distinct objects\n  attrInBase1 != attrInBase2 and\n  // Exclude special double-underscore methods\n  not attributeName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  // Exclude known exempt attributes\n  not is_exempt_attribute(attributeName) and\n  // Confirm derived class doesn't explicitly declare attribute\n  not derivedClass.declaresAttribute(attributeName) and\n  // Skip conflicts where first base handles method resolution\n  not invokes_super(attrInBase1) and\n  // Ignore trivial implementations in second base\n  not is_empty_implementation(attrInBase2) and\n  // Ensure no override relationship between attributes\n  not attrInBase1.overrides(attrInBase2) and\n  not attrInBase2.overrides(attrInBase1)\nselect derivedClass, \n  \"Base classes have conflicting values for attribute '\" + attributeName + \"': $@ and $@.\", \n  attrInBase1, attrInBase1.toString(), \n  attrInBase2, attrInBase2.toString()",
    "output": "from"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unused argument in a formatting call\n * @description Including surplus arguments in a formatting call makes code more difficult to read and may indicate an error.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/str-format/surplus-argument\n */\n\nimport python\nimport AdvancedFormatting\n\n// 计算格式化字符串中的字段数量\nint field_count(AdvancedFormatString fmt) { \n    result = max(fmt.getFieldNumber(_, _)) + 1 \n}\n\n// 从高级格式化调用中选择出多余的参数\nfrom AdvancedFormattingCall call, AdvancedFormatString fmt, int arg_count, int max_field\nwhere\n    arg_count = call.providedArgCount() and // 获取提供的参数数量\n    max_field = field_count(fmt) and // 计算格式化字符串中的字段数量\n_______________ // 补全条件\n    not exists(call.getStarargs()) and // 确保没有使用星号参数（*args）\n    forall(AdvancedFormatString other | other = call.getAFormat() | field_count(other) < arg_count) // 确保所有其他格式字符串的字段数量小于提供的参数数量\nselect call,\n    \"Too many arguments for string format. Format $@ requires only \" + max_field + \", but \" +\n    arg_count.toString() + \" are provided.\", fmt, \"\\\"\" + fmt.getText() + \"\\\"\" // 生成警告信息，指出多余的参数",
    "output": "call.getAFormat() = fmt and // 确保调用的格式与给定的格式匹配"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unnecessary-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using a 'delete' statement to delete a local variable is",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unnecessary delete statement in function\n * @description Using a 'delete' statement to delete a local variable is\n *              unnecessary, because the variable is deleted automatically when\n *              the function exits.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/unnecessary-delete\n */\n\nimport python\n\n/**\n * Determines if a given AST node is located within a loop structure.\n * Loop structures include 'while' and 'for' loops.\n */\npredicate locatedInLoop(AstNode node) {\n  // Direct parent is a loop type\n  node.getParentNode() instanceof While\n  or\n  node.getParentNode() instanceof For\n  or\n  // Recursive check: if there exists a parent node in a loop, and the current node is its child\n  exists(AstNode loopAncestor | \n    locatedInLoop(loopAncestor) and \n    node = loopAncestor.getAChildNode()\n  )\n}\n\n// Identify unnecessary deletion statements\nfrom Delete deletionStatement, Expr deletedExpression, Function enclosingFunction\nwhere\n  // The deletion statement is the final statement in the function\n  enclosingFunction.getLastStatement() = deletionStatement and\n  // The deletion statement targets a local variable within the function's scope\n  deletedExpression = deletionStatement.getATarget() and\n  enclosingFunction.containsInScope(deletedExpression) and\n  // Exclude deletion of compound expressions (e.g., del a[0], del a.b)\n  not (deletedExpression instanceof Subscript or deletedExpression instanceof Attribute) and\n  // Exclude deletion statements within loops\n  not locatedInLoop(deletionStatement) and\n  // Exclude functions that call sys.exc_info, which require explicit deletion to break reference cycles\n  not exists(FunctionValue excInfoFunction |\n    excInfoFunction = Value::named(\"sys.exc_info\") and\n    excInfoFunction.getACall().getScope() = enclosingFunction\n  )\nselect deletionStatement, \"Unnecessary deletion of local variable $@ in function $@.\", deletedExpression, deletedExpression.toString(), enclosingFunction,\n  enclosingFunction.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Import of deprecated module\n * @description Detects Python imports of modules deprecated in specific versions\n * @kind problem\n * @tags maintainability\n *       external/cwe/cwe-477\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/import-deprecated-module\n */\n\nimport python\n\n/**\n * Identifies modules deprecated in specific Python versions\n * with recommended replacement information\n_______________ // 补全条件\n * @param deprecatedModName The deprecated module name\n * @param suggestedReplacement Recommended replacement or \"no replacement\"\n * @param majorVersion Major version where module was deprecated\n * @param minorVersion Minor version where module was deprecated\n * @return True if module was deprecated in specified version\n */\npredicate module_deprecation_info(string deprecatedModName, string suggestedReplacement, int majorVersion, int minorVersion) {\n  // Python 1.x deprecated modules\n  (\n    deprecatedModName = \"posixfile\" and suggestedReplacement = \"fcntl\" and majorVersion = 1 and minorVersion = 5\n    or\n    deprecatedModName = \"pre\" and suggestedReplacement = \"re\" and majorVersion = 1 and minorVersion = 5\n  )\n  or\n  // Python 2.0-2.2 deprecated modules\n  (\n    deprecatedModName = \"whrandom\" and suggestedReplacement = \"random\" and majorVersion = 2 and minorVersion = 1\n    or\n    deprecatedModName = \"statcache\" and suggestedReplacement = \"no replacement\" and majorVersion = 2 and minorVersion = 2\n    or\n    deprecatedModName = \"mpz\" and suggestedReplacement = \"a third party\" and majorVersion = 2 and minorVersion = 2\n  )\n  or\n  // Python 2.3-2.4 deprecated modules\n  (\n    deprecatedModName = \"rfc822\" and suggestedReplacement = \"email\" and majorVersion = 2 and minorVersion = 3\n    or\n    deprecatedModName = \"mimetools\" and suggestedReplacement = \"email\" and majorVersion = 2 and minorVersion = 3\n    or\n    deprecatedModName = \"MimeWriter\" and suggestedReplacement = \"email\" and majorVersion = 2 and minorVersion = 3\n    or\n    deprecatedModName = \"mimify\" and suggestedReplacement = \"email\" and majorVersion = 2 and minorVersion = 3\n    or\n    deprecatedModName = \"xreadlines\" and suggestedReplacement = \"no replacement\" and majorVersion = 2 and minorVersion = 3\n    or\n    deprecatedModName = \"rotor\" and suggestedReplacement = \"no replacement\" and majorVersion = 2 and minorVersion = 4\n  )\n  or\n  // Python 2.5-2.6 deprecated modules\n  (\n    deprecatedModName = \"gopherlib\" and suggestedReplacement = \"no replacement\" and majorVersion = 2 and minorVersion = 5\n    or\n    deprecatedModName = \"rgbimgmodule\" and suggestedReplacement = \"no replacement\" and majorVersion = 2 and minorVersion = 5\n    or\n    deprecatedModName = \"multifile\" and suggestedReplacement = \"email\" and majorVersion = 2 and minorVersion = 5\n    or\n    deprecatedModName = \"sets\" and suggestedReplacement = \"builtins\" and majorVersion = 2 and minorVersion = 6\n  )\n  or\n  // Additional deprecated modules\n  (\n    deprecatedModName = \"buildtools\" and suggestedReplacement = \"no replacement\" and majorVersion = 2 and minorVersion = 3\n    or\n    deprecatedModName = \"cfmfile\" and suggestedReplacement = \"no replacement\" and majorVersion = 2 and minorVersion = 4\n    or\n    deprecatedModName = \"macfs\" and suggestedReplacement = \"no replacement\" and majorVersion = 2 and minorVersion = 3\n    or\n    deprecatedModName = \"md5\" and suggestedReplacement = \"hashlib\" and majorVersion = 2 and minorVersion = 5\n    or\n    deprecatedModName = \"sha\" and suggestedReplacement = \"hashlib\" and majorVersion = 2 and minorVersion = 5\n  )\n}\n\n/**\n * Generates deprecation warning message for a module\n *\n * @param deprecatedModName The deprecated module name\n * @return Formatted deprecation warning string\n */\nstring deprecation_message(string deprecatedModName) {\n  exists(int majorVersion, int minorVersion | \n    module_deprecation_info(deprecatedModName, _, majorVersion, minorVersion)\n  |\n    result = \"Module '\" + deprecatedModName + \"' was deprecated in Python \" + \n             majorVersion.toString() + \".\" + minorVersion.toString()\n  )\n}\n\n/**\n * Generates replacement suggestion for deprecated module\n *\n * @param deprecatedModName The deprecated module name\n * @return Replacement suggestion or empty string\n */\nstring replacement_message(string deprecatedModName) {\n  exists(string suggestedReplacement | \n    module_deprecation_info(deprecatedModName, suggestedReplacement, _, _)\n  |\n    (result = \" Consider using '\" + suggestedReplacement + \"' instead.\" and \n     not suggestedReplacement = \"no replacement\")\n    or\n    (result = \"\" and suggestedReplacement = \"no replacement\")\n  )\n}\n\n/**\n * Checks if import statement has ImportError exception handling\n *\n * @param importExpression The import statement to verify\n * @return True if ImportError exception handling exists\n */\npredicate has_import_error_handling(ImportExpr importExpression) {\n  exists(Try tryBlock, ExceptStmt exceptHandler | \n    exceptHandler = tryBlock.getAHandler() and\n    exceptHandler.getType().pointsTo(ClassValue::importError()) and\n    exceptHandler.containsInScope(importExpression)\n  )\n}\n\n// Main query to identify deprecated module imports\nfrom ImportExpr importExpression, string deprecatedModName, string suggestedReplacement\nwhere\n  deprecatedModName = importExpression.getName() and\n  module_deprecation_info(deprecatedModName, suggestedReplacement, _, _) and\n  not has_import_error_handling(importExpression)\nselect importExpression, deprecation_message(deprecatedModName) + replacement_message(deprecatedModName)",
    "output": "*"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-of-mutable-attribute]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Direct import of mutable attribute values prevents observing global state changes locally.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Importing value of mutable attribute\n * @description Direct import of mutable attribute values prevents observing global state changes locally.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity high\n * @precision medium\n * @id py/import-of-mutable-attribute\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom ImportMember importedMember, ModuleValue originalModule, AttrNode attributeModification, string attributeName\nwhere\n  // Verify module name consistency between import and source\n  originalModule.importedAs(importedMember.getModule().(ImportExpr).getImportedModuleName()) and\n  // Ensure imported member name matches attribute name\n  importedMember.getName() = attributeName and\n  // Confirm attribute is a store operation\n  attributeModification.isStore() and\n  // Attribute modification must occur within function scope\n  exists(Function func | attributeModification.getScope() = func) and\n  // Imported variable must have module-level scope (non-function)\n  not exists(Function func | importedMember.getScope() = func) and\n  // Verify attribute references the imported module\n  attributeModification.getObject(attributeName).pointsTo(originalModule) and\n  // Ensure import and modification occur in different modules\n  importedMember.getEnclosingModule() != attributeModification.getScope().getEnclosingModule() and\n  // Exclude modifications within test code\n  not exists(TestScope test | attributeModification.getScope().getScope*() = test)\nselect importedMember,\n  \"Importing the value of '\" + attributeName +\n    \"' from $@ means that any change made to $@ will be not be observed locally.\", originalModule,\n  \"module \" + originalModule.getName(), attributeModification, originalModule.getName() + \".\" + attributeName"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Pythagorean calculation with sub-optimal numerics\n * @description Detects hypotenuse calculations using standard formula that may cause numerical overflow\n * @kind problem\n * @tags accuracy\n * @problem.severity warning\n * @sub-severity low\n * @precision medium\n * @id py/pythagorean\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Identifies expressions that compute the square of a value\n// This includes both exponentiation with power 2 (e.g., x**2)\n// and self-multiplication (e.g., x*x)\nDataFlow::ExprNode squaredValueNode() {\n  exists(BinaryExpr binaryExpr | binaryExpr = result.asExpr() |\n    // Case 1: Exponentiation with power of 2\n    (binaryExpr.getOp() instanceof Pow and binaryExpr.getRight().(IntegerLiteral).getN() = \"2\")\n    or\n    // Case 2: Self-multiplication\n    (binaryExpr.getOp() instanceof Mult and \n     binaryExpr.getRight().(Name).getId() = binaryExpr.getLeft().(Name).getId())\n  )\n}\n\n_______________ // 补全条件\nfrom \n  DataFlow::CallCfgNode sqrtFunctionCall,   // math.sqrt() invocation site\n  BinaryExpr sumOfSquaresExpr,             // Addition expression inside sqrt\n  DataFlow::ExprNode firstSquareTerm,       // Left operand of addition\n  DataFlow::ExprNode secondSquareTerm       // Right operand of addition\nwhere\n  // Verify math.sqrt() call with addition argument\n  sqrtFunctionCall = API::moduleImport(\"math\").getMember(\"sqrt\").getACall() and\n  sqrtFunctionCall.getArg(0).asExpr() = sumOfSquaresExpr and\n  \n  // Confirm addition operation between two square terms\n  sumOfSquaresExpr.getOp() instanceof Add and\n  firstSquareTerm.asExpr() = sumOfSquaresExpr.getLeft() and\n  secondSquareTerm.asExpr() = sumOfSquaresExpr.getRight() and\n  \n  // Both operands originate from square operations\n  firstSquareTerm.getALocalSource() = squaredValueNode() and\n  secondSquareTerm.getALocalSource() = squaredValueNode()\nselect sqrtFunctionCall, \"Pythagorean calculation with sub-optimal numerics.\"",
    "output": "// Main detection logic for problematic hypotenuse calculations"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unreachable-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers that can never execute due to earlier broader handlers",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unreachable 'except' block\n * @description Identifies exception handlers that can never execute due to earlier broader handlers\n *              in the same try-except block that intercept all exceptions first.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Retrieves the exception class handled by an except clause\nClassValue getHandledExceptionType(ExceptStmt handler) { \n  handler.getType().pointsTo(result) \n}\n\n// Determines if an except handler is unreachable due to handler precedence\npredicate hasUnreachableHandler(ExceptStmt earlierHandler, ClassValue broaderException, \n                              ExceptStmt laterHandler, ClassValue narrowerException) {\n  exists(int earlierIndex, int laterIndex, Try tryBlock |\n    // Both handlers belong to the same try statement\n    earlierHandler = tryBlock.getHandler(earlierIndex) and\n    laterHandler = tryBlock.getHandler(laterIndex) and\n    // Earlier handler appears before later handler in source code\n    earlierIndex < laterIndex and\n    // Retrieve exception types for both handlers\n    broaderException = getHandledExceptionType(earlierHandler) and\n    narrowerException = getHandledExceptionType(laterHandler) and\n    // Earlier handler catches a superclass of later handler's exception\n    broaderException = narrowerException.getASuperType()\n  )\n}\n\n// Locates all unreachable exception handlers\nfrom ExceptStmt earlierHandler, ClassValue broaderException, \n     ExceptStmt laterHandler, ClassValue narrowerException\nwhere hasUnreachableHandler(earlierHandler, broaderException, laterHandler, narrowerException)\nselect laterHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  narrowerException, narrowerException.getName(), earlierHandler, \"except block\", broaderException, broaderException.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/pam-auth-bypass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测PAM认证实现中的安全缺陷：当系统调用`pam_authenticate`完成身份验证后，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name PAM授权绕过漏洞\n * @description 检测PAM认证实现中的安全缺陷：当系统调用`pam_authenticate`完成身份验证后，\n *              未能正确调用`pam_acct_mgmt`函数验证账户有效性，可能导致未授权访问。\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 8.1\n * @precision high\n * @id py/pam-auth-bypass\n * @tags security\n *       external/cwe/cwe-285\n */\n\nimport python\nimport PamAuthorizationFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.security.dataflow.PamAuthorizationQuery\n\n// 检测PAM认证流程中的潜在授权绕过路径\nfrom PamAuthorizationFlow::PathNode authStartNode, PamAuthorizationFlow::PathNode authEndNode\n// 确认存在从认证起点到终点的完整数据流，表明缺少账户验证步骤\nwhere PamAuthorizationFlow::flowPath(authStartNode, authEndNode)\n// 输出检测结果，标识存在授权绕过风险的代码位置及路径\nselect authEndNode.getNode(), authStartNode, authEndNode,\n  \"检测到PAM认证流程存在$@，但缺少后续的'pam_acct_mgmt'账户有效性验证调用。\",\n  authStartNode.getNode(), \"用户认证凭据\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/doc-string-ratio-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the percentage of docstring lines relative to total lines in Python source files.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Documentation coverage ratio\n * @description Calculates the percentage of docstring lines relative to total lines in Python source files.\n *              Higher values indicate better documentation coverage. Empty files are excluded from analysis.\n * @kind treemap\n * @id py/doc-string-ratio-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\n// Analyze Python modules with their metrics, excluding empty files\nfrom Module sourceModule, ModuleMetrics moduleMetrics\nwhere \n  moduleMetrics = sourceModule.getMetrics() and \n  moduleMetrics.getNumberOfLines() > 0\nselect \n  sourceModule,\n  // Compute documentation coverage: (docstring lines / total lines) * 100\n  (100.0 * \n    (moduleMetrics.getNumberOfLinesOfDocStrings().(float) / \n     moduleMetrics.getNumberOfLines().(float))) as documentationPercentage\norder by \n  documentationPercentage desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/local-shadows-builtin]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects local variables that override built-in objects, rendering them",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Local variable shadows built-in object\n * @description Detects local variables that override built-in objects, rendering them \n *              inaccessible within the current scope and reducing code clarity.\n * @kind problem\n * @tags maintainability\n *       readability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/local-shadows-builtin\n */\n\nimport python\nimport semmle.python.types.Builtins\n\n// Predicate that defines variable names allowed to shadow built-ins without introducing ambiguity\npredicate isAllowedShadowing(string variableName) {\n  variableName in [\n      // Infrequently used built-ins with minimal risk of confusion\n      \"iter\", \"next\", \"input\", \"file\", \"apply\", \"slice\", \"buffer\", \"coerce\", \"intern\", \"exit\",\n      \"quit\", \"license\",\n      // Commonly used short names or identifiers that are difficult to avoid\n      \"dir\", \"id\", \"max\", \"min\", \"sum\", \"cmp\", \"chr\", \"ord\", \"bytes\", \"_\",\n    ]\n}\n\n// Predicate that identifies local variables that shadow built-in objects\npredicate variableShadowsBuiltin(Name nodeName, string variableName, Function scopeContainer, int lineNumber) {\n  exists(LocalVariable localVar |\n    nodeName.defines(localVar) and // Confirm the name node defines a local variable\n    localVar.getId() = variableName and // Ensure variable identifier matches\n    exists(Builtin::builtin(localVar.getId())) // Verify collision with a built-in\n  ) and\n  nodeName.getScope() = scopeContainer and // Capture the enclosing function scope\n  nodeName.getLocation().getStartLine() = lineNumber and // Retrieve the source line number\n  not isAllowedShadowing(variableName) // Filter out permitted shadowing instances\n}\n\n// Predicate that identifies the first occurrence of built-in shadowing within a specific scope\npredicate isFirstOccurrenceInScope(Name nodeName, string variableName) {\n  exists(Scope variableScope, int earliestLine |\n    variableShadowsBuiltin(nodeName, variableName, variableScope, earliestLine) and\n    earliestLine = min(int line | variableShadowsBuiltin(_, variableName, variableScope, line))\n  )\n}\n\n// Main query: Identify initial local variables that shadow built-in objects\nfrom Name nodeName, string variableName\nwhere isFirstOccurrenceInScope(nodeName, variableName)\nselect nodeName, \"Local variable '\" + variableName + \"' shadows a built-in object.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-hashes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies the use of cryptographic hash functions that are either",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak cryptographic hash algorithms\n * @description Identifies the use of cryptographic hash functions that are either\n *              deprecated or considered insecure for security-sensitive applications.\n *              This query flags hash algorithms that are not within the approved\n *              strong algorithm set (SHA256, SHA384, SHA512) or cannot be\n *              properly identified by the analysis.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import necessary Python modules and cryptographic analysis components\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify cryptographic hash operations that utilize weak or non-approved algorithms\nfrom HashAlgorithm hashOperation, string algorithmName, string alertMessage\nwhere\n  // Extract the name of the hash algorithm being utilized\n  algorithmName = hashOperation.getHashName() and\n  // Exclude strong, approved hash algorithms from detection\n  not algorithmName = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // Generate appropriate security alert based on algorithm recognition status\n  (\n    // Case 1: Algorithm is recognized but not in the approved list\n    algorithmName != \"\" and\n    alertMessage = \"Use of unapproved hash algorithm or API \" + algorithmName + \".\"\n    or\n    // Case 2: Algorithm cannot be recognized by the analysis\n    algorithmName = \"\" and\n    alertMessage = \"Use of unrecognized hash algorithm.\"\n  )\nselect hashOperation, alertMessage"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Complete server-side request forgery\n * @description Detects network requests to URLs entirely controlled by user input, enabling request forgery attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision high\n * @id py/full-ssrf\n * @tags security\n *       external/cwe/cwe-918\n */\n\n// Import Python core libraries\nimport python\n// Import SSRF detection module\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\n// Import path visualization component\nimport FullServerSideRequestForgeryFlow::PathGraph\n\nfrom\n  // Origin point of untrusted data\n  FullServerSideRequestForgeryFlow::PathNode origin,\n  // Destination point where data is used\n  FullServerSideRequestForgeryFlow::PathNode destination,\n  // HTTP request object\n  Http::Client::Request httpRequest\nwhere\n  // Verify data flow path exists\n  FullServerSideRequestForgeryFlow::flowPath(origin, destination) and\n_______________ // 补全条件\n  httpRequest = destination.getNode().(Sink).getRequest() and\n  // Confirm complete user control\n  fullyControlledRequest(httpRequest)\nselect \n  // Output core components\n  httpRequest, origin, destination,\n  // Alert message with vulnerability context\n  \"The complete URL of this request is derived from a $@.\", origin.getNode(),\n  \"user-controlled input\"",
    "output": "// Match request with sink node"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/nested-loops-with-same-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies nested for-loops that reuse the same iteration variable,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Nested loops with identical loop variable\n * @description Identifies nested for-loops that reuse the same iteration variable,\n *              potentially causing unintended behavior and reducing code readability.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\n// Checks if a for-loop uses the specified variable as its iterator\npredicate hasIterationVariable(For loop, Variable iterVar) { \n    loop.getTarget().defines(iterVar) \n}\n\n// Detects nested loops sharing the same iterator variable where the variable\n// is referenced in the outer loop's scope (excluding the inner loop)\npredicate hasConflictingNestedLoop(For innerLoop, For outerLoop, Variable sharedVar) {\n    // Ensure inner loop is directly nested in outer loop's body (not else clause)\n    outerLoop.getBody().contains(innerLoop) and\n    \n    // Verify both loops use the same iteration variable\n    hasIterationVariable(innerLoop, sharedVar) and\n    hasIterationVariable(outerLoop, sharedVar) and\n    \n    // Confirm the variable is used in the outer loop's scope\n    exists(Name usage | \n        usage.uses(sharedVar) and \n        outerLoop.contains(usage) and \n        not innerLoop.contains(usage)\n    )\n}\n\n// Locate all instances of problematic nested loops with shared iteration variables\nfrom For nestedLoop, For enclosingLoop, Variable loopVar\nwhere hasConflictingNestedLoop(nestedLoop, enclosingLoop, loopVar)\nselect nestedLoop, \n    \"Nested for-loop reuses iteration variable '\" + loopVar.getId() + \n    \"' from enclosing $@.\", \n    enclosingLoop, \n    \"for-loop\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 类的源链接\n * @description 查找 Python 代码中所有类的源文件位置\n * @kind source-link\n * @id py/class-source-links\n * @metricType reftype\n */\n\nimport python\n_______________ // 补全条件\n// 遍历代码库中的所有 Python 类定义\nfrom Class cls\n// 返回类对象及其所在的源文件路径\nselect cls, cls.getLocation().getFile()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import CodeQL alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing module\nprivate import semmle.python.Comment as P\n\n// Represents AST nodes with location tracking capabilities\nclass AstNode instanceof P::AstNode {\n  // Verify node matches specified location coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Provide string representation of the node\n  string toString() { result = super.toString() }\n_______________ // 补全条件\n\n// Represents single-line comments with location tracking capabilities\nclass SingleLineComment instanceof P::Comment {\n  // Verify comment matches specified location coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Retrieve comment text content\n  string getText() { result = super.getContents() }\n\n  // Provide string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships using AS template\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Represents noqa-style suppression comments\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Initialize by matching noqa comment pattern\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Return suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define code coverage scope for this suppression\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Extract location details from comment\n    exists(int commentStartLine, int commentEndLine, int commentEndColumn |\n      // Get comment's location boundaries\n      this.hasLocationInfo(filePath, commentStartLine, _, commentEndLine, commentEndColumn) and\n      // Enforce line-start position and match boundaries\n      startLine = commentStartLine and\n      endLine = commentEndLine and\n      startCol = 1 and\n      endCol = commentEndColumn\n    )\n  }\n}",
    "output": "}"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks on substrings of unparsed URLs are vulnerable to bypass\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n_______________ // 补全条件\nprivate string getCommonTldPattern() { result = \"com|org|edu|gov|uk|net|io\" }\n\n// Determines if a string literal has the structure of a URL\npredicate resemblesUrl(StringLiteral urlStringLiteral) {\n  exists(string text | text = urlStringLiteral.getText() |\n    text.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + getCommonTldPattern() +\n        \")(:[0-9]+)?/?\")\n    or\n    text.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Identifies potentially insecure startswith method calls used for URL validation\npredicate hasUnsafeStartswithCheck(Call callExpr, StringLiteral urlStringLiteral) {\n  callExpr.getFunc().(Attribute).getName() = \"startswith\" and\n  callExpr.getArg(0) = urlStringLiteral and\n  not urlStringLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n}\n\n// Identifies potentially insecure endswith method calls used for URL validation\npredicate hasUnsafeEndswithCheck(Call callExpr, StringLiteral urlStringLiteral) {\n  callExpr.getFunc().(Attribute).getName() = \"endswith\" and\n  callExpr.getArg(0) = urlStringLiteral and\n  not urlStringLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n}\n\n// Detects URL sanitization operations that are incomplete and potentially vulnerable\npredicate hasIncompleteUrlSanitization(Expr sanitizationOperation, StringLiteral urlStringLiteral) {\n  resemblesUrl(urlStringLiteral) and\n  (\n    sanitizationOperation.(Compare).compares(urlStringLiteral, any(In i), _)\n    or\n    hasUnsafeStartswithCheck(sanitizationOperation, urlStringLiteral)\n    or\n    hasUnsafeEndswithCheck(sanitizationOperation, urlStringLiteral)\n  )\n}\n\n// Main query to identify expressions with incomplete URL substring sanitization\nfrom Expr sanitizationOperation, StringLiteral urlStringLiteral\nwhere hasIncompleteUrlSanitization(sanitizationOperation, urlStringLiteral)\nselect sanitizationOperation, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlStringLiteral,\n  urlStringLiteral.getText()",
    "output": "// Helper function that returns a regex pattern matching common top-level domains"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode IV or nonce\n_______________ // 补全条件\n *              Flags IVs/nonces not generated by cryptographically secure random methods (os.urandom).\n *\n *            NOTE: \n *              1. Simplified approach: Any IV/nonce not from os.urandom is flagged\n *              2. Special cases:\n *                 - GCM mode: Requires specific nonce handling (covered in separate query)\n *                 - Fernet: Explicitly excluded (uses os.urandom internally)\n *              3. Functions inferring mode/IV may trigger false positives (user suppression required)\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify block cipher operations with weak IV/nonce configuration\nfrom BlockMode blockModeOperation, string alertMessage, DataFlow::Node vulnerableNode\nwhere\n  // Exclude Fernet (handles IV generation internally)\n  not blockModeOperation instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet and\n  (\n    // Case 1: Missing IV/Nonce initialization\n    if not blockModeOperation.hasIVorNonce()\n    then (\n      vulnerableNode = blockModeOperation and\n      alertMessage = \"Block mode is missing IV/Nonce initialization\"\n    )\n    // Case 2: Non-os.urandom IV/Nonce source\n    else (\n      not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = blockModeOperation.getIVorNonce() and\n      vulnerableNode = blockModeOperation.getIVorNonce() and\n      alertMessage = \"Block mode uses non-cryptographic IV/Nonce source: $@\"\n    )\n  )\nselect blockModeOperation, alertMessage, vulnerableNode, vulnerableNode.toString()",
    "output": "* @description Detects weak/obsolete initialization vectors or nonces in block cipher modes."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects import statements that cannot be resolved to any known module.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unresolved import\n * @description Detects import statements that cannot be resolved to any known module.\n *              Unresolved imports may lead to reduced analysis coverage and accuracy.\n * @kind problem\n * @problem.severity info\n * @id py/import-failure\n */\n\n// Import the Python analysis library for code analysis\nimport python\n\n/**\n * Retrieves the current operating system platform identifier from the Python interpreter environment.\n * This helps determine platform-specific imports that may fail on different systems.\n */\nstring getCurrentPlatform() { \n  py_flags_versioned(\"sys.platform\", result, major_version().toString()) \n}\n\n/**\n * Determines the target operating system for platform-specific import statements.\n * Returns the corresponding OS name based on the imported module name patterns.\n */\nstring determineOSTarget(ImportExpr importExpression) {\n  exists(string importedModuleName | importedModuleName = importExpression.getImportedModuleName() |\n    // Java platform imports (Jython specific)\n    (importedModuleName.matches(\"org.python.%\") or importedModuleName.matches(\"java.%\")) and result = \"java\"\n    or\n    // Darwin/macOS platform imports\n    importedModuleName.matches(\"Carbon.%\") and result = \"darwin\"\n    or\n    // Windows platform imports\n    result = \"win32\" and\n    (\n      importedModuleName = \"_winapi\" or\n      importedModuleName = \"_win32api\" or\n      importedModuleName = \"_winreg\" or\n      importedModuleName = \"nt\" or\n      importedModuleName.matches(\"win32%\") or\n      importedModuleName = \"ntpath\"\n    )\n    or\n    // Linux/Unix platform imports\n    result = \"linux2\" and\n    (importedModuleName = \"posix\" or importedModuleName = \"posixpath\")\n    or\n    // Unsupported platform imports\n    result = \"unsupported\" and\n    (importedModuleName = \"__pypy__\" or importedModuleName = \"ce\" or importedModuleName.matches(\"riscos%\"))\n  )\n}\n\n/**\n * Represents a control flow node that performs Python interpreter version checks.\n * These nodes are typically used to guard version-specific import statements.\n */\nclass PythonVersionCheckNode extends ControlFlowNode {\n  PythonVersionCheckNode() {\n    exists(string versionAttributeName |\n      versionAttributeName.matches(\"%version%\") and\n      this.(CompareNode).getAChild+().pointsTo(Module::named(\"sys\").attr(versionAttributeName))\n    )\n  }\n\n  override string toString() { result = \"VersionCheck\" }\n}\n\n/**\n * Represents a conditional block that protects code based on interpreter version.\n * Used to identify version-specific imports that should not be flagged as issues.\n */\nclass VersionSpecificGuardBlock extends ConditionBlock {\n  VersionSpecificGuardBlock() { this.getLastNode() instanceof PythonVersionCheckNode }\n}\n\n/**\n * Checks if two imports are in separate conditional branches.\n */\npredicate areInSeparateBranches(ImportExpr import1, ImportExpr import2) {\n  exists(If conditionalBranch | \n    conditionalBranch.getBody().contains(import1) and conditionalBranch.getOrelse().contains(import2)\n  )\n  or\n  exists(If conditionalBranch | \n    conditionalBranch.getBody().contains(import2) and conditionalBranch.getOrelse().contains(import1)\n  )\n}\n\n/**\n * Checks if two imports are in try and except blocks.\n */\npredicate areInTryExceptBlocks(ImportExpr import1, ImportExpr import2) {\n  exists(Try exceptionHandlingBlock | \n    exceptionHandlingBlock.getBody().contains(import1) and exceptionHandlingBlock.getAHandler().contains(import2)\n  )\n  or\n  exists(Try exceptionHandlingBlock | \n    exceptionHandlingBlock.getBody().contains(import2) and exceptionHandlingBlock.getAHandler().contains(import1)\n  )\n}\n\n/**\n * Identifies alternative import expressions used as fallback mechanisms.\n * This function detects imports in conditional branches (if/else) or exception handling \n * blocks (try/except) that serve as alternatives when the primary import fails.\n */\nImportExpr findAlternativeImport(ImportExpr mainImport) {\n  // Ensure both primary and fallback imports have associated aliases\n  exists(Alias mainAlias, Alias alternativeAlias |\n    // Primary alias association check\n    (mainAlias.getValue() = mainImport or mainAlias.getValue().(ImportMember).getModule() = mainImport) and\n    // Fallback alias association check\n    (alternativeAlias.getValue() = result or alternativeAlias.getValue().(ImportMember).getModule() = result) and\n    (\n      // Check if imports are in separate conditional branches\n      areInSeparateBranches(mainImport, result)\n      or\n      // Check if imports are in try and except blocks\n      areInTryExceptBlocks(mainImport, result)\n    )\n  )\n}\n\n/**\n * Determines if an import failure is acceptable and should not be flagged as an issue.\n * Import failures are considered acceptable when there's a working alternative import\n * or when the import is OS-specific for a different platform than the current one.\n */\npredicate isAcceptableFailure(ImportExpr importExpression) {\n  // Check for existence of a working fallback import\n  findAlternativeImport(importExpression).refersTo(_)\n  or\n  // Verify if the import targets a different OS than the current platform\n  determineOSTarget(importExpression) != getCurrentPlatform()\n}\n\n/**\n * Checks if an import is protected by a version guard block.\n */\npredicate isProtectedByVersionGuard(ImportExpr importExpression) {\n  exists(VersionSpecificGuardBlock versionGuard | \n    versionGuard.controls(importExpression.getAFlowNode().getBasicBlock(), _)\n  )\n}\n\n// Main query: Identify unresolved imports that should be reported as issues\nfrom ImportExpr unresolvedImportExpression\nwhere\n  not unresolvedImportExpression.refersTo(_) and // Import cannot be resolved to any known module\n  exists(Context validContext | validContext.appliesTo(unresolvedImportExpression.getAFlowNode())) and // Import is in a valid context\n  not isAcceptableFailure(unresolvedImportExpression) and // Import failure is not acceptable\n  not isProtectedByVersionGuard(unresolvedImportExpression) // Not protected by version guard\nselect unresolvedImportExpression, \"Unable to resolve import of '\" + unresolvedImportExpression.getImportedModuleName() + \"'.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commented-out-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code that has been commented out, which can reduce code readability",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commented-out code\n * @description Identifies code that has been commented out, which can reduce code readability\n * and maintainability by leaving obsolete or non-functional code in the source.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code */\n\n// Import Python language support for code analysis\nimport python\n\n// Import lexical analysis capabilities for detecting commented code\nimport Lexical.CommentedOutCode\n\n// Main query to find commented-out code blocks\nfrom CommentedOutCodeBlock commentedBlock\n// Filter out blocks that are likely examples or documentation\nwhere not commentedBlock.maybeExampleCode()\n// Report each commented code block with an alert message\nselect commentedBlock, \"This comment appears to contain commented-out code, which may reduce code maintainability.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type metrics\n * @description Computes metrics for different kinds of type annotations in Python code, \n *              including parameters, return types, and annotated assignments.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents built-in Python types\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements supporting type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr func) { exists(func.getReturns()) } or\n  TAnnotatedParameter(Parameter param) { exists(param.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign stmt) { exists(stmt.getAnnotation()) }\n\n// Abstract base class for type-annotated elements\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr functionExpr;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(functionExpr) }\n  override Expr getAnnotation() { result = functionExpr.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter parameter;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(parameter) }\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assignmentStmt;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assignmentStmt) }\n  override Expr getAnnotation() { result = assignmentStmt.getAnnotation() }\n}\n\n/** Holds if `annotationExpr` is a forward declaration using string literal */\npredicate is_forward_declaration(Expr annotationExpr) { \n  annotationExpr instanceof StringLiteral \n}\n\n/** Holds if `annotationExpr` represents a complex type construct */\npredicate is_complex_type(Expr annotationExpr) {\n  (annotationExpr instanceof Subscript and not is_optional_type(annotationExpr)) or\n  annotationExpr instanceof Tuple or\n  annotationExpr instanceof List\n}\n\n/** Holds if `annotationExpr` is an Optional type annotation */\npredicate is_optional_type(Subscript annotationExpr) { \n  annotationExpr.getObject().(Name).getId() = \"Optional\" \n}\n\n/** Holds if `annotationExpr` is a simple non-built-in type identifier */\npredicate is_simple_type(Expr annotationExpr) {\n  (annotationExpr instanceof Name and not annotationExpr instanceof BuiltinType) or\n  (annotationExpr instanceof Attribute and is_simple_type(annotationExpr.(Attribute).getObject()))\n}\n\n/** Holds if `annotationExpr` is a built-in type */\npredicate is_builtin_type(Expr annotationExpr) { \n  annotationExpr instanceof BuiltinType \n}\n\n// Calculates type annotation metrics for each annotation category\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  category = \"Parameter annotation\" and\n  totalCount = count(AnnotatedParameter param) and\n  builtinCount = count(AnnotatedParameter param | is_builtin_type(param.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedParameter param | is_forward_declaration(param.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedParameter param | is_simple_type(param.getAnnotation())) and\n  complexTypeCount = count(AnnotatedParameter param | is_complex_type(param.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedParameter param | is_optional_type(param.getAnnotation()))\n  or\n  // Return type annotation metrics\n  category = \"Return type annotation\" and\n  totalCount = count(AnnotatedFunction func) and\n  builtinCount = count(AnnotatedFunction func | is_builtin_type(func.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedFunction func | is_forward_declaration(func.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedFunction func | is_simple_type(func.getAnnotation())) and\n  complexTypeCount = count(AnnotatedFunction func | is_complex_type(func.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedFunction func | is_optional_type(func.getAnnotation()))\n  or\n  // Annotated assignment metrics\n  category = \"Annotated assignment\" and\n  totalCount = count(AnnotatedAssignment assign) and\n  builtinCount = count(AnnotatedAssignment assign | is_builtin_type(assign.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedAssignment assign | is_forward_declaration(assign.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedAssignment assign | is_simple_type(assign.getAnnotation())) and\n  complexTypeCount = count(AnnotatedAssignment assign | is_complex_type(assign.getAnnotation())) and\n_______________ // 补全条件\n}\n\n// Main query execution\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount",
    "output": "optionalTypeCount = count(AnnotatedAssignment assign | is_optional_type(assign.getAnnotation()))"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/catch-base-exception]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Capturing 'BaseException' can lead to improper handling of system exits and keyboard interrupts.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Exception block catches 'BaseException'\n * @description Capturing 'BaseException' can lead to improper handling of system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// 判断异常处理块是否不重新抛出异常\npredicate doesNotReraise(ExceptStmt exceptBlock) { \n  // 获取异常处理块的流节点，检查其基本块是否到达程序退出点\n  exceptBlock.getAFlowNode().getBasicBlock().reachesExit() \n}\n\n// 判断异常处理块是否捕获了BaseException\npredicate catchesBaseException(ExceptStmt exceptBlock) {\n  // 检查异常类型是否为BaseException或未指定类型\n  exceptBlock.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  not exists(exceptBlock.getType())\n}\n\n// 主查询：找出捕获BaseException且不重新抛出的异常处理块\nfrom ExceptStmt exceptBlock\nwhere\n  catchesBaseException(exceptBlock) and // 条件：捕获BaseException\n  doesNotReraise(exceptBlock)           // 条件：不重新抛出异常\nselect exceptBlock, \"Except block directly handles BaseException.\" // 选择结果并添加描述信息"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Definitions\n * @description Enhanced jump-to-definition helper query for Python code analysis.\n *               This query identifies the relationship between code usage locations\n *               and their corresponding definitions, enabling navigation from usage\n *               to definition in the codebase.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import Python library for handling Python code analysis\nimport python\n\n_______________ // 补全条件\nimport analysis.DefinitionTracking\n\n// Select usage locations, their corresponding definitions, and definition types\nfrom NiceLocationExpr usageLocation, Definition definitionLocation, string definitionType\n// Establish relationship: the definition must correspond to the usage with matching type\nwhere definitionLocation = definitionOf(usageLocation, definitionType)\n// Output the usage location, its definition location, and the type of definition\nselect usageLocation, definitionLocation, definitionType",
    "output": "// Import definition tracking module to trace variables and function definitions"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/signature-mismatch]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects overriding methods with incompatible parameter counts,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Signature mismatch in overriding method\n * @description Detects overriding methods with incompatible parameter counts,\n *              which may cause runtime errors due to signature mismatches.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Identify overriding methods with parameter signature mismatches\nfrom FunctionValue baseMethod, PythonFunctionValue derivedMethod\nwhere\n  // Ensure base method isn't directly called and no sibling overrides are called\n  not exists(baseMethod.getACall()) and\n  not exists(FunctionValue siblingDerivedMethod |\n    siblingDerivedMethod.overrides(baseMethod) and\n    exists(siblingDerivedMethod.getACall())\n  ) and\n  // Validate derived method characteristics\n  not derivedMethod.getScope().isSpecialMethod() and\n  derivedMethod.getName() != \"__init__\" and\n  derivedMethod.isNormalMethod() and\n  // Verify override relationship and parameter incompatibility\n  derivedMethod.overrides(baseMethod) and\n  (\n    derivedMethod.minParameters() > baseMethod.maxParameters() or\n    derivedMethod.maxParameters() < baseMethod.minParameters()\n  )\nselect derivedMethod, \"Overriding method '\" + derivedMethod.getName() + \"' has signature mismatch with $@.\",\n  baseMethod, \"overridden method\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name NotImplemented is not an Exception\n * @description Detects code that raises 'NotImplemented' instead of 'NotImplementedError',\n *              which causes runtime type errors because NotImplemented is not an exception class.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n_______________ // 补全条件\n * @tags reliability\n *       maintainability\n */\n\n// Import fundamental Python language analysis capabilities\nimport python\n\n// Import specialized detection logic for NotImplemented misuse in exception handling\nimport Exceptions.NotImplemented\n\n// Find expressions where NotImplemented is improperly used in raise contexts\nfrom Expr erroneousNotImplementedExpr\nwhere \n    // Identify raise statements that incorrectly use NotImplemented\n    // instead of the appropriate exception class\n    use_of_not_implemented_in_raise(_, erroneousNotImplementedExpr)\nselect \n    // Output the problematic expression with suggested correction\n    erroneousNotImplementedExpr, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\"",
    "output": "* @id py/raise-not-implemented"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects import statements that cannot be resolved, which may reduce analysis coverage and accuracy.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unresolved import\n * @description Detects import statements that cannot be resolved, which may reduce analysis coverage and accuracy.\n * @kind problem\n * @problem.severity info\n * @id py/import-failure\n */\n\n// Import essential Python analysis capabilities\nimport python\n\n/**\n * Identifies fallback imports that serve as alternatives to primary imports.\n * This predicate finds imports within conditional (if/else) or exception-handling (try/except) blocks\n * that act as substitutes when primary imports are unavailable.\n */\nImportExpr findFallbackImport(ImportExpr mainImport) {\n  // Ensure both primary and fallback imports have associated aliases\n  exists(Alias mainAlias, Alias substituteAlias |\n    // Primary import alias relationship\n    (mainAlias.getValue() = mainImport or mainAlias.getValue().(ImportMember).getModule() = mainImport) and\n    // Fallback import alias relationship\n    (substituteAlias.getValue() = result or substituteAlias.getValue().(ImportMember).getModule() = result) and\n    (\n      // Identify alternative imports in conditional structures\n      exists(If branchCondition | \n        (branchCondition.getBody().contains(mainImport) and branchCondition.getOrelse().contains(result)) or\n        (branchCondition.getBody().contains(result) and branchCondition.getOrelse().contains(mainImport))\n      )\n      or\n      // Identify alternative imports in exception handling blocks\n      exists(Try exceptionBlock | \n        (exceptionBlock.getBody().contains(mainImport) and exceptionBlock.getAHandler().contains(result)) or\n        (exceptionBlock.getBody().contains(result) and exceptionBlock.getAHandler().contains(mainImport))\n      )\n    )\n  )\n}\n\n/**\n * Determines if an import is specific to a particular operating system.\n * Returns the OS identifier when the import is platform-dependent.\n */\nstring detectPlatformSpecificImport(ImportExpr importExpr) {\n  // Analyze imported module names for platform-specific patterns\n  exists(string modName | modName = importExpr.getImportedModuleName() |\n    // Java platform imports\n    (modName.matches(\"org.python.%\") or modName.matches(\"java.%\")) and result = \"java\"\n    or\n    // macOS platform imports\n    modName.matches(\"Carbon.%\") and result = \"darwin\"\n    or\n    // Windows platform imports\n    result = \"win32\" and\n    (\n      modName = \"_winapi\" or\n      modName = \"_win32api\" or\n      modName = \"_winreg\" or\n      modName = \"nt\" or\n      modName.matches(\"win32%\") or\n      modName = \"ntpath\"\n    )\n    or\n    // Linux platform imports\n    result = \"linux2\" and\n    (modName = \"posix\" or modName = \"posixpath\")\n    or\n    // Unsupported platform imports\n    result = \"unsupported\" and\n    (modName = \"__pypy__\" or modName = \"ce\" or modName.matches(\"riscos%\"))\n  )\n}\n\n/**\n * Retrieves the current operating system platform from the Python interpreter.\n */\nstring getRunningPlatform() { \n  py_flags_versioned(\"sys.platform\", result, major_version().toString()) \n}\n\n/**\n * Determines if an unresolved import should be considered acceptable.\n * An import failure is acceptable if it has a working alternative or is\n * platform-specific for a platform different from the current one.\n */\npredicate isAcceptableImportFailure(ImportExpr importStatement) {\n  // Check for available alternative imports\n  findFallbackImport(importStatement).refersTo(_)\n  or\n  // Check for platform-specific imports on incompatible platforms\n  detectPlatformSpecificImport(importStatement) != getRunningPlatform()\n}\n\n/**\n * Represents control flow nodes that evaluate Python interpreter version.\n * These nodes typically guard version-specific import statements.\n */\nclass VersionCheckNode extends ControlFlowNode {\n  VersionCheckNode() {\n    exists(string versionAttribute |\n      versionAttribute.matches(\"%version%\") and\n      this.(CompareNode).getAChild+().pointsTo(Module::named(\"sys\").attr(versionAttribute))\n    )\n  }\n\n  override string toString() { result = \"VersionCheck\" }\n}\n\n/**\n * Represents conditional blocks that guard code based on interpreter version.\n * Used to identify version-specific imports that should not be flagged.\n */\nclass VersionGuardedBlock extends ConditionBlock {\n  VersionGuardedBlock() { this.getLastNode() instanceof VersionCheckNode }\n}\n\n// Main query: Identify problematic unresolved imports\nfrom ImportExpr unresolvedImport\nwhere\n  not unresolvedImport.refersTo(_) and // Import cannot be resolved\n  exists(Context applicableContext | applicableContext.appliesTo(unresolvedImport.getAFlowNode())) and // Import is in valid context\n  not isAcceptableImportFailure(unresolvedImport) and // Import failure is not acceptable\n  not exists(VersionGuardedBlock versionGuard | versionGuard.controls(unresolvedImport.getAFlowNode().getBasicBlock(), _)) // Not version-guarded\nselect unresolvedImport, \"Unable to resolve import of '\" + unresolvedImport.getImportedModuleName() + \"'.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A module imports itself",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description A module imports itself\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n/**\n * Identifies modules that perform self-import operations.\n * This predicate detects when a module references itself through import statements\n * by comparing the importing module's context with the imported module's scope.\n */\npredicate isSelfImporting(ImportingStmt impStmt, ModuleValue modVal) {\n  // Confirm the importing module's context matches the imported module's scope\n  impStmt.getEnclosingModule() = modVal.getScope() and\n  // Resolve the most specific module reference using longest-name matching\n  // This approach ensures proper handling of relative import paths\n  modVal = \n    max(string impName, ModuleValue candidateMod |\n      impName = impStmt.getAnImportedModuleName() and\n      candidateMod.importedAs(impName)\n    |\n      candidateMod order by impName.length()\n    )\n}\n\n// Query to locate all instances of self-importing modules\nfrom ImportingStmt impStmt, ModuleValue modVal\nwhere isSelfImporting(impStmt, modVal)\nselect impStmt, \"The module '\" + modVal.getName() + \"' imports itself.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Summarized Callable Call Sites\n * @description Identifies call sites covered by flow summaries,\n *              including direct function calls and callback executions.\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/summarized-callable-call-sites\n * @tags meta\n * @precision very-low\n */\n\n// Import Python language core library\nimport python\n// Import data flow analysis modules\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\n_______________ // 补全条件\nimport meta.MetaMetrics\n\n// Define analysis elements: call site, summarized callable, and call classification\nfrom DataFlow::Node callSite, SummarizedCallable summarizedCallable, string callCategory\nwhere\n  // Exclude call sites located in ignored files\n  not callSite.getLocation().getFile() instanceof IgnoredFile\n  and\n  // Classify call as direct function call or callback execution\n  (\n    // Direct function call scenario\n    callSite = summarizedCallable.getACall() and callCategory = \"Call\"\n    or\n    // Callback execution scenario\n    callSite = summarizedCallable.getACallback() and callCategory = \"Callback\"\n  )\n// Format result message with call site and classification details\nselect callSite, callCategory + \" to \" + summarizedCallable",
    "output": "// Import meta metrics analysis module"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name PAM授权绕过问题由于不正确使用\n * @description 在`pam_authenticate`之后不使用`pam_acct_mgmt`来检查登录的有效性，可能导致授权绕过。\n_______________ // 补全条件\n * @problem.severity warning\n * @security-severity 8.1\n * @precision high\n * @id py/pam-auth-bypass\n * @tags security\n *       external/cwe/cwe-285\n */\n\nimport python\nimport PamAuthorizationFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.security.dataflow.PamAuthorizationQuery\n\n// 查找PAM授权流程的起始点和结束点\nfrom PamAuthorizationFlow::PathNode authStartPoint, PamAuthorizationFlow::PathNode authEndPoint\n// 验证是否存在从认证起点到终点的完整数据流路径\nwhere PamAuthorizationFlow::flowPath(authStartPoint, authEndPoint)\n// 输出检测结果，标识存在授权绕过风险的代码位置\nselect authEndPoint.getNode(), authStartPoint, authEndPoint,\n  \"This PAM authentication depends on a $@, and 'pam_acct_mgmt' is not called afterwards.\",\n  authStartPoint.getNode(), \"user-provided value\"",
    "output": "* @kind path-problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/external-dependencies]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：量化Python源文件所依赖的外部包数量。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name 外部依赖关系\n * @description 量化Python源文件所依赖的外部包数量。\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType externalDependency\n * @id py/external-dependencies\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 本查询输出两列数据，但实际涵盖了四个方面的信息：\n *\n * 1. Python源文件的路径（作为依赖关系的主体）\n * 2. 外部包对象（通常指PyPI或其他外部源提供的包）\n * 3. 包的版本信息（如果可获取）\n * 4. 源文件对该特定包的依赖数量\n *\n * 理想情况下，查询应当输出三列数据，\n * 但这需要调整仪表板数据库架构和数据提取器。\n *\n * 文件路径添加了'/'前缀，\n * 以匹配仪表板数据库中使用的相对文件路径格式。\n */\n\n// 从Python文件、外部包、依赖计数和依赖实体中选择数据\nfrom File pythonFile, ExternalPackage extPackage, int dependencyCount, string dependencyEntity\nwhere\n  // 计算Python文件对外部包的依赖数量\n  dependencyCount =\n    strictcount(AstNode node |\n      dependency(node, extPackage) and // 检查AST节点是否依赖于指定的外部包\n      node.getLocation().getFile() = pythonFile // 确保AST节点位于指定的源文件中\n    ) and\n  // 将Python文件和外部包信息合并为单个实体标识符\n  dependencyEntity = munge(pythonFile, extPackage)\n// 选择依赖实体和依赖计数，并按依赖数量降序排列\nselect dependencyEntity, dependencyCount order by dependencyCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 指向关系分析质量评估。该查询通过计算\"有效分析结果\"在\"总体分析结果\"中的比例，\n * 来评估指向关系分析的精确度和信息密度，为分析质量提供量化指标。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 判断控制流节点是否属于无分析价值的类型\n// 这些节点通常不包含有价值的指向关系信息，如参数、常量或不可变字面量\n_______________ // 补全条件\n  // 以下类型的节点被视为无分析价值：\n  node.getNode() instanceof Parameter    // 函数参数\n  or\n  node instanceof NameConstantNode       // 名称常量\n  or\n  node.getNode() instanceof ImmutableLiteral  // 不可变字面量\n}\n\n// 计算指向关系分析的各项质量指标\nfrom int significantFactsTotal, int sourceSignificantFacts, int totalAnalysisResults, float analysisQualityScore\nwhere\n  // 1. 计算有效分析结果总数（排除无价值的节点）\n  significantFactsTotal =\n    strictcount(ControlFlowNode node, Object refObj, ClassObject tgtClass |\n      node.refersTo(refObj, tgtClass, _) and not isTrivialNode(node)\n    ) and\n  // 2. 计算源文件中的有效分析结果数量\n  sourceSignificantFacts =\n    strictcount(ControlFlowNode node, Object refObj, ClassObject tgtClass |\n      node.refersTo(refObj, tgtClass, _) and\n      not isTrivialNode(node) and\n      exists(node.getScope().getEnclosingModule().getFile().getRelativePath())\n    ) and\n  // 3. 计算所有指向关系分析结果的总数\n  totalAnalysisResults =\n    strictcount(ControlFlowNode node, PointsToContext context, Object refObj, \n      ClassObject tgtClass, ControlFlowNode originalNode | \n      PointsTo::points_to(node, context, refObj, tgtClass, originalNode)\n    ) and\n  // 4. 计算分析质量得分：源文件有效分析结果占总体结果的百分比\n  analysisQualityScore = 100.0 * sourceSignificantFacts / totalAnalysisResults\nselect significantFactsTotal, sourceSignificantFacts, totalAnalysisResults, analysisQualityScore",
    "output": "predicate isTrivialNode(ControlFlowNode node) {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/encoding-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python encoding issues that can lead to runtime exceptions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Encoding error\n * @description Identifies Python encoding issues that can lead to runtime exceptions\n *              and hinder static analysis. These issues commonly occur during text \n *              processing operations when proper character encoding handling is absent.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/encoding-error\n */\n\nimport python\n\n// This query systematically examines the codebase for encoding-related problems\n// and gathers their diagnostic information for reporting\nfrom EncodingError encodingDefect\nselect encodingDefect, encodingDefect.getMessage()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/return-or-yield-outside-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies usage of 'return', 'yield', or 'yield from' statements",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Detection of 'return' or 'yield' statements outside function scope\n * @description Identifies usage of 'return', 'yield', or 'yield from' statements \n *              outside of function definitions, which leads to runtime 'SyntaxError'.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/return-or-yield-outside-function\n */\n\nimport python\n\n// 查询目标：检测在全局作用域中错误使用的关键字语句\nfrom AstNode invalidStmt, string statementType\nwhere \n  // 第一部分：识别目标语句类型并分类\n  (\n    invalidStmt instanceof Return and statementType = \"return\"\n    or\n    invalidStmt instanceof Yield and statementType = \"yield\"\n    or\n    invalidStmt instanceof YieldFrom and statementType = \"yield from\"\n  )\n  and\n  // 第二部分：确保语句不在任何函数的作用域内\n  not exists(Function parentFunction | invalidStmt.getScope() = parentFunction.getScope())\n// 输出结果：违规语句及其错误描述\nselect invalidStmt, \"'\" + statementType + \"' is used outside a function.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure Azure Storage v1 client-side encryption usage\n * @description Detects unsafe v1 encryption implementation in Azure Storage clients that may expose encrypted data\n * @kind path-problem\n * @tags security\n *       experimental\n *       cryptography\n *       external/cwe/cwe-327\n * @id py/azure-storage/unsafe-client-side-encryption-in-use\n * @problem.severity error\n * @precision medium\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Azure Storage client initialization methods\nAPI::Node azureBlobServiceClientNode(boolean isDirectlyCreated) {\n  // Direct BlobServiceClient instantiation\n  isDirectlyCreated = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getReturn()\n  or\n  // BlobServiceClient from connection string\n  isDirectlyCreated = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getMember(\"from_connection_string\")\n        .getReturn()\n}\n\nAPI::CallNode containerClientCreationCall() {\n  // Transition from BlobServiceClient to ContainerClient\n  result = azureBlobServiceClientNode(_).getMember(\"get_container_client\").getACall()\n  or\n  // Transition from BlobClient to ContainerClient\n  result = azureBlobClientNode(_).getMember(\"_get_container_client\").getACall()\n}\n\nAPI::Node azureContainerClientNode(boolean isDirectlyCreated) {\n  // ContainerClient obtained through transition\n  isDirectlyCreated = false and\n  result = containerClientCreationCall().getReturn()\n  or\n  // Direct ContainerClient instantiation\n  isDirectlyCreated = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getReturn()\n  or\n  // ContainerClient from connection string or URL\n  isDirectlyCreated = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getMember([\"from_connection_string\", \"from_container_url\"])\n        .getReturn()\n}\n\nAPI::CallNode blobClientCreationCall() {\n  // Transition from BlobServiceClient or ContainerClient to BlobClient\n  result = [azureBlobServiceClientNode(_), azureContainerClientNode(_)]\n        .getMember(\"get_blob_client\")\n        .getACall()\n}\n\nAPI::Node azureBlobClientNode(boolean isDirectlyCreated) {\n  // BlobClient obtained through transition\n  isDirectlyCreated = false and\n  result = blobClientCreationCall().getReturn()\n  or\n  // Direct BlobClient instantiation\n  isDirectlyCreated = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getReturn()\n  or\n  // BlobClient from connection string or URL\n  isDirectlyCreated = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n_______________ // 补全条件\n        .getMember([\"from_connection_string\", \"from_blob_url\"])\n        .getReturn()\n}\n\n// Unified representation of Azure Storage client types\nAPI::Node anyAzureStorageClientNode(boolean isDirectlyCreated) {\n  result in [azureBlobServiceClientNode(isDirectlyCreated), \n             azureContainerClientNode(isDirectlyCreated), \n             azureBlobClientNode(isDirectlyCreated)]\n}\n\n// Encryption state tracking definitions\nnewtype EncryptionFlowState =\n  V1EncryptionState() or\n  NoEncryptionState()\n\n// Data flow configuration with encryption state tracking\nprivate module EncryptionFlowConfiguration implements DataFlow::StateConfigSig {\n  class FlowState = EncryptionFlowState;\n\n  // Source nodes: uninitialized clients (no encryption configured)\n  predicate isSource(DataFlow::Node node, FlowState state) {\n    state = NoEncryptionState() and\n    node = anyAzureStorageClientNode(true).asSource()\n  }\n\n  // Barrier nodes: clients explicitly configured with v2 encryption\n  predicate isBarrier(DataFlow::Node node, FlowState state) {\n    exists(state) and\n    exists(DataFlow::AttrWrite encryptionAttr |\n      node = anyAzureStorageClientNode(_).getAValueReachableFromSource() and\n      encryptionAttr.accesses(node, \"encryption_version\") and\n      encryptionAttr.getValue().asExpr().(StringLiteral).getText() in [\"'2.0'\", \"2.0\"]\n    )\n    or\n    // Barrier for state transition when encryption is configured\n    isAdditionalFlowStep(_, NoEncryptionState(), node, V1EncryptionState()) and\n    state = NoEncryptionState()\n  }\n\n  // Flow transitions between client objects\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(DataFlow::MethodCallNode transitionCall |\n      transitionCall in [containerClientCreationCall(), blobClientCreationCall()] and\n      node1 = transitionCall.getObject() and\n      node2 = transitionCall\n    )\n  }\n\n  // State transition when encryption configuration is applied\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    node1 = node2.(DataFlow::PostUpdateNode).getPreUpdateNode() and\n    state1 = NoEncryptionState() and\n    state2 = V1EncryptionState() and\n    exists(DataFlow::AttrWrite encryptionAttr |\n      node1 = anyAzureStorageClientNode(_).getAValueReachableFromSource() and\n      encryptionAttr.accesses(node1, [\"key_encryption_key\", \"key_resolver_function\"])\n    )\n  }\n\n  // Sink nodes: v1 encrypted blob upload operations\n  predicate isSink(DataFlow::Node node, FlowState state) {\n    state = V1EncryptionState() and\n    exists(DataFlow::MethodCallNode uploadCall |\n      uploadCall = azureBlobClientNode(_).getMember(\"upload_blob\").getACall() and\n      node = uploadCall.getObject()\n    )\n  }\n\n  // No restrictions on incremental mode\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global data flow analysis with encryption state tracking\nmodule EncryptionDataFlowAnalysis = DataFlow::GlobalWithState<EncryptionFlowConfiguration>;\n\nimport EncryptionDataFlowAnalysis::PathGraph\n\n// Query: Identify unsafe v1 encryption usage paths\nfrom EncryptionDataFlowAnalysis::PathNode sourceNode, EncryptionDataFlowAnalysis::PathNode sinkNode\nwhere EncryptionDataFlowAnalysis::flowPath(sourceNode, sinkNode)\nselect sinkNode, sourceNode, sinkNode, \"Unsafe usage of v1 version of Azure Storage client-side encryption\"",
    "output": ".getMember(\"BlobClient\")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Default value parameter modification\n * @description Identifies modifications to parameters with default values, which can lead to unexpected behavior as default values persist across function invocations.\n * @kind path-problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/modification-of-default-value\n */\n\nimport python\nimport semmle.python.functions.ModificationOfParameterWithDefault\nimport ModificationOfParameterWithDefault::Flow::PathGraph\n\nfrom\n  ModificationOfParameterWithDefault::Flow::PathNode startNode,\n  ModificationOfParameterWithDefault::Flow::PathNode endNode\nwhere \n  ModificationOfParameterWithDefault::Flow::flowPath(startNode, endNode)\nselect \n  endNode.getNode(), \n  startNode, \n  endNode, \n_______________ // 补全条件\n  startNode.getNode(),\n  \"default value\"",
    "output": "\"This expression mutates a $@.\","
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Directory traversal during tarball extraction from attacker-controlled source\n_______________ // 补全条件\n *              enabling attackers to write files outside intended locations. Exploitable when tar files\n *              originate from untrusted inputs (remote sources or user-provided arguments).\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// Identify data flow paths from attacker-controlled sources to vulnerable extraction points\nfrom UnsafeUnpackFlow::PathNode maliciousInputSource, UnsafeUnpackFlow::PathNode unsafeExtractionTarget\nwhere UnsafeUnpackFlow::flowPath(maliciousInputSource, unsafeExtractionTarget)\nselect unsafeExtractionTarget.getNode(), maliciousInputSource, unsafeExtractionTarget,\n  \"Unsafe extraction from malicious tarball retrieved from remote location\"",
    "output": "* @description Detects insecure tar extraction operations lacking path validation against destination directory,"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-misconfiguration-with-credentials]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Disabling or weakening Same-Origin Policy (SOP) protection may expose",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name CORS Misconfiguration with Credentials\n * @description Disabling or weakening Same-Origin Policy (SOP) protection may expose\n *              the application to CORS attacks when credentials are allowed.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n// 检查来源配置是否包含通配符或空值\npredicate hasWildcardOrigin(DataFlow::Node originConfigNode) {\n  // 情况1：来源配置直接是 \"*\" 或 \"null\" 字符串\n  exists(StringLiteral literal |\n    literal = originConfigNode.asExpr() and\n    literal.getText() in [\"*\", \"null\"]\n  )\n  // 情况2：来源配置是列表且包含 \"*\" 或 \"null\" 元素\n  or\n  originConfigNode.asExpr() instanceof List and\n  exists(StringLiteral literal |\n    literal = originConfigNode.asExpr().getASubExpression() and\n    literal.getText() in [\"*\", \"null\"]\n  )\n}\n\n// 验证中间件是否为 CORS 类型\npredicate isCorsMiddlewareType(Http::Server::CorsMiddleware corsConfig) {\n  corsConfig.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n// 检查中间件是否启用了凭证支持\npredicate supportsCredentials(Http::Server::CorsMiddleware corsConfig) {\n  corsConfig.getCredentialsAllowed().asExpr() instanceof True\n}\n\n// 查询存在安全风险的 CORS 中间件配置\nfrom Http::Server::CorsMiddleware corsConfig\nwhere\n  // 条件组合：确认中间件类型 + 启用凭证 + 使用通配符来源\n  isCorsMiddlewareType(corsConfig) and\n  supportsCredentials(corsConfig) and\n  hasWildcardOrigin(corsConfig.getOrigins().getALocalSource())\nselect corsConfig,\n  // 安全风险说明：允许任意来源的认证请求可能导致敏感数据泄露\n  \"This CORS middleware configuration allows authenticated cross-origin requests from any source, potentially exposing sensitive data\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/slots-in-old-style-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：In Python, old-style classes (those not inheriting from object) do not properly support",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__slots__` in old-style class\n * @description In Python, old-style classes (those not inheriting from object) do not properly support\n *              the `__slots__` attribute. When `__slots__` is used in an old-style class, it does not\n *              override the class dictionary as intended, but instead creates a regular class attribute\n *              named `__slots__`. This can lead to unexpected behavior and memory inefficiency.\n * @kind problem\n * @problem.severity error\n * @tags portability\n *       correctness\n * @sub-severity low\n * @precision very-high\n * @id py/slots-in-old-style-class\n */\n\nimport python\n\nfrom ClassObject problematicClass\nwhere \n  not problematicClass.failedInference() and\n  not problematicClass.isNewStyle() and \n  problematicClass.declaresAttribute(\"__slots__\")\nselect problematicClass,\n  \"Using '__slots__' in an old style class just creates a class attribute called '__slots__'.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Source links of commits\n * @description Identifies source files affected by commits and provides their revision information.\n *              This query helps track which source code files were modified in each commit.\n *              It establishes a relationship between commits and the source files they impact,\n *              enabling developers to trace changes across the codebase.\n * @kind source-link\n * @id py/commit-source-links\n * @metricType commit\n */\n\n// Import Python library for code analysis capabilities\nimport python\n// Import VCS library for version control system functionality\nimport external.VCS\n\n_______________ // 补全条件\nfrom Commit commitRecord, File modifiedFile\nwhere \n  // Ensure we only process actual source code files\n  modifiedFile.fromSource() and\n  // Establish the relationship between commit and affected source file\n  modifiedFile = commitRecord.getAnAffectedFile()\n// Return commit revision identifier and corresponding source file\nselect commitRecord.getRevisionName(), modifiedFile",
    "output": "// Define the main query to analyze commit-file relationships"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-permissive-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects file permission settings that grant excessive access rights to non-owner users",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly permissive file permissions\n * @description Detects file permission settings that grant excessive access rights to non-owner users\n * @kind problem\n * @id py/overly-permissive-file\n * @problem.severity warning\n * @security-severity 7.8\n * @sub-severity high\n * @precision medium\n * @tags external/cwe/cwe-732\n *       security\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n/**\n * Extracts the world-accessible permission bits (least significant 3 bits) from a file permission value.\n * @param permissionValue The complete permission value (e.g., 0o777)\n * @return The world permission component (0-7)\n */\nbindingset[permissionValue]\nint extractWorldPermissionBits(int permissionValue) { \n  result = permissionValue % 8 \n}\n\n/**\n * Extracts the group-accessible permission bits (middle 3 bits) from a file permission value.\n * @param permissionValue The complete permission value (e.g., 0o777)\n * @return The group permission component (0-7)\n */\nbindingset[permissionValue]\nint extractGroupPermissionBits(int permissionValue) { \n  result = (permissionValue / 8) % 8 \n}\n\n/**\n * Generates a textual description of permission access levels.\n * @param permissionBits The permission component to describe (0-7)\n * @return \"writable\" if write access is granted, \"readable\" if only read access is granted\n */\nbindingset[permissionBits]\nstring describePermissionAccess(int permissionBits) {\n  permissionBits % 4 >= 2 and result = \"writable\"\n  or\n  permissionBits % 4 < 2 and permissionBits != 0 and result = \"readable\"\n}\n\n/**\n * Identifies overly permissive permission components within a file permission value.\n * @param permissionValue The complete permission value to analyze\n * @return Description of the permissive component (e.g., \"world writable\")\n */\nbindingset[permissionValue]\nstring identifyPermissiveComponent(int permissionValue) {\n  result = \"world \" + describePermissionAccess(extractWorldPermissionBits(permissionValue))\n  or\n  extractWorldPermissionBits(permissionValue) = 0 and \n  result = \"group \" + describePermissionAccess(extractGroupPermissionBits(permissionValue))\n}\n\n/**\n * Matches file permission API calls and extracts the permission mode parameter.\n * @param filePermissionCall The API call node\n * @param permissionMethodName The name of the API method (\"chmod\" or \"open\")\n * @param permissionMode The permission mode value\n */\npredicate matchFilePermissionCall(API::CallNode filePermissionCall, string permissionMethodName, int permissionMode) {\n  (permissionMethodName = \"chmod\" and\n   filePermissionCall = API::moduleImport(\"os\").getMember(\"chmod\").getACall() and\n   permissionMode = filePermissionCall.getParameter(1, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue())\n  or\n  (permissionMethodName = \"open\" and\n   filePermissionCall = API::moduleImport(\"os\").getMember(\"open\").getACall() and\n   permissionMode = filePermissionCall.getParameter(2, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue())\n}\n\n// Identify file permission API calls with overly permissive access modes\nfrom API::CallNode filePermissionCall, string permissionMethodName, int permissionMode, string permissionIssue\nwhere\n  matchFilePermissionCall(filePermissionCall, permissionMethodName, permissionMode) and\n  permissionIssue = identifyPermissiveComponent(permissionMode)\nselect filePermissionCall, \"Overly permissive mask in \" + permissionMethodName + \" sets file to \" + permissionIssue + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Vulnerable asymmetric encryption padding\n * @description\n * This security analysis identifies potentially insecure padding schemes used in\n * asymmetric encryption implementations. The query operates on a whitelist-based\n * security model, where only explicitly approved padding methods (OAEP, KEM, PSS)\n * are considered secure. Any other padding algorithm is flagged as a potential\n * security vulnerability.\n * \n * The detection mechanism focuses on identifying padding implementations that\n_______________ // 补全条件\n * encryption contexts, helping developers maintain strong cryptographic standards.\n * \n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define the set of cryptographically secure padding algorithms\n// that are approved for use in asymmetric encryption scenarios\nstring getSecurePaddingAlgorithm() { \n  result = [\"OAEP\", \"KEM\", \"PSS\"] \n}\n\n// Identify and analyze asymmetric encryption padding implementations\n// that do not use approved security standards\nfrom AsymmetricPadding vulnerablePaddingScheme, string paddingAlgorithm\nwhere\n  // Extract the algorithm identifier from the padding implementation\n  paddingAlgorithm = vulnerablePaddingScheme.getPaddingName()\n  // Filter out implementations using secure padding methods\n  and not paddingAlgorithm = getSecurePaddingAlgorithm()\nselect vulnerablePaddingScheme, \"Identified unapproved, weak, or unknown asymmetric padding algorithm: \" + paddingAlgorithm",
    "output": "* may be susceptible to cryptographic attacks when deployed in asymmetric"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/unmatchable-caret]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Finds regular expressions that have a caret '^' symbol positioned in the middle, making them impossible to match.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unmatchable caret in regular expression\n * @description Finds regular expressions that have a caret '^' symbol positioned in the middle, making them impossible to match.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/regex/unmatchable-caret\n */\n\nimport python\nimport semmle.python.regex\n\n/**\n * Detects regular expression patterns containing misplaced caret symbols.\n * The caret is deemed misplaced if:\n * - The regex pattern doesn't use MULTILINE or VERBOSE flags (these flags enable mid-string anchors)\n * - There's a literal '^' character at the given position\n * - The caret is not located at the pattern's start (where it serves as a valid start-of-string anchor)\n */\npredicate contains_invalid_caret(RegExp pattern, int caretPosition) {\n  // Check that the regex doesn't employ flags permitting mid-string anchors\n  not (pattern.getAMode() = \"MULTILINE\" or pattern.getAMode() = \"VERBOSE\") and\n  \n  // Confirm existence of a caret character precisely at the specified location\n  // and rule out valid scenarios where the caret appears at pattern's beginning\n  pattern.specialCharacter(caretPosition, caretPosition + 1, \"^\") and\n  not pattern.firstItem(caretPosition, caretPosition + 1)\n}\n\n// Primary query that identifies all regular expressions containing unmatchable caret symbols\nfrom RegExp invalidPattern, int caretOffset\nwhere contains_invalid_caret(invalidPattern, caretOffset)\nselect invalidPattern,\n  \"This regular expression includes an unmatchable caret at offset \" + caretOffset.toString() + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python functions that don't adhere to PEP8 naming standards, which require function names to begin with lowercase letters.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Function Naming Convention Violation\n * @description Identifies Python functions that don't adhere to PEP8 naming standards, which require function names to begin with lowercase letters.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n * @convention PEP8\n */\n\nimport python  // Import Python analysis library to enable code inspection capabilities\n\n// Predicate that determines if a function's name begins with an uppercase character\npredicate startsWithCapitalLetter(Function functionObj) {\n  exists(string firstChar |\n    firstChar = functionObj.getName().prefix(1) and  // Extract the first character from the function name\n    not firstChar = firstChar.toLowerCase()  // Confirm that the character remains uppercase when compared to its lowercase form\n  )\n}\n\n// Main query logic to detect functions violating PEP8 naming conventions\nfrom Function violatingFunction\nwhere\n  // Ensure the function is part of the source code (not library or generated code)\n  violatingFunction.inSource() and\n  // Check if the function violates the naming convention\n  startsWithCapitalLetter(violatingFunction) and\n  // Exclude results when multiple functions in the same file have the same violation\n  not exists(Function otherFunction |\n    otherFunction != violatingFunction and  // Verify it's a different function\n    otherFunction.getLocation().getFile() = violatingFunction.getLocation().getFile() and  // Both functions reside in the same file\n    startsWithCapitalLetter(otherFunction)  // The other function also violates the naming convention\n  )\nselect violatingFunction, \"Function names should start with lowercase letters according to PEP8.\"  // Report the violating function with a corrective message"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unused-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Import is not required as it is not used",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unused import\n * @description Import is not required as it is not used\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/unused-import */\n\nimport python\nimport Variables.Definition\nimport semmle.python.ApiGraphs\n\n/**\n * 判断导入是否为pytest的fixture装饰器\n * 检测通过pytest.fixture装饰的函数，这些导入不应被视为未使用\n */\nprivate predicate is_pytest_fixture(Import imp, Variable importedName) {\n  exists(Alias alias, API::Node fixtureNode, API::Node decoratorNode |\n    // 获取pytest.fixture装饰器节点\n    fixtureNode = API::moduleImport(\"pytest\").getMember(\"fixture\") and\n    // 处理直接使用fixture和使用其返回值的两种情况\n    decoratorNode in [fixtureNode, fixtureNode.getReturn()] and\n    // 获取导入别名\n    alias = imp.getAName() and\n    // 关联导入的变量名\n    alias.getAsname().(Name).getVariable() = importedName and\n    // 验证别名值与装饰器返回值匹配\n    alias.getValue() = decoratorNode.getReturn().getAValueReachableFromSource().asExpr()\n  )\n}\n\n/**\n * 检查模块中全局名称是否被使用\n * 包括直接使用的全局变量和在非函数作用域中使用的局部变量\n */\npredicate global_name_used(Module moduleScope, string nameStr) {\n  // 检查直接使用的全局变量\n  exists(Name usageNode, GlobalVariable globalVar |\n    usageNode.uses(globalVar) and\n    globalVar.getId() = nameStr and\n    usageNode.getEnclosingModule() = moduleScope\n  )\n  or\n  // 检查在非函数作用域中使用的局部变量（实际会引用全局变量）\n  exists(Name usageNode, LocalVariable localVar |\n    usageNode.uses(localVar) and\n    localVar.getId() = nameStr and\n    usageNode.getEnclosingModule() = moduleScope and\n    not localVar.getScope().getEnclosingScope*() instanceof Function\n  )\n}\n\n/**\n * 检测模块中是否存在无法静态分析的`__all__`定义\n * 如果`__all__`不是简单列表或被动态修改，则无法确定导入是否被使用\n */\npredicate all_not_understood(Module moduleScope) {\n  exists(GlobalVariable allVar | \n    allVar.getId() = \"__all__\" and \n    allVar.getScope() = moduleScope and\n    (\n      // `__all__`不是静态定义的简单列表\n      not moduleScope.declaredInAll(_)\n      or\n      // `__all__`在代码中被动态修改\n      exists(Call modifyCall | \n        modifyCall.getFunc().(Attribute).getObject() = allVar.getALoad()\n      )\n    )\n  )\n}\n\n/**\n * 检查导入的模块是否在doctest中被使用\n * 如果导入的名称出现在doctest示例中，则不应被视为未使用\n */\npredicate imported_module_used_in_doctest(Import importStmt) {\n  exists(string importedName, string docstringContent |\n    // 获取导入的名称\n    importStmt.getAName().getAsname().(Name).getId() = importedName and\n    // 检查doctest中是否引用了该导入\n    docstringContent = doctest_in_scope(importStmt.getScope()) and\n    docstringContent.regexpMatch(\"[\\\\s\\\\S]*(>>>|\\\\.\\\\.\\\\.).*\" + importedName + \"[\\\\s\\\\S]*\")\n  )\n}\n\n/**\n * 获取指定作用域中的doctest字符串内容\n * 标记为noinline以避免函数内联，保持查询性能\n */\npragma[noinline]\nprivate string doctest_in_scope(Scope scope) {\n  exists(StringLiteral docLiteral |\n    docLiteral.getEnclosingModule() = scope and\n    docLiteral.isDocString() and\n    result = docLiteral.getText() and\n    result.regexpMatch(\"[\\\\s\\\\S]*(>>>|\\\\.\\\\.\\\\.)[\\\\s\\\\S]*\")\n  )\n}\n\n/**\n * 获取模块中作为字符串出现的类型提示注释\n * 这些通常用于前向引用，标记为noinline以优化性能\n */\npragma[noinline]\nprivate string typehint_annotation_in_module(Module moduleScope) {\n  exists(StringLiteral typeAnnotation |\n    (\n      // 检查函数参数的类型注释\n      typeAnnotation = any(Arguments args).getAnAnnotation().getASubExpression*()\n      or\n      // 检查变量注解的类型注释\n      typeAnnotation = any(AnnAssign annAssign).getAnnotation().getASubExpression*()\n      or\n      // 检查函数返回值的类型注释\n      typeAnnotation = any(FunctionExpr func).getReturns().getASubExpression*()\n    ) and\n    typeAnnotation.pointsTo(Value::forString(result)) and\n    typeAnnotation.getEnclosingModule() = moduleScope\n  )\n}\n\n/**\n * 获取文件中的类型提示注释\n * 这些是以\"# type:\"开头的注释，标记为noinline以优化性能\n */\npragma[noinline]\nprivate string typehint_comment_in_file(File file) {\n  exists(Comment typeComment |\n    file = typeComment.getLocation().getFile() and\n    result = typeComment.getText() and\n    result.matches(\"# type:%\")\n  )\n}\n\n/**\n * 检查导入的别名是否在类型提示中被使用\n * 包括类型注释和字符串形式的类型提示（用于前向引用）\n */\npredicate imported_alias_used_in_typehint(Import importStmt, Variable importedVar) {\n  importStmt.getAName().getAsname().(Name).getVariable() = importedVar and\n  exists(File file, Module moduleScope |\n    moduleScope = importStmt.getEnclosingModule() and\n    file = moduleScope.getFile()\n  |\n    // 检查类型注释中是否使用了该导入\n    typehint_comment_in_file(file).regexpMatch(\"# type:.*\" + importedVar.getId() + \".*\")\n    or\n    // 检查字符串形式的类型提示中是否使用了该导入\n    typehint_annotation_in_module(moduleScope).regexpMatch(\".*\\\\b\" + importedVar.getId() + \"\\\\b.*\")\n  )\n}\n\n/**\n * 判断导入是否未被使用\n * 综合多种条件排除特殊情况，确保只报告真正未使用的导入\n */\npredicate unused_import(Import importStmt, Variable importedVar) {\n  // 基本条件：导入的变量存在且不是__future__导入\n  importStmt.getAName().getAsname().(Name).getVariable() = importedVar and\n  not importStmt.getAnImportedModuleName() = \"__future__\" and\n  \n  // 作用域条件：导入在模块级别\n  importStmt.getScope() = importStmt.getEnclosingModule() and\n  \n  // 使用条件：变量未被全局使用\n  not global_name_used(importStmt.getScope(), importedVar.getId()) and\n  \n  // 排除特殊情况：\n  // 1. 在__all__中声明的导入\n  not importStmt.getEnclosingModule().declaredInAll(importedVar.getId()) and\n  // 2. __init__.py中的导入用于强制模块加载\n  not importStmt.getEnclosingModule().isPackageInit() and\n  // 3. epytext文档中使用的导入\n  not exists(Comment docComment | \n    docComment.getText().matches(\"%L{\" + importedVar.getId() + \"}%\") and\n    docComment.getLocation().getFile() = importStmt.getLocation().getFile()\n  ) and\n  // 4. 符合未使用变量命名约定的变量（如_或__）\n  not name_acceptable_for_unused_variable(importedVar) and\n  // 5. 模块有不透明的__all__定义\n  not all_not_understood(importStmt.getEnclosingModule()) and\n  // 6. 在doctest中使用的导入\n  not imported_module_used_in_doctest(importStmt) and\n  // 7. 在类型提示中使用的导入\n  not imported_alias_used_in_typehint(importStmt, importedVar) and\n  // 8. pytest fixture导入\n  not is_pytest_fixture(importStmt, importedVar) and\n  \n  // 确保导入实际指向某个值（可能是未知模块）\n  importStmt.getAName().getValue().pointsTo(_)\n}\n\n/**\n * 主查询：查找并报告未使用的导入语句\n * 输出未使用的导入语句及其名称\n */\nfrom Import importStmt, Variable importedVar\nwhere unused_import(importStmt, importedVar)\nselect importStmt, \"Import of '\" + importedVar.getId() + \"' is not used.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/key-points-to-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Expression does not \"point-to\" an object which prevents further points-to analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Key points-to fails for expression.\n * @description Expression does not \"point-to\" an object which prevents further points-to analysis.\n * @kind problem\n * @problem.severity info\n * @id py/key-points-to-failure\n * @deprecated\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n// 定义一个谓词函数，用于判断表达式是否发生了points-to失败\npredicate points_to_failure(Expr e) {\n  // 存在一个控制流节点f，使得f等于表达式e的流节点，并且不存在从f到任何对象的points-to关系\n  exists(ControlFlowNode f | f = e.getAFlowNode() | not PointsTo::pointsTo(f, _, _, _))\n}\n\n// 定义另一个谓词函数，用于判断关键表达式是否发生了points-to失败\npredicate key_points_to_failure(Expr e) {\n  // 表达式e发生了points-to失败\n  points_to_failure(e) and\n  // 且其子表达式没有发生points-to失败\n  not points_to_failure(e.getASubExpression()) and\n  // 且不存在使用该表达式流节点的Ssa变量，使得该变量的定义节点也发生了points-to失败\n  not exists(SsaVariable ssa | ssa.getAUse() = e.getAFlowNode() |\n    points_to_failure(ssa.getAnUltimateDefinition().getDefinition().getNode())\n  ) and\n  // 且不存在将该表达式作为目标的赋值操作\n  not exists(Assign a | a.getATarget() = e)\n}\n\n// 查询语句：查找所有满足关键points-to失败条件的表达式，并确保这些表达式不是调用的结果\nfrom Attribute e\nwhere key_points_to_failure(e) and not exists(Call c | c.getFunc() = e)\nselect e, \"Expression does not 'point-to' any object, but all its sources do.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/symmetric-padding-schemes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies symmetric encryption algorithms that use padding schemes,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Symmetric Encryption Padding Detection\n * @description Identifies symmetric encryption algorithms that use padding schemes,\n *              which may be vulnerable to certain cryptographic attacks\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricPadding symmetricPadding\nselect symmetricPadding, \"Algorithm using padding scheme: \" + symmetricPadding.getPaddingName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/iv-sources]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects potential initialization vectors (IV) or nonce values",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Initialization Vector (IV) or Nonce Sources\n * @description Detects potential initialization vectors (IV) or nonce values \n *              used in block cipher operations across supported cryptographic libraries.\n *              This analysis identifies cryptographic components potentially vulnerable \n *              to quantum computing attacks.\n * @kind problem\n * @id py/quantum-readiness/cbom/iv-sources\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify cryptographic initialization vectors or nonces\n// originating from block cipher modes of operation\nfrom BlockMode cipherMode\nselect cipherMode.getIVorNonce().asExpr(), \"Block mode IV/Nonce source\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name All Cryptographic Algorithms\n_______________ // 补全条件\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import necessary Python and Semmle core libraries for cryptographic analysis\nimport python\nimport semmle.python.Concepts\n\n// Define the main query to detect cryptographic operations and extract algorithm information\nfrom Cryptography::CryptographicOperation cryptographicOp, string algoIdentifier\nwhere \n  // Case 1: Extract the algorithm name directly from the cryptographic operation\n  algoIdentifier = cryptographicOp.getAlgorithm().getName()\n  or\n  // Case 2: Extract the block mode information from the cryptographic operation\n  algoIdentifier = cryptographicOp.getBlockMode()\nselect cryptographicOp, \"Use of algorithm \" + algoIdentifier",
    "output": "* @description Identifies all cryptographic algorithm implementations across supported libraries."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/key-derivation]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies cryptographic operations using key derivation functions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Quantum Vulnerability in Key Derivation Algorithms\n * @description Identifies cryptographic operations using key derivation functions \n *              that may be vulnerable to quantum computing attacks through \n *              analysis of supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/key-derivation\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify cryptographic operations implementing key derivation\nfrom KeyDerivationOperation kdfOperation\nwhere kdfOperation.getAlgorithm() instanceof KeyDerivationAlgorithm\n// Generate alert with algorithm-specific vulnerability context\nselect kdfOperation,\n  \"Key derivation function detected: \" + \n  kdfOperation.getAlgorithm().(KeyDerivationAlgorithm).getKDFName() + \n  \" - This cryptographic operation may have quantum vulnerabilities\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mismatch between signature and use of an overriding method\n * @description Detects methods that override a base method but with a different signature,\n *              which would likely cause errors if called.\n * @kind problem\n * @tags maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/inheritance/incorrect-overriding-signature\n */\n\nimport python\nimport Expressions.CallArgs\n\n_______________ // 补全条件\nfrom Call methodCall, FunctionValue overridingMethod, FunctionValue baseMethod, string issueDescription\nwhere\n  // 确保overridingMethod确实重写了baseMethod\n  overridingMethod.overrides(baseMethod) and\n  (\n    // 情况1：调用overridingMethod时参数错误，但调用baseMethod时参数正确\n    wrong_args(methodCall, overridingMethod, _, issueDescription) and\n    correct_args_if_called_as_method(methodCall, baseMethod)\n    or\n    // 情况2：存在非法命名的参数\n    exists(string paramName |\n      illegally_named_parameter(methodCall, overridingMethod, paramName) and\n      issueDescription = \"an argument named '\" + paramName + \"'\" and\n      // 检查baseMethod中是否有相同名称的参数\n      baseMethod.getScope().getAnArg().(Name).getId() = paramName\n    )\n  )\nselect overridingMethod,\n  \"Overriding method signature does not match $@, where it is passed \" + issueDescription +\n    \". Overridden method $@ is correctly specified.\", methodCall, \"here\", baseMethod,\n  baseMethod.descriptiveString()",
    "output": "// 查找方法签名不匹配的重写方法"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and details alert suppressions using 'noqa' directives in Python code,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert Suppression Information\n * @description Identifies and details alert suppressions using 'noqa' directives in Python code,\n *              providing comprehensive location and coverage information.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import CodeQL's alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment handling module\nprivate import semmle.python.Comment as P\n\n// Represents AST nodes with enhanced location tracking capabilities\nclass AstNode instanceof P::AstNode {\n  // Check if node's location matches specified coordinates\n  predicate hasLocationInfo(\n    string filePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    super.getLocation().hasLocationInfo(filePath, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Generate string representation of AST node\n  string toString() { result = super.toString() }\n}\n\n// Represents location-aware single-line comments\nclass SingleLineComment instanceof P::Comment {\n  // Verify comment location against given coordinates\n  predicate hasLocationInfo(\n    string filePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    super.getLocation().hasLocationInfo(filePath, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Retrieve raw text content of comment\n  string getText() { result = super.getContents() }\n\n  // Provide string representation of comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships using AS template with custom node types\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * Represents suppression comments using 'noqa' directive. This directive is\n * recognized by both pylint and pyflakes, and should be respected by LGTM.\n */\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Constructor: Identify comments matching noqa pattern\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Provide suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define code coverage scope for this suppression\n  override predicate covers(\n    string filePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Extract location details of the comment\n    exists(int startLine, int endLine, int endCol |\n      this.hasLocationInfo(filePath, startLine, _, endLine, endCol) and\n      // Set coverage to entire line containing the comment\n      beginLine = startLine and\n      finishLine = endLine and\n      beginColumn = 1 and\n      finishColumn = endCol\n    )\n  }\n}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-deprecated-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies imports of Python modules that have been deprecated in specific versions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Import of deprecated module\n * @description Identifies imports of Python modules that have been deprecated in specific versions\n * @kind problem\n * @tags maintainability\n *       external/cwe/cwe-477\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/import-deprecated-module\n */\n\n// Import Python library for analyzing Python source code\nimport python\n\n/**\n * Determines if a module was deprecated in a specific Python version\n * and provides the recommended replacement module\n *\n * @param deprecatedModuleName The name of the deprecated module\n * @param recommendedReplacement The recommended replacement module or \"no replacement\"\n * @param deprecatedMajor The major version number of Python where the module was deprecated\n * @param deprecatedMinor The minor version number of Python where the module was deprecated\n * @return True if the module was deprecated in the specified version\n */\npredicate is_module_deprecated(string deprecatedModuleName, string recommendedReplacement, int deprecatedMajor, int deprecatedMinor) {\n  // Modules deprecated in Python 1.x\n  (\n    deprecatedModuleName = \"posixfile\" and recommendedReplacement = \"fcntl\" and deprecatedMajor = 1 and deprecatedMinor = 5\n    or\n    deprecatedModuleName = \"pre\" and recommendedReplacement = \"re\" and deprecatedMajor = 1 and deprecatedMinor = 5\n  )\n  or\n  // Modules deprecated in Python 2.0-2.2\n  (\n    deprecatedModuleName = \"whrandom\" and recommendedReplacement = \"random\" and deprecatedMajor = 2 and deprecatedMinor = 1\n    or\n    deprecatedModuleName = \"statcache\" and recommendedReplacement = \"no replacement\" and deprecatedMajor = 2 and deprecatedMinor = 2\n    or\n    deprecatedModuleName = \"mpz\" and recommendedReplacement = \"a third party\" and deprecatedMajor = 2 and deprecatedMinor = 2\n  )\n  or\n  // Modules deprecated in Python 2.3-2.4\n  (\n    deprecatedModuleName = \"rfc822\" and recommendedReplacement = \"email\" and deprecatedMajor = 2 and deprecatedMinor = 3\n    or\n    deprecatedModuleName = \"mimetools\" and recommendedReplacement = \"email\" and deprecatedMajor = 2 and deprecatedMinor = 3\n    or\n    deprecatedModuleName = \"MimeWriter\" and recommendedReplacement = \"email\" and deprecatedMajor = 2 and deprecatedMinor = 3\n    or\n    deprecatedModuleName = \"mimify\" and recommendedReplacement = \"email\" and deprecatedMajor = 2 and deprecatedMinor = 3\n    or\n    deprecatedModuleName = \"xreadlines\" and recommendedReplacement = \"no replacement\" and deprecatedMajor = 2 and deprecatedMinor = 3\n    or\n    deprecatedModuleName = \"rotor\" and recommendedReplacement = \"no replacement\" and deprecatedMajor = 2 and deprecatedMinor = 4\n  )\n  or\n  // Modules deprecated in Python 2.5-2.6\n  (\n    deprecatedModuleName = \"gopherlib\" and recommendedReplacement = \"no replacement\" and deprecatedMajor = 2 and deprecatedMinor = 5\n    or\n    deprecatedModuleName = \"rgbimgmodule\" and recommendedReplacement = \"no replacement\" and deprecatedMajor = 2 and deprecatedMinor = 5\n    or\n    deprecatedModuleName = \"multifile\" and recommendedReplacement = \"email\" and deprecatedMajor = 2 and deprecatedMinor = 5\n    or\n    deprecatedModuleName = \"sets\" and recommendedReplacement = \"builtins\" and deprecatedMajor = 2 and deprecatedMinor = 6\n  )\n  or\n  // Additional deprecated modules with various deprecation versions\n  (\n    deprecatedModuleName = \"buildtools\" and recommendedReplacement = \"no replacement\" and deprecatedMajor = 2 and deprecatedMinor = 3\n    or\n    deprecatedModuleName = \"cfmfile\" and recommendedReplacement = \"no replacement\" and deprecatedMajor = 2 and deprecatedMinor = 4\n    or\n    deprecatedModuleName = \"macfs\" and recommendedReplacement = \"no replacement\" and deprecatedMajor = 2 and deprecatedMinor = 3\n    or\n    deprecatedModuleName = \"md5\" and recommendedReplacement = \"hashlib\" and deprecatedMajor = 2 and deprecatedMinor = 5\n    or\n    deprecatedModuleName = \"sha\" and recommendedReplacement = \"hashlib\" and deprecatedMajor = 2 and deprecatedMinor = 5\n  )\n}\n\n/**\n * Constructs a deprecation warning message for a module\n *\n * @param moduleName The name of the deprecated module\n * @return A string describing when the module was deprecated\n */\nstring get_deprecation_message(string moduleName) {\n  // Retrieve deprecation version and format warning message\n  exists(int majorVersion, int minorVersion | \n    is_module_deprecated(moduleName, _, majorVersion, minorVersion)\n  |\n    result =\n      \"The \" + moduleName + \" module was deprecated in version \" + \n      majorVersion.toString() + \".\" + minorVersion.toString() + \".\"\n  )\n}\n\n/**\n * Constructs a replacement suggestion message for a deprecated module\n *\n * @param moduleName The name of the deprecated module\n * @return A string with replacement suggestion or empty string if no replacement\n */\nstring get_replacement_message(string moduleName) {\n  // Check for replacement module and format suggestion accordingly\n  exists(string replacement | \n    is_module_deprecated(moduleName, replacement, _, _)\n  |\n    (result = \" Use \" + replacement + \" module instead.\" and \n     not replacement = \"no replacement\")\n    or\n    (result = \"\" and replacement = \"no replacement\")\n  )\n}\n\n// Main query to identify imports of deprecated modules\nfrom ImportExpr importStmt, string moduleName, string replacementModule\nwhere\n  // Extract the imported module name\n  moduleName = importStmt.getName() and\n  // Verify the module is deprecated\n  is_module_deprecated(moduleName, replacementModule, _, _) and\n  // Exclude imports properly handled with ImportError exception handling\n  not exists(Try tryBlock, ExceptStmt exceptClause | \n    exceptClause = tryBlock.getAHandler() and\n    exceptClause.getType().pointsTo(ClassValue::importError()) and\n    exceptClause.containsInScope(importStmt)\n  )\nselect importStmt, get_deprecation_message(moduleName) + get_replacement_message(moduleName)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name An assert statement has a side-effect\n * @description Side-effects in assert statements result in differences between normal\n *              and optimized behavior.\n * @kind problem\n_______________ // 补全条件\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/side-effect-in-assert\n */\n\nimport python\n\n// Identifies expressions containing built-in functions with known side effects\npredicate isBuiltinFunctionWithSideEffects(Expr expr) {\n  exists(string funcName | \n    funcName = expr.(Attribute).getName() or funcName = expr.(Name).getId() |\n    funcName in [\n        \"print\", \"write\", \"append\", \"pop\", \"remove\", \"discard\", \"delete\", \"close\", \"open\", \"exit\"\n      ]\n  )\n}\n\n// Detects subprocess module calls that execute system commands\npredicate isSubprocessCallWithSideEffect(Call callExpr) {\n  exists(string subprocessFuncName | \n    subprocessFuncName = \"subprocess.call\" or \n    subprocessFuncName = \"subprocess.check_call\" or \n    subprocessFuncName = \"subprocess.check_output\" |\n    callExpr.getAFlowNode() = Value::named(subprocessFuncName).getACall()\n  )\n}\n\n// Determines if an expression likely produces side effects\npredicate hasProbableSideEffect(Expr expr) {\n  // Yield expressions (excluding pseudo-yields in comprehensions)\n  (expr instanceof Yield and not exists(Comp c | c.contains(expr)))\n  or\n  // YieldFrom expressions\n  expr instanceof YieldFrom\n  or\n  // Calls to built-in functions or subprocess commands with side effects\n  exists(Call callExpr | \n    callExpr = expr and \n    (isBuiltinFunctionWithSideEffects(callExpr.getFunc()) or \n     isSubprocessCallWithSideEffect(callExpr))\n  )\n}\n\n// Locates assert statements containing side-effect expressions\nfrom Assert assertStmt, Expr expr\nwhere hasProbableSideEffect(expr) and assertStmt.contains(expr)\nselect assertStmt, \"This 'assert' statement contains an $@ which may have side effects.\", expr, \"expression\"",
    "output": "* @tags reliability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of parameters without defaults\n * @description Counts the parameters in each function that are not assigned default values.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n_______________ // 补全条件\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // 导入Python分析库，提供处理Python代码的基础功能\n\n// 遍历所有函数对象，计算每个函数中未定义默认值的参数数量\nfrom FunctionMetrics functionObj\nselect functionObj, functionObj.getNumberOfParametersWithoutDefault() as nonDefaultParamCount order by nonDefaultParamCount desc\n// 输出函数对象及其无默认值的参数计数，按计数从高到低排序",
    "output": "* @metricType callable"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/improper-ldap-auth]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：LDAP bind operation lacks proper authentication mechanism",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Improper LDAP Authentication\n * @description LDAP bind operation lacks proper authentication mechanism\n * @kind problem\n * @problem.severity warning\n * @id py/improper-ldap-auth\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\n// Import necessary modules for data flow analysis and LDAP concepts\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\n\n/**\n * Predicate to detect LDAP bind operations that lack proper authentication.\n * This identifies cases where the password is either None, not provided, or an empty string.\n */\npredicate isLdapAuthenticationFlawed(LdapBind ldapOperation) {\n  // Check for None or missing password\n  (\n    DataFlow::localFlow(DataFlow::exprNode(any(None noneValue)), ldapOperation.getPassword()) or\n    not exists(ldapOperation.getPassword())\n  )\n  // Check for empty string password\n  or\n  exists(StringLiteral emptyStr |\n    emptyStr.getText() = \"\" and\n    DataFlow::localFlow(DataFlow::exprNode(emptyStr), ldapOperation.getPassword())\n  )\n}\n\n// Query to identify all LDAP bind operations with authentication issues\nfrom LdapBind ldapOperation\nwhere isLdapAuthenticationFlawed(ldapOperation)\nselect ldapOperation, \"The following LDAP bind operation is executed without authentication.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/init-calls-subclass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a class's `__init__` method invokes another method that can be overridden",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Constructor calls overridable method\n * @description Detects when a class's `__init__` method invokes another method that can be overridden \n *              by subclasses, which may lead to observing a partially initialized object.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/init-calls-subclass\n */\n\nimport python\n\n// Identify cases where parent class constructor invokes methods overridden by subclasses\nfrom\n  ClassObject parentClass, string methodName, Call dangerousCall, \n  FunctionObject overridingMethod, FunctionObject parentMethod, \n  FunctionObject parentConstructor, SelfAttribute selfMethodAttr\nwhere\n  // Step 1: Retrieve parent class constructor and target method\n  parentConstructor = parentClass.declaredAttribute(\"__init__\") and\n  parentMethod = parentClass.declaredAttribute(methodName) and\n  \n  // Step 2: Verify method call occurs within constructor scope\n  dangerousCall.getScope() = parentConstructor.getFunction() and\n  \n  // Step 3: Confirm call targets self attribute matching method name\n  dangerousCall.getFunc() = selfMethodAttr and\n  selfMethodAttr.getName() = methodName and\n  \n  // Step 4: Ensure subclass overrides parent method\n  overridingMethod.overrides(parentMethod)\n// Generate warning for potentially dangerous constructor method call\nselect dangerousCall, \"Call to self.$@ in __init__ method, which is overridden by $@.\", \n  parentMethod, methodName, overridingMethod, overridingMethod.descriptiveString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary pass\n * @description Identifies redundant 'pass' statements in Python code blocks\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unnecessary-pass\n */\n\nimport python\n\n// Helper predicate to check if an expression statement is a docstring\npredicate is_doc_string(ExprStmt docStringExpr) {\n  // Verify the expression value is either a Unicode or Bytes literal\n  docStringExpr.getValue() instanceof Unicode or docStringExpr.getValue() instanceof Bytes\n}\n\n// Helper predicate to determine if a statement list contains a docstring\npredicate has_doc_string(StmtList stmtList) {\n  // Ensure parent is a Scope and the first statement is a docstring\n  stmtList.getParent() instanceof Scope and\n  is_doc_string(stmtList.getItem(0))\n}\n\n// Helper predicate to identify contexts where 'pass' statements are unnecessary\npredicate is_unnecessary_pass_context(StmtList parentStmtList) {\n  exists(Pass redundantPass |\n    parentStmtList.getAnItem() = redundantPass and\n    (\n      // Case 1: Exactly 2 statements without a docstring\n      strictcount(parentStmtList.getAnItem()) = 2 and not has_doc_string(parentStmtList)\n      or\n      // Case 2: More than 2 statements present\n      strictcount(parentStmtList.getAnItem()) > 2\n    )\n  )\n}\n_______________ // 补全条件\nfrom Pass redundantPass, StmtList parentStmtList\nwhere\n  parentStmtList.getAnItem() = redundantPass and\n  is_unnecessary_pass_context(parentStmtList)\nselect redundantPass, \"Unnecessary 'pass' statement.\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/classes-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Statistical analysis showing the distribution of class definitions in Python source files",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Classes per file\n * @description Statistical analysis showing the distribution of class definitions in Python source files\n * @kind treemap\n * @id py/classes-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python\n\n// For each Python source file, determine the total number of class definitions\nfrom Module sourceFile, int classDefinitionCount\n\n// Calculate the number of classes by tallying all class declarations within the same Python file\nwhere classDefinitionCount = count(Class declaredClass | declaredClass.getEnclosingModule() = sourceFile)\n\n// Display the source file along with its class count, sorted in descending order based on the count\nselect sourceFile, classDefinitionCount order by classDefinitionCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unsafe-unpacking]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：当从用户控制源提取tar文件时，若未验证目标路径是否在预期目录内，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 恶意tar文件提取时的任意文件写入漏洞\n * @description 当从用户控制源提取tar文件时，若未验证目标路径是否在预期目录内，\n *             攻击者可能覆盖目标目录外的文件。此漏洞常见于从远程位置或命令行参数\n *             获取的tar文件处理场景。\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// 定义恶意输入源和不安全提取操作节点\nfrom UnsafeUnpackFlow::PathNode maliciousInput, UnsafeUnpackFlow::PathNode vulnerableExtraction\n// 检测从恶意输入源到不安全提取操作的数据流路径\nwhere UnsafeUnpackFlow::flowPath(maliciousInput, vulnerableExtraction)\n// 输出漏洞位置、数据流起点和终点，附带安全警告\nselect vulnerableExtraction.getNode(), maliciousInput, vulnerableExtraction,\n  \"检测到从远程位置获取的恶意tar文件的不安全提取操作，可能导致目录遍历攻击\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Module dependency analysis\n * @description Quantifies and visualizes incoming dependencies per module to identify highly coupled components.\n * @kind treemap\n * @id py/afferent-coupling-per-file\n_______________ // 补全条件\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       modularity\n */\n\nimport python\n\n// Analyze module coupling by counting incoming dependencies\nfrom ModuleMetrics moduleInfo, int incomingDependencyCount\nwhere \n  // Calculate the number of modules depending on this module\n  incomingDependencyCount = moduleInfo.getAfferentCoupling()\n  // Focus only on modules with actual dependencies\n  and incomingDependencyCount > 0\nselect \n  moduleInfo, \n  incomingDependencyCount as dependencyCount \norder by \n  dependencyCount desc",
    "output": "* @treemap.warnOn highValues"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-star-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python files that use wildcard imports ('from ... import *'), which can introduce naming conflicts and reduce code clarity.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' used\n * @description Identifies Python files that use wildcard imports ('from ... import *'), which can introduce naming conflicts and reduce code clarity.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// Import the Python analysis module to enable examination of Python source code\nimport python\n\n// Identify all wildcard import statements in the codebase\nfrom ImportStar wildcardImport\n// Generate an alert for each wildcard import found\nselect wildcardImport, \"Using 'from ... import *' pollutes the namespace.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Wildcard Import Usage\n * @description Detects Python files using wildcard imports ('from ... import *')\n *              which introduce namespace pollution and decrease code readability.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n_______________ // 补全条件\nimport python\n\n// Identify all wildcard import statements in the codebase\nfrom ImportStar starImport\n// Report each wildcard import with a descriptive message explaining the risks\nselect starImport, \"Wildcard imports ('from ... import *') pollute the namespace and reduce code clarity, increasing maintenance difficulty.\"",
    "output": "// Import core Python analysis capabilities for code examination"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Mostly duplicate module\n * @description Identifies Python modules with substantial code duplication\n *              that could be merged to improve maintainability and reduce redundancy.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-file\n */\n\nimport python\n\n// Define source module and its potential duplicate counterpart\n_______________ // 补全条件\n  Module originalModule, \n  Module duplicateModule, \n  string warningMessage\nwhere \n  none()  // Placeholder for actual duplication detection logic\nselect \n  originalModule, \n  warningMessage, \n  duplicateModule, \n  duplicateModule.getName()",
    "output": "from"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Deleted lines per file\n * @description Calculates the total number of lines deleted from each source file across all commits in the repository history.\n * @kind treemap\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\n// Identify Python modules and compute the aggregate count of lines removed across their commit history\nfrom Module targetModule, int cumulativeDeletions\n_______________ // 补全条件\n  // Verify that the module contains measurable code to ensure meaningful analysis\n  exists(targetModule.getMetrics().getNumberOfLinesOfCode()) and\n  // Compute the sum of deleted lines for each file across all legitimate commits\n  cumulativeDeletions = sum(int removedLines |\n      exists(Commit revision |\n          // Determine the number of lines deleted in each commit that affects this module\n          removedLines = revision.getRecentDeletionsForFile(targetModule.getFile()) and\n          // Exclude artificial commits that don't represent actual code changes\n          not artificialChange(revision)\n      )\n  )\nselect targetModule, cumulativeDeletions order by cumulativeDeletions desc",
    "output": "where"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-small-salt-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Key Derivation Function (KDF) implementations with salt sizes below the security threshold of 128 bits (16 bytes).",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insufficient KDF Salt Size\n * @description Detects Key Derivation Function (KDF) implementations with salt sizes below the security threshold of 128 bits (16 bytes).\n *\n * This rule identifies KDF operations where salt sizes are either:\n * - Explicitly configured below 16 bytes\n * - Cannot be statically determined during analysis\n * @kind problem\n * @id py/kdf-small-salt-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\nfrom KeyDerivationOperation kdfOperation, DataFlow::Node saltSizeParam, API::CallNode urandomInvocation, string warningText\nwhere\n  // Verify KDF operation requires salt parameter\n  kdfOperation.requiresSalt() and\n  \n  // Trace salt configuration to os.urandom source\n  urandomInvocation = kdfOperation.getSaltConfigSrc() and\n  urandomInvocation = API::moduleImport(\"os\").getMember(\"urandom\").getACall() and\n  \n  // Identify ultimate salt size parameter source\n  saltSizeParam = Utils::getUltimateSrcFromApiNode(urandomInvocation.getParameter(0, \"size\")) and\n  \n  // Evaluate salt size security conditions\n  (\n    // Case 1: Non-static salt size configuration\n    not exists(saltSizeParam.asExpr().(IntegerLiteral).getValue()) and\n    warningText = \"Salt size cannot be statically verified. \"\n    or\n    // Case 2: Insufficient salt size\n    saltSizeParam.asExpr().(IntegerLiteral).getValue() < 16 and\n    warningText = \"Salt size is below minimum requirement. \"\n  )\nselect kdfOperation,\n  warningText + \"Minimum 16 bytes required for salt. os.urandom Config: $@, Size Config: $@\", urandomInvocation,\n  urandomInvocation.toString(), saltSizeParam, saltSizeParam.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'import *' may pollute namespace\n * @description Detects namespace pollution caused by 'import *' statements\n *              when the imported module lacks an explicit '__all__' definition\n * @kind problem\n * @tags maintainability\n *       modularity\n_______________ // 补全条件\n * @sub-severity high\n * @precision very-high\n * @id py/polluting-import\n */\n\nimport python\n\nfrom ImportStar starImport, ModuleValue sourceModule\nwhere \n  // Verify the imported module matches the source module reference\n  sourceModule.importedAs(starImport.getImportedModuleName()) and\n  // Ensure source module exists and isn't missing\n  not sourceModule.isAbsent() and\n  // Check if source module defines '__all__' to control exports\n  not (\n    // Built-in modules are considered safe\n    sourceModule.isBuiltin() or\n    // Direct '__all__' definition in module scope\n    sourceModule.getScope().(ImportTimeScope).definesName(\"__all__\") or\n    // '__all__' definition in module's initialization scope\n    sourceModule.getScope().getInitModule().(ImportTimeScope).definesName(\"__all__\")\n  )\nselect starImport,\n  \"Import pollutes the enclosing namespace, as the imported module $@ does not define '__all__'.\",\n  sourceModule, sourceModule.getName()",
    "output": "* @problem.severity recommendation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Hash Algorithms\n * @description Identifies all instances where cryptographic hash algorithms are utilized within the codebase,\n *              including both standard hashing algorithms and password-specific hashing algorithms.\n *              This detection is performed across all supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/hash-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import necessary Python and Semmle libraries for cryptographic analysis\nimport python\nimport semmle.python.Concepts\n\n// Define variables for cryptographic operations and algorithms\nfrom Cryptography::CryptographicOperation cryptographicOperation, Cryptography::CryptographicAlgorithm cryptographicAlgorithm\nwhere\n  // Establish relationship between operation and its algorithm\n  cryptographicAlgorithm = cryptographicOperation.getAlgorithm() and\n  (\n_______________ // 补全条件\n    cryptographicAlgorithm instanceof Cryptography::HashingAlgorithm or\n    // Check if the algorithm is a password-specific hashing algorithm\n    cryptographicAlgorithm instanceof Cryptography::PasswordHashingAlgorithm\n  )\n// Select the cryptographic operation and provide a descriptive message about the algorithm used\nselect cryptographicOperation, \"Use of algorithm \" + cryptographicOperation.getAlgorithm().getName()",
    "output": "// Check if the algorithm is a standard hashing algorithm"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Nested loops with same variable reused after inner loop body\n * @description Detects when a variable is redefined in an inner loop and then\n *              used in an outer loop, which can lead to unexpected behavior.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/nested-loops-with-same-variable-reused\n */\n\nimport python\n\n// 检查循环变量是否在循环语句中被定义\npredicate loopVariableDefinition(For loopStmt, Variable iteratedVar, SsaVariable ssaDefinition) {\n_______________ // 补全条件\n  loopStmt.getTarget().getAFlowNode() = ssaDefinition.getDefinition() and \n  iteratedVar = ssaDefinition.getVariable()\n}\n\n// 检测嵌套循环中变量重用情况\npredicate nestedLoopVariableReuse(For innerForLoop, For outerForLoop, Variable sharedVar, Name varUsage) {\n  /* 内层循环必须位于外层循环的循环体中（排除else子句） */\n  outerForLoop.getBody().contains(innerForLoop) and\n  /* 变量在外层循环中被使用，但不在内层循环中使用 */\n  outerForLoop.contains(varUsage) and\n  not innerForLoop.contains(varUsage) and\n  /* 验证SSA定义关系：变量在内外层循环中均被定义 */\n  exists(SsaVariable innerSsaDef |\n    loopVariableDefinition(innerForLoop, sharedVar, innerSsaDef.getAnUltimateDefinition()) and\n    loopVariableDefinition(outerForLoop, sharedVar, _) and\n    innerSsaDef.getAUse().getNode() = varUsage\n  )\n}\n\n// 查询满足条件的嵌套循环结构\nfrom For innerForLoop, For outerForLoop, Variable sharedVar, Name varUsage\nwhere nestedLoopVariableReuse(innerForLoop, outerForLoop, sharedVar, varUsage)\nselect innerForLoop, \"Nested for statement $@ loop variable '\" + sharedVar.getId() + \"' of enclosing $@.\", \n       varUsage, \"uses\", outerForLoop, \"for statement\"",
    "output": "// 验证循环目标节点与SSA定义节点匹配，且变量一致"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Module is imported more than once\n * @description Detects redundant duplicate imports of the same module within the same scope\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/repeated-import\n */\n\nimport python\n\n// Predicate identifying imports without attribute access operations\npredicate is_simple_import(Import importNode) { \n  not exists(Attribute attr | importNode.contains(attr)) \n}\n\n// Predicate detecting duplicate imports with identical module references and aliases\npredicate double_import(Import initialImport, Import duplicateImport, Module targetModule) {\n  // Verify distinct import nodes and simple import structure\n  initialImport != duplicateImport and\n  is_simple_import(initialImport) and\n  is_simple_import(duplicateImport) and\n  \n  // Confirm both imports reference identical module\n  exists(ImportExpr initialModuleRef, ImportExpr duplicateModuleRef |\n    initialModuleRef.getName() = targetModule.getName() and\n    duplicateModuleRef.getName() = targetModule.getName() and\n    initialModuleRef = initialImport.getAName().getValue() and\n    duplicateModuleRef = duplicateImport.getAName().getValue()\n  ) and\n  \n  // Validate matching alias usage\n  initialImport.getAName().getAsname().(Name).getId() = \n  duplicateImport.getAName().getAsname().(Name).getId() and\n  \n_______________ // 补全条件\n  exists(Module parentModule |\n    initialImport.getScope() = parentModule and\n    duplicateImport.getEnclosingModule() = parentModule and\n    (\n      // Either duplicate is in nested scope (not top-level)\n      duplicateImport.getScope() != parentModule\n      or\n      // Or initial import appears before duplicate in code\n      initialImport.getAnEntryNode().dominates(duplicateImport.getAnEntryNode())\n    )\n  )\n}\n\n// Query to identify and report redundant duplicate imports\nfrom Import initialImport, Import duplicateImport, Module targetModule\nwhere double_import(initialImport, duplicateImport, targetModule)\nselect duplicateImport,\n  \"This import of module \" + targetModule.getName() + \" is redundant, as it was previously imported $@.\",\n  initialImport, \"on line \" + initialImport.getLocation().getStartLine().toString()",
    "output": "// Check scope containment and positioning constraints"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/classic-model/block-cipher-mode]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别代码中加密算法所采用的分组密码工作模式，帮助评估加密实现的安全性。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 分组密码工作模式识别\n * @description 识别代码中加密算法所采用的分组密码工作模式，帮助评估加密实现的安全性。\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/block-cipher-mode\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// 导入Python分析所需的库和密码学相关概念\nimport python\nimport semmle.python.Concepts\n\n// 定义变量：cryptoOp表示加密操作，modeOfOperation表示分组密码工作模式\nfrom Cryptography::CryptographicOperation cryptoOp, string modeOfOperation\n\n// 筛选条件：确保加密操作具有分组密码工作模式属性\nwhere modeOfOperation = cryptoOp.getBlockMode()\n\n// 输出检测结果，包括加密操作对象及其分组密码工作模式\nselect \n  cryptoOp, \n  \"检测到使用分组密码工作模式的加密实现: \" + modeOfOperation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name SimpleXMLRPCServer denial of service\n * @description Detects usage of SimpleXMLRPCServer which is vulnerable to XML bomb denial-of-service attacks\n * @kind problem\n * @problem.severity warning\n * @precision high\n * @id py/simple-xml-rpc-server-dos\n * @tags security\n *       experimental\n *       external/cwe/cwe-776\n_______________ // 补全条件\n\n// Import Python library for code analysis\nprivate import python\n\n// Import Semmle Python concepts for language abstractions and patterns\nprivate import semmle.python.Concepts\n\n// Import Semmle API graphs for data flow analysis\nprivate import semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode xmlRpcServerCall\nwhere\n  // Identify vulnerable SimpleXMLRPCServer instantiation\n  exists(API::Node xmlrpcModule |\n    xmlrpcModule = API::moduleImport(\"xmlrpc\") and\n    exists(API::Node serverModule |\n      serverModule = xmlrpcModule.getMember(\"server\") and\n      exists(API::Node serverClass |\n        serverClass = serverModule.getMember(\"SimpleXMLRPCServer\") and\n        xmlRpcServerCall = serverClass.getACall()\n      )\n    )\n  )\nselect xmlRpcServerCall, \"SimpleXMLRPCServer is vulnerable to XML bomb denial-of-service attacks\"",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-padding]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Detects padding mechanisms in asymmetric encryption that are either",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Detects padding mechanisms in asymmetric encryption that are either\n * cryptographically insecure or not explicitly recognized as secure by\n * established cryptographic standards. This query identifies potentially\n * vulnerable padding configurations by allowing only the most robust\n * padding methods (OAEP, KEM, PSS) and flagging all others as security risks.\n * \n * The analysis specifically targets padding implementations that may be\n * susceptible to cryptographic attacks when utilized in asymmetric encryption scenarios.\n * \n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define the set of cryptographically secure padding schemes for asymmetric encryption\n// These padding methods are proven to be resistant against known cryptographic vulnerabilities\nfrom AsymmetricPadding asymmetricPaddingScheme, string paddingAlgorithm\nwhere\n  // Extract the padding algorithm identifier from the implementation\n  paddingAlgorithm = asymmetricPaddingScheme.getPaddingName()\n  // Filter out implementations that utilize approved secure padding methods\n  and not paddingAlgorithm in [\"OAEP\", \"KEM\", \"PSS\"]\nselect asymmetricPaddingScheme, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + paddingAlgorithm"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Direct imports per file\n * @description Measures the count of modules directly imported by each Python file.\n * @kind treemap\n * @id py/direct-imports-per-file\n_______________ // 补全条件\n * @metricType file\n * @metricAggregate avg max\n * @tags modularity\n *       maintainability\n */\n\n// Import the Python analysis framework for AST traversal and module analysis\nimport python\n\n// For each Python module, calculate its direct import count\nfrom ModuleValue analyzedModule, int importCount\nwhere \n  // Compute the number of unique modules directly imported by the analyzed module\n  importCount = count(ModuleValue importedModule | \n                    importedModule = analyzedModule.getAnImportedModule())\n// Output the file scope along with its corresponding direct import count\nselect analyzedModule.getScope(), importCount",
    "output": "* @treemap.warnOn highValues"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure KDF Salt Generation\n * @description Identifies key derivation functions that use salt values not generated by the approved random number generator (os.urandom).\n * @kind problem\n * @id py/kdf-weak-salt-gen\n * @problem.severity error\n * @precision high\n */\n\n// Import core Python language analysis library\nimport python\n// Import experimental cryptography concepts for security analysis\nimport experimental.cryptography.Concepts\n// Import cryptography utilities with alias for helper functions\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n_______________ // 补全条件\nfrom KeyDerivationOperation kdfOperation, DataFlow::Node saltOrigin\nwhere\n  // Condition 1: The KDF operation requires a salt parameter\n  kdfOperation.requiresSalt() and\n  // Condition 2: The salt source is not from the approved os.urandom function\n  not saltOrigin = API::moduleImport(\"os\").getMember(\"urandom\").getACall() and\n  // Condition 3: The salt source is used as the salt configuration for this KDF\n  saltOrigin = kdfOperation.getSaltConfigSrc()\n// Report the security issue with details about the weak salt source\nselect kdfOperation, \"Salt configuration is not from an accepted random source: $@. Must be os.urandom\",\n  saltOrigin, saltOrigin.toString()",
    "output": "// Main query to identify KDF operations with insecure salt generation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-low-iteration-count]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies key derivation functions using iteration counts below 100k threshold",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insufficient KDF iteration count vulnerability\n * @description Identifies key derivation functions using iteration counts below 100k threshold\n * \n * This security query detects cryptographic key derivation operations that utilize iteration\n * counts below the recommended security threshold of 10000 iterations. Such configurations\n * are susceptible to brute force attacks. Additionally, the query flags scenarios where\n * the iteration count cannot be statically analyzed at compile time.\n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import core Python analysis capabilities\nimport python\n// Import cryptographic primitives and concepts for key derivation analysis\nimport experimental.cryptography.Concepts\n// Import cryptographic utility functions and helpers\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Main query logic: Detect vulnerable key derivation function configurations\nfrom KeyDerivationOperation kdfOperation, string alertMessage, DataFlow::Node iterationParamSource\nwhere\n  // Filter for KDF operations that require iteration parameters\n  kdfOperation.requiresIteration() and\n  \n  // Extract the source node providing the iteration count configuration\n  iterationParamSource = kdfOperation.getIterationSizeSrc() and\n  \n  // Analyze iteration count configuration for security vulnerabilities\n  (\n    // Vulnerability scenario 1: Explicit integer literal with insufficient value\n    exists(iterationParamSource.asExpr().(IntegerLiteral).getValue()) and\n    iterationParamSource.asExpr().(IntegerLiteral).getValue() < 10000 and\n    alertMessage = \"Insufficient iteration count detected. \"\n    \n    // Vulnerability scenario 2: Non-statically determinable iteration count\n    or\n    not exists(iterationParamSource.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Iteration count cannot be statically verified. \"\n  )\nselect \n  // Report format: vulnerable operation, detailed warning with configuration reference, and the configuration expression\n  kdfOperation, alertMessage + \"Minimum required iterations: 10000. Configuration source: $@\",\n  iterationParamSource.asExpr(), iterationParamSource.asExpr().toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects and reports all occurrences of padding techniques used within asymmetric encryption algorithms.\n * @kind problem\n * @id py/quantum-readiness/cbom/asymmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python  // 导入Python库，用于分析Python代码\nimport experimental.cryptography.Concepts  // 导入实验性加密概念库，用于处理加密相关的概念\n\n// 查询所有非对称加密填充方案实例\nfrom AsymmetricPadding cryptoPadding\n\n// 输出填充方案对象及其描述信息\nselect cryptoPadding, \"Identified asymmetric padding method: \" + cryptoPadding.getPaddingName()",
    "output": "* @name Identification of Asymmetric Cryptographic Padding Methods"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/undefined-placeholder-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of placeholder variables before they are properly initialized,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of an undefined placeholder variable\n * @description Detects usage of placeholder variables before they are properly initialized,\n *              which can lead to runtime exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/undefined-placeholder-variable\n */\n\nimport python\nimport Variables.MonkeyPatched\n\n// Check if the placeholder is initialized as a local variable within its scope\npredicate is_local_initialized(PlaceHolder varUse) {\n  exists(SsaVariable localVar, Function containingFunction | \n    containingFunction = varUse.getScope() and \n    localVar.getAUse() = varUse.getAFlowNode() |\n    localVar.getVariable() instanceof LocalVariable and\n    not localVar.maybeUndefined()\n  )\n}\n\n// Retrieve the enclosing class for a placeholder variable usage\nClass get_enclosing_class(PlaceHolder varUse) { \n  result.getAMethod() = varUse.getScope() \n}\n\n// Determine if the placeholder corresponds to a template attribute\npredicate is_template_attr(PlaceHolder varUse) {\n  exists(ImportTimeScope classScope | \n    classScope = get_enclosing_class(varUse) | \n    classScope.definesName(varUse.getId())\n  )\n}\n\n// Verify that the placeholder is not a global variable or a monkey-patched builtin\npredicate is_not_global_var(PlaceHolder varUse) {\n  not exists(PythonModuleObject moduleObj |\n    moduleObj.hasAttribute(varUse.getId()) and \n    moduleObj.getModule() = varUse.getEnclosingModule()\n  ) and\n  not globallyDefinedName(varUse.getId()) and\n  not monkey_patched_builtin(varUse.getId()) and\n  not globallyDefinedName(varUse.getId())\n}\n\n// Main query: Identify and report potentially undefined placeholder variable usages\nfrom PlaceHolder placeholderVar\nwhere\n  not is_local_initialized(placeholderVar) and // Exclude locally initialized variables\n  not is_template_attr(placeholderVar) and     // Exclude template attributes\n  is_not_global_var(placeholderVar)           // Exclude global variables\nselect placeholderVar, \"This use of place-holder variable '\" + placeholderVar.getId() + \"' may be undefined.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Syntax error detection\n * @description Identifies syntax errors that lead to runtime failures and hinder code analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n_______________ // 补全条件\n\n// Import Python library for code analysis and query processing\nimport python\n\n// Select syntax error instances, excluding encoding-related errors\nfrom SyntaxError syntaxIssue\nwhere not syntaxIssue instanceof EncodingError\nselect syntaxIssue, syntaxIssue.getMessage() + \" (in Python \" + major_version() + \").\"\n// Output syntax error details along with the current Python major version information",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-star-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python files that use wildcard imports ('from ... import *'), which can cause namespace pollution and reduce code maintainability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Wildcard Import Detection\n * @description Identifies Python files that use wildcard imports ('from ... import *'), which can cause namespace pollution and reduce code maintainability.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// Import the necessary Python analysis module for code inspection\nimport python\n\n// Source of wildcard imports in Python code\nfrom ImportStar wildcardImport\n// Generate an alert for each instance of wildcard import usage\nselect wildcardImport, \"Using 'from ... import *' pollutes the namespace.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name points-to fails for expression.\n * @description Expression does not \"point-to\" an object which prevents type inference.\n * @kind problem\n * @id py/points-to-failure\n * @problem.severity info\n_______________ // 补全条件\n * @deprecated\n */\n\n// Import Python analysis module for code inspection\nimport python\n\n// Locate expressions lacking object references\nfrom Expr exprWithoutRef\nwhere exists(ControlFlowNode cfNode | \n    // Establish connection between expression and its control flow node\n    cfNode = exprWithoutRef.getAFlowNode() and\n    // Verify the control flow node has no object reference\n    not cfNode.refersTo(_)\n)\n// Report the expression with appropriate diagnostic message\nselect exprWithoutRef, \"Expression does not 'point-to' any object.\"",
    "output": "* @tags debug"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/missing-docstring]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Lack of documentation strings in public classes, functions,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Missing docstring\n * @description Lack of documentation strings in public classes, functions, \n *              or methods impedes code maintainability, as it becomes difficult \n *              for other developers to understand the code's purpose and usage.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/missing-docstring\n */\n\n/*\n * Note: This query exhibits medium precision since the necessity of a docstring \n * is inherently subjective. The requirement frequently depends on the code's context \n * and its target audience.\n */\n\nimport python\n\n// Determines if a scope requires documentation\npredicate needsDocumentation(Scope currentScope) {\n  currentScope.isPublic() and\n  (\n    not currentScope instanceof Function\n    or\n    functionRequiresDoc(currentScope)\n  )\n}\n\n// Determines if a function requires documentation\npredicate functionRequiresDoc(Function functionObj) {\n  // Exclude lambda functions\n  functionObj.getName() != \"lambda\" and\n  // Calculate actual code lines (excluding decorators)\n  (functionObj.getMetrics().getNumberOfLinesOfCode() - count(functionObj.getADecorator())) > 2 and\n  // Ensure it's not a property getter/setter\n  not exists(PythonPropertyObject prop |\n    prop.getGetter().getFunction() = functionObj or\n    prop.getSetter().getFunction() = functionObj\n  ) and\n  // Validate override documentation requirements\n  not exists(FunctionValue overrideFunc, FunctionValue baseFuncObj | \n    overrideFunc.overrides(baseFuncObj) and overrideFunc.getScope() = functionObj |\n    not functionRequiresDoc(baseFuncObj.getScope())\n  )\n}\n\n// Returns the type name of a scope (Module, Class, or Function)\nstring getScopeTypeName(Scope currentScope) {\n  // Handle non-package modules\n  result = \"Module\" and currentScope instanceof Module and not currentScope.(Module).isPackage()\n  or\n  // Handle classes\n  result = \"Class\" and currentScope instanceof Class\n  or\n  // Handle functions\n  result = \"Function\" and currentScope instanceof Function\n}\n\n// Identifies scopes requiring documentation but missing it\nfrom Scope currentScope\nwhere needsDocumentation(currentScope) and not exists(currentScope.getDocString())\nselect currentScope, getScopeTypeName(currentScope) + \" \" + currentScope.getName() + \" does not have a docstring.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Vulnerable hostname regular expression patterns\n * @description Identifies security weaknesses in regular expressions used for URL/hostname validation where dots are not properly escaped, resulting in overly permissive hostname matching.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-hostname-regexp\n * @tags correctness\n *       security\n *       external/cwe/cwe-020\n */\n\n// Import specialized library for analyzing security of hostname regular expressions\nprivate import semmle.python.security.regexp.HostnameRegex as HostnameRegexChecker\n\n/**\n * This predicate detects security vulnerabilities in hostname regular expressions.\n * It identifies patterns where dots are not properly escaped, which could lead\n_______________ // 补全条件\n */\nquery predicate insecureHostnameRegexPatterns = HostnameRegexChecker::incompleteHostnameRegExp/4;",
    "output": "* to overly permissive hostname matching and potential security bypasses."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/call-graph]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and represents edges in the call graph, connecting function call sites with their corresponding callable targets.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Call graph\n * @description Identifies and represents edges in the call graph, connecting function call sites with their corresponding callable targets.\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/call-graph\n * @tags meta\n * @precision very-low\n */\n\n// Import Python language support\nimport python\n// Import internal data flow analysis utilities\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n// Import meta metrics utilities\nimport meta.MetaMetrics\n\n// Define variables representing call sites and their target callables\nfrom DataFlowCall callSite, DataFlowCallable targetCallable\nwhere\n  // Establish valid call relationship between site and target\n  targetCallable = viableCallable(callSite)\n  // Filter out call sites located in ignored files\n  and not callSite.getLocation().getFile() instanceof IgnoredFile\n  // Filter out target callables defined in ignored files\n  and not targetCallable.getScope().getLocation().getFile() instanceof IgnoredFile\nselect callSite, \"Call to $@\", targetCallable.getScope(), targetCallable.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：使用 super() 访问继承的方法在旧式类中是不被支持的。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description 使用 super() 访问继承的方法在旧式类中是不被支持的。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * 检测在旧式类中使用 super() 调用的情况。\n * 在 Python 中，旧式类不支持使用 super() 访问继承的方法，这会导致运行时错误。\n */\npredicate isSuperCallInOldStyleClass(Call superCallExpr) {\n  exists(Function enclosingMethod, ClassObject enclosingClass |\n    // 确认调用的是 super 函数\n    superCallExpr.getFunc().(Name).getId() = \"super\" and\n    // super() 调用必须位于方法内部\n    superCallExpr.getScope() = enclosingMethod and\n    // 方法必须定义在类内部\n    enclosingMethod.getScope() = enclosingClass.getPyClass() and\n    // 确保类的类型推断成功\n    not enclosingClass.failedInference() and\n    // 确认类是旧式类（非新式类）\n    not enclosingClass.isNewStyle()\n  )\n}\n\nfrom Call superCallExpr\nwhere isSuperCallInOldStyleClass(superCallExpr)\nselect superCallExpr, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-commented-out-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Counts the number of lines containing commented-out code for each file",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lines of commented-out code in files\n * @description Counts the number of lines containing commented-out code for each file\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// Import necessary modules for Python language support and lexical analysis of commented code\nimport python\nimport Lexical.CommentedOutCode\n\n// Declare variables representing target files and their respective commented code line counts\nfrom File targetFile, int commentedCodeLines\n// Filter files and calculate the total count of non-example commented code lines per file\nwhere commentedCodeLines = count(CommentedOutCodeLine commentedOutLine | \n        // Exclude lines that might be example code\n        not commentedOutLine.maybeExampleCode() and \n        // Ensure the commented line belongs to the current file being analyzed\n        commentedOutLine.getLocation().getFile() = targetFile)\n// Output the files with their commented code line counts, sorted in descending order\nselect targetFile, commentedCodeLines order by commentedCodeLines desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a module imports itself",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description Detects when a module imports itself\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n/**\n * Identifies self-importing modules by comparing importing and imported modules.\n * @param importStmt - The import statement being analyzed\n * @param importedModule - The module being imported\n * @returns True when the importing module matches the imported module\n */\npredicate modules_imports_itself(ImportingStmt importStmt, ModuleValue importedModule) {\n  // Verify the importing module's scope matches the target module's scope\n  importStmt.getEnclosingModule() = importedModule.getScope() and\n  // Resolve the imported module name to its corresponding ModuleValue\n  importedModule =\n    max(string moduleName, ModuleValue moduleCandidate |\n      moduleName = importStmt.getAnImportedModuleName() and\n      moduleCandidate.importedAs(moduleName)\n    |\n      moduleCandidate order by moduleName.length()\n    )\n}\n\n// Identify all instances where modules import themselves\nfrom ImportingStmt importStmt, ModuleValue importedModule\nwhere modules_imports_itself(importStmt, importedModule)\nselect importStmt, \"The module '\" + importedModule.getName() + \"' imports itself.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the total lines of code in each file (excluding lines that",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File Code Line Count\n * @kind treemap\n * @description Calculates the total lines of code in each file (excluding lines that\n *              only contain docstrings, comments or whitespace).\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n * @id py/lines-of-code-in-files\n */\n\nimport python\n\n// Select each Python module and compute its effective code line count\nfrom Module sourceFile, int codeLineCount\nwhere \n  // Obtain the count of non-trivial code lines (excluding comments/whitespace)\n  codeLineCount = sourceFile.getMetrics().getNumberOfLinesOfCode()\n// Output modules with their line counts in descending order\nselect sourceFile, codeLineCount order by codeLineCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression analysis\n * @description Identifies and evaluates alert suppression mechanisms in Python code\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing utilities\nprivate import semmle.python.Comment as PythonComment\n\n// Represents a single-line Python comment with location tracking\nclass SingleLineComment instanceof PythonComment::Comment {\n  // Check if comment has specific location details\n  predicate hasLocationInfo(\n    string sourceFilePath, int beginLine, int beginColumn, int endLine, int endColumn\n  ) {\n    // Validate location matches parent class information\n    super.getLocation().hasLocationInfo(sourceFilePath, beginLine, beginColumn, endLine, endColumn)\n  }\n\n  // Get the text content of the comment\n  string getText() { result = super.getContents() }\n\n  // Get string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Represents a Python AST node with location capabilities\nclass AstNode instanceof PythonComment::AstNode {\n  // Verify node has specific positional information\n  predicate hasLocationInfo(\n    string sourceFilePath, int beginLine, int beginColumn, int endLine, int endColumn\n  ) {\n    // Confirm location aligns with parent class data\n    super.getLocation().hasLocationInfo(sourceFilePath, beginLine, beginColumn, endLine, endColumn)\n  }\n\n  // Generate string representation of AST node\n  string toString() { result = super.toString() }\n}\n\n// Establish suppression relationships between AST nodes and comments\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * Suppression comment using noqa directive. Recognized by pylint and pyflakes linters,\n * and therefore supported by lgtm as well.\n */\n// Represents a suppression comment following noqa convention\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Constructor verifying comment matches noqa pattern\n  NoqaSuppressionComment() {\n    // Identify comments with case-insensitive noqa directive and optional suffix\n    super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Get annotation identifier for this suppression\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define code scope covered by this suppression directive\n  override predicate covers(\n    string sourceFilePath, int beginLine, int beginColumn, int endLine, int endColumn\n  ) {\n    // Extract comment location and ensure it starts at first column\n    this.hasLocationInfo(sourceFilePath, beginLine, _, endLine, endColumn) and\n_______________ // 补全条件\n  }\n}",
    "output": "beginColumn = 1"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-lines-deleted]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the total number of lines deleted for each file throughout its revision history.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Deleted lines per file\n * @description Calculates the total number of lines deleted for each file throughout its revision history.\n *               This metric helps identify files that have undergone significant refactoring or removal of code.\n * @kind treemap\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\n// Select file modules and their corresponding deletion counts\nfrom Module fileModule, int totalDeletedLines\nwhere\n  // Calculate total deletions for each file across commit history\n  totalDeletedLines = \n    sum(Commit commit, int deletedLines |\n      // Get deletion count from most recent commit for the file\n      deletedLines = commit.getRecentDeletionsForFile(fileModule.getFile()) and\n      // Exclude artificial changes from the calculation\n      not artificialChange(commit)\n    |\n      deletedLines\n    ) and\n  // Ensure the module has available code metrics\n  exists(fileModule.getMetrics().getNumberOfLinesOfCode())\nselect fileModule, totalDeletedLines order by totalDeletedLines desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 类构造函数参数数量不匹配\n * @description 检测类实例化时提供给 `__init__` 方法的参数数量与定义不符的情况，\n *              这种情况会导致运行时 TypeError 异常。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstantiation, ClassValue targetClass, string errorMessage, string constraintType, int expectedArgumentCount, FunctionValue initializerMethod\nwhere\n  // 获取目标类的初始化方法（构造函数）\n  initializerMethod = get_function_or_initializer(targetClass) and\n  (\n    // 处理参数数量过多的情况\n    too_many_args(classInstantiation, targetClass, expectedArgumentCount) and\n    errorMessage = \"too many arguments\" and\n    constraintType = \"no more than \"\n    or\n    // 处理参数数量过少的情况\n    too_few_args(classInstantiation, targetClass, expectedArgumentCount) and\n_______________ // 补全条件\n    constraintType = \"no fewer than \"\n  )\nselect classInstantiation, \n  \"Call to $@ with \" + errorMessage + \"; should be \" + constraintType + expectedArgumentCount.toString() + \".\", \n  initializerMethod,\n  initializerMethod.getQualifiedName()",
    "output": "errorMessage = \"too few arguments\" and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/function-display-strings]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Display strings of callables",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Display strings of callables\n * @kind display-string\n * @id py/function-display-strings\n * @metricType callable\n */\n\n// 导入Python分析库，提供对Python代码结构的访问能力\nimport python\n\n// 查询所有Python函数对象\nfrom Function func\n// 构造函数的显示字符串\nselect func, \"Function \" + func.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name NotImplemented is not an Exception\n * @description Detects improper use of 'NotImplemented' in raise statements.\n *              This causes type errors since NotImplemented is not an exception class.\n_______________ // 补全条件\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom Expr problematicExpr, Raise raiseStatement\nwhere use_of_not_implemented_in_raise(raiseStatement, problematicExpr)\nselect problematicExpr, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\"",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-callable called\n * @description Detects calls to objects that are not callable, which would result in a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python  // 导入Python代码分析库\nimport Exceptions.NotImplemented  // 导入NotImplemented异常处理模块\n\n// 定义查询变量：调用表达式、目标值、目标类、函数引用和值来源\nfrom Call callExpr, Value targetValue, ClassValue targetClass, Expr functionReference, AstNode valueOrigin\nwhere\n  // 步骤1：获取调用表达式及其引用的函数\n  functionReference = callExpr.getFunc() and\n  functionReference.pointsTo(targetValue, valueOrigin) and\n  \n  // 步骤2：确定目标值的类并验证其不可调用性\n  targetClass = targetValue.getClass() and\n  not targetClass.isCallable() and\n  \n  // 步骤3：排除已知的误报情况\n  (\n_______________ // 补全条件\n    not targetClass.failedInference(_) and\n    // 排除描述符对象（有__get__属性的对象）\n    not targetClass.hasAttribute(\"__get__\") and\n    // 排除None值\n    not targetValue = Value::named(\"None\") and\n    // 排除在raise语句中使用NotImplemented的情况\n    not use_of_not_implemented_in_raise(_, functionReference)\n  )\nselect callExpr, \"Call to a $@ of $@.\", valueOrigin, \"non-callable\", targetClass, targetClass.toString()",
    "output": "// 确保类型推断成功"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-block-mode]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies symmetric encryption block modes that are considered weak, deprecated, or non-compliant with security standards.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak block mode\n * @description Identifies symmetric encryption block modes that are considered weak, deprecated, or non-compliant with security standards.\n * @id py/weak-block-mode\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Select encryption artifacts and their corresponding security alerts\nfrom CryptographicArtifact encryptionArtifact, string securityAlert\nwhere\n  // Exclude false positives from cryptography/hazmat paths\n  // This specifically addresses cases where ECB is used internally within keywrap operations\n  not exists(string artifactPath |\n    artifactPath = encryptionArtifact.asExpr()\n        .getLocation()\n        .getFile()\n        .getAbsolutePath()\n        .toString() and\n    artifactPath.matches(\"%cryptography/hazmat/%\")\n  ) and\n  (\n    // Case 1: BlockMode instances with potentially weak configurations\n    encryptionArtifact instanceof BlockMode and\n    // ECB mode is only permitted for KeyWrapOperations\n    (encryptionArtifact.(BlockMode).getBlockModeName() = \"ECB\" implies not encryptionArtifact instanceof KeyWrapOperation) and\n    // Check if the block mode is weak or unapproved\n    exists(string modeName | \n      modeName = encryptionArtifact.(BlockMode).getBlockModeName() and\n      // Only allow CBC, CTS, and XTS modes as per security requirements\n      // Reference: https://liquid.microsoft.com/Web/Object/Read/MS.Security/Requirements/Microsoft.Security.Cryptography.10002\n      not modeName = [\"CBC\", \"CTS\", \"XTS\"] and\n      // Generate appropriate security alert based on the block mode\n      (\n        modeName = unknownAlgorithm() and\n        securityAlert = \"Use of unrecognized block mode algorithm.\"\n        or\n        modeName in [\"GCM\", \"CCM\"] and\n        securityAlert = \"Use of block mode algorithm \" + modeName + \" requires special crypto board approval/review.\"\n        or\n        securityAlert = \"Use of unapproved block mode algorithm or API \" + modeName + \".\"\n      )\n    )\n    or\n    // Case 2: SymmetricCipher instances without a specified block mode\n    encryptionArtifact instanceof SymmetricCipher and\n    not encryptionArtifact.(SymmetricCipher).hasBlockMode() and\n    securityAlert = \"Cipher has unspecified block mode algorithm.\"\n  )\nselect encryptionArtifact, securityAlert"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode detection\n * @description This query identifies symmetric encryption operations that utilize weak, obsolete, \n *              or otherwise unapproved block modes, which could lead to security vulnerabilities.\n * @id py/weak-block-mode\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Select cryptographic operations and generate appropriate alert messages\nfrom CryptographicArtifact encryptionOperation, string securityAlert\nwhere\n  // Exclude false positives from projects that include the entire cryptography module\n  // Filter out results matching the cryptography/hazmat path\n  // Particularly important for ECB usage within keywrap operations\n  not encryptionOperation.asExpr()\n      .getLocation()\n      .getFile()\n      .getAbsolutePath()\n      .toString()\n      .matches(\"%cryptography/hazmat/%\") and\n  (\n    // Case 1: Check if the operation is a BlockMode instance\n    encryptionOperation instanceof BlockMode and\n    // ECB mode is only allowed for KeyWrapOperations, so alert if ECB is not part of a KeyWrapOperation\n    (encryptionOperation.(BlockMode).getBlockModeName() = \"ECB\" implies not encryptionOperation instanceof KeyWrapOperation) and\n    exists(string modeIdentifier | modeIdentifier = encryptionOperation.(BlockMode).getBlockModeName() |\n      // Only CBC, CTS, and XTS modes are approved\n      // Reference: https://liquid.microsoft.com/Web/Object/Read/MS.Security/Requirements/Microsoft.Security.Cryptography.10002\n      not modeIdentifier = [\"CBC\", \"CTS\", \"XTS\"] and\n      // Generate appropriate alert message based on the mode type\n      (\n        modeIdentifier = unknownAlgorithm() and\n        securityAlert = \"Use of unrecognized block mode algorithm.\"\n        or\n        modeIdentifier in [\"GCM\", \"CCM\"] and\n        securityAlert = \"Use of block mode algorithm \" + modeIdentifier + \" requires special crypto board approval/review.\"\n        or\n        securityAlert = \"Use of unapproved block mode algorithm or API \" + modeIdentifier + \".\"\n      )\n_______________ // 补全条件\n    or\n    // Case 2: Check if the operation is a SymmetricCipher instance without a specified block mode algorithm\n    encryptionOperation instanceof SymmetricCipher and\n    not encryptionOperation.(SymmetricCipher).hasBlockMode() and\n    securityAlert = \"Cipher has unspecified block mode algorithm.\"\n  )\nselect encryptionOperation, securityAlert",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks on substrings of unparsed URLs are vulnerable to bypass\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Returns regex pattern for common top-level domains used in URL validation\nprivate string getCommonTldPattern() { result = \"com|org|edu|gov|uk|net|io\" }\n\n// Checks if string literal matches URL structure patterns\npredicate resemblesUrl(StringLiteral urlStr) {\n  exists(string text | text = urlStr.getText() |\n    text.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + getCommonTldPattern() +\n        \")(:[0-9]+)?/?\")\n    or\n    text.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Detects unsafe startswith checks for URL validation\n_______________ // 补全条件\n  callNode.getFunc().(Attribute).getName() = \"startswith\" and\n  callNode.getArg(0) = urlStr and\n  not urlStr.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n}\n\n// Detects unsafe endswith checks for URL validation\npredicate hasUnsafeEndswithCheck(Call callNode, StringLiteral urlStr) {\n  callNode.getFunc().(Attribute).getName() = \"endswith\" and\n  callNode.getArg(0) = urlStr and\n  not urlStr.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n}\n\n// Identifies incomplete sanitization operations on URL substrings\npredicate hasIncompleteUrlSanitization(Expr sanitOp, StringLiteral urlStr) {\n  resemblesUrl(urlStr) and\n  (\n    sanitOp.(Compare).compares(urlStr, any(In i), _)\n    or\n    hasUnsafeStartswithCheck(sanitOp, urlStr)\n    or\n    hasUnsafeEndswithCheck(sanitOp, urlStr)\n  )\n}\n\n// Main query: Find expressions with incomplete URL substring sanitization\nfrom Expr sanitOp, StringLiteral urlStr\nwhere hasIncompleteUrlSanitization(sanitOp, urlStr)\nselect sanitOp, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlStr,\n  urlStr.getText()",
    "output": "predicate hasUnsafeStartswithCheck(Call callNode, StringLiteral urlStr) {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/member-test-non-container]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies membership tests (e.g., 'item in sequence') where the right-hand side",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Membership test with a non-container\n * @description Identifies membership tests (e.g., 'item in sequence') where the right-hand side \n *              is a non-container object, which would raise a 'TypeError' at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n * Determines if a node serves as the right operand in an In/NotIn comparison.\n * @param candidateNode - The control flow node being evaluated\n * @param comparisonExpr - The comparison expression containing the operation\n */\npredicate isRightHandSideOfInTest(ControlFlowNode candidateNode, Compare comparisonExpr) {\n  exists(Cmpop operation, int operandIndex |\n    comparisonExpr.getOp(operandIndex) = operation and \n    comparisonExpr.getComparator(operandIndex) = candidateNode.getNode() and\n    (operation instanceof In or operation instanceof NotIn)\n  )\n}\n\nfrom \n  ControlFlowNode rhsNode, \n  Compare membershipTest, \n  Value pointedValue, \n  ClassValue valueClass, \n  ControlFlowNode originNode\nwhere\n  // Identify In/NotIn operations with the node as right operand\n  isRightHandSideOfInTest(rhsNode, membershipTest) and\n  \n  // Resolve the node's pointed value and its class\n  rhsNode.pointsTo(_, pointedValue, originNode) and\n  pointedValue.getClass() = valueClass and\n  \n  // Exclude cases where type inference failed\n  not Types::failedInference(valueClass, _) and\n  \n  // Verify the class lacks container-like capabilities\n  not valueClass.hasAttribute(\"__contains__\") and\n  not valueClass.hasAttribute(\"__iter__\") and\n  not valueClass.hasAttribute(\"__getitem__\") and\n  \n  // Exclude special types that might appear as containers\n  not valueClass = ClassValue::nonetype() and\n  not valueClass = Value::named(\"types.MappingProxyType\")\nselect \n  membershipTest, \n  \"This test may raise an Exception as the $@ may be of non-container class $@.\", \n  originNode, \"target\", valueClass, valueClass.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Redundant comparison\n * @description The result of a comparison is implied by a previous comparison.\n * @kind problem\n * @tags useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/redundant-comparison\n */\n\nimport python\nimport semmle.python.Comparisons\n\n/**\n * Checks whether a comparison expression has a complicated structure that includes\n * multiple operators. This covers chained comparisons like 'a < x < y' or nested unary expressions.\n */\nprivate predicate hasComplexStructure(Expr cmpExpr) {\n  // Verify if the comparison contains multiple operators (chained comparison)\n  exists(cmpExpr.(Compare).getOp(1))\n  or\n  // Recursively verify if the operand of a unary expression has complex structure\n  hasComplexStructure(cmpExpr.(UnaryExpr).getOperand())\n}\n\n/**\n * Recognizes a test as redundant when there's a more restrictive condition that already\n * controls the flow for the same block. Complex chained comparisons are omitted\n * due to flow analysis limitations.\n */\nprivate predicate isRedundantComparison(Comparison cmpNode, ComparisonControlBlock ctrlBlock, boolean evalResult) {\n  // The control block implies the result of the comparison\n  ctrlBlock.impliesThat(cmpNode.getBasicBlock(), cmpNode, evalResult) and\n  // Exclude complex chained comparisons as they may not have precise flow analysis\n  not hasComplexStructure(ctrlBlock.getTest().getNode())\n}\n\n/**\n * Links AST nodes containing redundant comparisons with their associated conditions.\n */\nprivate predicate hasRedundantComparisonInAST(AstNode astNode, AstNode condNode, boolean evalResult) {\n  forex(Comparison cmpNode, ConditionBlock condBlock |\n    // The AST node corresponds to a comparison node\n    cmpNode.getNode() = astNode and\n    // The associated condition corresponds to the last node in a condition block\n    condBlock.getLastNode().getNode() = condNode\n  |\n    // Verify if the comparison is redundant\n    isRedundantComparison(cmpNode, condBlock, evalResult)\n  )\n}\n\nfrom Expr testExpr, Expr relatedCondition, boolean evaluatesToTrue\nwhere\n  // Identify redundant tests, ensuring their child nodes are not also redundant\n  hasRedundantComparisonInAST(testExpr, relatedCondition, evaluatesToTrue) and \n  not hasRedundantComparisonInAST(testExpr.getAChildNode+(), relatedCondition, _)\nselect testExpr, \"Test is always \" + evaluatesToTrue + \", because of $@.\", relatedCondition, \"this condition\"",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Deleted lines per file\n * @description Computes the cumulative count of lines removed from each Python file\n *              across the complete version control history in the database.\n * @kind treemap\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n_______________ // 补全条件\nimport python\nimport external.VCS\n\n// Analysis to identify Python modules and aggregate their deletion statistics\nfrom Module sourceFile, int totalDeletions\nwhere\n  // Ensure the module has quantifiable code prior to processing\n  exists(sourceFile.getMetrics().getNumberOfLinesOfCode()) and\n  // Calculate the aggregate number of lines deleted across all valid commits\n  totalDeletions = sum(\n    // Nested query to collect deletion metrics from each applicable commit\n    Commit versionCommit, int commitDeletions |\n      // Establish the number of lines eliminated in this particular commit\n      commitDeletions = versionCommit.getRecentDeletionsForFile(sourceFile.getFile()) and\n      // Exclude commits that are synthetic or insignificant\n      not artificialChange(versionCommit)\n    |\n      // Sum the deletion metrics\n      commitDeletions\n  )\n// Display results sorted by deletion count in descending sequence\nselect sourceFile, totalDeletions order by totalDeletions desc",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/afferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Analyzes and quantifies the number of external classes depending on each target class.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incoming class dependencies analysis\n * @description Analyzes and quantifies the number of external classes depending on each target class. \n *              Higher values indicate classes with more incoming dependencies, impacting modularity.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// Extract classes with measurable incoming dependencies\nfrom ClassMetrics targetClass\nwhere exists(targetClass.getAfferentCoupling())\n// Display each target class and its incoming dependency count, sorted by highest values first\nselect targetClass, \n       targetClass.getAfferentCoupling() as incomingDependencyCount \norder by incomingDependencyCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-inference-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cases where type inference is incomplete for object instances,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type inference fails for 'object'\n * @description Detects cases where type inference is incomplete for object instances,\n *              potentially reducing security analysis effectiveness. This pattern manifests\n *              when control flow nodes reference objects without utilizing the comprehensive\n *              3-argument type specification form.\n * @kind problem\n * @problem.severity info\n * @id py/type-inference-failure\n * @deprecated\n */\n\nimport python\n\nfrom ControlFlowNode flowNode, Object objInstance\nwhere \n  // Identify control flow nodes that have references to object instances\n  flowNode.refersTo(objInstance) \n  // Exclude nodes that provide complete type information via 3-argument form\n  and not flowNode.refersTo(objInstance, _, _)\nselect objInstance, \"Type inference fails for 'object'.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when an attribute set in a superclass's __init__ method",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description Detects when an attribute set in a superclass's __init__ method \n *              unintentionally hides a method defined in a subclass, potentially causing runtime errors.\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * This query identifies subclass methods that become inaccessible due to \n * attribute assignments in superclass initializers, which may lead to \n * unexpected behavior when method resolution order is affected.\n */\n\nimport python\n\n// Predicate detecting subclass methods hidden by superclass attributes\npredicate method_hidden_by_super_attr(\n  ClassObject subCls, ClassObject superCls, Assign attrAssign, FunctionObject hiddenMethod\n) {\n  // Establish inheritance relationship\n  subCls.getASuperType() = superCls and\n  // Verify subclass contains the hidden method\n  subCls.declaredAttribute(_) = hiddenMethod and\n  // Find superclass __init__ containing the shadowing attribute\n  exists(FunctionObject superInit |\n    superCls.declaredAttribute(\"__init__\") = superInit and\n    // Identify attribute assignment that causes shadowing\n    exists(Attribute assignedAttr |\n      assignedAttr = attrAssign.getATarget() and\n      // Confirm assignment targets 'self' instance\n      assignedAttr.getObject().(Name).getId() = \"self\" and\n      // Match attribute name with hidden method name\n      assignedAttr.getName() = hiddenMethod.getName() and\n      // Ensure assignment occurs within __init__ scope\n      attrAssign.getScope() = superInit.getOrigin().(FunctionExpr).getInnerScope()\n    )\n  ) and\n  // Exclude cases where superclass defines the same method\n  not superCls.hasAttribute(hiddenMethod.getName())\n}\n\n// Query to identify shadowed methods and their source attributes\nfrom ClassObject subCls, ClassObject superCls, Assign attrAssign, FunctionObject hiddenMethod\nwhere method_hidden_by_super_attr(subCls, superCls, attrAssign, hiddenMethod)\n// Output: hidden method location, detailed message, attribute assignment location\nselect hiddenMethod.getOrigin(),\n  \"Method \" + hiddenMethod.getName() + \" is shadowed by $@ in superclass '\" + superCls.getName() +\n    \"'.\", attrAssign, \"attribute\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call-to-non-callable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects calls to objects that are not callable, which would result in a TypeError at runtime.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-callable called\n * @description Detects calls to objects that are not callable, which would result in a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python\nimport Exceptions.NotImplemented\n\n// 查找所有调用非可调用对象的代码位置\nfrom Call invocationNode, Value calledValue, ClassValue calledClass, Expr functionExpr, AstNode valueSource\nwhere\n  // 获取调用表达式及其指向的值\n  functionExpr = invocationNode.getFunc() and\n  functionExpr.pointsTo(calledValue, valueSource) and\n  \n  // 确定目标值的类并验证其不可调用性\n  calledClass = calledValue.getClass() and\n  not calledClass.isCallable() and\n  \n  // 排除特殊情况以减少误报\n  not calledClass.failedInference(_) and  // 确保类型推断成功\n  not calledClass.hasAttribute(\"__get__\") and  // 排除描述符协议对象\n  not calledValue = Value::named(\"None\") and  // 排除对None的调用\n  not use_of_not_implemented_in_raise(_, functionExpr)  // 排除raise语句中的NotImplemented\nselect invocationNode, \"Call to a $@ of $@.\", valueSource, \"non-callable\", calledClass, calledClass.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__init__` method returns a value\n_______________ // 补全条件\n *              and should not explicitly return any value (it implicitly returns None).\n *              Returning a non-None value from `__init__` will raise a TypeError.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/explicit-return-in-init\n */\n\nimport python\n\n// 查找所有位于__init__方法中的Return语句\nfrom Return returnStmt, Expr returnValueExpr\nwhere\n  // 确保Return语句位于__init__方法中\n  exists(Function initMethod | \n    initMethod.isInitMethod() and \n    returnStmt.getScope() = initMethod\n  ) and\n  // 获取Return语句的返回值表达式\n  returnStmt.getValue() = returnValueExpr and\n  // 确保返回值不是None\n  not returnValueExpr.pointsTo(Value::none_()) and\n  // 排除那些永远不会返回的函数调用\n  not exists(FunctionValue funcValue | \n    funcValue.getACall() = returnValueExpr.getAFlowNode() | \n    funcValue.neverReturns()\n  ) and\n  // 避免重复报告，如果返回结果来自其他__init__函数则不触发\n  not exists(Attribute methodAttr | \n    methodAttr = returnValueExpr.(Call).getFunc() | \n    methodAttr.getName() = \"__init__\"\n  )\n// 选择Return语句并标记问题\nselect returnStmt, \"Explicit return in __init__ method.\"",
    "output": "* @description In Python, the `__init__` method should only initialize an object instance"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/syntax-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python syntax errors that could cause runtime failures",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Syntax error detection\n * @description Detects Python syntax errors that could cause runtime failures\n *              and hinder static analysis. This query excludes encoding-related\n *              issues to focus specifically on actual syntax problems.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import the Python module for analyzing source code\nimport python\n\n// Find syntax errors in Python source files\nfrom SyntaxError syntaxIssue\n// Exclude encoding-related errors to concentrate on pure syntax issues\nwhere not (syntaxIssue instanceof EncodingError)\n// Present the syntax error along with its message and Python version\nselect syntaxIssue, syntaxIssue.getMessage() + \" (in Python \" + major_version() + \").\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Construction of a cookie using user-supplied input\n * @description Building cookies from user-controlled input may enable Cookie Poisoning attacks.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\n// Define data flow source (untrusted user input) and sink (cookie construction)\nfrom \n  CookieInjectionFlow::PathNode taintedSource,  // User-controlled input origin\n  CookieInjectionFlow::PathNode cookieSink      // Cookie assembly point\n// Validate data flow path existence\nwhere CookieInjectionFlow::flowPath(taintedSource, cookieSink)\n// Output sink location, source details, path, and security message\nselect \n  cookieSink.getNode(), \n  taintedSource, \n_______________ // 补全条件\n  \"Cookie is constructed from a $@.\", \n  taintedSource.getNode(),\n  \"user-supplied input\"",
    "output": "cookieSink,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class should be a context manager\n * @description Detects classes that implement a __del__ method for resource cleanup\n *              but are not implemented as context managers. Such classes should be\n *              converted to context managers to enable explicit resource management\n *              using 'with' statements, which enhances code readability and reliability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision medium\n * @id py/should-be-context-manager\n */\n\nimport python\n\n// Identify classes requiring context manager implementation\nfrom ClassValue targetClass\nwhere \n_______________ // 补全条件\n  not targetClass.isBuiltin()\n  and \n  // Ensure the class isn't already a context manager\n  not targetClass.isContextManager()\n  and \n  // Check for __del__ method presence indicating resource cleanup\n  exists(targetClass.declaredAttribute(\"__del__\"))\nselect targetClass, \n  \"Class \" + targetClass.getName() + \n    \" implements __del__ (presumably to release some resource). Consider making it a context manager.\"",
    "output": "// Exclude built-in classes as they cannot be modified"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-deprecated-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies imports of deprecated Python modules and suggests replacements",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Import of deprecated module\n * @description Identifies imports of deprecated Python modules and suggests replacements\n * @kind problem\n * @tags maintainability\n *       external/cwe/cwe-477\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/import-deprecated-module\n */\n\n// Import the Python library for handling Python code queries\nimport python\n\n/**\n * Determines if a module is deprecated in a specific Python version\n * \n * @param deprecatedModName The name of the deprecated module\n * @param replacementModName The replacement module name (\"no replacement\" if none)\n * @param majorVersion The major version number where deprecation occurred\n * @param minorVersion The minor version number where deprecation occurred\n * @return true if the module is deprecated in the specified version\n */\npredicate deprecated_module(string deprecatedModName, string replacementModName, int majorVersion, int minorVersion) {\n  // Core deprecation definitions for various Python modules\n  deprecatedModName = \"posixfile\" and replacementModName = \"fcntl\" and majorVersion = 1 and minorVersion = 5\n  or\n  deprecatedModName = \"gopherlib\" and replacementModName = \"no replacement\" and majorVersion = 2 and minorVersion = 5\n  or\n  deprecatedModName = \"rgbimgmodule\" and replacementModName = \"no replacement\" and majorVersion = 2 and minorVersion = 5\n  or\n  deprecatedModName = \"pre\" and replacementModName = \"re\" and majorVersion = 1 and minorVersion = 5\n  or\n  deprecatedModName = \"whrandom\" and replacementModName = \"random\" and majorVersion = 2 and minorVersion = 1\n  or\n  deprecatedModName = \"rfc822\" and replacementModName = \"email\" and majorVersion = 2 and minorVersion = 3\n  or\n  deprecatedModName = \"mimetools\" and replacementModName = \"email\" and majorVersion = 2 and minorVersion = 3\n  or\n  deprecatedModName = \"MimeWriter\" and replacementModName = \"email\" and majorVersion = 2 and minorVersion = 3\n  or\n  deprecatedModName = \"mimify\" and replacementModName = \"email\" and majorVersion = 2 and minorVersion = 3\n  or\n  deprecatedModName = \"rotor\" and replacementModName = \"no replacement\" and majorVersion = 2 and minorVersion = 4\n  or\n  deprecatedModName = \"statcache\" and replacementModName = \"no replacement\" and majorVersion = 2 and minorVersion = 2\n  or\n  deprecatedModName = \"mpz\" and replacementModName = \"a third party\" and majorVersion = 2 and minorVersion = 2\n  or\n  deprecatedModName = \"xreadlines\" and replacementModName = \"no replacement\" and majorVersion = 2 and minorVersion = 3\n  or\n  deprecatedModName = \"multifile\" and replacementModName = \"email\" and majorVersion = 2 and minorVersion = 5\n  or\n  deprecatedModName = \"sets\" and replacementModName = \"builtins\" and majorVersion = 2 and minorVersion = 6\n  or\n  deprecatedModName = \"buildtools\" and replacementModName = \"no replacement\" and majorVersion = 2 and minorVersion = 3\n  or\n  deprecatedModName = \"cfmfile\" and replacementModName = \"no replacement\" and majorVersion = 2 and minorVersion = 4\n  or\n  deprecatedModName = \"macfs\" and replacementModName = \"no replacement\" and majorVersion = 2 and minorVersion = 3\n  or\n  deprecatedModName = \"md5\" and replacementModName = \"hashlib\" and majorVersion = 2 and minorVersion = 5\n  or\n  deprecatedModName = \"sha\" and replacementModName = \"hashlib\" and majorVersion = 2 and minorVersion = 5\n}\n\n/**\n * Generates deprecation version information for a module\n * \n * @param deprecatedModName The name of the deprecated module\n * @return A string containing the deprecation version information\n */\nstring get_deprecation_info(string deprecatedModName) {\n  // Generate version-specific deprecation message\n  exists(int majorVersion, int minorVersion | \n    deprecated_module(deprecatedModName, _, majorVersion, minorVersion)\n  |\n    result = \"The \" + deprecatedModName + \" module was deprecated in version \" + \n             majorVersion.toString() + \".\" + minorVersion.toString() + \".\"\n  )\n}\n\n/**\n * Generates replacement suggestion for a deprecated module\n * \n * @param deprecatedModName The name of the deprecated module\n * @return A string containing replacement suggestion or empty if no replacement\n */\nstring get_replacement_suggestion(string deprecatedModName) {\n  // Generate replacement suggestion if available\n  exists(string replacementModName | \n    deprecated_module(deprecatedModName, replacementModName, _, _)\n  |\n    result = \" Use \" + replacementModName + \" module instead.\" \n    and not replacementModName = \"no replacement\"\n    or\n    result = \"\" and replacementModName = \"no replacement\"\n  )\n}\n\n// Main query to find deprecated module imports\nfrom ImportExpr importNode, string deprecatedModName, string replacementModName\nwhere\n  // Identify imported module name\n  deprecatedModName = importNode.getName()\n  and\n  // Verify module is deprecated\n  deprecated_module(deprecatedModName, replacementModName, _, _)\n  and\n  // Exclude imports handled by ImportError try-except blocks\n  not exists(Try tryStmt, ExceptStmt exceptHandler |\n    exceptHandler = tryStmt.getAHandler() and\n    exceptHandler.getType().pointsTo(ClassValue::importError()) and\n    exceptHandler.containsInScope(importNode)\n  )\nselect importNode, \n       get_deprecation_info(deprecatedModName) + \n       get_replacement_suggestion(deprecatedModName)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/nested-loops-with-same-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies nested for loops that share the same iteration variable. This practice",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Nested loops reusing iteration variable\n * @description Identifies nested for loops that share the same iteration variable. This practice\n *              can lead to the inner loop overwriting the outer loop's variable, potentially\n *              causing unintended behavior and reducing code maintainability.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\n// Detects nested loops sharing an iteration variable where the variable is accessed\n// outside the inner loop's scope\npredicate hasNestedLoopWithSharedVariable(For innerLoop, For outerLoop, Variable commonVar) {\n  // Verify inner loop is directly nested within outer loop's body\n  outerLoop.getBody().contains(innerLoop) and\n  // Confirm both loops utilize the same iteration variable\n  innerLoop.getTarget().defines(commonVar) and\n  outerLoop.getTarget().defines(commonVar) and\n  // Validate variable usage in outer loop beyond inner loop's scope\n  exists(Name varUsage |\n    varUsage.uses(commonVar) and \n    outerLoop.contains(varUsage) and \n    not innerLoop.contains(varUsage)\n  )\n}\n\n// Query: Locate problematic nested loops with shared iteration variables\nfrom For innerLoop, For outerLoop, Variable commonVar\nwhere hasNestedLoopWithSharedVariable(innerLoop, outerLoop, commonVar)\nselect innerLoop, \n  \"Nested for loop reuses iteration variable '\" + commonVar.getId() + \n  \"' from enclosing $@.\", \n  outerLoop, \n  \"outer for loop\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'To Do' comment detection\n * @description Finds code comments that include 'TODO' or 'TO DO' markers, which usually signify\n *              unfinished functionality or temporary code that requires future attention.\n * @kind problem\n * @tags maintainability\n *       readability\n_______________ // 补全条件\n *       external/cwe/cwe-546\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/todo-comment\n */\n\nimport python  // 导入Python语言库，用于分析Python代码\n\nfrom Comment commentWithTodo  // 从所有注释节点中选择变量commentWithTodo\nwhere exists(string text | text = commentWithTodo.getText() and text.matches(\"%(TODO|TO DO)%\"))  // 过滤条件：检查注释文本是否存在并匹配包含\"TODO\"或\"TO DO\"的模式\nselect commentWithTodo, commentWithTodo.getText()  // 选择符合条件的注释节点及其文本内容",
    "output": "*       documentation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/signing-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and reports all cryptographic signing algorithm implementations that may be vulnerable to quantum computing attacks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Quantum-Readiness: Cryptographic Signing Algorithms Detection\n * @description Identifies and reports all cryptographic signing algorithm implementations that may be vulnerable to quantum computing attacks.\n * @kind problem\n * @id py/quantum-readiness/cbom/signing-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python language analysis capabilities\nimport python\n\n// Import experimental cryptography framework for algorithm detection\nimport experimental.cryptography.Concepts\n\n// Define the source of cryptographic signing algorithm instances\nfrom SigningAlgorithm signingAlgorithmImpl\n\n// Construct and format the alert message with algorithm details\nselect signingAlgorithmImpl, \n       \"Potential quantum-vulnerable cryptographic signing algorithm found: \" + \n       signingAlgorithmImpl.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak elliptic curve detection\n * @description Identifies cryptographic implementations that utilize elliptic curve algorithms\n *              which are either unrecognized or classified as having inadequate security strength.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm curveUsage, string alertMessage, string curveName\nwhere\n  curveName = curveUsage.getCurveName()\n  and\n  (\n    // Check for unrecognized curve algorithms\n    curveName = unknownAlgorithm() and\n    alertMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Check for recognized but weak curve algorithms\n    curveName != unknownAlgorithm() and\n    not curveName in\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n_______________ // 补全条件\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    alertMessage = \"Use of weak curve algorithm \" + curveName + \".\"\n  )\nselect curveUsage, alertMessage",
    "output": "\"SECP521R1\",              // P-521 curve"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/procedure-return-value-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code that utilizes return values from procedures (functions returning None).",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of the return value of a procedure\n * @description Identifies code that utilizes return values from procedures (functions returning None). \n *              Such usage is problematic since the returned value (None) typically has no meaningful purpose.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/procedure-return-value-used\n */\n\nimport python\nimport Testing.Mox\n\n/**\n * Determines if a function call's result is utilized in the code.\n * A call is considered used if it participates in expressions requiring values,\n * excluding specific patterns like standalone returns.\n */\npredicate is_used(Call funcCall) {\n  // Case 1: Call is nested within value-requiring expressions\n  exists(Expr parentExpr | \n    parentExpr != funcCall and \n    parentExpr.containsInScope(funcCall) and\n    (parentExpr instanceof Call or \n     parentExpr instanceof Attribute or \n     parentExpr instanceof Subscript)\n  )\n  // Case 2: Call is part of non-expression statements\n  or\n  exists(Stmt containerStmt |\n    funcCall = containerStmt.getASubExpression() and\n    not containerStmt instanceof ExprStmt and\n    /* Exclude single return statements (e.g., 'def f(): return g()') \n       and implicit lambda returns */\n    not (containerStmt instanceof Return and \n         strictcount(Return r | r.getScope() = containerStmt.getScope()) = 1)\n  )\n}\n\nfrom Call funcCall, FunctionValue calledFunction\nwhere\n  /* Call result is used but callee is a procedure */\n  is_used(funcCall) and\n  funcCall.getFunc().pointsTo(calledFunction) and\n  calledFunction.getScope().isProcedure() and\n  /* Verify all possible callees are procedures */\n  forall(FunctionValue potentialCallee | \n    funcCall.getFunc().pointsTo(potentialCallee) | \n    potentialCallee.getScope().isProcedure()\n  ) and\n  /* Exclude Mox mock objects with `AndReturn` methods */\n  not useOfMoxInModule(funcCall.getEnclosingModule())\nselect funcCall, \"The result of $@ is used even though it is always None.\", calledFunction, calledFunction.getQualifiedName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'super' in old style class\n * @description 使用 super() 访问继承的方法在旧式类中是不被支持的。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n// 检测旧式类中 super() 调用的谓词\n_______________ // 补全条件\n  // 确保调用发生在函数作用域内\n  exists(Function enclosingFunction |\n    invocation.getScope() = enclosingFunction and\n    // 确保函数定义在类作用域内\n    exists(ClassObject containerClass |\n      enclosingFunction.getScope() = containerClass.getPyClass() and\n      // 验证类对象状态：类型推断成功且非新式类\n      not containerClass.failedInference() and\n      not containerClass.isNewStyle() and\n      // 确认调用目标为 super 函数\n      invocation.getFunc().(Name).getId() = \"super\"\n    )\n  )\n}\n\n// 查询所有满足条件的 super() 调用点\nfrom Call problematicCall\nwhere uses_of_super_in_old_style_class(problematicCall)\nselect problematicCall, \"'super()' will not work in old-style classes.\"",
    "output": "predicate uses_of_super_in_old_style_class(Call invocation) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Duplicate code block\n * @description Identifies duplicated code blocks that could be refactored.\n * This check reports all basic blocks as potential duplicates since actual\n * duplicate detection requires additional analysis. Note: Results may include\n * false positives as this is a statistical check.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @deprecated\n * @precision medium\n * @id py/duplicate-block\n */\n\nimport python\n\n// Retrieve all basic blocks without filtering conditions\nfrom BasicBlock block\nwhere none()\n// Generate alert message for each basic block\nselect block, \n       \"Duplicate code: \" + \n_______________ // 补全条件\n       \" lines are duplicated at \" + \n       \"<file>\" + \n       \":\" + \n       \"-1\"",
    "output": "\"-1\" +"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Initializing SECRET_KEY of Flask/Django with Constant Value\n * @description Detects hardcoded SECRET_KEY assignments in Flask/Django applications\n * which can enable authentication bypass vulnerabilities\n * @kind path-problem\n * @id py/flask-constant-secret-key\n * @problem.severity error\n * @security-severity 8.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.filters.Tests\n\n// Framework type enumeration (Flask or Django)\nnewtype WebFramework =\n  Flask() or\n  Django()\n\n// Centralized configuration for secret key detection logic\nprivate module SecretKeyDetectionConfig {\n  import semmle.python.dataflow.new.DataFlow\n\n  // Identify potential secret key sources (non-empty strings excluding placeholders)\n  predicate isPotentialSecretSource(DataFlow::Node potentialSecretSource) {\n    exists(string strValue |\n      strValue = potentialSecretSource.asExpr().(StringLiteral).getText() and\n      strValue.length() > 0 and\n      // Filter common placeholder values\n      not strValue in [\"\", \"changeme\", \"secret\", \"password\", \"default\"]\n    )\n  }\n\n  // Identify SECRET_KEY assignment targets\n  predicate isSecretKeyAssignmentSink(DataFlow::Node secretKeySink) {\n    exists(DataFlow::Node configAttrNode |\n      configAttrNode.asExpr().(Attribute).getName() = \"SECRET_KEY\" and\n      secretKeySink.asExpr() = configAttrNode.asExpr().(Attribute).getObject()\n    )\n  }\n}\n\n// Data flow configuration with framework state tracking\nprivate module WebAppSecretKeyConfig implements DataFlow::StateConfigSig {\n  // Framework state representation\n  class FlowState = WebFramework;\n\n  // Unified source detection for both frameworks\n  predicate isSource(DataFlow::Node sourceNode, FlowState frameworkType) {\n    SecretKeyDetectionConfig::isPotentialSecretSource(sourceNode) and\n    (frameworkType = Flask() or frameworkType = Django())\n  }\n\n  // Barrier conditions to filter false positives\n  predicate isBarrier(DataFlow::Node barrierNode) {\n    // Exclude standard library components\n    barrierNode.getLocation().getFile().inStdlib()\n    or\n    // Exclude test/demo/example files except specific test cases\n    exists(string relativePath |\n      relativePath = barrierNode.getLocation().getFile().getRelativePath() and\n      relativePath.matches([\"%test%\", \"%demo%\", \"%example%\", \"%sample%\"]) and\n      not relativePath.matches(\"%query-tests/Security/CWE-287%\")\n    )\n    or\n    // Exclude obvious placeholder values\n    exists(string value |\n      value = barrierNode.asExpr().(StringLiteral).getText() and\n      value in [\"\", \"changeme\", \"secret\", \"password\", \"default\"]\n    )\n  }\n\n  // Unified sink detection for both frameworks\n  predicate isSink(DataFlow::Node sinkNode, FlowState frameworkType) {\n    SecretKeyDetectionConfig::isSecretKeyAssignmentSink(sinkNode) and\n    (frameworkType = Flask() or frameworkType = Django())\n  }\n\n_______________ // 补全条件\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global taint tracking with framework state\nmodule WebAppSecretKeyFlow = TaintTracking::GlobalWithState<WebAppSecretKeyConfig>;\n\n// Import path graph for visualization\nimport WebAppSecretKeyFlow::PathGraph\n\n// Main query detecting hardcoded secret key assignments\nfrom WebAppSecretKeyFlow::PathNode source, WebAppSecretKeyFlow::PathNode sink\nwhere WebAppSecretKeyFlow::flowPath(source, sink)\nselect sink, source, sink, \"The SECRET_KEY config variable is assigned by $@.\", source,\n  \" this constant String\"",
    "output": "// Enable differential analysis for incremental mode"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/symmetric-encryption-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query identifies all occurrences of symmetric encryption algorithms",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Symmetric Encryption Algorithm Usage Detection\n * @description This query identifies all occurrences of symmetric encryption algorithms\n *              being utilized in the Python codebase through supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-encryption-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricEncryptionAlgorithm symmetricAlgorithmInstance\nselect symmetricAlgorithmInstance, \n       \"Use of algorithm \" + symmetricAlgorithmInstance.getEncryptionName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of 'return' or 'yield' outside a function\n * @description Detects 'return'/'yield' statements outside function scope, which cause runtime SyntaxError.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/return-or-yield-outside-function\n */\n\nimport python\n\n_______________ // 补全条件\nfrom AstNode astNode, string stmtType\nwhere\n  // Verify the node is not within any function's scope\n  not astNode.getScope() instanceof Function\n  and (\n    // Match return statements with \"return\" type\n    astNode instanceof Return and stmtType = \"return\"\n    or\n    // Match yield statements with \"yield\" type\n    astNode instanceof Yield and stmtType = \"yield\"\n    or\n    // Match yield-from statements with \"yield from\" type\n    astNode instanceof YieldFrom and stmtType = \"yield from\"\n  )\n// Generate alert with problematic node and context message\nselect astNode, \"'\" + stmtType + \"' is used outside a function.\"",
    "output": "// Identify AST nodes and their corresponding statement types"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Display strings of Python classes\n * @description Shows all Python classes along with their names as display strings\n * @kind display-string\n * @id py/lgtm/class-display-strings\n_______________ // 补全条件\n */\n\nimport python\n\n// Identify all Python classes in the codebase and extract their names\nfrom Class cls\nselect cls, cls.getName()",
    "output": "* @metricType reftype"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/class-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检索 Python 代码库中所有类定义，并关联到它们所在的源文件路径",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python 类定义源文件定位\n * @description 检索 Python 代码库中所有类定义，并关联到它们所在的源文件路径\n * @kind source-link\n * @id py/class-source-links\n * @metricType reftype\n */\n\nimport python\n\n// 获取所有 Python 类定义及其源文件路径\nfrom Class pythonClass, File sourceFile\nwhere sourceFile = pythonClass.getLocation().getFile()\n// 选择类对象及其源文件位置\nselect pythonClass, sourceFile"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Outgoing class dependencies\n * @description Evaluates the count of external dependencies for individual classes.\n * @kind treemap\n * @id py/efferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags testability\n *       modularity\n */\n_______________ // 补全条件\nimport python\n\n// 本查询用于分析Python代码库中每个类的外向耦合度（Efferent Coupling）\n// 外向耦合度指一个类所依赖的其他类的数量，是衡量软件设计质量的重要指标\n// 高外向耦合度可能表明类承担了过多职责，或与系统其他部分紧密耦合\n// 查询结果按耦合度降序排列，帮助开发者优先关注需要重构的高耦合类\nfrom ClassMetrics targetClass\nselect targetClass, \n       targetClass.getEfferentCoupling() as outgoingCoupling \norder by outgoingCoupling desc",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/polluting-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies 'import *' statements that risk namespace pollution",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' may pollute namespace\n * @description Identifies 'import *' statements that risk namespace pollution\n *              when the imported module lacks '__all__' definition\n * @kind problem\n * @tags maintainability\n *       modularity\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/polluting-import\n */\n\n// Import Python analysis library for AST traversal and module inspection\nimport python\n\n/**\n * Helper predicate to check if a module defines its public API properly\n * Returns true if the module either:\n * - Is a built-in module (which inherently controls namespace)\n * - Defines '__all__' in its import-time scope\n * - Has '__all__' defined in its initialization context\n */\npredicate definesPublicAPIControl(ModuleValue sourceModule) {\n  // Built-in modules inherently control their namespace\n  sourceModule.isBuiltin()\n  or\n  // Check for '__all__' definition in the module's import-time scope\n  exists(ImportTimeScope scope | scope = sourceModule.getScope() | scope.definesName(\"__all__\"))\n  or\n  // Verify '__all__' exists in the module's initialization context\n  exists(ImportTimeScope initScope | \n    initScope = sourceModule.getScope().getInitModule().(ImportTimeScope) | \n    initScope.definesName(\"__all__\")\n  )\n}\n\n// Main query to identify problematic star imports that may pollute namespace\nfrom ImportStar starImport, ModuleValue sourceModule\nwhere \n  // Link the import statement to the module it imports\n  sourceModule.importedAs(starImport.getImportedModuleName())\n  and\n  // Only consider modules that do not properly define their public API\n  not definesPublicAPIControl(sourceModule)\n  and\n  // Exclude modules that cannot be resolved (missing modules)\n  not sourceModule.isAbsent()\nselect starImport,\n  \"Namespace pollution risk: Module $@ lacks '__all__' definition for star import.\",\n  sourceModule, sourceModule.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__init__` method calls overridden method\n * @description Identifies when `__init__` methods invoke functions that could be overridden by subclasses,\n *              which may lead to exposure of partially initialized objects.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/init-calls-subclass\n */\n\nimport python\n_______________ // 补全条件\nfrom\n  ClassObject parentClass, string methodIdentifier, Call selfMethodCall,\n  FunctionObject overridingMethod, FunctionObject originalMethod\nwhere\n  // Step 1: Identify the parent class and its __init__ method\n  exists(FunctionObject initializer, SelfAttribute selfRef |\n    // Ensure we're examining the __init__ method of a parent class\n    parentClass.declaredAttribute(\"__init__\") = initializer and\n    \n    // Step 2: Locate self method calls within the __init__ method\n    selfMethodCall.getScope() = initializer.getFunction() and\n    selfMethodCall.getFunc() = selfRef and\n    \n    // Step 3: Extract the method name being called on self\n    selfRef.getName() = methodIdentifier and\n    \n    // Step 4: Verify the method exists in the parent class\n    originalMethod = parentClass.declaredAttribute(methodIdentifier) and\n    \n    // Step 5: Confirm the method is overridden by a subclass\n    overridingMethod.overrides(originalMethod)\n  )\n// Generate alert with details about the problematic call\nselect selfMethodCall, \"Call to self.$@ in __init__ method, which is overridden by $@.\", \n  originalMethod, methodIdentifier, overridingMethod, overridingMethod.descriptiveString()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Modification of dictionary returned by locals()\n * @description Detects attempts to modify the dictionary returned by locals() which do not affect the actual local variables.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/modification-of-locals\n */\n\nimport python\n\n// Identifies control flow nodes referencing the result of locals() function call\npredicate referencesLocalsCall(ControlFlowNode controlFlowNode) { \n    controlFlowNode.pointsTo(_, _, Value::named(\"locals\").getACall()) \n}\n\n// Detects any modification operation on the dictionary returned by locals()\npredicate modifiesLocalsDictionary(ControlFlowNode modificationNode) {\n    // Case 1: Dictionary subscript operations (assignment or deletion)\n    exists(SubscriptNode subscriptNode |\n        subscriptNode = modificationNode and\n        referencesLocalsCall(subscriptNode.getObject()) and\n        (subscriptNode.isStore() or subscriptNode.isDelete())\n    )\n    or\n    // Case 2: Dictionary method calls that modify content\n    exists(CallNode callNode, AttrNode attributeNode, string methodName |\n        callNode = modificationNode and\n        attributeNode = callNode.getFunction() and\n        referencesLocalsCall(attributeNode.getObject(methodName)) and\n        methodName in [\"pop\", \"popitem\", \"update\", \"clear\"]\n    )\n_______________ // 补全条件\n\nfrom AstNode astNode, ControlFlowNode modificationNode\nwhere\n    // Find operations modifying the locals() dictionary\n    modifiesLocalsDictionary(modificationNode) and\n    // Map control flow node to corresponding AST node\n    astNode = modificationNode.getNode() and\n    // Exclude module-level scope where locals() is equivalent to globals()\n    not astNode.getScope() instanceof ModuleScope\n// Output results with warning message\nselect astNode, \"Modification of the locals() dictionary will have no effect on the local variables.\"",
    "output": "}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/syntax-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python syntax errors that lead to runtime failures and prevent accurate code analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Syntax error\n * @description Detects Python syntax errors that lead to runtime failures and prevent accurate code analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import the Python module which provides necessary classes and predicates for analyzing Python code\nimport python\n\n// Define the source of syntax errors in Python code\nfrom SyntaxError errorInstance\n\n// Filter out encoding-related errors as they are handled differently\nwhere not errorInstance instanceof EncodingError\n\n// Return the syntax error along with a contextual message including the Python version\nselect errorInstance, errorInstance.getMessage() + \" (in Python \" + major_version() + \").\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies the use of cryptographic elliptic curve algorithms that are either unapproved",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak elliptic curve\n * @description Identifies the use of cryptographic elliptic curve algorithms that are either unapproved \n *              or known to be weak, potentially compromising the security of the system.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm cryptoOperation, string warningMessage, string curveName\nwhere\n  curveName = cryptoOperation.getCurveName() and\n  (\n    // Case 1: Unrecognized algorithm\n    curveName = unknownAlgorithm() and\n    warningMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: Recognized but weak algorithm\n    curveName != unknownAlgorithm() and\n    not curveName in\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curve\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    warningMessage = \"Use of weak curve algorithm \" + curveName + \".\"\n  )\nselect cryptoOperation, warningMessage"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Key points-to fails for expression.\n * @description Identifies expressions that fail to point-to any object, blocking further points-to analysis.\n * @kind problem\n * @problem.severity info\n * @id py/key-points-to-failure\n * @deprecated\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n// Predicate to determine if an expression fails to point-to any object\n_______________ // 补全条件\n  // Check if there's a control flow node associated with the expression that has no points-to relations\n  exists(ControlFlowNode controlFlowNode | \n    controlFlowNode = problematicExpr.getAFlowNode() | \n    not PointsTo::pointsTo(controlFlowNode, _, _, _)\n  )\n}\n\n// Predicate to identify critical points-to failure expressions that meet specific criteria\npredicate representsCriticalPointToFailure(Expr problematicExpr) {\n  // Verify the expression itself has points-to failure\n  expressionLacksPointToTarget(problematicExpr) and\n  // Ensure all sub-expressions have successful points-to relationships\n  not expressionLacksPointToTarget(problematicExpr.getASubExpression()) and\n  // Confirm no SSA variables using this expression have definition nodes with points-to failure\n  not exists(SsaVariable ssaVariable | \n    ssaVariable.getAUse() = problematicExpr.getAFlowNode() |\n    expressionLacksPointToTarget(ssaVariable.getAnUltimateDefinition().getDefinition().getNode())\n  ) and\n  // Ensure the expression is not the target of an assignment operation\n  not exists(Assign assignment | assignment.getATarget() = problematicExpr)\n}\n\n// Main query: Find all critical points-to failure expressions, excluding those used as function calls\nfrom Attribute problematicExpr\nwhere \n  representsCriticalPointToFailure(problematicExpr) and \n  not exists(Call functionCall | functionCall.getFunc() = problematicExpr)\nselect problematicExpr, \"Expression does not 'point-to' any object, but all its sources do.\"",
    "output": "predicate expressionLacksPointToTarget(Expr problematicExpr) {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commit-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Establishes connections between version control commits and their corresponding",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Source links of commits\n * @kind source-link\n * @id py/commit-source-links\n * @metricType commit\n * @description Establishes connections between version control commits and their corresponding\n *              source files by analyzing commit metadata and tracking file modifications\n *              across the repository's history.\n */\n\n// Enable Python-specific code analysis functionality\nimport python\n// Access version control system data including commit history and file change tracking\nimport external.VCS\n\n// Query structure: retrieve commit records and associated modified files\nfrom Commit commitEntry, File affectedSourceFile\n// Validate that the file is a legitimate source code file within the project\nwhere affectedSourceFile.fromSource()\n// Establish direct relationship between commit and file modification\nand affectedSourceFile = commitEntry.getAnAffectedFile()\n// Return formatted results with commit identifier and the corresponding source file\nselect commitEntry.getRevisionName(), affectedSourceFile"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mostly-similar-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies modules with substantial code similarity. Note that variable names and types may differ between modules. Consolidation is recommended for maintainability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Mostly similar module detection\n * @description Identifies modules with substantial code similarity. Note that variable names and types may differ between modules. Consolidation is recommended for maintainability.\n * @kind problem\n * @problem.severity recommendation\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @sub-severity low\n * @precision high\n * @id py/mostly-similar-file\n */\n\nimport python\n\n// Define source and target modules along with their similarity analysis details\nfrom Module analyzedModule, \n     Module comparedModule, \n     string similarityAnalysis\nwhere \n  // Placeholder condition that prevents any results from being returned\n  // Actual similarity detection logic would replace this condition\n  none()\nselect \n  analyzedModule, \n  similarityAnalysis, \n  comparedModule, \n  comparedModule.getName()  // Include the name of the compared module in the output"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/truncated-division]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies division operations where both operands are integers,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Result of integer division may be truncated\n * @description Identifies division operations where both operands are integers,\n *              which may cause truncation in Python 2 due to floor division behavior.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// Find division operations that may truncate results in Python 2\nfrom BinaryExpr integerDivisionExpr, ControlFlowNode leftOperand, ControlFlowNode rightOperand\nwhere\n  // Only relevant for Python 2 where integer division truncates\n  major_version() = 2 and\n  exists(BinaryExprNode divisionNode, Value leftIntVal, Value rightIntVal |\n    // Map division expression to its AST node\n    divisionNode = integerDivisionExpr.getAFlowNode() and\n    \n    // Verify division operator is used\n    divisionNode.getNode().getOp() instanceof Div and\n    \n    // Validate left operand is integer\n    divisionNode.getLeft().pointsTo(leftIntVal, leftOperand) and\n    leftIntVal.getClass() = ClassValue::int_() and\n    \n    // Validate right operand is integer\n    divisionNode.getRight().pointsTo(rightIntVal, rightOperand) and\n    rightIntVal.getClass() = ClassValue::int_() and\n    \n    // Exclude exact divisions with no remainder\n    not leftIntVal.(NumericValue).getIntValue() % rightIntVal.(NumericValue).getIntValue() = 0 and\n    \n    // Exclude modules using true division from __future__\n    not divisionNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // Exclude explicit integer conversions of division result\n    not exists(CallNode intConversion |\n      intConversion = ClassValue::int_().getACall() and\n      intConversion.getAnArg() = divisionNode\n    )\n  )\nselect integerDivisionExpr, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftOperand, \"left\", rightOperand, \"right\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-input]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：在 Python 2 中，内置的 'input()' 函数会将用户输入作为 Python 代码执行，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python 2 中不安全的 'input' 函数使用\n * @description 在 Python 2 中，内置的 'input()' 函数会将用户输入作为 Python 代码执行，\n *              这可能导致严重的代码注入漏洞。相比之下，'raw_input()' 函数会安全地返回字符串。\n *              本查询旨在识别并报告所有使用不安全 'input' 函数的代码位置。\n * @kind problem\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/use-of-input\n */\n\nimport python  // 导入 Python 代码分析库\nimport semmle.python.dataflow.new.DataFlow  // 导入数据流分析库\nimport semmle.python.ApiGraphs  // 导入 API 图分析库\n\n// 定义变量以捕获不安全的 input 函数调用\nfrom DataFlow::CallCfgNode problematicInputCall\nwhere\n  // 限定分析范围：仅处理 Python 2 版本代码\n  major_version() = 2\n  and (\n    // 识别对内置 'input' 函数的调用\n    problematicInputCall = API::builtin(\"input\").getACall()\n    // 排除安全的 'raw_input' 函数调用\n    and problematicInputCall != API::builtin(\"raw_input\").getACall()\n  )\nselect problematicInputCall, \"检测到 Python 2 中使用了不安全的内置函数 'input'，可能导致代码注入攻击\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/points-to-analysis-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies expressions that fail to point-to any object, blocking further points-to analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Expression points-to analysis failure.\n * @description Identifies expressions that fail to point-to any object, blocking further points-to analysis.\n * @kind problem\n * @problem.severity info\n * @id py/points-to-analysis-failure\n * @deprecated\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n// 谓词：确定表达式是否在点对分析中失败\npredicate exprPointsToAnalysisFailed(Expr targetExpr) {\n  // 检查与表达式关联的所有控制流节点都没有指向关系\n  exists(ControlFlowNode flowNode | \n    flowNode = targetExpr.getAFlowNode() and\n    not PointsTo::pointsTo(flowNode, _, _, _)\n  )\n}\n\n// 谓词：判断表达式是否为关键的点对分析失败情况\npredicate isCriticalFailureInPointsTo(Expr targetExpr) {\n  // 表达式本身在点对分析中失败\n  exprPointsToAnalysisFailed(targetExpr) and\n  // 子表达式条件：存在一个子表达式不会导致点对分析失败\n  not exprPointsToAnalysisFailed(targetExpr.getASubExpression()) and\n  // SSA变量条件：没有使用该表达式的SSA变量，其定义节点也点对分析失败\n  not exists(SsaVariable ssaVar | \n    ssaVar.getAUse() = targetExpr.getAFlowNode() and\n    exprPointsToAnalysisFailed(ssaVar.getAnUltimateDefinition().getDefinition().getNode())\n  ) and\n  // 赋值条件：表达式不是赋值操作的目标\n  not exists(Assign assignStmt | assignStmt.getATarget() = targetExpr)\n}\n\n// 主查询：识别关键点对分析失败的表达式，但排除作为函数调用的情况\nfrom \n  Attribute targetExpr\nwhere \n  isCriticalFailureInPointsTo(targetExpr) and \n  not exists(Call funcCall | funcCall.getFunc() = targetExpr)\nselect \n  targetExpr, \n  \"Expression does not 'point-to' any object, but all its sources do.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Archive extraction path traversal vulnerability (\"Zip Slip\")\n * @description Detects archive extraction code that fails to sanitize paths containing \n *              traversal sequences (e.g., '../'), which could allow attackers to write \n *              files outside the intended directory, potentially leading to unauthorized access.\n * @kind path-problem\n * @id py/zipslip\n_______________ // 补全条件\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\n// Import core Python analysis modules\nimport python\n\n// Import specialized logic for detecting archive traversal vulnerabilities\nimport experimental.semmle.python.security.ZipSlip\n\n// Import path tracking infrastructure for visualizing data flows\nimport ZipSlipFlow::PathGraph\n\n// Identify vulnerable data flows originating from archive entries to file operations\nfrom \n  ZipSlipFlow::PathNode entryNode, \n  ZipSlipFlow::PathNode fileOpNode\n\n// Verify that data flows from an untrusted archive entry to a dangerous file operation\nwhere \n  ZipSlipFlow::flowPath(entryNode, fileOpNode)\n\n// Report the vulnerability with source and sink context along with an explanation\nselect \n  entryNode.getNode(), \n  entryNode, \n  fileOpNode,\n  \"This unsanitized archive entry (possibly containing '../') reaches a $@.\", \n  fileOpNode.getNode(),\n  \"file system operation\"",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cryptographic operations utilizing elliptic curve algorithms that are either",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak elliptic curve\n * @description Detects cryptographic operations utilizing elliptic curve algorithms that are either\n *              unrecognized or classified as weak according to security best practices.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm cryptoOperation, string warningMessage, string curveIdentifier\nwhere\n  // Extract the curve identifier from the cryptographic operation\n  curveIdentifier = cryptoOperation.getCurveName() and\n  (\n    // Case 1: The curve algorithm is not recognized by the system\n    curveIdentifier = unknownAlgorithm() and\n    warningMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: The curve algorithm is recognized but not in the approved secure curves list\n    curveIdentifier != unknownAlgorithm() and\n    not curveIdentifier =\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    warningMessage = \"Use of weak curve algorithm \" + curveIdentifier + \".\"\n  )\nselect cryptoOperation, warningMessage"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-hashes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of deprecated or insecure cryptographic hash functions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak cryptographic hash algorithms\n * @description Detects usage of deprecated or insecure cryptographic hash functions\n *              that should not be used in security-sensitive contexts.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import required Python libraries and cryptographic analysis modules\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify hash functions using weak or deprecated algorithms\nfrom HashAlgorithm hashFunc, string algoName, string warningMsg\nwhere\n  // Extract algorithm name from the hash function\n  algoName = hashFunc.getHashName() and\n  \n  // Define approved strong hash algorithms\n  not algoName = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  \n  // Generate warning message based on algorithm recognition\n  (\n    // Case 1: Known but unapproved algorithm\n    algoName != \"\" and\n    warningMsg = \"Use of unapproved hash algorithm or API \" + algoName + \".\"\n  )\n  or\n  (\n    // Case 2: Unrecognized algorithm\n    algoName = \"\" and\n    warningMsg = \"Use of unrecognized hash algorithm.\"\n  )\nselect hashFunc, warningMsg"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/xxe]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies unsafe XML processing where untrusted input",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name XML external entity expansion vulnerability\n * @description Identifies unsafe XML processing where untrusted input\n *              is parsed without protection against XXE attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision high\n * @id py/xxe\n * @tags security\n *       external/cwe/cwe-611\n *       external/cwe/cwe-827\n */\n\n// Core Python analysis libraries\nimport python\n\n// XXE vulnerability detection modules\nimport semmle.python.security.dataflow.XxeQuery\n\n// Path graph for tracking data flow paths\nimport XxeFlow::PathGraph\n\n// Identify vulnerable XML processing flows\nfrom XxeFlow::PathNode userInputNode, XxeFlow::PathNode xmlProcessingNode\nwhere XxeFlow::flowPath(userInputNode, xmlProcessingNode)\n\n// Report vulnerable XML parsing without XXE mitigation\nselect xmlProcessingNode.getNode(), userInputNode, xmlProcessingNode,\n  \"XML parsing processes $@ without external entity expansion protection.\",\n  userInputNode.getNode(), \"user-controlled input\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name File-level code churn analysis\n * @description Quantifies the cumulative line modifications per file across the entire version control history.\n * @kind treemap\n * @id py/historical-churn\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\n// Import the Python language module for code analysis\nimport python\n// Import the external Version Control System (VCS) module for commit history\nimport external.VCS\n\n// Query to fetch source modules and their corresponding total churn metrics\nfrom Module sourceModule, int totalChurn\nwhere\n  // Ensure the module has a valid lines of code measurement\n  exists(sourceModule.getMetrics().getNumberOfLinesOfCode()) and\n  // Calculate the aggregate churn across all commits for the file\n  totalChurn =\n    sum(Commit versionCommit, int changedLines |\n      // Extract the churn metric for each file in recent commits, filtering out synthetic changes\n      changedLines = versionCommit.getRecentChurnForFile(sourceModule.getFile()) and \n      not artificialChange(versionCommit)\n_______________ // 补全条件\n      // Sum up all the individual line changes\n      changedLines\n    )\n// Select the module and its total churn, ordered by highest churn first\nselect sourceModule, totalChurn order by totalChurn desc",
    "output": "|"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'exec' usage detection\n * @description Identifies instances of 'exec' statement/function usage that may enable arbitrary code execution.\n * @details This query detects both Python 2 'exec' statements and Python 3 'exec' function calls.\n *          Using 'exec' can lead to arbitrary code execution, which is a significant security risk.\n * @kind problem\n * @tags security\n *       correctness\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec\n_______________ // 补全条件\n\nimport python\n\n// Generates version-specific warning message for 'exec' usage\nstring getExecWarningMessage() {\n  // In Python 2, 'exec' is a statement\n  result = \"The 'exec' statement is used.\" and major_version() = 2\n  or\n  // In Python 3, 'exec' is a built-in function\n  result = \"The 'exec' function is used.\" and major_version() = 3\n}\n\n// Main detection logic for 'exec' usage\nfrom AstNode dangerousExecNode\nwhere \n  // Case 1: Python 2 'exec' statement\n  dangerousExecNode instanceof Exec\n  or\n  // Case 2: Python 3 'exec' function call\n  exists(GlobalVariable globalExecReference | \n    dangerousExecNode instanceof Call and\n    globalExecReference = dangerousExecNode.(Call).getFunc().(Name).getVariable() and \n    globalExecReference.getId() = \"exec\"\n  )\n// Output detected node with appropriate warning message\nselect dangerousExecNode, getExecWarningMessage()",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-low-iteration-count]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects key derivation functions using inadequate iteration counts.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insufficient KDF Iteration Count Detection\n * @description Detects key derivation functions using inadequate iteration counts.\n * \n * When deriving cryptographic keys from user inputs (e.g., passwords), it's critical\n * to use a sufficiently high iteration count (minimum 10,000) to protect against\n * brute force attacks.\n * \n * This query identifies two security concerns:\n * 1. Iteration counts explicitly configured below the security threshold\n * 2. Iteration count sources that cannot be statically analyzed\n * \n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import standard Python analysis library\nimport python\n// Import experimental cryptography concepts for key derivation operations\nimport experimental.cryptography.Concepts\n// Import utility functions for cryptography analysis, aliased as CryptoUtils\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Select key derivation operations with potentially insufficient iteration counts\nfrom KeyDerivationOperation keyDerivationOp, string warningMessage, DataFlow::Node iterationCountSource\nwhere\n  // Filter for operations that require iteration configuration\n  keyDerivationOp.requiresIteration() and\n  // Identify the source node for iteration count configuration\n  iterationCountSource = keyDerivationOp.getIterationSizeSrc() and\n  (\n    // Check for explicitly defined iteration counts below security threshold\n    exists(int iterationValue |\n      iterationValue = iterationCountSource.asExpr().(IntegerLiteral).getValue() and\n      iterationValue < 10000 and\n      warningMessage = \"Insufficient iteration count detected. \"\n    )\n    or\n    // Check for iteration counts that cannot be statically determined\n    not exists(iterationCountSource.asExpr().(IntegerLiteral).getValue()) and\n    warningMessage = \"Iteration count cannot be statically verified. \"\n  )\nselect \n  // Report the key derivation operation with appropriate security warning\n  keyDerivationOp, warningMessage + \"Minimum required iteration count is 10000. Configuration source: $@\",\n  iterationCountSource.asExpr(), iterationCountSource.asExpr().toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Wrong name for an argument in a class instantiation\n * @description Detects class instantiations using named arguments that don't match\n *              any parameter in the class's __init__ method, which causes runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\n// Import Python analysis and call argument modules\nimport python\nimport Expressions.CallArgs\n\n// Identify class instantiation calls with invalid named arguments\nfrom Call instanceCall, ClassValue targetCls, string wrongArgName, FunctionValue initMethod\nwhere\n  // Find instance calls containing illegally named parameters\n  illegally_named_parameter(instanceCall, targetCls, wrongArgName)\n  and\n  // Resolve the target class's initialization method\n  initMethod = get_function_or_initializer(targetCls)\nselect \n  // Report location: class instantiation call\n  instanceCall, \n  // Error message: specify unsupported argument name\n  \"Keyword argument '\" + wrongArgName + \"' is not a supported parameter name of $@.\", \n  // Related element: initialization method\n  initMethod,\n  // Initialization method's qualified name\n_______________ // 补全条件",
    "output": "initMethod.getQualifiedName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Lines of commented-out code in files\n * @description Counts the number of lines containing commented-out code for each file\n * @kind treemap\n * @treemap.warnOn highValues\n_______________ // 补全条件\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// Import necessary modules for Python language support and lexical analysis of commented code\nimport python\nimport Lexical.CommentedOutCode\n\n// Declare variables representing target files and their respective commented code line counts\nfrom File targetFile, int commentedCodeLines\n// Filter files and calculate the total count of non-example commented code lines per file\nwhere commentedCodeLines = count(CommentedOutCodeLine commentedOutLine | \n        // Exclude lines that might be example code\n        not commentedOutLine.maybeExampleCode() and \n        // Ensure the commented line belongs to the current file being analyzed\n        commentedOutLine.getLocation().getFile() = targetFile)\n// Output the files with their commented code line counts, sorted in descending order\nselect targetFile, commentedCodeLines order by commentedCodeLines desc",
    "output": "* @metricType file"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of 'global' at module level\n * @description Identifies redundant 'global' statements used at module level in Python code\n * @kind problem\n_______________ // 补全条件\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-global-declaration\n */\n\n// Import Python module for code analysis\nimport python\n\n// Identify global variables declared at module level\nfrom Global redundantGlobal\nwhere \n    // Filter for globals declared at module scope\n    redundantGlobal.getScope() instanceof Module\nselect \n    redundantGlobal, \n    // Generate warning message for redundant global declaration\n    \"Declaring '\" + redundantGlobal.getAName() + \"' as global at module-level is redundant.\"",
    "output": "* @tags maintainability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-global]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies global variables that are accessed or modified",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of the 'global' statement.\n * @description Identifies global variables that are accessed or modified\n *              outside of the module scope. This practice can lead to\n *              unintended side effects and violates encapsulation,\n *              making code more difficult to maintain and debug.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/use-of-global\n */\n\nimport python\n\n// Identify global variables used in non-module contexts\nfrom Global globalVarInNonModule\nwhere \n  // Check if variable's scope is not at module level\n  exists(Scope varScope | \n    varScope = globalVarInNonModule.getScope() and\n    not varScope instanceof Module\n  )\nselect \n  globalVarInNonModule, \n  \"Updating global variables except at module initialization is discouraged.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies weak initialization vectors (IVs) or nonces in block cipher operations.\n *              This query flags cases where IVs/nonces are either missing or not generated by os.urandom.\n *              Fernet is excluded as it handles IV generation internally. Complex cases may require\n *              manual review.\n *\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags security\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Find block mode operations with weak IV/nonce configurations\nfrom BlockMode cipherOperation, string diagnosticMessage, DataFlow::Node weakInitializationVector\nwhere\n  // Exclude Fernet which handles IV generation internally\n  not cipherOperation instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet and\n  (\n    // Identify cases with missing IV/nonce or IV/nonce not from os.urandom\n    not cipherOperation.hasIVorNonce() or\n    not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = cipherOperation.getIVorNonce()\n  ) and\n  // Set the weak source and diagnostic message based on the IV/nonce presence\n  (\n    if not cipherOperation.hasIVorNonce()\n    then (\n      // Case when IV/nonce is missing\n      weakInitializationVector = cipherOperation and \n      diagnosticMessage = \"Block mode is missing IV/Nonce initialization.\"\n    )\n    else (\n      // Case when IV/nonce is from an insecure source\n      weakInitializationVector = cipherOperation.getIVorNonce()\n    )\n  ) and\n  // Finalize the diagnostic message\n  diagnosticMessage = \"Block mode is not using an accepted IV/Nonce initialization: $@\"\nselect cipherOperation, diagnosticMessage, weakInitializationVector, weakInitializationVector.toString()",
    "output": "* @name Weak block mode IV or nonce"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Import of deprecated module\n * @description Identifies imports of Python modules that have been deprecated in specific versions\n * @kind problem\n * @tags maintainability\n *       external/cwe/cwe-477\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/import-deprecated-module\n */\n\n// Import Python library for analyzing Python source code\nimport python\n\n/**\n * Determines if a module was deprecated in a specific Python version\n * and provides the recommended replacement module\n *\n * @param moduleName The name of the deprecated module\n * @param replacementModule The recommended replacement module or \"no replacement\"\n * @param major The major version number of Python where the module was deprecated\n * @param minor The minor version number of Python where the module was deprecated\n * @return True if the module was deprecated in the specified version\n */\npredicate deprecated_module(string moduleName, string replacementModule, int major, int minor) {\n  // Modules deprecated in Python 1.x\n  (\n    moduleName = \"posixfile\" and replacementModule = \"fcntl\" and major = 1 and minor = 5\n    or\n    moduleName = \"pre\" and replacementModule = \"re\" and major = 1 and minor = 5\n  )\n  or\n  // Modules deprecated in Python 2.0-2.2\n  (\n    moduleName = \"whrandom\" and replacementModule = \"random\" and major = 2 and minor = 1\n    or\n    moduleName = \"statcache\" and replacementModule = \"no replacement\" and major = 2 and minor = 2\n    or\n    moduleName = \"mpz\" and replacementModule = \"a third party\" and major = 2 and minor = 2\n  )\n  or\n  // Modules deprecated in Python 2.3-2.4\n  (\n    moduleName = \"rfc822\" and replacementModule = \"email\" and major = 2 and minor = 3\n    or\n    moduleName = \"mimetools\" and replacementModule = \"email\" and major = 2 and minor = 3\n    or\n    moduleName = \"MimeWriter\" and replacementModule = \"email\" and major = 2 and minor = 3\n    or\n    moduleName = \"mimify\" and replacementModule = \"email\" and major = 2 and minor = 3\n    or\n    moduleName = \"xreadlines\" and replacementModule = \"no replacement\" and major = 2 and minor = 3\n    or\n    moduleName = \"rotor\" and replacementModule = \"no replacement\" and major = 2 and minor = 4\n  )\n  or\n  // Modules deprecated in Python 2.5-2.6\n  (\n    moduleName = \"gopherlib\" and replacementModule = \"no replacement\" and major = 2 and minor = 5\n    or\n    moduleName = \"rgbimgmodule\" and replacementModule = \"no replacement\" and major = 2 and minor = 5\n    or\n_______________ // 补全条件\n    or\n    moduleName = \"sets\" and replacementModule = \"builtins\" and major = 2 and minor = 6\n  )\n  or\n  // Other deprecated modules\n  (\n    moduleName = \"buildtools\" and replacementModule = \"no replacement\" and major = 2 and minor = 3\n    or\n    moduleName = \"cfmfile\" and replacementModule = \"no replacement\" and major = 2 and minor = 4\n    or\n    moduleName = \"macfs\" and replacementModule = \"no replacement\" and major = 2 and minor = 3\n    or\n    moduleName = \"md5\" and replacementModule = \"hashlib\" and major = 2 and minor = 5\n    or\n    moduleName = \"sha\" and replacementModule = \"hashlib\" and major = 2 and minor = 5\n  )\n}\n\n/**\n * Constructs a deprecation warning message for a module\n *\n * @param deprecatedModuleName The name of the deprecated module\n * @return A string describing when the module was deprecated\n */\nstring deprecation_message(string deprecatedModuleName) {\n  // Find the version where the module was deprecated and format the message\n  exists(int majorVersion, int minorVersion | \n    deprecated_module(deprecatedModuleName, _, majorVersion, minorVersion)\n  |\n    result =\n      \"The \" + deprecatedModuleName + \" module was deprecated in version \" + \n      majorVersion.toString() + \".\" + minorVersion.toString() + \".\"\n  )\n}\n\n/**\n * Constructs a replacement suggestion message for a deprecated module\n *\n * @param deprecatedModuleName The name of the deprecated module\n * @return A string with replacement suggestion or empty string if no replacement\n */\nstring replacement_message(string deprecatedModuleName) {\n  // Check if there's a replacement module and format the message accordingly\n  exists(string replacementModule | \n    deprecated_module(deprecatedModuleName, replacementModule, _, _)\n  |\n    (result = \" Use \" + replacementModule + \" module instead.\" and \n     not replacementModule = \"no replacement\")\n    or\n    (result = \"\" and replacementModule = \"no replacement\")\n  )\n}\n\n// Main query to find imports of deprecated modules\nfrom ImportExpr importExpr, string moduleName, string replacementModule\nwhere\n  // Get the name of the imported module\n  moduleName = importExpr.getName() and\n  // Verify the module is deprecated\n  deprecated_module(moduleName, replacementModule, _, _) and\n  // Exclude imports that are properly handled with ImportError exception handling\n  not exists(Try tryBlock, ExceptStmt exceptHandler | \n    exceptHandler = tryBlock.getAHandler() and\n    exceptHandler.getType().pointsTo(ClassValue::importError()) and\n    exceptHandler.containsInScope(importExpr)\n  )\nselect importExpr, deprecation_message(moduleName) + replacement_message(moduleName)",
    "output": "moduleName = \"multifile\" and replacementModule = \"email\" and major = 2 and minor = 5"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/paramiko-command-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies potential security risks where user-supplied data can lead to",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Remote server command execution vulnerability\n * @description Identifies potential security risks where user-supplied data can lead to\n *              command execution on remote systems, potentially affecting other users\n *              or critical infrastructure components\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.3\n * @precision high\n * @id py/paramiko-command-injection\n * @tags security\n *       experimental\n *       external/cwe/cwe-074\n */\n\n// Import essential Python language support for security analysis\nimport python\n// Import experimental functionality for detecting remote command execution vulnerabilities\nimport experimental.semmle.python.security.RemoteCommandExecution\n// Import path graph utilities to visualize and track data flow propagation\nimport RemoteCommandExecutionFlow::PathGraph\n\n// Define variables representing the start and end points of the data flow\nfrom RemoteCommandExecutionFlow::PathNode untrustedInputSource, RemoteCommandExecutionFlow::PathNode remoteCommandSink\n// Ensure there is a complete data flow path from the untrusted source to the command execution sink\nwhere RemoteCommandExecutionFlow::flowPath(untrustedInputSource, remoteCommandSink)\n// Output the vulnerability details including the full propagation path\nselect remoteCommandSink.getNode(), untrustedInputSource, remoteCommandSink, \n       \"This command execution originates from a $@.\", untrustedInputSource.getNode(),\n       \"user-controlled input source\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/polluting-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies 'import *' statements that risk namespace pollution",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Star import namespace pollution\n * @description Identifies 'import *' statements that risk namespace pollution\n *              when the source module doesn't define '__all__' to restrict exports\n * @kind problem\n * @tags maintainability\n *       modularity\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/polluting-import\n */\n\n// Import the Python analysis framework for AST and module analysis\nimport python\n\n// Predicate to determine if a module provides a controlled public interface\npredicate moduleHasControlledExports(ModuleValue importedModule) {\n  // Built-in modules inherently have controlled namespaces\n  importedModule.isBuiltin()\n  or\n  // Check if '__all__' is defined in the module's import-time scope\n  importedModule.getScope().(ImportTimeScope).definesName(\"__all__\")\n  or\n  // Verify '__all__' exists in the module's initialization context\n  importedModule.getScope().getInitModule().(ImportTimeScope).definesName(\"__all__\")\n}\n\n// Query to detect star imports that may cause namespace pollution\nfrom ImportStar starImport, ModuleValue importedModule\nwhere \n  // Establish relationship between import statement and source module\n  importedModule.importedAs(starImport.getImportedModuleName())\n  and\n  // Filter out modules with properly controlled exports\n  not moduleHasControlledExports(importedModule)\n  and\n  // Ensure the module can be located in the codebase\n  not importedModule.isAbsent()\nselect starImport,\n  \"Namespace pollution risk: Module $@ lacks '__all__' definition for star import.\",\n  importedModule, importedModule.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/tarslip]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测tar存档解压过程中的路径遍历漏洞。当解压操作未验证文件路径是否",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description 检测tar存档解压过程中的路径遍历漏洞。当解压操作未验证文件路径是否\n *              限制在目标目录内时，攻击者可能利用包含\"../\"序列的路径覆盖任意文件。\n * @kind path-problem\n * @id py/tarslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\n// 定义不可信输入源和不安全的文件提取操作\nfrom TarSlipFlow::PathNode taintedSource, \n     TarSlipFlow::PathNode unsafeExtraction\n// 验证从不可信输入源到不安全文件提取操作的数据流路径是否存在\nwhere TarSlipFlow::flowPath(taintedSource, unsafeExtraction)\n// 输出结果：不安全的文件提取操作、不可信输入源、提取操作详情及安全警告\nselect unsafeExtraction.getNode(), \n       taintedSource, \n       unsafeExtraction, \n       \"This file extraction depends on a $@.\", \n       taintedSource.getNode(),\n       \"potentially untrusted source\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python 函数定义源码位置映射\n * @description 此查询用于分析 Python 代码库中的所有函数定义，建立每个可调用实体与其源代码文件位置的精确对应关系。\n *              通过这种映射，可以快速定位任何函数定义的源文件，有助于代码审计、依赖分析和安全研究。\n * @kind source-link\n * @id py/function-source-links\n * @metricType callable\n_______________ // 补全条件\n\nimport python\n\n// 提取所有 Python 函数定义及其源码位置信息\nfrom Function pyFunction, Location defLocation\nwhere defLocation = pyFunction.getLocation()\nselect pyFunction, defLocation.getFile()",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of insecure SSL/TLS version\n * @description Detects when insecure SSL/TLS protocol versions are used, potentially exposing connections to attacks.\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n/* Represents protocol configuration nodes that may use insecure SSL/TLS versions */\nclass InsecureProtocolConfig extends DataFlow::Node {\n  InsecureProtocolConfig() {\n    /* Case 1: Insecure connection created with context */\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    /* Case 2: Insecure connection created without context */\n    unsafe_connection_creation_without_context(this, _)\n    or\n    /* Case 3: Insecure context creation */\n    unsafe_context_creation(this, _)\n  }\n\n  /* Get the function node associated with this configuration */\n  DataFlow::Node getAssociatedFunction() { result = this.(DataFlow::CallCfgNode).getFunction() }\n}\n\n/* Represents nodes that can be named (function calls or attribute references) */\nclass QualifiedNode extends DataFlow::Node {\n  QualifiedNode() {\n    /* Case 1: Node is a function from a protocol configuration */\n    this = any(InsecureProtocolConfig ipc).getAssociatedFunction()\n    or\n    /* Case 2: Node is an attribute reference of another qualified node */\n    this = any(QualifiedNode qn).(DataFlow::AttrRef).getObject()\n_______________ // 补全条件\n}\n\n/* Get the qualified name of a qualified node */\nstring getNodeQualifiedName(QualifiedNode node) {\n  /* Case 1: Direct function name */\n  result = node.asExpr().(Name).getId()\n  or\n  /* Case 2: Attribute access chain */\n  exists(DataFlow::AttrRef attrRef | attrRef = node |\n    result = getNodeQualifiedName(attrRef.getObject()) + \".\" + attrRef.getAttributeName()\n  )\n}\n\n/* Get descriptive name for protocol configuration */\nstring getConfigNodeDescription(InsecureProtocolConfig configNode) {\n  /* Case 1: Function call configuration */\n  exists(DataFlow::CallCfgNode callNode | callNode = configNode |\n    result = \"call to \" + getNodeQualifiedName(callNode.getFunction())\n  )\n  or\n  /* Case 2: Context modification (non-call, non-context-creation) */\n  not configNode instanceof DataFlow::CallCfgNode and\n  not configNode instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n/* Get appropriate verb based on specificity flag */\nstring getVerbForm(boolean specificityFlag) {\n  specificityFlag = true and result = \"specified\"\n  or\n  specificityFlag = false and result = \"allowed\"\n}\n\n/* Query to detect insecure SSL/TLS version usage */\nfrom\n  DataFlow::Node insecureConnectionNode, string insecureVersion, \n  InsecureProtocolConfig configNode, boolean specificityFlag\nwhere\n  /* Case 1: Insecure connection with context */\n  (\n    unsafe_connection_creation_with_context(insecureConnectionNode, insecureVersion, configNode, specificityFlag)\n  )\n  or\n  /* Case 2: Insecure connection without context */\n  (\n    unsafe_connection_creation_without_context(insecureConnectionNode, insecureVersion) and\n    configNode = insecureConnectionNode and\n    specificityFlag = true\n  )\n  or\n  /* Case 3: Insecure context creation */\n  (\n    unsafe_context_creation(configNode, insecureVersion) and\n    insecureConnectionNode = configNode and\n    specificityFlag = true\n  )\nselect insecureConnectionNode,\n  \"Insecure SSL/TLS protocol version \" + insecureVersion + \" \" + getVerbForm(specificityFlag) + \" by $@.\",\n  configNode, getConfigNodeDescription(configNode)",
    "output": "}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commit-display-strings]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Display strings of commits",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Display strings of commits\n * @kind display-string\n * @id py/commit-display-strings\n * @metricType commit\n */\n\nimport python  // 导入Python语言分析库，用于Python代码语义分析\nimport external.VCS  // 导入外部版本控制库，提供版本历史和提交记录访问能力\n\n// 查询范围：从版本控制系统中提取所有提交记录\nfrom Commit commitRecord\n// 构造输出结果：包含提交修订ID和格式化的提交信息（含日期）\nselect \n    commitRecord.getRevisionName(), \n    commitRecord.getMessage() + \"(\" + commitRecord.getDate().toString() + \")\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commented-out-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code segments that have been deactivated through commenting,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inactive commented code detection\n * @description Detects code segments that have been deactivated through commenting,\n * which can negatively impact code clarity and maintenance by preserving outdated\n * or non-executable code within the source files.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code\n */\n\n// Import Python language support for source code analysis\nimport python\n\n// Import lexical analysis utilities to identify commented code sections\nimport Lexical.CommentedOutCode\n\n// Define the main query to find commented code blocks\nfrom CommentedOutCodeBlock inactiveCode\n// Apply filtering condition to exclude legitimate documentation or example code\nwhere not inactiveCode.maybeExampleCode()\n// Generate alert for each identified commented code block\nselect inactiveCode, \"This comment contains code that has been commented out and is no longer active.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/efferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the number of distinct external classes that each class depends on.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class External Dependency Analysis\n * @description Calculates the number of distinct external classes that each class depends on.\n *              This metric helps identify highly coupled classes that may be harder to maintain and test.\n * @kind treemap\n * @id py/efferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags testability\n *       modularity\n */\n\nimport python\n\n// Analyze each class in the codebase to determine its external dependencies\nfrom ClassMetrics analyzedClass\nwhere exists(analyzedClass.getEfferentCoupling())\nselect analyzedClass, \n       analyzedClass.getEfferentCoupling() as efferentCouplingCount \norder by efferentCouplingCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/elliptic-curve-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects and catalogs elliptic curve cryptography implementations",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Elliptic Curve Cryptography Implementation Detection\n * @description Detects and catalogs elliptic curve cryptography implementations\n *              within Python cryptographic libraries for CBOM analysis\n * @kind problem\n * @id py/quantum-readiness/cbom/elliptic-curve-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import necessary Python language analysis modules\nimport python\n\n// Import experimental cryptographic framework with elliptic curve definitions\nimport experimental.cryptography.Concepts\n\n// Main query logic to identify elliptic curve cryptographic algorithm implementations\nfrom EllipticCurveAlgorithm ecAlgorithm\n\n// Generate formatted output containing algorithm name and key size details\nselect ecAlgorithm,\n  \"Algorithm: \" + ecAlgorithm.getCurveName() + \n  \" | Key Size (bits): \" + ecAlgorithm.getCurveBitSize().toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/similar-lines-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Analysis placeholder for evaluating similarity metrics between files.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Similar lines in files\n * @description Analysis placeholder for evaluating similarity metrics between files.\n *              This implementation selects target files and assigns arbitrary integer similarity scores.\n *              Note: The actual similarity calculation algorithm is not implemented in this version.\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags testability\n * @id py/similar-lines-in-files\n */\n\nimport python // Python module for code analysis and query operations\n\n// Define variables for the target file and its similarity score\nfrom File targetFile, int similarityScore\n\n// Apply filtering conditions (none in this placeholder implementation)\nwhere \n  none()\n\n// Output results: display the target file and its similarity score,\n// ordered by the similarity score in descending order\nselect targetFile, similarityScore order by similarityScore desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/hardcoded-credentials]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Credentials are hard coded in the source code of the application.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Hard-coded credentials\n * @description Credentials are hard coded in the source code of the application.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.8\n * @precision medium\n * @id py/hardcoded-credentials\n * @tags security\n *       external/cwe/cwe-259\n *       external/cwe/cwe-321\n *       external/cwe/cwe-798\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.filters.Tests\nprivate import semmle.python.dataflow.new.internal.DataFlowDispatch as DataFlowDispatch\nprivate import semmle.python.dataflow.new.internal.Builtins::Builtins as Builtins\nprivate import semmle.python.frameworks.data.ModelsAsData\n\n// 定义一个绑定集，用于存储字符和分数的映射关系\nbindingset[char, fraction]\n\n// 判断字符串字面量中某个字符的数量是否少于给定比例\npredicate fewer_characters_than(StringLiteral str, string char, float fraction) {\n  exists(string text, int chars |\n    text = str.getText() and // 获取字符串文本内容\n    chars = count(int i | text.charAt(i) = char) // 计算指定字符的数量\n  |\n    /* Allow one character */\n    chars = 1 or // 如果字符数量为1，则满足条件\n    chars < text.length() * fraction // 如果字符数量小于文本长度乘以给定比例，则满足条件\n  )\n}\n\n// 判断名称是否可能是反射名称\npredicate possible_reflective_name(string name) {\n  any(Function f).getName() = name // 检查是否有函数名匹配\n  or\n  any(Class c).getName() = name // 检查是否有类名匹配\n  or\n  any(Module m).getName() = name // 检查是否有模块名匹配\n  or\n  exists(Builtins::likelyBuiltin(name)) // 检查是否是内建函数名\n}\n\n// 计算字符串字面量中的字符数量\nint char_count(StringLiteral str) { result = count(string c | c = str.getText().charAt(_)) }\n\n// 判断字符串字面量是否是首字母大写的单词\npredicate capitalized_word(StringLiteral str) { str.getText().regexpMatch(\"[A-Z][a-z]+\") }\n\n// 判断字符串字面量是否是格式化字符串\npredicate format_string(StringLiteral str) { str.getText().matches(\"%{%}%\") }\n\n// 判断控制流节点是否可能是凭证信息\npredicate maybeCredential(ControlFlowNode f) {\n  /* A string that is not too short and unlikely to be text or an identifier. */\n  exists(StringLiteral str | str = f.getNode() |\n    /* At least 10 characters */\n    str.getText().length() > 9 and // 字符串长度至少为10个字符\n    /* Not too much whitespace */\n    fewer_characters_than(str, \" \", 0.05) and // 空格字符不超过总长度的5%\n    /* or underscores */\n    fewer_characters_than(str, \"_\", 0.2) and // 下划线字符不超过总长度的20%\n    /* Not too repetitive */\n    exists(int chars | chars = char_count(str) |\n      chars > 15 or // 字符种类超过15种\n      chars * 3 > str.getText().length() * 2 // 字符种类的三倍大于字符串长度的两倍\n    ) and\n    not possible_reflective_name(str.getText()) and // 不是反射名称\n    not capitalized_word(str) and // 不是首字母大写的单词\n    not format_string(str) // 不是格式化字符串\n  )\n  or\n  /* Or, an integer with over 32 bits */\n  exists(IntegerLiteral lit | f.getNode() = lit |\n    not exists(lit.getValue()) and // 整数值不存在\n    /* Not a set of flags or round number */\n    not lit.getN().matches(\"%00%\") // 不是一组标志或整数\n  )\n}\n\n// 定义硬编码值源类，继承自数据流节点类\nclass HardcodedValueSource extends DataFlow::Node {\n  HardcodedValueSource() { maybeCredential(this.asCfgNode()) } // 如果当前节点可能是凭证信息，则实例化该类\n}\n\n// 定义凭证接收器类，继承自数据流节点类\nclass CredentialSink extends DataFlow::Node {\n  CredentialSink() {\n    exists(string s | s.matches(\"credentials-%\") |\n      // 实际的接收器类型将是诸如 `credentials-password` 或 `credentials-username` 之类的内容\n      this = ModelOutput::getASinkNode(s).asSink()\n    )\n    or\n    exists(string name |\n      name.regexpMatch(getACredentialRegex()) and // 匹配凭证正则表达式\n      not name.matches(\"%file\") // 排除文件类型的凭证\n    |\n      exists(DataFlowDispatch::ArgumentPosition pos | pos.isKeyword(name) |\n        this.(DataFlow::ArgumentNode).argumentOf(_, pos) // 参数节点是关键字参数\n      )\n      or\n      exists(Keyword k | k.getArg() = name and k.getValue().getAFlowNode() = this.asCfgNode()) // 关键字参数的值是当前节点\n      or\n      exists(CompareNode cmp, NameNode n | n.getId() = name |\n        cmp.operands(this.asCfgNode(), any(Eq eq), n) // 比较操作符的操作数是当前节点和名称节点\n        or\n        cmp.operands(n, any(Eq eq), this.asCfgNode()) // 比较操作符的操作数是名称节点和当前节点\n      )\n    )\n  }\n}\n\n/**\n * Gets a regular expression for matching names of locations (variables, parameters, keys) that\n * indicate the value being held is a credential.\n */\nprivate string getACredentialRegex() {\n  result = \"(?i).*pass(wd|word|code|phrase)(?!.*question).*\" or // 匹配包含密码、密码短语等的变量名，但不包括问题部分\n  result = \"(?i).*(puid|username|userid).*\" or // 匹配包含用户名、用户ID等的变量名\n  result = \"(?i).*(cert)(?!.*(format|name)).*\" // 匹配包含证书的变量名，但不包括格式或名称部分\n}\n\n// 定义硬编码凭证配置模块，实现数据流配置接口\nprivate module HardcodedCredentialsConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof HardcodedValueSource } // 判断节点是否是硬编码值源\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof CredentialSink } // 判断节点是否是凭证接收器\n\n  predicate observeDiffInformedIncrementalMode() { any() } // 观察差异通知增量模式\n}\n\n// 定义全局数据流跟踪模块，使用硬编码凭证配置模块进行配置\nmodule HardcodedCredentialsFlow = TaintTracking::Global<HardcodedCredentialsConfig>;\n\nimport HardcodedCredentialsFlow::PathGraph // 导入路径图模块\n\nfrom HardcodedCredentialsFlow::PathNode src, HardcodedCredentialsFlow::PathNode sink // 从路径图中选择源节点和目标节点\nwhere\n  HardcodedCredentialsFlow::flowPath(src, sink) and // 判断是否存在从源节点到目标节点的数据流路径\n  not any(TestScope test).contains(src.getNode().asCfgNode().getNode()) // 排除测试范围内的节点\nselect src.getNode(), src, sink, \"This hardcoded value is $@.\", sink.getNode(), // 选择源节点、目标节点以及相关信息\n  \"used as credentials\" // 输出硬编码值被用作凭证的信息"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Backspace escape in regular expression\n * @description Detects the use of '\\b' to represent a backspace character within regular expressions.\n *              This can be confusing because outside character sets, '\\b' typically means word boundary.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int escapePos\nwhere\n  // Check if the character at escapePos is an escaping backslash\n  regexPattern.escapingChar(escapePos) and\n  // Ensure the character following the escape is 'b'\n  regexPattern.getChar(escapePos + 1) = \"b\" and\n  // Verify the escape sequence is within a character set\n_______________ // 补全条件\n    regexPattern.charSet(charSetBegin, charSetFinish) and\n    // The escape position must be inside the character set\n    charSetBegin < escapePos and \n    charSetFinish > escapePos\n  )\nselect regexPattern, \"Backspace escape in regular expression at offset \" + escapePos + \".\"",
    "output": "exists(int charSetBegin, int charSetFinish |"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unexpected-raise-in-special-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects special methods that raise non-standard exceptions,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-standard exception raised in special method\n * @description Detects special methods that raise non-standard exceptions, \n *              which violates their expected interface and may cause unexpected behavior.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/unexpected-raise-in-special-method\n */\n\nimport python\n\n// Helper predicate to identify attribute-related special methods\nprivate predicate isAttributeMethod(string methodIdentifier) {\n  methodIdentifier = [\"__getattribute__\", \"__getattr__\", \"__setattr__\"]\n}\n\n// Helper predicate to identify indexing-related special methods\nprivate predicate isIndexingMethod(string methodIdentifier) {\n  methodIdentifier = [\"__getitem__\", \"__setitem__\", \"__delitem__\"]\n}\n\n// Helper predicate to identify arithmetic operation special methods\nprivate predicate isArithmeticMethod(string methodIdentifier) {\n  methodIdentifier in [\n      \"__add__\", \"__sub__\", \"__or__\", \"__xor__\", \"__rshift__\", \"__pow__\", \"__mul__\", \"__neg__\",\n      \"__radd__\", \"__rsub__\", \"__rdiv__\", \"__rfloordiv__\", \"__div__\", \"__rdiv__\", \"__rlshift__\",\n      \"__rand__\", \"__ror__\", \"__rxor__\", \"__rrshift__\", \"__rpow__\", \"__rmul__\", \"__truediv__\",\n      \"__rtruediv__\", \"__pos__\", \"__iadd__\", \"__isub__\", \"__idiv__\", \"__ifloordiv__\", \"__idiv__\",\n      \"__ilshift__\", \"__iand__\", \"__ior__\", \"__ixor__\", \"__irshift__\", \"__abs__\", \"__ipow__\",\n      \"__imul__\", \"__itruediv__\", \"__floordiv__\", \"__div__\", \"__divmod__\", \"__lshift__\", \"__and__\"\n    ]\n}\n\n// Helper predicate to identify ordering comparison special methods\nprivate predicate isOrderingMethod(string methodIdentifier) {\n  methodIdentifier = [\"__lt__\", \"__le__\", \"__gt__\", \"__ge__\"] or\n  (methodIdentifier = \"__cmp__\" and major_version() = 2)\n}\n\n// Helper predicate to identify type conversion special methods\nprivate predicate isCastMethod(string methodIdentifier) {\n  (methodIdentifier = \"__nonzero__\" and major_version() = 2) or\n  methodIdentifier = [\"__int__\", \"__float__\", \"__long__\", \"__trunc__\", \"__complex__\"]\n}\n\n// Predicate to determine if exception type is appropriate for special method\npredicate isValidExceptionType(string methodIdentifier, ClassObject exceptionClass) {\n  // Valid cases for TypeError\n  exceptionClass.getAnImproperSuperType() = theTypeErrorType() and\n  (\n    methodIdentifier = [\"__copy__\", \"__deepcopy__\", \"__call__\"] or\n    isIndexingMethod(methodIdentifier) or\n    isAttributeMethod(methodIdentifier)\n  )\n  or\n  // Check against preferred exception types\n  isPreferredExceptionType(methodIdentifier, exceptionClass)\n  or\n  // Check parent types against preferred exceptions\n  isPreferredExceptionType(methodIdentifier, exceptionClass.getASuperType())\n}\n\n// Predicate defining preferred exception types for special methods\npredicate isPreferredExceptionType(string methodIdentifier, ClassObject exceptionClass) {\n  // Attribute methods should raise AttributeError\n  isAttributeMethod(methodIdentifier) and exceptionClass = theAttributeErrorType()\n  or\n  // Indexing methods should raise LookupError\n  isIndexingMethod(methodIdentifier) and exceptionClass = Object::builtin(\"LookupError\")\n  or\n  // Ordering methods should raise TypeError\n  isOrderingMethod(methodIdentifier) and exceptionClass = theTypeErrorType()\n  or\n  // Arithmetic methods should raise ArithmeticError\n  isArithmeticMethod(methodIdentifier) and exceptionClass = Object::builtin(\"ArithmeticError\")\n  or\n  // __bool__ method should raise TypeError\n  methodIdentifier = \"__bool__\" and exceptionClass = theTypeErrorType()\n}\n\n// Predicate for cases where raising exception is unnecessary\npredicate isUnnecessaryRaise(string methodIdentifier, string recommendation) {\n  // Special case for __hash__ method\n  methodIdentifier = \"__hash__\" and recommendation = \"use __hash__ = None instead\"\n  or\n  // Cast methods may not need implementation\n  isCastMethod(methodIdentifier) and recommendation = \"there is no need to implement the method at all.\"\n}\n\n// Predicate to identify abstract functions\npredicate isAbstractFunction(FunctionObject methodFunction) {\n  exists(Name decorator |\n    decorator = methodFunction.getFunction().getADecorator() and\n    decorator.getId().matches(\"%abstract%\")\n  )\n}\n\n// Predicate to identify functions that always raise specific exceptions\npredicate alwaysRaisesException(FunctionObject methodFunction, ClassObject exceptionClass) {\n  exceptionClass = methodFunction.getARaisedType() and\n  strictcount(methodFunction.getARaisedType()) = 1 and\n  not exists(methodFunction.getFunction().getANormalExit()) and\n  /* raising StopIteration is equivalent to a return in a generator */\n  not exceptionClass = theStopIterationType()\n}\n\n// Main query selecting special methods with non-standard exception handling\nfrom FunctionObject f, ClassObject cls, string message\nwhere\n  f.getFunction().isSpecialMethod() and\n  not isAbstractFunction(f) and\n  alwaysRaisesException(f, cls) and\n  (\n    // Case 1: Unnecessary raise with recommendation\n    isUnnecessaryRaise(f.getName(), message) and \n    not cls.getName() = \"NotImplementedError\"\n    or\n    // Case 2: Invalid exception type with alternative suggestion\n    not isValidExceptionType(f.getName(), cls) and\n    not cls.getName() = \"NotImplementedError\" and\n    exists(ClassObject preferredType | \n      isPreferredExceptionType(f.getName(), preferredType) |\n      message = \"raise \" + preferredType.getName() + \" instead\"\n    )\n  )\nselect f, \"Function always raises $@; \" + message, cls, cls.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/assert-literal-constant]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies assert statements that evaluate literal constants,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Assert statement tests the truth value of a literal constant\n * @description Identifies assert statements that evaluate literal constants,\n *              which may behave unexpectedly under compiler optimizations.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/assert-literal-constant\n */\n\nimport python\nimport semmle.python.filters.Tests\n\n// Find assert statements with literal constant test expressions\nfrom Assert assertion, string literalValue\nwhere\n  /* Exclude assertions within test execution contexts */\n  not assertion.getScope().getScope*() instanceof TestScope and\n  /* Extract constant values from different literal types */\n  exists(Expr testExpr | testExpr = assertion.getTest() |\n    /* Handle integer literal constants */\n    literalValue = testExpr.(IntegerLiteral).getN()\n    or\n    /* Handle string literal constants with quoted representation */\n    literalValue = \"\\\"\" + testExpr.(StringLiteral).getS() + \"\\\"\"\n    or\n    /* Handle named constants (True/False/None) */\n    literalValue = testExpr.(NameConstant).toString()\n  ) and\n  /* Exclude assertions at the end of elif statement chains */\n  not exists(If ifStmt | ifStmt.getElif().getAnOrelse() = assertion)\nselect assertion, \"Assert of literal constant \" + literalValue + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Misnamed function\n * @description Functions with names starting with uppercase letters reduce code readability.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python  // Import Python library for analyzing Python source code\n\n// Predicate to identify functions with uppercase-initial names\npredicate hasUppercaseInitialName(Function func) {\n  exists(string initialChar |\n    initialChar = func.getName().prefix(1) and  // Extract first character of function name\n    initialChar != initialChar.toLowerCase()   // Check if character is not lowercase\n  )\n_______________ // 补全条件\n\n// Query to find misnamed functions while avoiding duplicate reports\nfrom Function func\nwhere\n  func.inSource() and                    // Ensure function is defined in source code\n  hasUppercaseInitialName(func) and      // Verify function starts with uppercase letter\n  not exists(Function dupFunc |          // Exclude duplicate function reports\n    dupFunc != func and                  // Different function instance\n    dupFunc.getLocation().getFile() = func.getLocation().getFile() and  // Same file\n    hasUppercaseInitialName(dupFunc)     // Also has uppercase-initial name\n  )\nselect func, \"Function names should start in lowercase.\"  // Report finding with recommendation",
    "output": "}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/class-extents]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies the location and extent of all classes in the codebase.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Extents of classes\n * @description Identifies the location and extent of all classes in the codebase.\n * @kind extent\n * @id py/class-extents\n * @metricType reftype\n */\n\nimport python\n\n// 查询所有类的范围信息\nfrom Class classExtent\n// 选择类的位置信息和类本身\nselect classExtent.getLocation(), classExtent"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/ineffectual-statement]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A statement has no effect",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Statement has no effect\n * @description A statement has no effect\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/ineffectual-statement\n */\n\nimport python\n\n// Attribute analysis predicates\n/**\n * Determines if an attribute is understood by tracking its class hierarchy\n */\npredicate understood_attribute(Attribute attrRef, ClassValue originClass, ClassValue attrClass) {\n  exists(string attrName | attrRef.getName() = attrName |\n    attrRef.getObject().pointsTo().getClass() = originClass and\n    originClass.attr(attrName).getClass() = attrClass\n  )\n}\n\n/**\n * Checks if attribute access has side effects through descriptor types\n */\npredicate side_effecting_attribute(Attribute attrRef) {\n  exists(ClassValue descriptorClass |\n    understood_attribute(attrRef, _, descriptorClass) and\n    side_effecting_descriptor_type(descriptorClass)\n  )\n}\n\n/**\n * Identifies attributes that might have side effects\n */\npredicate maybe_side_effecting_attribute(Attribute attrRef) {\n  not understood_attribute(attrRef, _, _) and not attrRef.pointsTo(_)\n  or\n  side_effecting_attribute(attrRef)\n}\n\n/**\n * Determines if a descriptor type has side effects\n */\npredicate side_effecting_descriptor_type(ClassValue descriptor) {\n  descriptor.isDescriptorType() and\n  // Exclude specific built-in descriptor types known to be side-effect free\n  not descriptor = ClassValue::functionType() and\n  not descriptor = ClassValue::staticmethod() and\n  not descriptor = ClassValue::classmethod()\n}\n\n// Binary operation analysis predicates\n/**\n * Identifies binary operations with potential side effects\n */\npredicate side_effecting_binary(Expr binaryExpr) {\n  exists(Expr operand, ClassValue operandClass, string methodName |\n    binary_operator_special_method(binaryExpr, operand, operandClass, methodName)\n    or\n    comparison_special_method(binaryExpr, operand, operandClass, methodName)\n  |\n    methodName = special_method() and\n    operandClass.hasAttribute(methodName) and\n    not exists(ClassValue declaringClass |\n      declaringClass.declaresAttribute(methodName) and\n      declaringClass = operandClass.getASuperType() and\n      declaringClass.isBuiltin() and\n      not declaringClass = ClassValue::object()\n    )\n  )\n}\n\npragma[nomagic]\nprivate predicate binary_operator_special_method(\n  BinaryExpr binaryExpr, Expr leftOperand, ClassValue leftClass, string methodName\n) {\n  methodName = special_method() and\n  leftOperand = binaryExpr.getLeft() and\n  methodName = binaryExpr.getOp().getSpecialMethodName() and\n  leftOperand.pointsTo().getClass() = leftClass\n}\n\npragma[nomagic]\nprivate predicate comparison_special_method(\n  Compare compareExpr, Expr comparedOperand, ClassValue operandClass, string methodName\n) {\n  exists(Cmpop op |\n    compareExpr.compares(comparedOperand, op, _) and\n    methodName = op.getSpecialMethodName()\n  ) and\n  comparedOperand.pointsTo().getClass() = operandClass\n}\n\nprivate string special_method() {\n  result = any(Cmpop c).getSpecialMethodName()\n  or\n  result = any(BinaryExpr b).getOp().getSpecialMethodName()\n}\n\n// Notebook analysis predicates\n/**\n * Checks if a file is a Jupyter/IPython notebook\n */\npredicate is_notebook(File sourceFile) {\n  exists(Comment comment | comment.getLocation().getFile() = sourceFile |\n    comment.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\n/** Identifies expressions within Jupyter/IPython notebooks */\npredicate in_notebook(Expr expr) { is_notebook(expr.getScope().(Module).getFile()) }\n\n// Testing context predicates\n/**\n * Gets the FunctionValue for unittest.TestCase's assertRaises method\n */\nFunctionValue assertRaises() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\n/** Checks if an expression is within a test for exception raising */\npredicate in_raises_test(Expr expr) {\n  exists(With withBlock |\n    withBlock.contains(expr) and\n    withBlock.getContextExpr() = assertRaises().getACall().getNode()\n  )\n}\n\n// Python 2 compatibility predicates\n/** Identifies Python 2 print statements (>> syntax) */\npredicate python2_print(Expr expr) {\n  expr.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n  expr.(BinaryExpr).getOp() instanceof RShift\n  or\n  python2_print(expr.(Tuple).getElt(0))\n}\n\n// Core analysis predicate\n/**\n * Determines if an expression has no effect\n */\npredicate no_effect(Expr expr) {\n  // Exclude string literals (used as docstrings/comments)\n  not expr instanceof StringLiteral and\n  // Exclude expressions with known side effects\n  not expr.hasSideEffects() and\n  // Check all sub-expressions for potential side effects\n  forall(Expr subExpr | subExpr = expr.getASubExpression*() |\n    not side_effecting_binary(subExpr) and\n    not maybe_side_effecting_attribute(subExpr)\n  ) and\n  // Exclude special contexts where expressions might have semantic meaning\n  not in_notebook(expr) and\n  not in_raises_test(expr) and\n  not python2_print(expr)\n}\n\n// Main query\nfrom ExprStmt stmt\nwhere no_effect(stmt.getValue())\nselect stmt, \"This statement has no effect.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：超类属性遮蔽子类方法是指在继承体系中，超类的 __init__ 方法中定义的实例属性",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 超类属性遮蔽子类方法是指在继承体系中，超类的 __init__ 方法中定义的实例属性\n *              与子类中定义的方法同名，导致子类方法无法正常访问的问题。这种情况会导致\n *              运行时行为异常，因为属性赋值会覆盖方法引用。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 本查询通过分析类继承体系、属性定义和方法声明，检测子类方法是否被超类\n * 初始化方法中定义的属性遮蔽的情况。核心检测逻辑包括：\n * 1. 验证类之间的直接继承关系\n * 2. 确认子类声明了被遮蔽的方法\n * 3. 在超类初始化方法中定位同名属性赋值\n * 4. 排除超类中存在同名方法的情况（视为有意设计）\n */\n\nimport python\n\n// 定义谓词：判断子类方法是否被超类属性遮蔽\npredicate isMethodShadowedBySuperAttribute(\n  ClassObject subclass, ClassObject superclass, Assign attributeAssignment, FunctionObject shadowedMethod\n) {\n  // 验证继承关系：subclass 直接继承自 superclass\n  subclass.getASuperType() = superclass and\n  \n  // 确认子类声明了被遮蔽的方法\n  subclass.declaredAttribute(shadowedMethod.getName()) = shadowedMethod and\n  \n  // 在超类初始化方法中查找同名属性赋值\n  exists(FunctionObject superInitMethod, Attribute attributeTarget |\n    // 超类定义了 __init__ 方法\n    superclass.declaredAttribute(\"__init__\") = superInitMethod and\n    \n    // 属性赋值的目标是 attributeTarget\n    attributeTarget = attributeAssignment.getATarget() and\n    \n    // 属性赋值对象是 self\n    attributeTarget.getObject().(Name).getId() = \"self\" and\n    \n    // 属性名称与子类方法名称相同\n    attributeTarget.getName() = shadowedMethod.getName() and\n    \n    // 赋值操作发生在超类的初始化方法中\n    attributeAssignment.getScope() = superInitMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  \n  // 排除超类中定义同名方法的情况（视为有意设计）\n  not superclass.hasAttribute(shadowedMethod.getName())\n}\n\n// 查询被遮蔽的方法及其相关信息\nfrom ClassObject subclass, ClassObject superclass, Assign attributeAssignment, FunctionObject shadowedMethod\nwhere isMethodShadowedBySuperAttribute(subclass, superclass, attributeAssignment, shadowedMethod)\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superclass.getName() +\n    \"'.\", attributeAssignment, \"attribute\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insufficient cryptographic key strength\n * @description Identifies cryptographic keys with bit lengths below security thresholds, susceptible to brute-force attacks\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/weak-crypto-key\n * @tags security\n *       external/cwe/cwe-326\n */\n\nimport python\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.filters.Tests\n_______________ // 补全条件\nfrom Cryptography::PublicKey::KeyGeneration keyGen, int keyBitLength, DataFlow::Node keySizeOrigin\nwhere\n  // Trace key size parameter to its source\n  keyBitLength = keyGen.getKeySizeWithOrigin(keySizeOrigin)\n  and\n  // Validate against minimum security requirements\n  keyBitLength < keyGen.minimumSecureKeySize()\n  and\n  // Exclude test code from analysis scope\n  not keySizeOrigin.getScope().getScope*() instanceof TestScope\nselect keyGen,\n  \"Generation of $@ key uses \" + keyBitLength.toString() + \" bits, below the secure threshold of \" +\n    keyGen.minimumSecureKeySize().toString() + \" bits (vulnerable to brute-force attacks).\", \n  keySizeOrigin, keyGen.getName()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 调用图结构量化分析：评估调用图的紧凑度与信息密度。\n * 本查询通过统计调用事实基数、关系规模、上下文深度并计算密度指标，\n * 量化调用图的数据压缩效率和结构优化空间，为代码重构提供数据支持。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 输出变量定义：invocationFactCount（调用事实基数）、invocationRelationCount（关系规模）、\n// invocationContextDepth（上下文深度）和invocationDensityMetric（密度指标）\nfrom int invocationFactCount, int invocationRelationCount, int invocationContextDepth, float invocationDensityMetric\n_______________ // 补全条件\n  // 计算调用事实基数：统计所有(调用者节点, 被调用函数)二元组的数量\n  // 同时记录上下文深度信息用于后续密度计算\n  invocationFactCount =\n    strictcount(ControlFlowNode callerNode, CallableValue calleeFunction |\n      exists(PointsToContext callContext |\n        callerNode = calleeFunction.getACall(callContext) and // 提取调用者与被调用者关系\n        invocationContextDepth = callContext.getDepth() // 记录调用上下文深度\n      )\n    ) and\n  // 计算调用图关系规模：统计所有(调用者节点, 被调用函数, 调用上下文)三元组的数量\n  // 使用与事实基数计算相同的逻辑结构，确保计算基准一致\n  invocationRelationCount =\n    strictcount(ControlFlowNode callerNode, CallableValue calleeFunction, PointsToContext callContext |\n      callerNode = calleeFunction.getACall(callContext) and // 提取完整调用关系三元组\n      invocationContextDepth = callContext.getDepth() // 保持上下文深度一致性\n    ) and\n  // 计算密度指标：将调用事实基数转换为相对于关系规模的百分比\n  // 该指标反映调用图的结构紧凑度，数值越高表示信息密度越大\n  invocationDensityMetric = 100.0 * invocationFactCount / invocationRelationCount\nselect invocationContextDepth, invocationFactCount, invocationRelationCount, invocationDensityMetric // 返回分析结果：上下文深度、调用事实基数、关系规模和密度指标",
    "output": "where"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-co-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the average number of additional files modified in commits",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Co-committed Files Count\n * @description Calculates the average number of additional files modified in commits \n *              that also affect a specific file. This metric helps identify files \n *              that are frequently modified together, indicating potential \n *              coupling or dependencies.\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Helper function that determines the total count of files affected in a specific commit\nint countFilesInCommit(Commit c) { \n    result = count(c.getAnAffectedFile()) \n}\n\n// Main analysis logic: evaluate modules with line count metrics for co-commit patterns\nfrom Module analyzedModule\nwhere exists(analyzedModule.getMetrics().getNumberOfLinesOfCode())\nselect analyzedModule,\n  // Calculate the average number of co-committed files for each analyzed module\n  avg(Commit commitAffectingModule, int coCommittedFiles |\n    // Filter commits affecting the module's file and compute co-commit count\n    commitAffectingModule.getAnAffectedFile() = analyzedModule.getFile() and \n    coCommittedFiles = countFilesInCommit(commitAffectingModule) - 1\n  |\n    coCommittedFiles\n  )"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Command execution on a secondary remote server\n * @description user provided command can lead to execute code on an external server that can belong to other users or admins\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.3\n * @precision high\n * @id py/paramiko-command-injection\n * @tags security\n *       experimental\n *       external/cwe/cwe-074\n */\n\n// 导入Python语言库\nimport python\n// 导入实验性的远程命令执行安全分析模块\nimport experimental.semmle.python.security.RemoteCommandExecution\n// 从远程命令执行流中导入路径图类\nimport RemoteCommandExecutionFlow::PathGraph\n\n// 定义数据流源节点和汇节点\nfrom RemoteCommandExecutionFlow::PathNode source, RemoteCommandExecutionFlow::PathNode sink\n// 条件：存在从源节点到汇节点的流路径\nwhere RemoteCommandExecutionFlow::flowPath(source, sink)\n// 选择汇节点、源节点、汇节点信息，并生成警告信息\nselect sink.getNode(), source, sink, \"This code execution depends on a $@.\", source.getNode(),\n_______________ // 补全条件",
    "output": "\"a user-provided value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-of-identical-expressions]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects redundant comparisons where a value is compared to itself,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comparison of identical values\n * @description Detects redundant comparisons where a value is compared to itself,\n *              typically indicating logical errors or unclear implementation intent.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\nimport python\nimport Expressions.RedundantComparison\n\nfrom RedundantComparison identicalExpr\nwhere \n  // Exclude constant comparisons which are often intentional\n  not identicalExpr.isConstant() \n  // Filter cases where 'self' might be missing to reduce false positives\n  and not identicalExpr.maybeMissingSelf()\nselect identicalExpr, \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type metrics\n * @description Provides counts of different kinds of type annotations in Python code, including parameters, return types, and annotated assignments.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents a built-in type in Python.\n_______________ // 补全条件\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr function) { exists(function.getReturns()) } or\n  TAnnotatedParameter(Parameter parameter) { exists(parameter.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign assignment) { exists(assignment.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr functionExpr;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(functionExpr) }\n  override Expr getAnnotation() { result = functionExpr.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter parameterVar;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(parameterVar) }\n  override Expr getAnnotation() { result = parameterVar.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assignmentStmt;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assignmentStmt) }\n  override Expr getAnnotation() { result = assignmentStmt.getAnnotation() }\n}\n\n/** Holds if `expr` is a forward declaration (string literal) of a type. */\npredicate is_forward_declaration(Expr expr) { expr instanceof StringLiteral }\n\n/** Holds if `expr` is a type that may be difficult to analyze. */\npredicate is_complex_type(Expr expr) {\n  (expr instanceof Subscript and not is_optional_type(expr)) or\n  expr instanceof Tuple or\n  expr instanceof List\n}\n\n/** Holds if `expr` is a type of the form `Optional[...]`. */\npredicate is_optional_type(Subscript expr) { expr.getObject().(Name).getId() = \"Optional\" }\n\n/** Holds if `expr` is a simple type (non-built-in identifier or attribute chain). */\npredicate is_simple_type(Expr expr) {\n  (expr instanceof Name and not expr instanceof BuiltinType) or\n  is_simple_type(expr.(Attribute).getObject())\n}\n\n/** Holds if `expr` is a built-in type. */\npredicate is_builtin_type(Expr expr) { expr instanceof BuiltinType }\n\n// Computes type annotation metrics for different annotation categories\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  category = \"Parameter annotation\" and\n  totalCount = count(AnnotatedParameter parameter) and\n  builtinCount = count(AnnotatedParameter parameter | is_builtin_type(parameter.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedParameter parameter | is_forward_declaration(parameter.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedParameter parameter | is_simple_type(parameter.getAnnotation())) and\n  complexTypeCount = count(AnnotatedParameter parameter | is_complex_type(parameter.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedParameter parameter | is_optional_type(parameter.getAnnotation()))\n  or\n  // Return type annotation metrics\n  category = \"Return type annotation\" and\n  totalCount = count(AnnotatedFunction function) and\n  builtinCount = count(AnnotatedFunction function | is_builtin_type(function.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedFunction function | is_forward_declaration(function.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedFunction function | is_simple_type(function.getAnnotation())) and\n  complexTypeCount = count(AnnotatedFunction function | is_complex_type(function.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedFunction function | is_optional_type(function.getAnnotation()))\n  or\n  // Annotated assignment metrics\n  category = \"Annotated assignment\" and\n  totalCount = count(AnnotatedAssignment assignment) and\n  builtinCount = count(AnnotatedAssignment assignment | is_builtin_type(assignment.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedAssignment assignment | is_forward_declaration(assignment.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedAssignment assignment | is_simple_type(assignment.getAnnotation())) and\n  complexTypeCount = count(AnnotatedAssignment assignment | is_complex_type(assignment.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedAssignment assignment | is_optional_type(assignment.getAnnotation()))\n}\n\n// Query execution and output\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount",
    "output": "class BuiltinType extends Name {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Syntax error detection\n * @description Detects syntax errors causing runtime failures and impeding code analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n_______________ // 补全条件\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import the Python module for code analysis capabilities\nimport python\n\n// Find syntax issues that are not related to encoding problems\nfrom SyntaxError syntaxFault\nwhere not syntaxFault instanceof EncodingError\n\n// Create result with error message and Python version information\nselect syntaxFault, \n       // Format output to include error details and Python version\n       syntaxFault.getMessage() + \" (in Python \" + major_version() + \").\"",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-be-context-manager]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes that implement __del__ for resource cleanup",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class should be a context manager\n * @description Identifies classes that implement __del__ for resource cleanup\n *              but lack context manager protocol support. Converting these\n *              classes to context managers improves resource management\n *              and code clarity.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision medium\n * @id py/should-be-context-manager\n */\n\nimport python\n\nfrom ClassValue cls\nwhere\n  // Exclude built-in classes from analysis scope\n  not cls.isBuiltin() and\n  // Verify absence of context manager protocol implementation\n  not cls.isContextManager() and\n  // Confirm presence of __del__ method for resource cleanup\n  exists(cls.declaredAttribute(\"__del__\"))\nselect cls,\n  \"Class \" + cls.getName() +\n    \" implements __del__ (presumably to release some resource). Consider making it a context manager.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-url-substring-sanitization]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects security risks when URL substrings are validated without proper parsing, which can be bypassed.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incomplete URL substring sanitization\n * @description Detects security risks when URL substrings are validated without proper parsing, which can be bypassed.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Generates regex pattern for widely used top-level domains\nprivate string commonTldPattern() { result = \"com|org|edu|gov|uk|net|io\" }\n\n// Determines if a string literal exhibits URL-like characteristics\npredicate isUrlLike(StringLiteral urlStrLiteral) {\n  exists(string strValue | strValue = urlStrLiteral.getText() |\n    // Match URLs with common TLDs\n    strValue.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + commonTldPattern() +\n        \")(:[0-9]+)?/?\")\n    or\n    // Alternative pattern for HTTP URLs with arbitrary TLDs\n    strValue.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Identifies inadequate sanitization operations applied to URL substrings\npredicate hasInsufficientSanitization(Expr sanitizationExpr, StringLiteral urlStrLiteral) {\n  isUrlLike(urlStrLiteral) and\n  (\n    // Case 1: Direct comparison operations\n    sanitizationExpr.(Compare).compares(urlStrLiteral, any(In i), _)\n    or\n    // Case 2: Unsafe startswith operations\n    exists(Call prefixCall |\n      prefixCall.getFunc().(Attribute).getName() = \"startswith\" and\n      prefixCall.getArg(0) = urlStrLiteral and\n      not urlStrLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\") and\n      sanitizationExpr = prefixCall\n    )\n    or\n    // Case 3: Unsafe endswith operations\n    exists(Call suffixCall |\n      suffixCall.getFunc().(Attribute).getName() = \"endswith\" and\n      suffixCall.getArg(0) = urlStrLiteral and\n      not urlStrLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\") and\n      sanitizationExpr = suffixCall\n    )\n  )\n}\n\n// Main query: Finds expressions with incomplete URL substring sanitization\nfrom Expr sanitizationExpr, StringLiteral urlStrLiteral\nwhere hasInsufficientSanitization(sanitizationExpr, urlStrLiteral)\nselect sanitizationExpr, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlStrLiteral,\n  urlStrLiteral.getText()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name URL redirection from remote source\n * @description Detects URL redirection vulnerabilities where unvalidated user input\n *              can redirect users to malicious websites, enabling phishing attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @sub-severity low\n * @id py/url-redirection\n * @tags security\n *       external/cwe/cwe-601\n * @precision high\n */\n\n// Core Python analysis libraries\nimport python\n\n// Security dataflow analysis for URL redirection\nimport semmle.python.security.dataflow.UrlRedirectQuery\n\n// Path graph visualization module\nimport UrlRedirectFlow::PathGraph\n\n// Identify vulnerable URL redirection paths\nfrom UrlRedirectFlow::PathNode userInputNode, UrlRedirectFlow::PathNode redirectTargetNode\nwhere \n  // Data flows from untrusted user input to redirect target\n  UrlRedirectFlow::flowPath(userInputNode, redirectTargetNode)\nselect \n  // Vulnerable redirect location\n_______________ // 补全条件\n  // Complete dataflow path visualization\n  userInputNode, redirectTargetNode, \n  // Security alert with source annotation\n  \"Untrusted URL redirection depends on a $@.\", \n  userInputNode.getNode(), \n  \"user-provided value\"",
    "output": "redirectTargetNode.getNode(),"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incorrect keyword argument in class instantiation\n * @description Identifies class instantiations using keyword arguments that don't match \n *              any parameter in the class's __init__ method, leading to runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n_______________ // 补全条件\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call instantiationCall, ClassValue targetClass, string invalidArgument, FunctionValue initializerMethod\nwhere\n  // Find class instantiations with invalid keyword arguments\n  illegally_named_parameter(instantiationCall, targetClass, invalidArgument)\n  and\n  // Obtain the initializer method for the target class\n  initializerMethod = get_function_or_initializer(targetClass)\nselect instantiationCall, \n       \"Keyword argument '\" + invalidArgument + \"' is not a supported parameter name of $@.\", \n       initializerMethod,\n       initializerMethod.getQualifiedName()",
    "output": "*       external/cwe/cwe-628"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 近期代码提交分析\n_______________ // 补全条件\n *              通过分析提交频率来评估项目的开发活动水平。\n * @kind treemap\n * @id py/historical-number-of-recent-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\nimport python // 导入Python语言分析库\nimport external.VCS // 导入版本控制系统(VCS)外部库\n\n// 查询提交记录数据\nfrom Commit recentCommit\n// 应用筛选条件：1. 非人工变更；2. 提交时间在180天内\nwhere \n  not artificialChange(recentCommit) and\n  recentCommit.daysToNow() <= 180\n// 返回修订名称及计数（用于聚合统计）\nselect recentCommit.getRevisionName(), 1",
    "output": "* @description 统计最近180天内的代码提交数量，排除人工变更。此查询用于识别代码库的活跃度，"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jwt-missing-verification]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The application does not verify the JWT payload with a cryptographic secret or public key.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name JWT missing secret or public key verification\n * @description The application does not verify the JWT payload with a cryptographic secret or public key.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-missing-verification\n * @tags security\n *       experimental\n *       external/cwe/cwe-347\n */\n\n// 导入Python分析库和实验性概念模型，提供JWT分析所需的基础类和谓词\nimport python\nimport experimental.semmle.python.Concepts\n\n// 查找所有未经验证签名的JWT解码操作\n// 这类操作可能导致安全漏洞，因为未验证的JWT可能被篡改\nfrom JwtDecoding insecureJwtDecoding\n\n// 筛选条件：仅选择那些未执行签名验证的JWT解码实例\n// verifiesSignature()方法检查JWT解码操作是否验证了签名\nwhere not insecureJwtDecoding.verifiesSignature()\n\n// 输出结果：JWT有效载荷及相应的安全警告信息\n// getPayload()方法获取JWT的有效载荷部分\nselect insecureJwtDecoding.getPayload(), \"is not verified with a cryptographic secret or public key.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-data-to-external-api]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies security vulnerabilities where untrusted remote user input",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted data passed to external API\n * @description Identifies security vulnerabilities where untrusted remote user input\n *              flows directly into external API calls without proper sanitization.\n * @id py/untrusted-data-to-external-api\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 7.8\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport ExternalAPIs\nimport UntrustedDataToExternalApiFlow::PathGraph\n\nfrom\n  // Source node representing the entry point of untrusted data flow\n  UntrustedDataToExternalApiFlow::PathNode untrustedDataSource,\n  // Sink node representing the termination point at the vulnerable API call\n  UntrustedDataToExternalApiFlow::PathNode apiSinkNode,\n  // External API call that consumes the tainted data\n  ExternalApiUsedWithUntrustedData vulnerableApiCall\nwhere\n  // Establish connection between sink node and the API's tainted parameter\n  apiSinkNode.getNode() = vulnerableApiCall.getUntrustedDataNode()\n  and\n  // Verify complete data flow path exists from source to sink\n  UntrustedDataToExternalApiFlow::flowPath(untrustedDataSource, apiSinkNode)\nselect\n  // Preserve original output format with enhanced variable naming\n  apiSinkNode.getNode(), untrustedDataSource, apiSinkNode,\n  \"Call to \" + vulnerableApiCall.toString() + \" with untrusted data from $@.\", untrustedDataSource.getNode(),\n  untrustedDataSource.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Provides a comprehensive overview of snapshot metadata including\n *              extractor details, build information, interpreter version,\n *              platform details, source location, and code metrics.\n */\n\nimport python\n\n// Define key-value pairs for snapshot summary data\nfrom string infoKey, string infoValue\nwhere\n  // Extractor version identification\n  infoKey = \"Extractor version\" and \n  py_flags_versioned(\"extractor.version\", infoValue, _)\n  or\n  // Snapshot build timestamp information\n  infoKey = \"Snapshot build time\" and\n  exists(date buildDate | snapshotDate(buildDate) and infoValue = buildDate.toString())\n  or\n  // Python interpreter version in major.minor format\n  infoKey = \"Interpreter version\" and\n  exists(string majorVer, string minorVer |\n    py_flags_versioned(\"extractor_python_version.major\", majorVer, _) and\n    py_flags_versioned(\"extractor_python_version.minor\", minorVer, _) and\n    infoValue = majorVer + \".\" + minorVer\n  )\n  or\n  // Build platform with user-friendly naming\n  infoKey = \"Build platform\" and\n  exists(string platformRaw | py_flags_versioned(\"sys.platform\", platformRaw, _) |\n    if platformRaw = \"win32\"\n    then infoValue = \"Windows\"\n    else\n      if platformRaw = \"linux2\"\n      then infoValue = \"Linux\"\n      else\n        if platformRaw = \"darwin\"\n        then infoValue = \"OSX\"\n        else infoValue = platformRaw\n  )\n  or\n  // Source code location prefix path\n  infoKey = \"Source location\" and sourceLocationPrefix(infoValue)\n  or\n  // Total lines of source code (excluding generated code)\n  infoKey = \"Lines of code (source)\" and\n  infoValue =\n    sum(ModuleMetrics metrics | exists(metrics.getFile().getRelativePath()) | \n        metrics.getNumberOfLinesOfCode()).toString()\n  or\n  // Total lines of code (including all generated code)\n  infoKey = \"Lines of code (total)\" and\n  infoValue = sum(ModuleMetrics metrics | any() | metrics.getNumberOfLinesOfCode()).toString()\nselect infoKey, infoValue",
    "output": "* @name Snapshot Information Summary"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type metrics\n * @description Provides counts of different kinds of type annotations in Python code, \n *              including parameters, return types, and annotated assignments.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents a built-in type in Python (e.g., int, str, bool)\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr func) { exists(func.getReturns()) } or\n  TAnnotatedParameter(Parameter param) { exists(param.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign stmt) { exists(stmt.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr func;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(func) }\n  override Expr getAnnotation() { result = func.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter param;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(param) }\n  override Expr getAnnotation() { result = param.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assign;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assign) }\n  override Expr getAnnotation() { result = assign.getAnnotation() }\n}\n\n/** Holds if `expr` is a forward declaration (string literal) of a type. */\npredicate is_forward_declaration(Expr expr) { expr instanceof StringLiteral }\n\n/** Holds if `expr` is a type that may be difficult to analyze. */\npredicate is_complex_type(Expr expr) {\n  (expr instanceof Subscript and not is_optional_type(expr)) or\n  expr instanceof Tuple or\n  expr instanceof List\n}\n\n/** Holds if `expr` is a type of the form `Optional[...]`. */\npredicate is_optional_type(Subscript expr) { expr.getObject().(Name).getId() = \"Optional\" }\n\n/** Holds if `expr` is a simple type (non-built-in identifier or attribute chain). */\npredicate is_simple_type(Expr expr) {\n  (expr instanceof Name and not expr instanceof BuiltinType) or\n  is_simple_type(expr.(Attribute).getObject())\n}\n\n/** Holds if `expr` is a built-in type. */\npredicate is_builtin_type(Expr expr) { expr instanceof BuiltinType }\n\n// Computes type annotation metrics for different annotation categories\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  category = \"Parameter annotation\" and\n  totalCount = count(AnnotatedParameter param) and\n  builtinCount = count(AnnotatedParameter param | is_builtin_type(param.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedParameter param | is_forward_declaration(param.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedParameter param | is_simple_type(param.getAnnotation())) and\n  complexTypeCount = count(AnnotatedParameter param | is_complex_type(param.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedParameter param | is_optional_type(param.getAnnotation()))\n  or\n_______________ // 补全条件\n  category = \"Return type annotation\" and\n  totalCount = count(AnnotatedFunction func) and\n  builtinCount = count(AnnotatedFunction func | is_builtin_type(func.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedFunction func | is_forward_declaration(func.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedFunction func | is_simple_type(func.getAnnotation())) and\n  complexTypeCount = count(AnnotatedFunction func | is_complex_type(func.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedFunction func | is_optional_type(func.getAnnotation()))\n  or\n  // Annotated assignment metrics\n  category = \"Annotated assignment\" and\n  totalCount = count(AnnotatedAssignment assign) and\n  builtinCount = count(AnnotatedAssignment assign | is_builtin_type(assign.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedAssignment assign | is_forward_declaration(assign.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedAssignment assign | is_simple_type(assign.getAnnotation())) and\n  complexTypeCount = count(AnnotatedAssignment assign | is_complex_type(assign.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedAssignment assign | is_optional_type(assign.getAnnotation()))\n}\n\n// Query execution and output\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount",
    "output": "// Return type annotation metrics"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary pass\n * @description Identifies unnecessary 'pass' statements in Python code\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unnecessary-pass\n */\n\nimport python\n\n// Predicate to determine if an expression statement is a docstring\npredicate is_doc_string(ExprStmt exprStmt) {\n  // Check if the expression value is of Unicode or Bytes type\n  exprStmt.getValue() instanceof Unicode or exprStmt.getValue() instanceof Bytes\n}\n\n// Predicate to check if a statement list contains a docstring\npredicate has_doc_string(StmtList statementList) {\n  // Verify that the parent of the statement list is a Scope\n  // and the first statement is a docstring\n  statementList.getParent() instanceof Scope and\n  is_doc_string(statementList.getItem(0))\n}\n\n// Select Pass statements and their containing statement lists\nfrom Pass passStmt, StmtList stmtList\nwhere\n  // The pass statement is an item in the statement list\n  stmtList.getAnItem() = passStmt and\n  // The list has either more than 2 items, or exactly 2 items without a docstring\n  (strictcount(stmtList.getAnItem()) > 2 or \n_______________ // 补全条件\nselect passStmt, \"Unnecessary 'pass' statement.\"",
    "output": "(strictcount(stmtList.getAnItem()) = 2 and not has_doc_string(stmtList)))"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/side-effect-in-assert]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects assert statements containing expressions with side effects,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name An assert statement has a side-effect\n * @description Detects assert statements containing expressions with side effects,\n *              which can cause behavioral differences between normal and optimized execution.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/side-effect-in-assert\n */\n\nimport python\n\n// Identifies expressions that involve built-in functions known to have side effects\npredicate sideEffectFunctionCall(Expr expr) {\n  exists(string funcName | \n    funcName = expr.(Attribute).getName() or funcName = expr.(Name).getId() |\n    funcName in [\n        \"print\", \"write\", \"append\", \"pop\", \"remove\", \"discard\", \"delete\", \"close\", \"open\", \"exit\"\n      ]\n  )\n}\n\n// Detects calls to specific subprocess module functions that execute system commands\npredicate subprocessSystemCall(Call methodCall) {\n  exists(string subprocessFuncName | \n    subprocessFuncName = \"subprocess.call\" or \n    subprocessFuncName = \"subprocess.check_call\" or \n    subprocessFuncName = \"subprocess.check_output\" |\n    methodCall.getAFlowNode() = Value::named(subprocessFuncName).getACall()\n  )\n}\n\n// Determines if an expression potentially produces side effects\npredicate hasSideEffect(Expr targetExpr) {\n  // Case 1: Standalone yield expressions (excluding pseudo-yields in comprehensions)\n  (targetExpr instanceof Yield and not exists(Comp c | c.contains(targetExpr)))\n  or\n  // Case 2: YieldFrom expressions\n  targetExpr instanceof YieldFrom\n  or\n  // Case 3: Calls to built-in functions with known side effects\n  exists(Call methodCall | \n    methodCall = targetExpr and \n    sideEffectFunctionCall(methodCall.getFunc())\n  )\n  or\n  // Case 4: Calls to subprocess system commands\n  exists(Call methodCall | \n    methodCall = targetExpr and \n    subprocessSystemCall(methodCall)\n  )\n}\n\n// Finds assert statements containing expressions with potential side effects\nfrom Assert assertStmt, Expr targetExpr\nwhere hasSideEffect(targetExpr) and assertStmt.contains(targetExpr)\nselect assertStmt, \"This 'assert' statement contains an $@ which may have side effects.\", targetExpr, \"expression\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-data-to-external-api]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Data provided remotely is used in this external API without sanitization, which could be a security risk.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted data passed to external API\n * @description Data provided remotely is used in this external API without sanitization, which could be a security risk.\n * @id py/untrusted-data-to-external-api\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 7.8\n * @tags security external/cwe/cwe-20\n */\n\n// 导入Python库，用于处理Python代码的解析和分析\nimport python\n// 导入外部API库，用于识别外部API调用\nimport ExternalAPIs\n// 导入路径图类，用于跟踪数据流路径\nimport UntrustedDataToExternalApiFlow::PathGraph\n\n// 从UntrustedDataToExternalApiFlow模块中引入PathNode类，表示数据流路径中的节点\nfrom\n  UntrustedDataToExternalApiFlow::PathNode source, // 源节点，表示不信任数据的起始点\n  UntrustedDataToExternalApiFlow::PathNode sink,   // 汇节点，表示不信任数据的终点（即外部API调用）\n  ExternalApiUsedWithUntrustedData externalApi    // 外部API调用，使用了不信任的数据\nwhere\n  // 条件1：汇节点必须是外部API调用中使用的不信任数据节点\n  sink.getNode() = externalApi.getUntrustedDataNode() and\n  // 条件2：存在从源节点到汇节点的数据流路径\n  UntrustedDataToExternalApiFlow::flowPath(source, sink)\nselect\n  // 选择要报告的结果，包括汇节点、源节点、汇节点、外部API调用的描述信息以及源节点的详细信息\n  sink.getNode(), source, sink,\n  \"Call to \" + externalApi.toString() + \" with untrusted data from $@.\", source.getNode(),\n  source.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-be-context-manager]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes that implement __del__ for resource cleanup",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class should be a context manager\n * @description Identifies classes that implement __del__ for resource cleanup\n *              but lack context manager protocol support. Such classes would\n *              benefit from being converted to context managers for improved\n *              resource handling and code readability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision medium\n * @id py/should-be-context-manager\n */\n\nimport python\n\nfrom ClassValue cls\nwhere\n  // Focus on user-defined classes that manage resources via __del__\n  not cls.isBuiltin() and\n  exists(cls.declaredAttribute(\"__del__\")) and\n  // Exclude classes that already implement context manager protocol\n  not cls.isContextManager()\nselect cls,\n  \"Class \" + cls.getName() +\n    \" implements __del__ (presumably to release some resource). Consider making it a context manager.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-iterable used in for loop\n * @description Detects for loops that attempt to iterate over non-iterable objects, which would cause a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/non-iterable-in-for-loop\n */\n\nimport python\n\n// 检测for循环中使用了不可迭代对象的潜在问题\nfrom For forLoopStmt, ControlFlowNode iterationExprNode, Value targetValue, ClassValue targetClass, ControlFlowNode valueSourceLocation\nwhere\n_______________ // 补全条件\n  forLoopStmt.getIter().getAFlowNode() = iterationExprNode and\n  iterationExprNode.pointsTo(_, targetValue, valueSourceLocation) and\n  // 获取被迭代值的类类型，并验证它是有效的不可迭代类\n  targetValue.getClass() = targetClass and\n  not targetClass.isIterable() and\n  not targetClass.failedInference(_) and\n  // 排除特殊情况的误报：None值和描述符类型可能有特殊处理逻辑\n  not (targetValue = Value::named(\"None\") or targetClass.isDescriptorType())\nselect forLoopStmt, \"This for-loop may attempt to iterate over a $@ of class $@.\", valueSourceLocation,\n  \"non-iterable instance\", targetClass, targetClass.getName()",
    "output": "// 建立for循环与其迭代表达式之间的关联，并追踪到被迭代的值及其来源"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/summarized-callable-call-sites]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies locations where summarized callables are invoked",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Summarized callable call sites\n * @description Identifies locations where summarized callables are invoked\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/summarized-callable-call-sites\n * @tags meta\n * @precision very-low\n */\n\n// Import Python language support\nimport python\n// Import data flow analysis framework\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\n// Import meta metrics utilities\nimport meta.MetaMetrics\n\n// Define variables for call location, summarized function, and invocation type\nfrom DataFlow::Node callLocation, SummarizedCallable summarizedFunc, string invocationType\nwhere\n  // Check if the location represents a direct call to the summarized function\n  (callLocation = summarizedFunc.getACall() and invocationType = \"Call\")\n  or\n  // Check if the location represents a callback to the summarized function\n  (callLocation = summarizedFunc.getACallback() and invocationType = \"Callback\") and\n  // Filter out call sites located in ignored files\n  not callLocation.getLocation().getFile() instanceof IgnoredFile\n// Output the call location with a descriptive message\nselect callLocation, invocationType + \" to \" + summarizedFunc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete special group in regular expression\n * @description An incomplete special group is parsed as a normal group and is unlikely to match the intended strings.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/regex/incomplete-special-group\n */\n\nimport python\nimport semmle.python.regex\n_______________ // 补全条件\nfrom RegExp regexPattern, string missingChar, string groupType\nwhere \n  regexPattern.getText().regexpMatch(\".*\\\\(P<\\\\w+>.*\") and\n  missingChar = \"?\" and \n  groupType = \"named group\"\nselect regexPattern, \"Regular expression is missing '\" + missingChar + \"' in \" + groupType + \".\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Property in old-style class\n * @description Detects property descriptors within legacy Python classes that lack proper support since version 2.1.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/property-in-old-style-class\n */\n\nimport python\n_______________ // 补全条件\n// Identify legacy classes containing property descriptors\nfrom PropertyObject propDescriptor, ClassObject enclosingClass\nwhere \n  // Verify class is properly analyzable and contains the property\n  enclosingClass.declaredAttribute(_) = propDescriptor and\n  not enclosingClass.failedInference() and\n  \n  // Confirm class uses legacy inheritance model (non-new-style)\n  not enclosingClass.isNewStyle()\n\n// Generate warning message with property and class context\nselect propDescriptor,\n  \"Property '\" + propDescriptor.getName() + \"' will malfunction because class '\" + enclosingClass.getName() +\n    \"' uses legacy inheritance (old-style class).\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/doc-string-ratio-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the percentage of lines that contain docstrings in each Python source file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Docstring Coverage Percentage\n * @description Calculates the percentage of lines that contain docstrings in each Python source file.\n * @kind treemap\n * @id py/doc-string-ratio-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\n// Retrieve all Python modules along with their corresponding code metrics\nfrom Module sourceModule, ModuleMetrics codeMetrics\nwhere \n  // Establish relationship between module and its metrics\n  codeMetrics = sourceModule.getMetrics() and \n  // Exclude modules that contain no actual code\n  codeMetrics.getNumberOfLines() > 0\nselect sourceModule,\n  // Compute documentation coverage as a percentage value\n  100.0 * (codeMetrics.getNumberOfLinesOfDocStrings().(float) / codeMetrics.getNumberOfLines().(float)) as documentationRatio\norder by documentationRatio desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-named-class-argument]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects class instantiations where keyword arguments use names",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incorrect argument name in class constructor call\n * @description Detects class instantiations where keyword arguments use names\n *              that don't match any parameters in the class's __init__ method.\n *              Such mismatches cause TypeError exceptions at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\n// Import core Python analysis modules and call argument inspection utilities\nimport python\nimport Expressions.CallArgs\n\n// Identify class instantiations containing incorrectly named keyword arguments\nfrom \n  Call classInstantiation, \n  ClassValue targetClass, \n  string mismatchedArgName, \n  FunctionValue initializerMethod\nwhere \n  // First obtain the class initializer method for error context\n  initializerMethod = get_function_or_initializer(targetClass)\n  and \n  // Then detect keyword arguments that don't match any __init__ parameters\n  illegally_named_parameter(classInstantiation, targetClass, mismatchedArgName)\nselect \n  classInstantiation,\n  \"Keyword argument '\" + mismatchedArgName + \"' is not a supported parameter name of $@.\",\n  initializerMethod,\n  initializerMethod.getQualifiedName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of insecure SSL/TLS version\n * @description Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n/* Represents protocol configuration nodes that may use insecure SSL/TLS versions */\nclass ProtocolConfiguration extends DataFlow::Node {\n  ProtocolConfiguration() {\n    /* Case 1: Insecure connection created with context */\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    /* Case 2: Insecure connection created without context */\n    unsafe_connection_creation_without_context(this, _)\n    or\n    /* Case 3: Insecure context created */\n    unsafe_context_creation(this, _)\n  }\n\n  /* Get the function node associated with this configuration */\n  DataFlow::Node getAssociatedFunction() { result = this.(DataFlow::CallCfgNode).getFunction() }\n}\n\n/* Represents nodes that can be named (function calls or attribute references) */\nclass NameableNode extends DataFlow::Node {\n  NameableNode() {\n    /* Case 1: Node is a function from a protocol configuration */\n    this = any(ProtocolConfiguration pc).getAssociatedFunction()\n    or\n    /* Case 2: Node is an attribute reference of another nameable node */\n    this = any(NameableNode attr).(DataFlow::AttrRef).getObject()\n  }\n}\n\n/* Get the qualified name of a nameable node */\nstring getQualifiedName(NameableNode node) {\n  /* Case 1: Direct function name */\n  result = node.asExpr().(Name).getId()\n  or\n  /* Case 2: Attribute access chain */\n  exists(DataFlow::AttrRef attrRef | attrRef = node |\n    result = getQualifiedName(attrRef.getObject()) + \".\" + attrRef.getAttributeName()\n  )\n}\n\n/* Get descriptive name for protocol configuration */\n_______________ // 补全条件\n  /* Case 1: Function call configuration */\n  result = \"call to \" + getQualifiedName(configNode.(DataFlow::CallCfgNode).getFunction())\n  or\n  /* Case 2: Context modification (non-call, non-context-creation) */\n  not configNode instanceof DataFlow::CallCfgNode and\n  not configNode instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n/* Get appropriate verb based on specificity flag */\nstring getVerb(boolean isSpecific) {\n  isSpecific = true and result = \"specified\"\n  or\n  isSpecific = false and result = \"allowed\"\n}\n\n/* Query to detect insecure SSL/TLS version usage */\nfrom\n  DataFlow::Node connectionNode, string insecureVersion, \n  ProtocolConfiguration configNode, boolean isSpecific\nwhere\n  /* Case 1: Insecure connection with context */\n  unsafe_connection_creation_with_context(connectionNode, insecureVersion, configNode, isSpecific)\n  or\n  /* Case 2: Insecure connection without context */\n  unsafe_connection_creation_without_context(connectionNode, insecureVersion) and\n  configNode = connectionNode and\n  isSpecific = true\n  or\n  /* Case 3: Insecure context creation */\n  unsafe_context_creation(configNode, insecureVersion) and\n  connectionNode = configNode and\n  isSpecific = true\nselect connectionNode,\n  \"Insecure SSL/TLS protocol version \" + insecureVersion + \" \" + getVerb(isSpecific) + \" by $@.\",\n  configNode, getConfigurationName(configNode)",
    "output": "string getConfigurationName(ProtocolConfiguration configNode) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Wrong name for an argument in a class instantiation\n * @description Detects class instantiations using keyword arguments that do not match \n *              any parameter in the class's __init__ method, which causes runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call instanceCall, ClassValue targetCls, string invalidArg, FunctionValue initMethod\nwhere\n  // Identify class instantiations with invalid keyword arguments\n_______________ // 补全条件\n  // Retrieve the corresponding initializer method for the target class\n  initMethod = get_function_or_initializer(targetCls)\nselect instanceCall, \n       \"Keyword argument '\" + invalidArg + \"' is not a supported parameter name of $@.\", \n       initMethod,\n       initMethod.getQualifiedName()",
    "output": "illegally_named_parameter(instanceCall, targetCls, invalidArg) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/explicit-call-to-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The `__del__` special method is called by the virtual machine when an object is being finalized. It should not be called explicitly.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__del__` is called explicitly\n * @description The `__del__` special method is called by the virtual machine when an object is being finalized. It should not be called explicitly.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/explicit-call-to-delete\n */\n\nimport python  // 导入Python库，用于分析Python代码\n\n// 定义一个名为DelCall的类，继承自Call类\nclass DelCall extends Call {\n  // 构造函数，初始化时检查调用的方法名是否为\"__del__\"\n  DelCall() { this.getFunc().(Attribute).getName() = \"__del__\" }\n\n  // 定义一个谓词isSuperCall，用于判断是否是对super的__del__方法的调用\n  predicate isSuperCall() {\n    // 存在一个函数f，其名称为\"__del__\"且在当前作用域中\n    exists(Function f | f = this.getScope() and f.getName() = \"__del__\" |\n      // 检查第一个参数是否为self\n      f.getArg(0).asName().getVariable() = this.getArg(0).(Name).getVariable()\n      or\n      // 或者调用形式为`super(Type, self).__del__()`或Python 3中的`super().__del__()`\n      exists(Call superCall | superCall = this.getFunc().(Attribute).getObject() |\n        superCall.getFunc().(Name).getId() = \"super\"\n      )\n    )\n  }\n}\n\n// 从DelCall类中选择所有不是对super的__del__方法调用的实例\nfrom DelCall del\nwhere not del.isSuperCall()\nselect del, \"The __del__ special method is called explicitly.\"  // 选择这些实例并报告问题"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/side-effect-in-assert]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies assert statements that include expressions with side-effects,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name An assert statement has a side-effect\n * @description Identifies assert statements that include expressions with side-effects,\n *              leading to different behavior between normal execution and optimized builds\n *              where assertions are disabled.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/side-effect-in-assert\n */\n\nimport python\n\n// Predicate that checks if an expression references a function known to have side effects\npredicate expressionHasSideEffectFunction(Expr expr) {\n  // Determine if the expression is an attribute access or name reference to a side-effect function\n  exists(string functionName | \n    functionName = expr.(Attribute).getName() or functionName = expr.(Name).getId() |\n    functionName in [\n        \"print\", \"write\", \"append\", \"pop\", \"remove\", \"discard\", \"delete\", \"close\", \"open\", \"exit\"\n      ]\n  )\n}\n\n// Predicate that identifies calls to subprocess module functions which execute external commands\npredicate isSubprocessModuleCall(Call callExpr) {\n  // Match calls to subprocess functions that spawn external processes\n  callExpr.getAFlowNode() = Value::named(\"subprocess.call\").getACall()\n  or\n  callExpr.getAFlowNode() = Value::named(\"subprocess.check_call\").getACall()\n  or\n  callExpr.getAFlowNode() = Value::named(\"subprocess.check_output\").getACall()\n}\n\n// Predicate that determines if an expression could potentially produce side effects\npredicate expressionMayHaveSideEffect(Expr expr) {\n  // Check for yield expressions (excluding those within comprehensions)\n  (expr instanceof Yield and not exists(Comp c | c.contains(expr)))\n  or\n  // Check for yield from expressions\n  expr instanceof YieldFrom\n  or\n  // Check for function calls that may have side effects\n  (expr instanceof Call and (\n    expressionHasSideEffectFunction(expr.(Call).getFunc()) or \n    isSubprocessModuleCall(expr)\n  ))\n}\n\n// Main query that locates assert statements containing expressions with side effects\nfrom Assert assertionStatement, Expr problematicExpression\nwhere \n  expressionMayHaveSideEffect(problematicExpression) and \n  assertionStatement.contains(problematicExpression)\nselect assertionStatement, \"This 'assert' statement contains an $@ which may have side effects.\", problematicExpression, \"expression\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 指向关系图压缩效率分析\n * @description 本查询评估指向关系图的压缩效率，通过计算唯一事实的数量与关系图总大小的比例，\n *              分析不同上下文深度下的压缩效率百分比。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义查询输出变量：唯一事实数量、关系总大小、上下文深度和压缩效率\nfrom int distinctFactsCount, int totalRelationsSize, int contextDepth, float compressionRatio\nwhere\n  // 确定上下文深度\n  exists(PointsToContext ctx | contextDepth = ctx.getDepth()) and\n  (\n    // 计算唯一事实数量：统计不同的(控制流节点, 被指向对象, 类对象)组合\n    distinctFactsCount =\n      strictcount(ControlFlowNode cfgNode, Object pointedObject, ClassObject classObject |\n        exists(PointsToContext ctx |\n          // 检查在给定上下文中，控制流节点是否指向对象，且该对象是类对象的实例\n          PointsTo::points_to(cfgNode, ctx, pointedObject, classObject, _) and\n          ctx.getDepth() = contextDepth\n        )\n      )\n  ) and\n  (\n    // 计算关系总大小：统计所有(控制流节点, 被指向对象, 类对象, 上下文, 源控制流节点)组合\n    totalRelationsSize =\n      strictcount(ControlFlowNode cfgNode, Object pointedObject, ClassObject classObject, \n        PointsToContext ctx, ControlFlowNode sourceCfgNode |\n_______________ // 补全条件\n        PointsTo::points_to(cfgNode, ctx, pointedObject, classObject, sourceCfgNode) and\n        ctx.getDepth() = contextDepth\n      )\n  ) and\n  (\n    // 计算压缩效率：唯一事实数量与关系总大小的百分比\n    compressionRatio = 100.0 * distinctFactsCount / totalRelationsSize\n  )\n// 输出结果：上下文深度、唯一事实数量、关系总大小和压缩效率\nselect contextDepth, distinctFactsCount, totalRelationsSize, compressionRatio",
    "output": "// 检查在给定上下文中，控制流节点是否指向对象，且该对象是类对象的实例，并记录源控制流节点"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class inheritance hierarchy inference failure\n_______________ // 补全条件\n *              during analysis, potentially reducing the precision of the analysis results.\n * @id py/failed-inheritance-inference\n * @kind problem\n * @problem.severity info\n * @tags debug\n */\n\nimport python\n\n// Identify classes with inheritance inference issues and their corresponding failure causes\nfrom Class targetClass, string cause\nwhere exists(ClassObject classObj | \n    classObj.getPyClass() = targetClass and \n    classObj.failedInference(cause))\nselect targetClass, \"Inference of class hierarchy failed for class '\" + targetClass.getName() + \"': \" + cause + \".\"",
    "output": "* @description Identifies classes where the inheritance hierarchy could not be determined"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 错误的类实例化参数数量\n * @description 检测类构造函数调用时参数数量不匹配的情况，可能导致运行时TypeError异常\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call callNode, ClassValue targetClass, string issueType, string requirementPrefix, int limitValue, FunctionValue initMethod\nwhere\n  // 获取目标类的初始化方法\n  initMethod = get_function_or_initializer(targetClass) and\n  (\n    // 处理参数过多的情况\n    too_many_args(callNode, targetClass, limitValue) and\n    issueType = \"too many arguments\" and\n_______________ // 补全条件\n    or\n    // 处理参数过少的情况\n    too_few_args(callNode, targetClass, limitValue) and\n    issueType = \"too few arguments\" and\n    requirementPrefix = \"no fewer than \"\n  )\nselect callNode, \n  \"Call to $@ with \" + issueType + \"; should be \" + requirementPrefix + limitValue.toString() + \".\", \n  initMethod,\n  // 输出调用位置、错误描述及初始化方法的完全限定名\n  initMethod.getQualifiedName()",
    "output": "requirementPrefix = \"no more than \""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unicode-dos]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies when remote user input reaches expensive Unicode normalization operations (NFKC/NFKD).",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Denial of Service using Unicode Characters\n * @description Identifies when remote user input reaches expensive Unicode normalization operations (NFKC/NFKD). \n *              These operations can trigger denial of service on Windows through attacks like \"One Million Unicode Characters\". \n *              Special characters (e.g., U+2100 ℀ or U+2105 ℅) can triple payload size during normalization.\n * @kind path-problem\n * @id py/unicode-dos\n * @precision high\n * @problem.severity error\n * @tags security\n *       experimental\n *       external/cwe/cwe-770\n */\n\nimport python\nimport semmle.python.ApiGraphs\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n// Represents Unicode compatibility normalization calls from \n// unicodedata, unidecode, pyunormalize, and textnorm modules.\n// normalizedArgPos identifies the argument index containing the string to normalize.\nclass UnicodeCompatibilityNormalizationCall extends API::CallNode {\n  int normalizedArgPos; // Position of the argument being normalized\n\n  UnicodeCompatibilityNormalizationCall() {\n    // Case 1: normalize() calls with NFKC/NFKD form (2nd argument normalized)\n    (\n      this = API::moduleImport(\"unicodedata\").getMember(\"normalize\").getACall() and\n      this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember(\"normalize\").getACall() and\n      this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n    ) and\n    normalizedArgPos = 1\n    or\n    // Case 2: Other normalization calls where 1st argument is normalized\n    (\n      this = API::moduleImport(\"textnorm\").getMember(\"normalize_unicode\").getACall() and\n      this.getParameter(1).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"unidecode\").getMember(\"unidecode\").getACall()\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember([\"NFKC\", \"NFKD\"]).getACall()\n    ) and\n    normalizedArgPos = 0\n  }\n\n  DataFlow::Node getNormalizedArgument() { \n    result = this.getArg(normalizedArgPos) \n  }\n}\n\n// Detects guard conditions enforcing size limits on input values\npredicate hasSizeLimitGuard(DataFlow::GuardNode guard, ControlFlowNode controlled, boolean branchVal) {\n  exists(CompareNode comparison | comparison = guard |\n    exists(API::CallNode lenCall, Cmpop op, Node lenNode |\n      lenCall = lenNode.getALocalSource() and\n      (\n        // Patterns: input <= LIMIT or input < LIMIT (branch true)\n        (op instanceof LtE or op instanceof Lt) and\n        branchVal = true and\n        comparison.operands(lenNode.asCfgNode(), op, _)\n        or\n        // Patterns: LIMIT >= input or LIMIT > input (branch true)\n        (op instanceof GtE or op instanceof Gt) and\n        branchVal = true and\n        comparison.operands(_, op, lenNode.asCfgNode())\n        or\n        // Patterns: not input >= LIMIT or not input > LIMIT (branch false)\n        (op instanceof GtE or op instanceof Gt) and\n        branchVal = false and\n        comparison.operands(lenNode.asCfgNode(), op, _)\n        or\n        // Patterns: not LIMIT <= input or not LIMIT < input (branch false)\n        (op instanceof LtE or op instanceof Lt) and\n        branchVal = false and\n        comparison.operands(_, op, lenNode.asCfgNode())\n      )\n    |\n      lenCall = API::builtin(\"len\").getACall() and\n      controlled = lenCall.getArg(0).asCfgNode()\n    )\n  )\n}\n\n// Taint tracking configuration for Unicode DoS vulnerability analysis\nprivate module UnicodeDoSAnalysisConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { \n    source instanceof RemoteFlowSource \n  }\n\n  predicate isBarrier(DataFlow::Node barrier) {\n    // Size limit checks prevent uncontrolled input expansion\n    barrier = DataFlow::BarrierGuard<hasSizeLimitGuard/3>::getABarrierNode()\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    // Direct Unicode normalization calls\n    sink = any(UnicodeCompatibilityNormalizationCall ucnCall).getNormalizedArgument()\n    or\n    // werkzeug's secure_filename() internally uses Unicode normalization\n    exists(API::CallNode werkzeugCall |\n      werkzeugCall = API::moduleImport(\"werkzeug\").getMember(\"secure_filename\").getACall() and\n      sink = werkzeugCall.getArg(_)\n    )\n    or\n    exists(API::CallNode werkzeugUtilsCall |\n      werkzeugUtilsCall = API::moduleImport(\"werkzeug\")\n          .getMember(\"utils\")\n          .getMember(\"secure_filename\")\n          .getACall() and\n      sink = werkzeugUtilsCall.getArg(_)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global taint tracking analysis using the Unicode DoS configuration\nmodule UnicodeDoSFlow = TaintTracking::Global<UnicodeDoSAnalysisConfig>;\n\nimport UnicodeDoSFlow::PathGraph\n\nfrom UnicodeDoSFlow::PathNode source, UnicodeDoSFlow::PathNode sink\nwhere UnicodeDoSFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This $@ can reach a $@.\", source.getNode(),\n  \"user-provided value\", sink.getNode(), \"costly Unicode normalization operation\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/init-calls-subclass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calling a method from `__init__` that is overridden by a subclass may result in a partially",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__init__` method calls overridden method\n * @description Calling a method from `__init__` that is overridden by a subclass may result in a partially\n *              initialized instance being observed.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/init-calls-subclass\n */\n\nimport python\n\n// 查找父类__init__方法中调用被子类重写的方法\nfrom\n  ClassObject parentClass, string methodName, Call problematicCall,\n  FunctionObject overridingMethod, FunctionObject overriddenMethod\nwhere\n  // 确保调用发生在父类的__init__方法中，且调用的是self的属性\n  exists(FunctionObject initMethod, SelfAttribute selfAttr |\n    parentClass.declaredAttribute(\"__init__\") = initMethod and\n    problematicCall.getScope() = initMethod.getFunction() and\n    problematicCall.getFunc() = selfAttr and\n    selfAttr.getName() = methodName\n  ) and\n  // 获取父类中声明的方法（被重写的方法）\n  overriddenMethod = parentClass.declaredAttribute(methodName) and\n  // 确认子类中存在重写该方法的方法\n  overridingMethod.overrides(overriddenMethod)\n// 输出问题调用及关联方法信息\nselect problematicCall, \"Call to self.$@ in __init__ method, which is overridden by $@.\", overriddenMethod, methodName,\n  overridingMethod, overridingMethod.descriptiveString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/percent-format/unsupported-character]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python format strings containing invalid conversion specifiers",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unsupported format character\n * @description Identifies Python format strings containing invalid conversion specifiers\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/percent-format/unsupported-character\n */\n\n// Import core Python analysis modules\nimport python\n// Import string processing utilities\nimport semmle.python.strings\n\n// Locate format string expressions with problematic conversion specifiers\nfrom Expr formatStrExpr, int invalidSpecPos\nwhere \n  // Calculate position of invalid conversion specifier\n  invalidSpecPos = illegal_conversion_specifier(formatStrExpr)\nselect \n  formatStrExpr, \n  \"Invalid conversion specifier detected at position \" + invalidSpecPos + \n  \" in format string: \" + repr(formatStrExpr) + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/direct-imports-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The number of modules directly imported by this file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Direct imports per file\n * @description The number of modules directly imported by this file.\n * @kind treemap\n * @id py/direct-imports-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg max\n * @tags modularity\n *       maintainability\n */\n\n// 导入Python库，用于处理Python代码的解析和分析\nimport python\n\n// 从ModuleValue类中获取模块m，并计算其直接导入的模块数量n\nfrom ModuleValue m, int n\n// 条件：n等于通过调用m.getAnImportedModule()方法获取的直接导入模块的数量\nwhere n = count(ModuleValue imp | imp = m.getAnImportedModule())\n// 选择模块m的作用域和直接导入模块的数量n作为查询结果\nselect m.getScope(), n"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Superclass attribute shadows subclass method\n * @description 当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 检测子类中定义的方法是否被超类中的属性所遮蔽的情况\n */\n\n/* 需要定位在超类初始化方法中定义的属性 */\nimport python\n\n// 定义谓词 isMethodShadowedBySuperAttribute，用于判断子类方法是否被超类属性遮蔽\npredicate isMethodShadowedBySuperAttribute(\n  ClassObject subClass, ClassObject superClass, Assign attrAssignment, FunctionObject shadowedMethod\n) {\n  // 确认继承关系：subClass 继承自 superClass\n  subClass.getASuperType() = superClass and\n  // 子类声明了 shadowedMethod 作为其属性\n  subClass.declaredAttribute(_) = shadowedMethod and\n  // 检查超类初始化方法中是否存在同名属性赋值\n  exists(FunctionObject initMethod, Attribute assignedAttr |\n    // 超类定义了 __init__ 方法\n    superClass.declaredAttribute(\"__init__\") = initMethod and\n    // 属性赋值的目标是 assignedAttr\n    assignedAttr = attrAssignment.getATarget() and\n    // 属性赋值对象是 self\n    assignedAttr.getObject().(Name).getId() = \"self\" and\n    // 属性名称与子类方法名称相同\n    assignedAttr.getName() = shadowedMethod.getName() and\n    // 赋值操作发生在超类的初始化方法中\n    attrAssignment.getScope() = initMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  /*\n   * 排除超类中也定义了同名方法的情况\n   * 这种情况下，我们认为是有意为之的设计\n   */\n  // 确保超类没有定义同名属性\n  not superClass.hasAttribute(shadowedMethod.getName())\n}\n\n// 从子类、超类、属性赋值和被遮蔽的方法中查询\nfrom ClassObject subClass, ClassObject superClass, Assign attrAssignment, FunctionObject shadowedMethod\n// 应用谓词进行筛选\n_______________ // 补全条件\n// 选择被遮蔽方法的位置、错误信息、属性赋值位置和属性类型\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superClass.getName() +\n    \"'.\", attrAssignment, \"attribute\"",
    "output": "where isMethodShadowedBySuperAttribute(subClass, superClass, attrAssignment, shadowedMethod)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mismatch between signature and use of an overridden method\n * @description Detects when a method overrides another with a different signature,\n *              and is called with arguments that match the overriding method but not the original.\n *              This creates a potential runtime error if the original method is called instead.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/inheritance/incorrect-overridden-signature\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call methodInvocation, FunctionValue baseMethod, FunctionValue derivedMethod, string mismatchDetails\nwhere\n  // Skip constructor methods as they have special handling\n  not baseMethod.getName() = \"__init__\" and\n  // Verify inheritance relationship\n  derivedMethod.overrides(baseMethod) and\n  // Identify actual call site of the overriding method\n  methodInvocation = derivedMethod.getAMethodCall().getNode() and\n  // Confirm call arguments match the derived method's signature\n  correct_args_if_called_as_method(methodInvocation, derivedMethod) and\n  // Detect specific signature mismatches\n  (\n    // Case 1: Insufficient arguments for base method\n    arg_count(methodInvocation) + 1 < baseMethod.minParameters() and \n    mismatchDetails = \"too few arguments\"\n_______________ // 补全条件\n    // Case 2: Excessive arguments for base method\n    arg_count(methodInvocation) >= baseMethod.maxParameters() and \n    mismatchDetails = \"too many arguments\"\n    or\n    // Case 3: Keyword argument exists in derived but not in base method\n    exists(string parameterName |\n      methodInvocation.getAKeyword().getArg() = parameterName and\n      derivedMethod.getScope().getAnArg().(Name).getId() = parameterName and\n      not baseMethod.getScope().getAnArg().(Name).getId() = parameterName and\n      mismatchDetails = \"an argument named '\" + parameterName + \"'\"\n    )\n  )\nselect baseMethod,\n  \"Overridden method signature does not match $@, where it is passed \" + mismatchDetails +\n    \". Overriding method $@ matches the call.\", methodInvocation, \"call\", derivedMethod,\n  derivedMethod.descriptiveString()",
    "output": "or"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides statistics on different kinds of type annotations in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Provides statistics on different kinds of type annotations in Python code.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents built-in types in Python.\nclass BuiltinType extends Name {\n  // Constructor that checks if the current instance is one of the core types.\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Defines a new type TTypedElement that can be one of three cases:\nnewtype TTypedElement =\n  TFunctionWithReturn(FunctionExpr f) { exists(f.getReturns()) } or // Function expressions with return type\n  TAnnotatedParameter(Parameter p) { exists(p.getAnnotation()) } or // Parameters with annotations\n  TAnnotatedAssignment(AnnAssign a) { exists(a.getAnnotation()) } // Assignment statements with annotations\n\n// Abstract class TypedElement, inheriting from TTypedElement, representing elements that can have type annotations.\nabstract class TypedElement extends TTypedElement {\n  // Converts the object to its string representation.\n  string toString() { result = \"TypedElement\" }\n\n  // Abstract method to get the annotation expression.\n  abstract Expr getAnnotation();\n}\n\n// Class FunctionWithReturn, inheriting from TFunctionWithReturn and TypedElement, representing functions with return type annotations.\nclass FunctionWithReturn extends TFunctionWithReturn, TypedElement {\n  FunctionExpr functionExpr; // Function expression\n\n  // Constructor that initializes the functionExpr attribute.\n  FunctionWithReturn() { this = TFunctionWithReturn(functionExpr) }\n\n  // Overrides getAnnotation method to return the function's return type annotation.\n  override Expr getAnnotation() { result = functionExpr.getReturns() }\n}\n\n// Class AnnotatedParameter, inheriting from TAnnotatedParameter and TypedElement, representing parameters with annotations.\nclass AnnotatedParameter extends TAnnotatedParameter, TypedElement {\n  Parameter parameter; // Parameter\n\n  // Constructor that initializes the parameter attribute.\n  AnnotatedParameter() { this = TAnnotatedParameter(parameter) }\n\n  // Overrides getAnnotation method to return the parameter's annotation.\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\n// Class AnnotatedAssignment, inheriting from TAnnotatedAssignment and TypedElement, representing assignment statements with annotations.\nclass AnnotatedAssignment extends TAnnotatedAssignment, TypedElement {\n  AnnAssign annotatedAssign; // Assignment statement\n\n  // Constructor that initializes the annotatedAssign attribute.\n  AnnotatedAssignment() { this = TAnnotatedAssignment(annotatedAssign) }\n\n  // Overrides getAnnotation method to return the assignment's annotation.\n  override Expr getAnnotation() { result = annotatedAssign.getAnnotation() }\n}\n\n/** True if `e` is a string literal used as a forward declaration of a type. */\npredicate isForwardDeclaration(Expr e) { e instanceof StringLiteral }\n\n/** True if `e` represents a type that is complex to analyze. */\npredicate isComplexType(Expr e) {\n  e instanceof Subscript and not isOptionalType(e) // If e is a subscript but not an optional type\n  or\n  e instanceof Tuple // If e is a tuple type\n  or\n  e instanceof List // If e is a list type\n}\n\n/** True if `e` is a type of the form `Optional[...]`. */\npredicate isOptionalType(Subscript e) { e.getObject().(Name).getId() = \"Optional\" }\n\n/** True if `e` is a simple type, i.e., an identifier (excluding builtin types) or an attribute of a simple type. */\npredicate isBasicType(Expr e) {\n  e instanceof Name and not e instanceof BuiltinType // If e is a name but not a builtin type\n  or\n  isBasicType(e.(Attribute).getObject()) // If e is an attribute and its object is a basic type\n}\n\n/** True if `e` is a builtin type. */\npredicate isBuiltinType(Expr e) { e instanceof BuiltinType }\n\n// Predicate to calculate counts of different types of annotations.\npredicate typeAnnotationMetrics(\n  string category, int overall, int builtin_count, int forward_count, int basic_count,\n  int complex_count, int optional_count\n) {\n  // For parameter annotations\n  category = \"Parameter annotation\" and \n  overall = count(AnnotatedParameter param) and \n  builtin_count = count(AnnotatedParameter param | isBuiltinType(param.getAnnotation())) and \n  forward_count = count(AnnotatedParameter param | isForwardDeclaration(param.getAnnotation())) and \n  basic_count = count(AnnotatedParameter param | isBasicType(param.getAnnotation())) and \n  complex_count = count(AnnotatedParameter param | isComplexType(param.getAnnotation())) and \n  optional_count = count(AnnotatedParameter param | isOptionalType(param.getAnnotation()))\n  or\n  // For return type annotations\n  category = \"Return type annotation\" and \n  overall = count(FunctionWithReturn func) and \n  builtin_count = count(FunctionWithReturn func | isBuiltinType(func.getAnnotation())) and \n  forward_count = count(FunctionWithReturn func | isForwardDeclaration(func.getAnnotation())) and \n  basic_count = count(FunctionWithReturn func | isBasicType(func.getAnnotation())) and \n  complex_count = count(FunctionWithReturn func | isComplexType(func.getAnnotation())) and \n  optional_count = count(FunctionWithReturn func | isOptionalType(func.getAnnotation()))\n  or\n  // For annotated assignments\n  category = \"Annotated assignment\" and \n  overall = count(AnnotatedAssignment assign) and \n  builtin_count = count(AnnotatedAssignment assign | isBuiltinType(assign.getAnnotation())) and \n  forward_count = count(AnnotatedAssignment assign | isForwardDeclaration(assign.getAnnotation())) and \n  basic_count = count(AnnotatedAssignment assign | isBasicType(assign.getAnnotation())) and \n  complex_count = count(AnnotatedAssignment assign | isComplexType(assign.getAnnotation())) and \n  optional_count = count(AnnotatedAssignment assign | isOptionalType(assign.getAnnotation()))\n}\n\n// Query statement to select data from the database that satisfies the typeAnnotationMetrics predicate.\nfrom\n  string category, int overall, int builtin, int forward, int basic, int complex, int optional\nwhere typeAnnotationMetrics(category, overall, builtin, forward, basic, complex, optional)\nselect category, overall, builtin, forward, basic, complex, optional"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/member-test-non-container]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies membership tests (e.g., 'item in sequence') where the right-hand operand",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Membership test with a non-container\n * @description Identifies membership tests (e.g., 'item in sequence') where the right-hand operand \n *              is a non-container value, potentially causing runtime 'TypeError'.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n// Determines if a node is the right operand in membership operations (In/NotIn)\npredicate isRhsOfMembershipTest(ControlFlowNode rhsNode, Compare comparisonNode) {\n  exists(Cmpop operation, int operandIndex | \n    comparisonNode.getOp(operandIndex) = operation and \n    comparisonNode.getComparator(operandIndex) = rhsNode.getNode() and \n    (operation instanceof In or operation instanceof NotIn)\n  )\n}\n\nfrom ControlFlowNode rhsNode, Compare comparisonNode, Value pointedValue, ClassValue valueClass, ControlFlowNode originNode\nwhere\n  // Verify current node is right operand of membership test\n  isRhsOfMembershipTest(rhsNode, comparisonNode) and\n  // Resolve value and its origin through points-to analysis\n  rhsNode.pointsTo(_, pointedValue, originNode) and\n  // Extract class of the resolved value\n  pointedValue.getClass() = valueClass and\n  // Skip cases with incomplete type inference\n  not Types::failedInference(valueClass, _) and\n  // Exclude classes implementing container protocols\n  not (\n    valueClass.hasAttribute(\"__contains__\") or\n    valueClass.hasAttribute(\"__iter__\") or\n    valueClass.hasAttribute(\"__getitem__\")\n  ) and\n  // Exclude None type and special container types\n  not valueClass = ClassValue::nonetype() and\n  not valueClass = Value::named(\"types.MappingProxyType\")\nselect comparisonNode, \"This test may raise an Exception as the $@ may be of non-container class $@.\", originNode,\n  \"target\", valueClass, valueClass.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-symmetric-encryption]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Finds uses of symmetric cryptography algorithms that are weak, obsolete, or otherwise unaccepted.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak symmetric encryption algorithm\n * @description Finds uses of symmetric cryptography algorithms that are weak, obsolete, or otherwise unaccepted.\n *\n *              The key lengths allowed are 128, 192, and 256 bits. These are all the key lengths supported by AES, so any\n *              application of AES is considered acceptable.\n * @id py/weak-symmetric-encryption\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python // 导入python库，用于分析Python代码\nimport experimental.cryptography.Concepts // 导入实验性加密概念库，用于处理加密相关的概念\n\n// 从SymmetricEncryptionAlgorithm操作符中选择op、name和msg字段\nfrom SymmetricEncryptionAlgorithm op, string name, string msg\nwhere\n  // 获取加密算法的名称并赋值给变量name\n  name = op.getEncryptionName() and\n  // 过滤掉AES及其变种（AES128, AES192, AES256）的加密算法\n  not name = [\"AES\", \"AES128\", \"AES192\", \"AES256\"] and\n  // 如果算法名称未知，则设置消息为“使用未识别的对称加密算法”\n  if name = unknownAlgorithm()\n  then msg = \"Use of unrecognized symmetric encryption algorithm.\"\n  // 否则，设置消息为“使用未经批准的对称加密算法或API”并附加算法名称\n  else msg = \"Use of unapproved symmetric encryption algorithm or API \" + name + \".\"\n// 选择操作符op和消息msg作为查询结果\nselect op, msg"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/afferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Quantifies and displays how many other classes depend on each target class.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class Dependency Analysis: Inbound Coupling Metrics\n * @description Quantifies and displays how many other classes depend on each target class.\n *              This metric helps understand class importance and potential change impact.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// Extract all classes and calculate their inbound dependency count\n// Afferent coupling measures how many other classes depend on the current class\nfrom ClassMetrics evaluatedClass, int inboundCoupling\nwhere inboundCoupling = evaluatedClass.getAfferentCoupling()\nselect evaluatedClass, \n       inboundCoupling as dependencyCount \norder by dependencyCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Encoding error detection\n * @description Identifies potential encoding issues in Python code that may cause runtime exceptions\n *              or interfere with static analysis. This query targets cases where improper encoding\n *              handling could lead to data corruption or execution failures.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/encoding-error\n */\n\nimport python\n\n_______________ // 补全条件\n// Each issue represents a location where encoding errors might occur\nfrom EncodingError encodingIssue\nselect encodingIssue, encodingIssue.getMessage()",
    "output": "// Identify all encoding-related issues in the codebase"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unsafe-unpacking]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Extracting tar files from user-controlled sources without validating",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file write during tarball extraction from user-controlled source\n * @description Extracting tar files from user-controlled sources without validating \n *              destination paths may allow overwriting files outside the target directory.\n *              This occurs when tarballs originate from user-controlled locations,\n *              whether remote or via command-line arguments.\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// Define path nodes for vulnerability tracking\nfrom UnsafeUnpackFlow::PathNode maliciousSource, UnsafeUnpackFlow::PathNode extractionSink\nwhere UnsafeUnpackFlow::flowPath(maliciousSource, extractionSink)\n// Report vulnerability with path context\nselect extractionSink.getNode(), \n       maliciousSource, \n       extractionSink,\n       \"Unsafe extraction of malicious tarball from uncontrolled remote source\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raises-tuple]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别在 Python 2 中引发元组的代码，这种行为会导致除第一个元素外的所有元素被丢弃",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python 2 元组引发检测\n * @description 识别在 Python 2 中引发元组的代码，这种行为会导致除第一个元素外的所有元素被丢弃\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// 查找 Python 2 中的 raise 语句，其中引发的是一个元组表达式\nfrom Raise raiseStatement, DataFlow::LocalSourceNode tupleExprNode\nwhere\n  // 确保代码运行在 Python 2 环境中\n  major_version() = 2 and\n  // 验证数据流源确实是一个元组表达式\n  tupleExprNode.asExpr() instanceof Tuple and\n  // 检查数据流：元组表达式是否流向 raise 语句的异常部分\n  exists(DataFlow::Node exceptionDestNode | \n    exceptionDestNode.asExpr() = raiseStatement.getException() and\n    tupleExprNode.flowsTo(exceptionDestNode)\n  )\n\n/* 注意：在 Python 3 中，引发元组会导致 TypeError，这由 IllegalRaise 查询处理。 */\nselect raiseStatement,\n  \"引发 $@ 将导致仅第一个元素（递归地）被引发，而所有其他元素将被丢弃。\",\n  tupleExprNode, \"元组\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/modification-of-locals]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code that modifies the dictionary returned by locals(),",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Modification of dictionary returned by locals()\n * @description Identifies code that modifies the dictionary returned by locals(),\n *              which has no effect on the actual local variables in a function.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/modification-of-locals\n */\n\nimport python\n\n// Determines if a control flow node references the locals() function call\npredicate isLocalsReference(ControlFlowNode controlNode) { \n    controlNode.pointsTo(_, _, Value::named(\"locals\").getACall()) \n}\n\n// Detects modifications to the locals() dictionary through subscript operations\npredicate isSubscriptUpdate(ControlFlowNode indexNode) {\n    // Verify that the subscript operation is performed on the result of locals()\n    isLocalsReference(indexNode.(SubscriptNode).getObject()) and\n    // Confirm it's a store or delete operation\n    (indexNode.isStore() or indexNode.isDelete())\n}\n\n// Detects modifications to the locals() dictionary through method calls\npredicate isMethodUpdate(ControlFlowNode funcCallNode) {\n    exists(string funcName, AttrNode attributeNode |\n        // Get the attribute node for the method call\n        attributeNode = funcCallNode.(CallNode).getFunction() and\n        // Verify the attribute object comes from a locals() call\n        isLocalsReference(attributeNode.getObject(funcName))\n    |\n        // Check if the method name is in the set of dictionary-modifying methods\n        funcName in [\"pop\", \"popitem\", \"update\", \"clear\"]\n    )\n}\n\n// Identifies any modification operation on the dictionary returned by locals()\npredicate containsLocalsModification(ControlFlowNode updateNode) {\n    isSubscriptUpdate(updateNode) or\n    isMethodUpdate(updateNode)\n}\n\n// Main query: Locates and reports modifications to the locals() dictionary\nfrom AstNode astNode, ControlFlowNode controlFlowNode\nwhere\n    // Confirm there's a modification to the locals() dictionary\n    containsLocalsModification(controlFlowNode) and\n    // Get the AST node corresponding to the control flow node\n    astNode = controlFlowNode.getNode() and\n    // Exclude module-level scope, where locals() is equivalent to globals()\n    not astNode.getScope() instanceof ModuleScope\n// Select results and attach warning message\nselect astNode, \"Modification of the locals() dictionary will have no effect on the local variables.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent equality and hashing\n * @description Classes defining equality without hashability (or vice-versa) violate object model contracts\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-581\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/equals-hash-mismatch\n */\n\nimport python\n\n// Checks whether a class implements equality comparison methods\nCallableValue hasEqualityMethod(ClassValue targetClass, string methodName) {\n  // Verify presence of __eq__ in all Python versions or __cmp__ in Python 2\n  (\n    methodName = \"__eq__\"\n    or\n    major_version() = 2 and methodName = \"__cmp__\"\n  ) and\n  result = targetClass.declaredAttribute(methodName)\n}\n\n// Retrieves methods implemented for equality comparison or hashing\nCallableValue getImplementedMethod(ClassValue targetClass, string methodName) {\n  // Obtain either equality methods or __hash__ implementation\n  result = hasEqualityMethod(targetClass, methodName)\n  or\n  result = targetClass.declaredAttribute(\"__hash__\") and methodName = \"__hash__\"\n}\n\n/** Determines if a class is explicitly marked as unhashable */\npredicate isUnhashable(ClassValue targetClass) {\n  // Check if __hash__ is explicitly set to None or if it never returns\n  targetClass.lookup(\"__hash__\") = Value::named(\"None\")\n  or\n  targetClass.lookup(\"__hash__\").(CallableValue).neverReturns()\n}\n\n// Identifies methods that are missing in a class implementation\nstring getMissingMethod(ClassValue targetClass) {\n  // Detect missing equality methods based on Python version\n  not exists(hasEqualityMethod(targetClass, _)) and\n  (\n    result = \"__eq__\" and major_version() = 3\n    or\n    major_version() = 2 and result = \"__eq__ or __cmp__\"\n  )\n  or\n  // Detect missing __hash__ in Python 2 (Python 3 handles this automatically)\n  not targetClass.declaresAttribute(result) and result = \"__hash__\" and major_version() = 2\n}\n\n// Identifies classes that violate the hash contract implementation\npredicate violatesHashContract(ClassValue targetClass, string implementedMethod, string missingMethod, Value foundMethod) {\n  // Exclude classes that are explicitly unhashable or have failed inference\n  not isUnhashable(targetClass) and\n_______________ // 补全条件\n  // Verify that a method is implemented while another is missing\n  missingMethod = getMissingMethod(targetClass) and\n  foundMethod = getImplementedMethod(targetClass, implementedMethod)\n}\n\n// Main query: Detects classes with inconsistent equality and hashing implementations\nfrom ClassValue targetClass, string implementedMethod, string missingMethod, CallableValue foundMethod\nwhere\n  violatesHashContract(targetClass, implementedMethod, missingMethod, foundMethod) and\n  exists(targetClass.getScope()) // Exclude classes not defined in source code\nselect foundMethod, \"Class $@ implements \" + implementedMethod + \" but does not define \" + missingMethod + \".\", targetClass,\n  targetClass.getName()",
    "output": "not targetClass.failedInference(_) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-commented-out-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The number of lines of commented out code per file",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lines of commented-out code in files\n * @description The number of lines of commented out code per file\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// 导入Python分析库和注释代码检测库\nimport python\nimport Lexical.CommentedOutCode\n\n// 定义查询：从源文件和注释行计数中获取数据\nfrom File sourceFile, int commentedLineCount\n// 计算每个源文件中被注释掉的代码行数\nwhere \n    // 获取所有非示例代码的注释行\n    exists(CommentedOutCodeLine commentedLine | \n        // 确保注释行不是示例代码\n        not commentedLine.maybeExampleCode() and\n        // 确保注释行属于当前分析的源文件\n        commentedLine.getLocation().getFile() = sourceFile\n    ) and\n    // 统计满足条件的注释行总数\n    commentedLineCount = count(CommentedOutCodeLine commentedLine | \n        not commentedLine.maybeExampleCode() and \n        commentedLine.getLocation().getFile() = sourceFile\n    )\n// 输出结果：源文件及其对应的注释行计数，按注释行数降序排列\nselect sourceFile, commentedLineCount order by commentedLineCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-exit-or-quit]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of exit() or quit() functions which might fail when the Python interpreter is run with the -S option.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of exit() or quit()\n * @description Detects usage of exit() or quit() functions which might fail when the Python interpreter is run with the -S option.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/use-of-exit-or-quit\n */\n\nimport python  // Import Python library for analyzing Python code\n\nfrom CallNode callNode, string functionName  // Obtain function call nodes and their corresponding names\nwhere \n  // Identify calls to functions that point to siteQuitter objects\n  callNode.getFunction().pointsTo(Value::siteQuitter(functionName))\nselect callNode,  // Output the matching function call nodes\n  \"Potential issue: '\" + functionName +\n    \"' is a site.Quitter object that may not exist if the 'site' module is not loaded or has been modified.\"  // Warning about site.Quitter object availability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Untrusted Data Propagation to Cookie Construction\n * @description Identifies security vulnerabilities where untrusted user input \n *              propagates into cookie value assignments. This can lead to \n_______________ // 补全条件\n * @id py/untrusted-cookie-injection\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 8.7\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\nfrom \n  CookieInjectionFlow::PathNode untrustedDataSource,\n  CookieInjectionFlow::PathNode cookieValueSink\nwhere \n  CookieInjectionFlow::flowPath(untrustedDataSource, cookieValueSink)\nselect \n  cookieValueSink.getNode(), \n  untrustedDataSource, \n  cookieValueSink, \n  \"Cookie value constructed from $@.\", \n  untrustedDataSource.getNode(), \n  \"untrusted user input\"",
    "output": "*              injection attacks compromising cookie integrity and security."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Vulnerable block mode IV or nonce usage\n * @description Detects insecure initialization vectors (IVs) or nonces in block cipher implementations.\n_______________ // 补全条件\n *              cryptographically secure os.urandom. Fernet is exempt since it manages IV generation\n *              internally. Certain sophisticated scenarios might necessitate manual verification.\n *\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags security\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify block cipher operations with insecure IV/nonce configurations\nfrom BlockMode blockCipherOp, string securityAlert, DataFlow::Node vulnerableIVSource\nwhere\n  // Exclude Fernet as it manages IV generation internally\n  not blockCipherOp instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet and\n  (\n    // Detect scenarios with missing IV/nonce or IV/nonce not from os.urandom\n    not blockCipherOp.hasIVorNonce() or\n    not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = blockCipherOp.getIVorNonce()\n  ) and\n  // Determine the vulnerable source and security alert based on IV/nonce presence\n  (\n    if not blockCipherOp.hasIVorNonce()\n    then (\n      // Scenario where IV/nonce is absent\n      vulnerableIVSource = blockCipherOp and \n      securityAlert = \"Block mode is missing IV/Nonce initialization.\"\n    )\n    else (\n      // Scenario where IV/nonce originates from an untrusted source\n      vulnerableIVSource = blockCipherOp.getIVorNonce()\n    )\n  ) and\n  // Construct the final security alert message\n  securityAlert = \"Block mode is not using an accepted IV/Nonce initialization: $@\"\nselect blockCipherOp, securityAlert, vulnerableIVSource, vulnerableIVSource.toString()",
    "output": "*              This query highlights instances where IVs/nonces are either absent or not derived from"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Identifies asymmetric cryptographic key generation operations",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak key generation key size (< 2048 bits)\n * @description\n * Identifies asymmetric cryptographic key generation operations\n * using insufficient key sizes (below 2048 bits), which are\n * vulnerable to brute-force attacks.\n * @id py/weak-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define query components with improved variable naming\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node configNode, int keySize, string algorithmName\nwhere\n  // Extract cryptographic configuration details\n  (\n    keySize = keyGenOperation.getKeySizeInBits(configNode) and\n    algorithmName = keyGenOperation.getAlgorithm().getName()\n  ) and\n  // Apply security validation criteria\n  (\n    keySize < 2048 and\n    not isEllipticCurveAlgorithm(algorithmName, _)\n  )\n// Report findings with contextual information\nselect keyGenOperation,\n  \"Weak asymmetric key size (\" + keySize.toString() + \" bits) for algorithm \" +\n    algorithmName + \" configured at $@\", configNode, configNode.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/percent-format/unsupported-character]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects format strings containing unsupported or invalid conversion specifiers",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unsupported format character\n * @description Detects format strings containing unsupported or invalid conversion specifiers\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/percent-format/unsupported-character\n */\n\n// Import core Python analysis capabilities\nimport python\n// Import string processing utilities for format string validation\nimport semmle.python.strings\n\n// This query identifies Python format string expressions containing invalid conversion specifiers.\n// It determines the exact position where the invalid specifier occurs within the string.\nfrom Expr formatStringExpr, int invalidSpecifierIndex\nwhere \n    // Validate the format string expression to locate any invalid conversion specifiers\n    // The function returns the index position of the first invalid specifier found\n    invalidSpecifierIndex = illegal_conversion_specifier(formatStringExpr)\nselect \n    // Output the problematic expression with detailed error information\n    formatStringExpr, \n    \"Invalid conversion specifier at index \" + invalidSpecifierIndex + \" of \" + repr(formatStringExpr) + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/dependency-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：外部依赖源链接",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name 外部依赖源链接\n * @kind source-link\n * @metricType externalDependency\n * @id py/dependency-source-links\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/**\n * 查询目标：为外部依赖生成源链接信息\n * \n * 背景说明：\n * - 外部依赖实体表示为'/file/path<|>dependency'格式\n * - 路径部分是相对于源代码存档根目录的字符串\n * - 这些路径需要通过File实体建立版本关联\n * \n * 功能描述：\n * - 识别代码文件与外部依赖之间的关系\n * - 生成仪表板数据库可用的源链接信息\n * - 输出中的File实体可通过ExternalEntity.getASourceLink()恢复源链接\n * \n * 实现逻辑：\n * 1. 遍历所有Python代码文件\n * 2. 查找每个文件引用的外部包\n * 3. 为文件-包对生成依赖标识符\n * 4. 输出依赖标识符和源文件\n */\n\nfrom File sourceFile, string packageIdentifier\nwhere\n  exists(PackageObject externalDependency, AstNode importNode |\n    // 建立导入语句与外部依赖的关联\n    dependency(importNode, externalDependency) and\n    // 确保导入语句位于当前源文件中\n    importNode.getLocation().getFile() = sourceFile and\n    // 生成唯一的文件-依赖对标识符\n    packageIdentifier = munge(sourceFile, externalDependency)\n  )\nselect packageIdentifier, sourceFile"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Command execution on a secondary remote server\n * @description User-controlled input can trigger command execution on external servers,\n *              potentially compromising other users or administrative systems\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.3\n * @precision high\n * @id py/paramiko-command-injection\n_______________ // 补全条件\n *       experimental\n *       external/cwe/cwe-074\n */\n\n// Import required libraries for security analysis\nimport python\n// Import experimental remote command execution analysis module\nimport experimental.semmle.python.security.RemoteCommandExecution\n// Import path graph class for tracking data flows\nimport RemoteCommandExecutionFlow::PathGraph\n\n// Define data flow tracking from untrusted sources to command sinks\nfrom RemoteCommandExecutionFlow::PathNode taintedInput, RemoteCommandExecutionFlow::PathNode executionPoint\n// Validate data flow path exists between input and execution\nwhere RemoteCommandExecutionFlow::flowPath(taintedInput, executionPoint)\n// Report results with vulnerability context\nselect executionPoint.getNode(), taintedInput, executionPoint, \n       \"This code execution depends on a $@.\", taintedInput.getNode(),\n       \"user-controlled input source\"",
    "output": "* @tags security"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-protocol]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of insecure SSL/TLS version\n * @description Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n// ProtocolConfiguration类用于表示协议配置节点，继承自DataFlow::Node。\nclass ProtocolConfiguration extends DataFlow::Node {\n  // 构造函数，定义了三种情况下的ProtocolConfiguration实例。\n  ProtocolConfiguration() {\n    // 使用上下文创建不安全的连接。\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    // 不使用上下文创建不安全的连接。\n    unsafe_connection_creation_without_context(this, _)\n    or\n    // 创建不安全的上下文。\n    unsafe_context_creation(this, _)\n  }\n\n  // 获取当前节点对应的函数节点。\n  DataFlow::Node getNode() { result = this.(DataFlow::CallCfgNode).getFunction() }\n}\n\n// Nameable类用于表示可以命名的节点，继承自DataFlow::Node。\nclass Nameable extends DataFlow::Node {\n  // 构造函数，定义了两种情况下的Nameable实例。\n  Nameable() {\n    // 当前节点是任何ProtocolConfiguration节点的函数节点。\n    this = any(ProtocolConfiguration pc).getNode()\n    or\n    // 当前节点是任何Nameable对象的属性引用。\n    this = any(Nameable attr).(DataFlow::AttrRef).getObject()\n  }\n}\n\n// 返回给定Nameable对象的调用名称。\nstring callName(Nameable call) {\n  // 如果call是一个名称表达式，则返回其ID。\n  result = call.asExpr().(Name).getId()\n  or\n  // 如果call是一个属性引用，则返回其对象的名称加上属性名。\n  exists(DataFlow::AttrRef a | a = call |\n    result = callName(a.getObject()) + \".\" + a.getAttributeName()\n  )\n}\n\n// 返回给定ProtocolConfiguration对象的配置名称。\nstring configName(ProtocolConfiguration protocolConfiguration) {\n  // 如果protocolConfiguration是一个函数调用节点，则返回其调用名称。\n  result = \"call to \" + callName(protocolConfiguration.(DataFlow::CallCfgNode).getFunction())\n  or\n  // 如果protocolConfiguration不是函数调用节点且不是上下文创建节点，则返回\"context modification\"。\n  not protocolConfiguration instanceof DataFlow::CallCfgNode and\n  not protocolConfiguration instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n// 根据specific布尔值返回相应的动词。\nstring verb(boolean specific) {\n  // 如果specific为true，则返回\"specified\"。\n  specific = true and result = \"specified\"\n  or\n  // 如果specific为false，则返回\"allowed\"。\n  specific = false and result = \"allowed\"\n}\n\n// 查询语句，查找不安全的SSL/TLS版本使用情况。\nfrom\n  DataFlow::Node connectionCreation, string insecure_version, DataFlow::Node protocolConfiguration,\n  boolean specific\nwhere\n  // 查找使用上下文创建不安全连接的情况。\n  unsafe_connection_creation_with_context(connectionCreation, insecure_version,\n    protocolConfiguration, specific)\n  or\n  // 查找不使用上下文创建不安全连接的情况。\n  unsafe_connection_creation_without_context(connectionCreation, insecure_version) and\n  protocolConfiguration = connectionCreation and\n  specific = true\n  or\n  // 查找创建不安全上下文的情况。\n  unsafe_context_creation(protocolConfiguration, insecure_version) and\n  connectionCreation = protocolConfiguration and\n  specific = true\nselect connectionCreation,\n  // 选择不安全连接创建节点、描述信息、协议配置节点及其配置名称。\n  \"Insecure SSL/TLS protocol version \" + insecure_version + \" \" + verb(specific) + \" by $@.\",\n  protocolConfiguration, configName(protocolConfiguration)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Total lines of Python code in the database\n * @description 计算数据库中所有Python源文件的有效代码行总数，包含第三方库和自动生成的代码。\n *   该度量指标用于评估项目的整体规模。统计范围仅限于实际代码行，排除空行和注释行。\n * @kind metric\n * @tags summary\n *       telemetry\n * @id py/summary/lines-of-code\n */\n\nimport python // 导入Python分析模块，用于处理Python代码库的度量分析\n\n// 遍历数据库中的每个Python模块，获取其代码度量信息\n_______________ // 补全条件\nfrom Module pythonModule\nselect sum(pythonModule.getMetrics().getNumberOfLinesOfCode())",
    "output": "// 然后计算所有模块的有效代码行总数，排除注释和空白行"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/tarslip]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies directory traversal vulnerabilities in tar extraction where untrusted archive contents could overwrite files outside the target directory",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description Identifies directory traversal vulnerabilities in tar extraction where untrusted archive contents could overwrite files outside the target directory\n * @kind path-problem\n * @id py/tarslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\n// Trace vulnerable data flows from untrusted origins to extraction targets\nfrom TarSlipFlow::PathNode untrustedOriginNode, TarSlipFlow::PathNode extractionTargetNode\nwhere \n  // Validate complete data flow path exists between origin and target\n  TarSlipFlow::flowPath(untrustedOriginNode, extractionTargetNode)\nselect \n  extractionTargetNode.getNode(), \n  untrustedOriginNode, \n  extractionTargetNode, \n  \"This file extraction depends on a $@.\", \n  untrustedOriginNode.getNode(),\n  \"potentially untrusted source\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Display strings of callables\n * @kind display-string\n * @id py/function-display-strings\n * @metricType callable\n */\n_______________ // 补全条件\n// Import Python language module for code structure analysis\nimport python\n\n// Define query scope: select all Python function definitions\nfrom Function pyFunction\n// Produce output: function entity with descriptive string representation\nselect pyFunction, \"Function \" + pyFunction.getName()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'super' in old style class\n * @description 旧式类（不继承自object的类）中调用super()会导致运行时错误。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * 检查给定的super()调用是否位于旧式类中。\n * 旧式类即未继承object的类（Python 2.x风格）。\n * 在旧式类中使用super()会引发运行时错误。\n */\npredicate isSuperCallInOldStyleClass(Call superInvocation) {\n  exists(Function enclosingFunction, ClassObject enclosingClass |\n    // 确认调用的是 super 函数（快速判断）\n    superInvocation.getFunc().(Name).getId() = \"super\" and\n    // 验证调用发生在函数内部，且该函数定义在类中\n    superInvocation.getScope() = enclosingFunction and\n    enclosingFunction.getScope() = enclosingClass.getPyClass() and\n_______________ // 补全条件\n    not enclosingClass.failedInference() and\n    // 检查类是否为旧式类（非新式类）\n    not enclosingClass.isNewStyle()\n  )\n}\n\n// 查找所有在旧式类中使用的 super() 调用\nfrom Call problematicSuperCall\nwhere isSuperCallInOldStyleClass(problematicSuperCall)\n// 输出问题代码和错误信息\nselect problematicSuperCall, \"'super()' will not work in old-style classes.\"",
    "output": "// 确保类信息能够被正确推断"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Syntax error detection\n * @description Identifies Python syntax errors that lead to runtime failures and hinder proper code analysis.\n_______________ // 补全条件\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import the Python library required for code querying and analysis\nimport python\n\n// Query for syntax errors, filtering out encoding-related issues\nfrom SyntaxError syntaxProblem\nwhere not syntaxProblem instanceof EncodingError\nselect syntaxProblem, syntaxProblem.getMessage() + \" (in Python \" + major_version() + \").\"\n// Output the syntax error instance along with a detailed error message including the Python version",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Modification of dictionary returned by locals()\n * @description Identifies code that attempts to modify the dictionary returned by locals(),\n_______________ // 补全条件\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/modification-of-locals\n */\n\nimport python\n\n// Determines if a control flow node references the result of a locals() function call\npredicate referencesLocalsCall(ControlFlowNode flowNode) { \n    flowNode.pointsTo(_, _, Value::named(\"locals\").getACall()) \n}\n\n// Checks for dictionary operations (subscript assignment or deletion) on the dictionary returned by locals()\npredicate isDictionaryModification(ControlFlowNode modificationNode) {\n    exists(SubscriptNode subscriptAccess |\n        subscriptAccess = modificationNode and\n        referencesLocalsCall(subscriptAccess.getObject()) and\n        (subscriptAccess.isStore() or subscriptAccess.isDelete())\n    )\n}\n\n// Checks for method calls on the dictionary returned by locals() that modify the dictionary content\npredicate isMethodCallModification(ControlFlowNode modificationNode) {\n    exists(CallNode methodCall, AttrNode attributeAccess, string methodName |\n        methodCall = modificationNode and\n        attributeAccess = methodCall.getFunction() and\n        referencesLocalsCall(attributeAccess.getObject(methodName)) and\n        methodName in [\"pop\", \"popitem\", \"update\", \"clear\"]\n    )\n}\n\n// Determines if there is any modification operation on the dictionary returned by locals()\npredicate modifiesLocalsDictionary(ControlFlowNode modificationNode) {\n    isDictionaryModification(modificationNode) or\n    isMethodCallModification(modificationNode)\n}\n\nfrom AstNode syntaxNode, ControlFlowNode modificationNode\nwhere\n    // Find operations that modify the dictionary returned by locals()\n    modifiesLocalsDictionary(modificationNode) and\n    // Get the AST node corresponding to the control flow node\n    syntaxNode = modificationNode.getNode() and\n    // Exclude module-level scope, as locals() is equivalent to globals() at module level\n    not syntaxNode.getScope() instanceof ModuleScope\n// Output the result with a warning message\nselect syntaxNode, \"Modification of the locals() dictionary will have no effect on the local variables.\"",
    "output": "*              which does not actually affect the local variables in the current scope."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/paramiko-command-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when user-controlled input triggers command execution on external systems,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Command execution on a secondary remote server\n * @description Detects when user-controlled input triggers command execution on external systems,\n *              potentially compromising other users or administrative infrastructure\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.3\n * @precision high\n * @id py/paramiko-command-injection\n * @tags security\n *       experimental\n *       external/cwe/cwe-074\n */\n\n// Import core Python analysis capabilities\nimport python\n// Import experimental module for remote command execution detection\nimport experimental.semmle.python.security.RemoteCommandExecution\n// Import path graph utilities for data flow tracking\nimport RemoteCommandExecutionFlow::PathGraph\n\n// Identify vulnerable data flows from user-controlled sources to remote command execution\nfrom RemoteCommandExecutionFlow::PathNode taintedSource, RemoteCommandExecutionFlow::PathNode executionSink\nwhere RemoteCommandExecutionFlow::flowPath(taintedSource, executionSink)\nselect executionSink.getNode(), taintedSource, executionSink, \n       \"This code execution depends on a $@.\", taintedSource.getNode(),\n       \"user-controlled input source\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during a tarball extraction from a user controlled source\n * @description 当提取用户控制的tar文件时，未验证目标路径是否在目标目录内，可能导致目录遍历攻击。\n *             这种漏洞发生在tar文件源自不受信任的位置（如远程服务器或用户输入参数）。\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n_______________ // 补全条件\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// 定义数据流分析的起点（用户控制源）和终点（危险解包操作）\nfrom UnsafeUnpackFlow::PathNode untrustedSourceNode, UnsafeUnpackFlow::PathNode dangerousUnpackNode\n// 检测是否存在从用户控制源到危险解包操作的完整数据流路径\nwhere UnsafeUnpackFlow::flowPath(untrustedSourceNode, dangerousUnpackNode)\n// 输出漏洞位置、数据流起点和终点，并附带安全警告信息\nselect dangerousUnpackNode.getNode(), untrustedSourceNode, dangerousUnpackNode,\n  \"危险解包操作：从不信任的远程位置获取的恶意tar文件可能导致目录遍历攻击\"",
    "output": "*       experimental"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class Cohesion Deficiency (HM Method)\n * @description Quantifies class cohesion deficiency employing Hitz and Montazeri's approach.\n * @kind treemap\n * @id py/lack-of-cohesion-hitz-montazeri\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n */\n\nimport python  // Import Python module for code analysis capabilities\n\n// Detect classes exhibiting poor cohesion using the HM assessment technique\n// This evaluation examines the connectivity between methods and instance attributes\nfrom ClassMetrics clsMetric\n\n// Arrange output to prioritize classes with the most critical cohesion deficiencies\n// Fetch class data and compute its cohesion deficiency metric\n// Elevated scores signify more pronounced cohesion problems within the class\nselect \n_______________ // 补全条件\n    clsMetric.getLackOfCohesionHM() as cohesionValue \norder by \n    cohesionValue desc",
    "output": "clsMetric,"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：在继承体系中，若基类的属性与派生类的方法同名，则派生类的方法会被基类的属性所遮蔽。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 在继承体系中，若基类的属性与派生类的方法同名，则派生类的方法会被基类的属性所遮蔽。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 本查询用于识别派生类中定义的方法被基类属性遮蔽的情况。\n * 特别关注在基类的__init__方法中通过self赋值定义的属性。\n */\n\nimport python\n\n// 定义谓词 isMethodHiddenByBaseClassAttribute，用于判断派生类方法是否被基类属性遮蔽\npredicate isMethodHiddenByBaseClassAttribute(\n  ClassObject childClass, ClassObject parentClass, Assign attrAssignment, FunctionObject shadowedMethod\n) {\n  // 确认继承关系：childClass 继承自 parentClass\n  childClass.getASuperType() = parentClass and\n  // 派生类声明了 shadowedMethod 作为其属性\n  childClass.declaredAttribute(_) = shadowedMethod and\n  // 检查基类初始化方法中是否存在同名属性赋值\n  exists(FunctionObject parentInitMethod, Attribute assignedAttribute |\n    // 基类定义了 __init__ 方法\n    parentClass.declaredAttribute(\"__init__\") = parentInitMethod and\n    // 属性赋值的目标是 assignedAttribute\n    assignedAttribute = attrAssignment.getATarget() and\n    // 属性赋值对象是 self\n    assignedAttribute.getObject().(Name).getId() = \"self\" and\n    // 属性名称与派生类方法名称相同\n    assignedAttribute.getName() = shadowedMethod.getName() and\n    // 赋值操作发生在基类的初始化方法中\n    attrAssignment.getScope() = parentInitMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  /*\n   * 排除基类中也定义了同名方法的情况\n   * 这种情况下，我们认为是有意为之的设计\n   */\n  // 确保基类没有定义同名属性\n  not parentClass.hasAttribute(shadowedMethod.getName())\n}\n\n// 从派生类、基类、属性赋值和被遮蔽的方法中查询\nfrom ClassObject childClass, ClassObject parentClass, Assign attrAssignment, FunctionObject shadowedMethod\n// 应用谓词进行筛选\nwhere isMethodHiddenByBaseClassAttribute(childClass, parentClass, attrAssignment, shadowedMethod)\n// 选择被遮蔽方法的位置、错误信息、属性赋值位置和属性类型\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + parentClass.getName() +\n    \"'.\", attrAssignment, \"attribute\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jwt-empty-secret-or-algorithm]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects JWT token creation that employs blank cryptographic keys",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name JWT encoding with empty key or algorithm\n * @description Detects JWT token creation that employs blank cryptographic keys \n *              or unspecified algorithms, which may lead to security weaknesses \n *              in token authentication mechanisms.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-empty-secret-or-algorithm\n * @tags security\n *       experimental\n */\n\n// Import Python analysis core libraries\nimport python\nimport experimental.semmle.python.Concepts\nimport experimental.semmle.python.frameworks.JWT\n\n// Identify JWT encoding operations with security deficiencies\nfrom JwtEncoding jwtTokenCreation, string insecureParameter\nwhere\n  // Determine if critical security parameters are missing or invalid\n  exists(string securityParam |\n    (\n      securityParam = \"algorithm\" and isEmptyOrNone(jwtTokenCreation.getAlgorithm()) or\n      securityParam = \"key\" and isEmptyOrNone(jwtTokenCreation.getKey())\n    ) and\n    insecureParameter = securityParam\n  )\nselect jwtTokenCreation, \"This JWT encoding uses an empty \" + insecureParameter + \" parameter.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete regular expression for hostnames\n * @description Identifies security vulnerabilities in regular expressions used for URL or hostname validation.\n *              The query specifically detects patterns with unescaped dots ('.') that match any character,\n *              potentially enabling unauthorized hostname access outside the intended scope.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-hostname-regexp\n * @tags correctness\n *       security\n *       external/cwe/cwe-020\n */\n\n// Import specialized library for analyzing security issues in hostname regular expressions\nprivate import semmle.python.security.regexp.HostnameRegex as HostnamePatternChecker\n\n_______________ // 补全条件\n// This predicate serves as the entry point to the core analysis logic in the HostnamePatternChecker module\nquery predicate problems = HostnamePatternChecker::incompleteHostnameRegExp/4;",
    "output": "// Main query predicate that identifies security issues in incomplete hostname regular expressions"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 重写方法签名不匹配\n * @description 检测方法重写时参数签名不匹配的情况：派生类方法与基类方法接受的参数数量或类型不一致\n *              可能导致运行时错误\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n// 查找方法重写时签名不匹配的情况\nfrom FunctionValue baseMethod, PythonFunctionValue derivedMethod\nwhere\n  // 确保基类方法未被调用\n  not exists(baseMethod.getACall())\n  and\n  // 确保没有其他派生类方法重写基类方法且被调用\n_______________ // 补全条件\n    otherDerivedMethod.overrides(baseMethod) and\n    exists(otherDerivedMethod.getACall())\n  )\n  and\n  // 验证派生类方法类型：非特殊方法、非构造函数且为普通方法\n  not derivedMethod.getScope().isSpecialMethod() and\n  derivedMethod.getName() != \"__init__\" and\n  derivedMethod.isNormalMethod()\n  and\n  // 检查重写关系与参数数量不匹配\n  derivedMethod.overrides(baseMethod) and\n  (\n    derivedMethod.minParameters() > baseMethod.maxParameters()  // 派生类最小参数数 > 基类最大参数数\n    or\n    derivedMethod.maxParameters() < baseMethod.minParameters()  // 派生类最大参数数 < 基类最小参数数\n  )\nselect derivedMethod, \"重写方法 '\" + derivedMethod.getName() + \"' 与 $@ 签名不匹配。\", \n  baseMethod, \"被重写的基类方法\"",
    "output": "not exists(FunctionValue otherDerivedMethod |"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Mostly similar module detection\n * @description Detects modules that share significant code similarity. This analysis considers structural patterns even when variable names and types differ between modules. Merging similar modules is advised to enhance code maintainability.\n * @kind problem\n * @problem.severity recommendation\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @sub-severity low\n * @precision high\n * @id py/mostly-similar-file\n */\n\nimport python\n\n// Define variables for source module, target module, and similarity details\nfrom Module sourceModule, \n     Module targetModule, \n     string similarityDetails\nwhere \n  // Placeholder condition for similarity detection logic\n  // Currently no filtering is applied (actual implementation needed)\n  none()\n  // Additional constraints would be added here to identify similar modules\nselect \n  sourceModule, \n  similarityDetails, \n_______________ // 补全条件\n  targetModule.getName()  // Display the name of the target module for reference",
    "output": "targetModule,"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-misconfiguration-with-credentials]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Disabling or weakening SOP protection may make the application",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cors misconfiguration with credentials\n * @description Disabling or weakening SOP protection may make the application\n *              vulnerable to a CORS attack.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n/** 检查节点是否包含通配符或null值 */\npredicate containsWildcardOrNull(DataFlow::Node originNode) {\n  // 检查列表类型节点是否包含\"*\"或\"null\"字符串字面量\n  originNode.asExpr() instanceof List and\n  originNode.asExpr().getASubExpression().(StringLiteral).getText() in [\"*\", \"null\"]\n  // 检查节点本身是否为\"*\"或\"null\"字符串字面量\n  or\n  originNode.asExpr().(StringLiteral).getText() in [\"*\", \"null\"]\n}\n\n/** 验证中间件是否为CORS中间件 */\npredicate isCorsConfiguredMiddleware(Http::Server::CorsMiddleware middleware) {\n  middleware.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n/** 检查CORS中间件是否启用了凭证支持 */\npredicate hasCredentialsEnabled(Http::Server::CorsMiddleware middleware) {\n  middleware.getCredentialsAllowed().asExpr() instanceof True\n}\n\nfrom Http::Server::CorsMiddleware vulnerableMiddleware\nwhere\n  // 验证中间件类型和凭证配置\n  isCorsConfiguredMiddleware(vulnerableMiddleware) and\n  hasCredentialsEnabled(vulnerableMiddleware) and\n  // 检查来源配置是否包含不安全的通配符\n  containsWildcardOrNull(vulnerableMiddleware.getOrigins().getALocalSource())\nselect vulnerableMiddleware,\n  \"This CORS middleware uses a vulnerable configuration that allows arbitrary websites to make authenticated cross-site requests\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-crypto-key]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测使用长度不足的加密密钥，这些密钥可能被破解。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 使用弱加密密钥\n * @description 检测使用长度不足的加密密钥，这些密钥可能被破解。\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/weak-crypto-key\n * @tags security\n *       external/cwe/cwe-326\n */\n\nimport python\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.filters.Tests\n\n// 从加密密钥生成器类中获取相关参数\nfrom Cryptography::PublicKey::KeyGeneration cryptoKeyGenerator, int securityKeySize, DataFlow::Node sourceNode\nwhere\n  // 获取密钥大小并验证其安全性\n  securityKeySize = cryptoKeyGenerator.getKeySizeWithOrigin(sourceNode) and\n  // 检查密钥大小是否低于最小安全标准\n  securityKeySize < cryptoKeyGenerator.minimumSecureKeySize() and\n  // 确保密钥生成不在测试代码中\n  not sourceNode.getScope().getScope*() instanceof TestScope\nselect cryptoKeyGenerator,\n  // 生成警告信息，包含密钥类型、大小和安全建议\n  \"Creation of an \" + cryptoKeyGenerator.getName() + \" key uses $@ bits, which is below \" +\n    cryptoKeyGenerator.minimumSecureKeySize() + \" and considered breakable.\", sourceNode, securityKeySize.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Signature mismatch in overriding method\n * @description Detects when a subclass method overrides a superclass method\n *              with incompatible parameter counts, potentially causing runtime errors.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Identify methods with signature mismatches in inheritance hierarchies\nfrom FunctionValue parentMethod, PythonFunctionValue childMethod\nwhere\n  // Verify the override relationship exists between child and parent methods\n  childMethod.overrides(parentMethod) and\n  \n  // Focus only on regular instance methods, excluding special methods and constructors\n  childMethod.isNormalMethod() and\n  not childMethod.getScope().isSpecialMethod() and\n  childMethod.getName() != \"__init__\" and\n  \n  // Filter out cases where the parent method is called directly\n  not exists(parentMethod.getACall()) and\n  \n  // Ensure no other overriding child methods are being called\n  not exists(FunctionValue otherChildMethod |\n_______________ // 补全条件\n    exists(otherChildMethod.getACall())\n  ) and\n  \n  // Check for parameter count incompatibility between child and parent methods\n  (\n    // Case 1: Child method requires more parameters than parent method can provide\n    childMethod.minParameters() > parentMethod.maxParameters()\n    or\n    // Case 2: Child method accepts fewer parameters than parent method requires\n    childMethod.maxParameters() < parentMethod.minParameters()\n  )\nselect childMethod, \"Overriding method '\" + childMethod.getName() + \"' has signature mismatch with $@.\",\n  parentMethod, \"overridden method\"",
    "output": "otherChildMethod.overrides(parentMethod) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-of-identical-expressions]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects comparisons between identical values that may indicate",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Identical value comparison detection\n * @description Detects comparisons between identical values that may indicate\n *              unclear logic, potential errors, or redundant code patterns.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\n// Import required modules for Python code analysis\nimport python\nimport Expressions.RedundantComparison\n\n// Identify redundant comparisons between identical values\nfrom RedundantComparison redundantExpr\nwhere \n    // First condition: exclude cases where 'self' might be missing from attribute references\n    not redundantExpr.maybeMissingSelf()\n    // Second condition: filter out constant comparisons which may be intentionally designed\n    and not redundantExpr.isConstant()\n// Report identified redundant comparisons with appropriate guidance\nselect redundantExpr, \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name File Code Line Count\n * @kind treemap\n * @description Computes the effective lines of code for each Python file, \n *              excluding documentation, comments, and whitespace-only lines.\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n * @id py/lines-of-code-in-files\n */\n\nimport python\n\n// Identify Python modules and calculate their effective code line count\nfrom Module pyModule, int locCount\n_______________ // 补全条件\n  // Calculate the number of lines containing actual code by excluding\n  // documentation, comments, and whitespace-only lines\n  locCount = pyModule.getMetrics().getNumberOfLinesOfCode()\n// Output the Python modules and their corresponding line counts,\n// sorted in descending order to highlight files with the most code\nselect pyModule, locCount order by locCount desc",
    "output": "where"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Documentation coverage ratio\n * @description Measures the ratio of docstring lines to total lines in Python source files.\n * @kind treemap\n * @id py/doc-string-ratio-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\n// Identify Python modules with their corresponding metrics, excluding empty files\nfrom Module pyModule, ModuleMetrics moduleStats\nwhere \n  moduleStats = pyModule.getMetrics() and \n  moduleStats.getNumberOfLines() > 0\nselect \n  pyModule,\n  // Calculate the docstring coverage percentage relative to total lines\n  100.0 * \n    (moduleStats.getNumberOfLinesOfDocStrings().(float) / \n_______________ // 补全条件\norder by \n  docCoverageRatio desc",
    "output": "moduleStats.getNumberOfLines().(float)) as docCoverageRatio"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Backspace escape in regular expression\n * @description Identifies regular expressions containing '\\b' escape sequence within character sets,\n *              which represents a backspace character but is often confused with word boundary assertion.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int escapePos\nwhere\n_______________ // 补全条件\n  regexPattern.escapingChar(escapePos) and\n  // Validate subsequent character is 'b' forming '\\b' sequence\n  regexPattern.getChar(escapePos + 1) = \"b\" and\n  // Confirm sequence resides within a character set boundary\n  exists(int charSetStart, int charSetEnd | \n    // Verify valid character set encompasses the escape position\n    regexPattern.charSet(charSetStart, charSetEnd) and\n    // Ensure character set starts before escape sequence\n    charSetStart < escapePos and \n    // Ensure character set ends after escape sequence\n    charSetEnd > escapePos\n  )\nselect regexPattern, \"Backspace escape in regular expression at offset \" + escapePos + \".\"",
    "output": "// Identify position of escape character (backslash)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies imports that cannot be resolved, which may lead to reduced analysis coverage and accuracy.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unresolved import\n * @description Identifies imports that cannot be resolved, which may lead to reduced analysis coverage and accuracy.\n * @kind problem\n * @problem.severity info\n * @id py/import-failure\n */\n\n// Import the Python analysis library\nimport python\n\n/**\n * Retrieves the current operating system platform from the Python interpreter.\n * This is used to determine if OS-specific imports should be flagged as unresolved.\n */\nstring getCurrentOSPlatform() { \n  py_flags_versioned(\"sys.platform\", result, major_version().toString()) \n}\n\n/**\n * Identifies imports that are specific to a particular operating system.\n * Returns the operating system name if the import is OS-specific.\n */\nstring getOSSpecificImportType(ImportExpr impExpr) {\n  // Check if the imported module name matches OS-specific patterns\n  exists(string moduleName | moduleName = impExpr.getImportedModuleName() |\n    // Java-related imports\n    (moduleName.matches(\"org.python.%\") or moduleName.matches(\"java.%\")) and result = \"java\"\n    or\n    // macOS imports\n    moduleName.matches(\"Carbon.%\") and result = \"darwin\"\n    or\n    // Windows imports\n    result = \"win32\" and\n    (\n      moduleName = \"_winapi\" or\n      moduleName = \"_win32api\" or\n      moduleName = \"_winreg\" or\n      moduleName = \"nt\" or\n      moduleName.matches(\"win32%\") or\n      moduleName = \"ntpath\"\n    )\n    or\n    // Linux imports\n    result = \"linux2\" and\n    (moduleName = \"posix\" or moduleName = \"posixpath\")\n    or\n    // Unsupported platform imports\n    result = \"unsupported\" and\n    (moduleName = \"__pypy__\" or moduleName = \"ce\" or moduleName.matches(\"riscos%\"))\n  )\n}\n\n/**\n * Finds alternative import expressions that serve as fallback imports.\n * This function identifies imports used in conditional statements (if/else) or \n * exception handling (try/except) as alternatives to each other.\n */\nImportExpr getAlternativeImport(ImportExpr originalImport) {\n  // Verify aliases exist for both the primary and alternative imports\n  exists(Alias originalAlias, Alias alternativeAlias |\n    // Original alias mapping\n    (originalAlias.getValue() = originalImport or originalAlias.getValue().(ImportMember).getModule() = originalImport) and\n    // Alternative alias mapping\n    (alternativeAlias.getValue() = result or alternativeAlias.getValue().(ImportMember).getModule() = result) and\n    (\n      // Check if imports are in different branches of conditional statements\n      exists(If conditional | \n        conditional.getBody().contains(originalImport) and conditional.getOrelse().contains(result)\n      )\n      or\n      exists(If conditional | \n        conditional.getBody().contains(result) and conditional.getOrelse().contains(originalImport)\n      )\n      or\n      // Check if imports are in try and except blocks\n      exists(Try tryBlock | \n        tryBlock.getBody().contains(originalImport) and tryBlock.getAHandler().contains(result)\n      )\n      or\n      exists(Try tryBlock | \n        tryBlock.getBody().contains(result) and tryBlock.getAHandler().contains(originalImport)\n      )\n    )\n  )\n}\n\n/**\n * Determines if an import is allowed to fail without being flagged as an issue.\n * An import is allowed to fail if it has an alternative or if it's OS-specific\n * for a different OS than the current one.\n */\npredicate isImportFailureAllowed(ImportExpr impExpr) {\n  // Check if there's a working alternative import\n  getAlternativeImport(impExpr).refersTo(_)\n  or\n  // Check if the import is OS-specific but not for the current OS\n  getOSSpecificImportType(impExpr) != getCurrentOSPlatform()\n}\n\n/**\n * Represents a control flow node that tests the Python interpreter version.\n * These nodes are typically used to conditionally import modules based on version compatibility.\n */\nclass InterpreterVersionCheckNode extends ControlFlowNode {\n  InterpreterVersionCheckNode() {\n    exists(string versionAttr |\n      versionAttr.matches(\"%version%\") and\n      this.(CompareNode).getAChild+().pointsTo(Module::named(\"sys\").attr(versionAttr))\n    )\n  }\n\n  override string toString() { result = \"VersionTest\" }\n}\n\n/**\n * Represents a conditional block that guards code based on the Python interpreter version.\n * This is used to identify version-specific import statements that should not be flagged.\n */\nclass InterpreterVersionGuardBlock extends ConditionBlock {\n  InterpreterVersionGuardBlock() { this.getLastNode() instanceof InterpreterVersionCheckNode }\n}\n\n// Main query: Find unresolved imports that should be flagged as issues\nfrom ImportExpr unresolvedImport\nwhere\n  not unresolvedImport.refersTo(_) and // Import cannot be resolved\n  exists(Context validContext | validContext.appliesTo(unresolvedImport.getAFlowNode())) and // Import is in a valid context\n  not isImportFailureAllowed(unresolvedImport) and // Import is not allowed to fail\n  not exists(InterpreterVersionGuardBlock versionGuard | versionGuard.controls(unresolvedImport.getAFlowNode().getBasicBlock(), _)) // Not protected by version guard\nselect unresolvedImport, \"Unable to resolve import of '\" + unresolvedImport.getImportedModuleName() + \"'.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-small-salt-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Key Derivation Function (KDF) salts must be at least 128 bits (16 bytes) in length.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insufficient KDF Salt Size\n * @description Key Derivation Function (KDF) salts must be at least 128 bits (16 bytes) in length.\n *\n * This rule identifies security vulnerabilities where the salt size used in key derivation\n * functions is less than the required 128 bits, or when the salt size cannot be statically\n * determined during code analysis. Insufficient salt size can weaken cryptographic security\n * by making the derived keys more susceptible to brute-force attacks.\n * @kind problem\n * @id py/kdf-small-salt-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// 定义查询变量：检测密钥派生函数中盐值大小不足的情况\nfrom KeyDerivationOperation keyDerivationFunc, DataFlow::Node saltSizeNode, API::CallNode urandomCall, string alertMessage\nwhere\n  // 条件1：确保密钥派生操作需要盐值\n  keyDerivationFunc.requiresSalt() and\n  \n  // 条件2：验证盐值配置源是os.urandom\n  urandomCall = keyDerivationFunc.getSaltConfigSrc() and\n  urandomCall = API::moduleImport(\"os\").getMember(\"urandom\").getACall() and\n  \n  // 条件3：追踪盐值大小参数的最终来源\n  saltSizeNode = CryptoUtils::getUltimateSrcFromApiNode(urandomCall.getParameter(0, \"size\")) and\n  \n  // 条件4：安全检查 - 验证盐值大小是否足够或可静态确定\n  (\n    // 子情况A：盐值大小无法静态验证（动态确定）\n    not exists(saltSizeNode.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Salt config is not a statically verifiable size. \"\n    or\n    // 子情况B：盐值大小不足（小于16字节）\n    saltSizeNode.asExpr().(IntegerLiteral).getValue() < 16 and\n    alertMessage = \"Salt config is insufficiently large. \"\n  )\nselect keyDerivationFunc,  // 选择存在安全问题的密钥派生操作\n  alertMessage + \"Salt size must be a minimum of 16 (bytes). os.urandom Config: $@, Size Config: $@\",  // 构建安全警报消息\n  urandomCall, urandomCall.toString(),  // 显示urandom调用及其字符串表示\n  saltSizeNode, saltSizeNode.toString()  // 显示盐值大小参数及其字符串表示"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/incorrect-overridden-signature]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects methods in derived classes whose signatures differ from their base class counterparts,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Method Signature Mismatch in Overridden Methods\n * @description Detects methods in derived classes whose signatures differ from their base class counterparts,\n *              and identifies cases where actual method calls don't align with either signature,\n *              potentially leading to runtime invocation errors.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/inheritance/incorrect-overridden-signature\n */\n\nimport python  // 导入Python代码分析库，支持Python代码的静态分析功能\nimport Expressions.CallArgs  // 导入调用参数处理库，用于分析函数调用参数\n\nfrom Call invocationNode, FunctionValue parentMethod, FunctionValue childMethod, string mismatchReason\nwhere\n  // 排除构造函数，仅关注普通实例方法\n  not parentMethod.getName() = \"__init__\" and\n  // 确认子类方法确实覆盖了父类方法\n  childMethod.overrides(parentMethod) and\n  // 获取子类方法的调用节点\n  invocationNode = childMethod.getAMethodCall().getNode() and\n  // 验证作为方法调用时的参数是否正确\n  correct_args_if_called_as_method(invocationNode, childMethod) and\n  (\n    // 检查参数数量不匹配的情况\n    (\n      arg_count(invocationNode) + 1 < parentMethod.minParameters() and \n      mismatchReason = \"too few arguments\"\n    )\n    or\n    (\n      arg_count(invocationNode) >= parentMethod.maxParameters() and \n      mismatchReason = \"too many arguments\"\n    )\n    or\n    // 检查关键字参数不匹配的情况\n    (\n      exists(string parameterName |\n        // 从调用中提取关键字参数名称\n        invocationNode.getAKeyword().getArg() = parameterName and\n        // 确认该参数名存在于子类方法中\n        childMethod.getScope().getAnArg().(Name).getId() = parameterName and\n        // 确认该参数名不存在于父类方法中\n        not parentMethod.getScope().getAnArg().(Name).getId() = parameterName and\n        // 构建问题描述\n        mismatchReason = \"an argument named '\" + parameterName + \"'\"\n      )\n    )\n  )\nselect parentMethod,\n  \"Overridden method signature does not match $@, where it is passed \" + mismatchReason +\n    \". Overriding method $@ matches the call.\", invocationNode, \"call\", childMethod,\n  childMethod.descriptiveString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Discovers all cryptographic key exchange algorithm implementations across supported libraries.\n *              This query identifies algorithm usage for cryptographic bill of materials (CBOM) analysis.\n * @kind problem\n * @id py/quantum-readiness/cbom/key-exchange\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import core Python analysis components\nimport python\n\n// Import experimental cryptography primitives for security analysis\nimport experimental.cryptography.Concepts\n\n// Identify key exchange algorithm implementations\nfrom KeyExchangeAlgorithm keyExchangeAlgorithm\n\n// Format results with algorithm identification details\nselect keyExchangeAlgorithm, \n       \"Use of algorithm \" + keyExchangeAlgorithm.getName()",
    "output": "* @name Key Exchange Algorithms Identification"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode IV or nonce\n * @description Detects vulnerable initialization vectors/nonces in block cipher modes.\n *              Flags IVs/nonces not generated via cryptographically secure methods (os.urandom).\n * \n *            NOTE:\n *              1. Simplified approach: Any IV/nonce not from os.urandom is flagged\n *              2. Special cases:\n *                 - GCM mode: Requires specific nonce handling (covered in separate query)\n *                 - Fernet: Explicitly excluded (uses os.urandom internally)\n *              3. Functions inferring mode/IV may trigger false positives (user suppression required)\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Detect block cipher operations with weak IV/nonce configuration\nfrom BlockMode blockModeOperation, string message, DataFlow::Node vulnerableNode\nwhere\n  // Exclude Fernet (handles IV generation internally)\n  not blockModeOperation instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet and\n  (\n    // Case 1: Missing IV/Nonce initialization\n    (\n      not blockModeOperation.hasIVorNonce() and\n      vulnerableNode = blockModeOperation and\n      message = \"Block mode is missing IV/Nonce initialization\"\n    )\n    or\n    // Case 2: Non-os.urandom IV/Nonce source\n    (\n      blockModeOperation.hasIVorNonce() and\n_______________ // 补全条件\n      vulnerableNode = blockModeOperation.getIVorNonce() and\n      message = \"Block mode uses non-cryptographic IV/Nonce source: $@\"\n    )\n  )\nselect blockModeOperation, message, vulnerableNode, vulnerableNode.toString()",
    "output": "not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = blockModeOperation.getIVorNonce() and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Membership test with a non-container\n * @description Identifies membership operations ('in'/'not in') where the right-hand operand \n *              is a non-container type, causing runtime TypeError.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n * Identifies nodes serving as right operands in membership tests.\n * @param node - Control flow node being evaluated\n * @param comparisonNode - Comparison expression containing the membership test\n */\npredicate isRightHandSideOfInTest(ControlFlowNode node, Compare comparisonNode) {\n  exists(Cmpop operation, int operandIndex |\n    comparisonNode.getOp(operandIndex) = operation and \n    comparisonNode.getComparator(operandIndex) = node.getNode() and\n    (operation instanceof In or operation instanceof NotIn)\n  )\n}\n\nfrom \n  ControlFlowNode rhsNode, \n  Compare comparisonNode, \n  Value pointedToValue, \n  ClassValue nonContainerClass, \n  ControlFlowNode sourceNode\nwhere\n  // Step 1: Confirm node is right operand of membership test\n  isRightHandSideOfInTest(rhsNode, comparisonNode) and\n  \n  // Step 2: Resolve pointed value and class information\n  rhsNode.pointsTo(_, pointedToValue, sourceNode) and\n  pointedToValue.getClass() = nonContainerClass and\n  \n  // Step 3: Exclude cases with failed type inference\n  not Types::failedInference(nonContainerClass, _) and\n  \n  // Step 4: Verify class lacks container interface methods\n  not nonContainerClass.hasAttribute(\"__contains__\") and\n  not nonContainerClass.hasAttribute(\"__iter__\") and\n  not nonContainerClass.hasAttribute(\"__getitem__\") and\n  \n  // Step 5: Exclude special pseudo-container types\n  not nonContainerClass = ClassValue::nonetype() and\n_______________ // 补全条件\nselect \n  comparisonNode, \n  \"This test may raise an Exception as the $@ may be of non-container class $@.\", \n  sourceNode, \"target\", nonContainerClass, nonContainerClass.getName()",
    "output": "not nonContainerClass = Value::named(\"types.MappingProxyType\")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Membership test with a non-container\n * @description Detects membership operations (e.g., 'item in sequence') where the right-hand operand \n *              is a non-container object, causing a runtime 'TypeError'.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n * Identifies right operands in membership test operations.\n * @param operand - The control flow node being evaluated\n * @param comparison - The comparison expression containing the operation\n */\npredicate isRhsOfInTest(ControlFlowNode operand, Compare comparison) {\n  exists(Cmpop operator, int index |\n    comparison.getOp(index) = operator and \n    comparison.getComparator(index) = operand.getNode() and\n    (operator instanceof In or operator instanceof NotIn)\n  )\n}\n\nfrom \n  ControlFlowNode rhsOperand, \n  Compare comparisonNode, \n  Value pointedValue, \n  ClassValue objectClass, \n  ControlFlowNode originNode\nwhere\n  // Verify membership test context\n  isRhsOfInTest(rhsOperand, comparisonNode) and\n  \n  // Resolve object type information\n  rhsOperand.pointsTo(_, pointedValue, originNode) and\n  pointedValue.getClass() = objectClass and\n  \n  // Exclude cases with incomplete type analysis\n  not Types::failedInference(objectClass, _) and\n  \n  // Confirm absence of container interface methods\n  not objectClass.hasAttribute(\"__contains__\") and\n  not objectClass.hasAttribute(\"__iter__\") and\n  not objectClass.hasAttribute(\"__getitem__\") and\n  \n  // Exclude special container-like types\n  not objectClass = ClassValue::nonetype() and\n  not objectClass = Value::named(\"types.MappingProxyType\")\nselect \n_______________ // 补全条件\n  \"This test may raise an Exception as the $@ may be of non-container class $@.\", \n  originNode, \"target\", objectClass, objectClass.getName()",
    "output": "comparisonNode,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Constant in conditional expression or statement\n * @description Detects conditional expressions or statements that always evaluate to true or false due to the use of constants\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/constant-conditional-expression\n */\n\nimport python\n\n// Determines whether an expression is used in a conditional context\npredicate is_condition(Expr testExpr) {\n  // Checks if the expression appears as the test in an if statement or conditional expression\n  exists(If ifNode | ifNode.getTest() = testExpr) or\n  exists(IfExp ternaryExpr | ternaryExpr.getTest() = testExpr)\n}\n\n/* Treat certain unmodified builtins as constants as well. */\n// Identifies specific built-in constant names that are effectively constants\npredicate effective_constant(Name identifierNode) {\n  // Finds global built-in constants that have not been redefined\n_______________ // 补全条件\n    builtinVar = identifierNode.getVariable() and \n    not exists(NameNode defNode | defNode.defines(builtinVar)) and\n    (builtinVar.getId() = \"True\" or \n     builtinVar.getId() = \"False\" or \n     builtinVar.getId() = \"NotImplemented\")\n  )\n}\n\n// Detects conditions that lead to unreachable code in control structures\npredicate test_makes_code_unreachable(Expr conditionExpr) {\n  // Checks conditions in if statements that make a branch unreachable\n  (exists(If conditionalStmt | \n    conditionalStmt.getTest() = conditionExpr and \n    (conditionalStmt.getStmt(0).isUnreachable() or \n     conditionalStmt.getOrelse(0).isUnreachable()))\n  )\n  or\n  // Checks conditions in while loops that make the loop body unreachable\n  (exists(While loopStmt | \n    loopStmt.getTest() = conditionExpr and \n    loopStmt.getStmt(0).isUnreachable())\n  )\n}\n\n// Finds all constant expressions used in conditional contexts\nfrom Expr conditionalExpr\nwhere\n  // Ensures the expression is used in a conditional context\n  is_condition(conditionalExpr) and\n  // Checks if the expression is a constant or effectively a constant\n  (conditionalExpr.isConstant() or effective_constant(conditionalExpr)) and\n  /* Exclude conditions that make code unreachable (handled by separate query) */\n  // Excludes cases that lead to unreachable code (handled by a separate query)\n  not test_makes_code_unreachable(conditionalExpr)\n// Reports the findings\nselect conditionalExpr, \"Testing a constant will always give the same result.\"",
    "output": "exists(GlobalVariable builtinVar |"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/timing-attack-against-hash]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：验证消息哈希值时必须使用恒定时间算法。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Timing attack against Hash\n * @description 验证消息哈希值时必须使用恒定时间算法。\n *              非恒定时间比较会通过运行时差异泄露信息，\n *              使攻击者能够伪造有效哈希并绕过认证机制。\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/timing-attack-against-hash\n * @tags security\n *       external/cwe/cwe-208\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * 加密时序攻击分析配置\n * 指定数据流分析的起点（加密操作）和终点（非恒定时间比较）\n */\nprivate module CryptoTimingAnalysisConfig implements DataFlow::ConfigSig {\n  /**\n   * 源点定义：识别加密操作产生的数据节点\n   * 包括可能生成加密值的哈希函数调用等操作\n   */\n  predicate isSource(DataFlow::Node cryptoSource) { \n    cryptoSource instanceof ProduceCryptoCall \n  }\n\n  /**\n   * 汇点定义：识别非恒定时间比较操作节点\n   * 这些操作可能因执行时间差异泄露敏感信息\n   */\n  predicate isSink(DataFlow::Node timingSink) { \n    timingSink instanceof NonConstantTimeComparisonSink \n  }\n}\n\n/**\n * 全局污点传播跟踪模块\n * 追踪从加密操作到非恒定时间比较的数据流路径\n */\nmodule CryptoTimingAttackFlow = TaintTracking::Global<CryptoTimingAnalysisConfig>;\n\n// 导入路径图用于路径分析\nimport CryptoTimingAttackFlow::PathGraph\n\n/**\n * 主查询：识别哈希验证中的时序攻击路径\n * 定位从加密操作到非恒定时间比较的数据流，\n * 特别关注涉及用户可控输入的比较操作\n */\nfrom CryptoTimingAttackFlow::PathNode cryptoOriginPath, CryptoTimingAttackFlow::PathNode timingTargetPath\nwhere\n  // 确保存在从加密操作到比较操作的数据流路径\n  CryptoTimingAttackFlow::flowPath(cryptoOriginPath, timingTargetPath) and\n  // 检查比较操作是否包含用户输入，评估潜在攻击面\n  timingTargetPath.getNode().(NonConstantTimeComparisonSink).includesUserInput()\nselect \n  // 输出格式：汇节点、源节点、路径节点、描述信息、消息类型\n  timingTargetPath.getNode(), \n  cryptoOriginPath, \n  timingTargetPath, \n  \"Timing attack against $@ validation.\",\n  cryptoOriginPath.getNode().(ProduceCryptoCall).getResultType(), \n  \"message\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称密钥生成中的未知密钥大小\n * @description 识别在非对称加密算法生成密钥时，使用了无法通过静态分析验证的密钥尺寸的安全风险\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n_______________ // 补全条件\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 检索非对称密钥生成实例，其中密钥长度无法被静态分析工具确定\nfrom AsymmetricKeyGen keyGenOp, DataFlow::Node keySizeSource, string cryptoAlgorithm\nwhere\n  // 提取密钥配置来源和加密算法名称\n  keySizeSource = keyGenOp.getKeyConfigSrc() and\n  cryptoAlgorithm = keyGenOp.getAlgorithm().getName() and\n  // 确认密钥生成操作缺少静态可验证的密钥大小信息\n  not keyGenOp.hasKeySize(keySizeSource)\nselect keyGenOp,\n  // 构建安全警告消息，标识算法类型和配置源位置\n  \"算法 \" + cryptoAlgorithm.toString() + \" 的密钥生成过程使用了无法静态验证的密钥大小，配置源位于 $@\", keySizeSource, keySizeSource.toString()",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/diagnostics/successfully-extracted-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：此查询用于检测并报告所有在代码分析过程中成功提取的Python源文件。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 已成功提取的Python源文件\n * @description 此查询用于检测并报告所有在代码分析过程中成功提取的Python源文件。\n *              成功提取的文件是指那些具有可访问相对路径的Python文件。\n * @kind diagnostic\n * @id py/diagnostics/successfully-extracted-files\n * @tags successfully-extracted-files\n */\n\nimport python\n\n// 定义查询范围：所有Python源文件\nfrom File pySourceFile\n// 应用筛选条件：文件必须具有可访问的相对路径，这表明文件已成功提取\nwhere exists(pySourceFile.getRelativePath())\n// 输出结果：文件实例和空字符串（作为占位符）\nselect pySourceFile, \"\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-weak-mode]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies key derivation functions that fail to utilize CounterMode,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak KDF Mode\n * @description Identifies key derivation functions that fail to utilize CounterMode,\n *              which is the recommended secure configuration for KDF implementations\n * @kind problem\n * @id py/kdf-weak-mode\n * @problem.severity error\n * @precision high\n */\n\n// Import Python language module for security analysis\nimport python\n// Import experimental cryptography concepts for KDF identification\nimport experimental.cryptography.Concepts\n// Import cryptography utilities with abbreviated alias for enhanced readability\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\nfrom \n  KeyDerivationOperation kdfOperation, \n  DataFlow::Node configuredMode,\n  DataFlow::Node secureCounterMode\nwhere\n  // Establish reference to the secure CounterMode from cryptography API\n  secureCounterMode = API::moduleImport(\"cryptography\")\n                      .getMember(\"hazmat\")\n                      .getMember(\"primitives\")\n                      .getMember(\"kdf\")\n                      .getMember(\"kbkdf\")\n                      .getMember(\"Mode\")\n                      .getMember(\"CounterMode\")\n                      .asSource() and\n  // Determine if the KDF operation necessitates mode configuration\n  kdfOperation.requiresMode() and\n  // Retrieve the actual mode configuration from the KDF operation\n  configuredMode = kdfOperation.getModeSrc() and\n  // Confirm that the configured mode differs from the secure CounterMode\n  not configuredMode = secureCounterMode\nselect \n  kdfOperation, \n  \"Key derivation function is not configured with CounterMode. Current Mode Setting: $@\", \n  configuredMode,\n  configuredMode.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/all-asymmetric-encryption-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别代码中使用非对称加密算法的所有位置。这些算法在量子计算时代可能变得不安全，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 非对称加密算法检测\n * @description 识别代码中使用非对称加密算法的所有位置。这些算法在量子计算时代可能变得不安全，\n *               本查询旨在标记所有通过受支持库执行非对称加密或密钥交换操作的代码位置，\n *               以评估代码的量子就绪状态。\n * @kind 问题\n * @id py/quantum-readiness/cbom/all-asymmetric-encryption-algorithms\n * @problem.severity 错误\n * @tags cbom\n *       密码学\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 检测所有非对称加密算法实例并提取算法名称\nfrom AsymmetricEncryptionAlgorithm cryptoOperation, string algorithmName\nwhere algorithmName = cryptoOperation.getEncryptionName()\n\n// 生成包含算法名称的警告信息\nselect cryptoOperation, \"Detected use of quantum-vulnerable algorithm: \" + algorithmName"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Cumulative deleted lines per source file\n * @description Calculates the total number of lines removed from each source file across the entire commit history.\n_______________ // 补全条件\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\n// Identify source modules and their corresponding accumulated line deletion metrics\nfrom Module sourceModule, int deletedLinesCount\nwhere\n  // Ensure the module has valid code metrics available for analysis\n  exists(sourceModule.getMetrics().getNumberOfLinesOfCode()) and\n  // Calculate the aggregate count of lines removed across all relevant commits\n  deletedLinesCount = \n    sum(Commit commitEntry, int linesDeletedInCommit |\n      // Retrieve the number of lines deleted in the latest commit affecting this file\n      linesDeletedInCommit = commitEntry.getRecentDeletionsForFile(sourceModule.getFile()) and\n      // Filter out commits that represent artificial or insignificant modifications\n      not artificialChange(commitEntry)\n    |\n      linesDeletedInCommit\n    )\nselect sourceModule, deletedLinesCount order by deletedLinesCount desc",
    "output": "* @kind treemap"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use iteration count at least 100k to prevent brute force attacks\n * @description Identifies key derivation functions with insufficient iteration counts.\n * \n * Detects KDF operations using iteration counts below 10000 or when the iteration count\n * cannot be statically determined from the code.\n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import standard Python analysis framework\nimport python\n_______________ // 补全条件\nimport experimental.cryptography.Concepts\n// Import utility functions for cryptographic analysis\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Query body: Identify vulnerable key derivation operations\nfrom KeyDerivationOperation kdfOperation, string warningMessage, DataFlow::Node iterationSource\nwhere\n  // Filter for KDF operations requiring iteration parameters\n  kdfOperation.requiresIteration() and\n  // Identify the source of iteration count configuration\n  iterationSource = kdfOperation.getIterationSizeSrc() and\n  (\n    // Case 1: Explicit integer literal with insufficient value\n    exists(iterationSource.asExpr().(IntegerLiteral).getValue()) and\n    iterationSource.asExpr().(IntegerLiteral).getValue() < 10000 and\n    warningMessage = \"Iteration count is too low. \"\n    or\n    // Case 2: Non-statically determinable iteration count\n    not exists(iterationSource.asExpr().(IntegerLiteral).getValue()) and\n    warningMessage = \"Iteration count is not a statically verifiable size. \"\n  )\nselect \n  // Output format: operation, warning message with iteration config reference, and the config expression\n  kdfOperation, warningMessage + \"Iteration count must be a minimum of 10000. Iteration Config: $@\",\n  iterationSource.asExpr(), iterationSource.asExpr().toString()",
    "output": "// Import cryptographic concepts for key derivation analysis"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/implicit-string-concatenation-in-list]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects string literals that are implicitly concatenated within a list,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Implicit string concatenation in a list\n * @description Detects string literals that are implicitly concatenated within a list,\n *              which may indicate a missing comma and reduce code clarity.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-665\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/implicit-string-concatenation-in-list\n */\n\nimport python\n\n/**\n * Determines if an expression represents a string constant value,\n * accounting for both direct literals and implicitly concatenated strings.\n * This includes recursive binary operations between string constants.\n */\npredicate isStringConstant(Expr strExpr) {\n  // Base case: Direct string literal\n  strExpr instanceof StringLiteral\n  // Recursive case: Binary operation combining string constants\n  or \n  exists(BinaryExpr binOp | \n    binOp = strExpr and \n    isStringConstant(binOp.getLeft()) and \n    isStringConstant(binOp.getRight())\n  )\n}\n\nfrom StringLiteral strLit\nwhere\n  // Condition 1: Identify non-parenthesized strings with implicit concatenation\n  exists(strLit.getAnImplicitlyConcatenatedPart()) and\n  not strLit.isParenthesized() and\n  \n  // Condition 2: Verify presence in a list containing other string constants\n  exists(List containerList, Expr adjacentStr |\n    // Current string is part of the list\n    containerList.getAnElt() = strLit and\n    // Another string constant exists in the same list\n    containerList.getAnElt() = adjacentStr and\n    adjacentStr != strLit and\n    isStringConstant(adjacentStr)\n  )\nselect strLit, \"Implicit string concatenation. Maybe missing a comma?\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The use of '\\b' to represent a backspace character within regular expressions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Backspace escape in regular expression\n * @description The use of '\\b' to represent a backspace character within regular expressions\n *              can lead to confusion, as it is commonly interpreted as a word boundary.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int escapePos\nwhere\n  // Identify a backslash character used for escaping at the given position\n  regexPattern.escapingChar(escapePos) and\n  // Check if the character immediately following the backslash is 'b'\n  regexPattern.getChar(escapePos + 1) = \"b\" and\n  // Determine if this escape sequence is located inside a character set\n  exists(int setStart, int setEnd | \n    // Find a character set that contains the escape sequence\n    regexPattern.charSet(setStart, setEnd) and\n    // Ensure the escape position is within the boundaries of the character set\n    setStart < escapePos and \n    setEnd > escapePos\n  )\nselect regexPattern, \"Backspace escape in regular expression at offset \" + escapePos + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies functions with names starting with an uppercase letter, which can reduce code readability.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python\n\n// Predicate to determine if a function name begins with an uppercase letter\npredicate hasUppercaseInitial(Function func) {\n  exists(string initialChar |\n    initialChar = func.getName().prefix(1) and  // Extract the first character of the function name\n    initialChar = initialChar.toUpperCase()  // Verify the initial character is uppercase\n  )\n}\n\n// Query to identify functions violating naming conventions\nfrom Function func\nwhere\n  func.inSource() and  // Ensure the function is defined in source code\n  hasUppercaseInitial(func) and  // Function name starts with uppercase letter\n  not exists(Function otherFunc |\n    otherFunc != func and  // Exclude other functions with same name\n    otherFunc.getLocation().getFile() = func.getLocation().getFile() and  // Located in same file\n    hasUppercaseInitial(otherFunc)  // Also has uppercase initial\n  )\nselect func, \"Function names should start in lowercase.\"  // Report violation with recommendation",
    "output": "* @name Misnamed function"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-data-to-external-api]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies when untrusted data from external sources is passed to external APIs",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted Data in External API Calls\n * @description Identifies when untrusted data from external sources is passed to external APIs\n *              without proper sanitization, which may result in security vulnerabilities.\n * @id py/untrusted-data-to-external-api\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 7.8\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport ExternalAPIs\nimport UntrustedDataToExternalApiFlow::PathGraph\n\nfrom\n  UntrustedDataToExternalApiFlow::PathNode taintedSource,  // Origin of untrusted data flow\n  UntrustedDataToExternalApiFlow::PathNode apiSink,         // Termination at API call site\n  ExternalApiUsedWithUntrustedData riskyApiCall            // External API consuming tainted data\nwhere\n  // Validate existence of data flow path from source to sink\n  UntrustedDataToExternalApiFlow::flowPath(taintedSource, apiSink)\n  and\n  // Verify sink node corresponds to the API's parameter receiving untrusted input\n  apiSink.getNode() = riskyApiCall.getUntrustedDataNode()\nselect\n  // Preserve original output structure with enhanced variable references\n  apiSink.getNode(), taintedSource, apiSink,\n  \"Call to \" + riskyApiCall.toString() + \" with untrusted data from $@.\", taintedSource.getNode(),\n  taintedSource.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unused exception object\n * @description Identifies code locations where exception instances are created\n *              but never utilized, potentially indicating programming errors\n *              or redundant code segments.\n_______________ // 补全条件\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unused-exception-object\n */\n\nimport python  // 导入Python库，用于分析Python代码\n\n// 查找创建了异常实例但没有使用的代码位置\nfrom Call exceptionInstanceCreation\nwhere\n  // 验证调用是创建一个异常类的实例\n  exists(ClassValue exceptionType | \n    exceptionInstanceCreation.getFunc().pointsTo(exceptionType) and\n    // 确保该类继承自Exception基类\n    exceptionType.getASuperType() = ClassValue::exception()\n  ) and\n  // 检查异常对象仅作为独立表达式语句存在，未被使用\n  exists(ExprStmt standaloneStatement | \n    standaloneStatement.getValue() = exceptionInstanceCreation\n  )\nselect exceptionInstanceCreation, \"Exception object created but not used. Consider raising the exception or removing this statement.\"",
    "output": "* @kind problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-complex-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This rule identifies Python classes containing `__del__` methods with high cyclomatic complexity.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly complex `__del__` method\n * @description This rule identifies Python classes containing `__del__` methods with high cyclomatic complexity.\n *              The `__del__` method in Python is invoked during object destruction, a process that\n *              can occur unpredictably or may be skipped entirely in certain scenarios.\n *              Methods with high complexity in `__del__` can cause performance issues and\n *              erratic behavior during garbage collection cycles. Best practices suggest\n *              maintaining minimal complexity in these special methods.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python\n\nfrom FunctionValue destructorMethod\nwhere\n  exists(ClassValue ownerClass |\n    // Verify the method is the __del__ method of a class\n    ownerClass.declaredAttribute(\"__del__\") = destructorMethod\n  ) and\n  // Check if the method's cyclomatic complexity exceeds the threshold of 3\n  destructorMethod.getScope().getMetrics().getCyclomaticComplexity() > 3\nselect destructorMethod, \"Overly complex '__del__' method.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-block-mode-iv-or-nonce]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies vulnerable initialization vectors/nonces in block cipher modes.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak block mode IV or nonce\n * @description Identifies vulnerable initialization vectors/nonces in block cipher modes.\n *              Flags IVs/nonces not generated via cryptographically secure methods (os.urandom).\n *\n *            NOTE: \n *              1. Simplified approach: Any IV/nonce not from os.urandom is flagged\n *              2. Special cases:\n *                 - GCM mode: Requires specific nonce handling (covered in separate query)\n *                 - Fernet: Explicitly excluded (uses os.urandom internally)\n *              3. Functions inferring mode/IV may trigger false positives (user suppression required)\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify block cipher operations with insecure IV/nonce handling\nfrom BlockMode cipherOperation, string alertMsg, DataFlow::Node vulnerableNode\nwhere\n  // Exclude Fernet (handles IV generation internally)\n  not cipherOperation instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet\n  and (\n    // Case 1: Missing IV/Nonce initialization\n    not cipherOperation.hasIVorNonce()\n    and vulnerableNode = cipherOperation\n    and alertMsg = \"Block mode is missing IV/Nonce initialization\"\n    or\n    // Case 2: Non-os.urandom IV/Nonce source\n    cipherOperation.hasIVorNonce()\n    and not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = cipherOperation.getIVorNonce()\n    and vulnerableNode = cipherOperation.getIVorNonce()\n    and alertMsg = \"Block mode uses non-cryptographic IV/Nonce source: $@\"\n  )\nselect cipherOperation, alertMsg, vulnerableNode, vulnerableNode.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Result of integer division may be truncated\n * @description Detects division operations where both operands are integers,\n *              potentially causing truncation in Python 2.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// Identify division expressions with integer operands that may truncate results\nfrom BinaryExpr divisionExpr, ControlFlowNode leftOperand, ControlFlowNode rightOperand\nwhere\n  // Only relevant in Python 2 (true division was implemented in later versions)\n  major_version() = 2 and\n  exists(BinaryExprNode binaryNode, Value leftValue, Value rightValue |\n    // Verify division operator\n    binaryNode = divisionExpr.getAFlowNode() and\n    binaryNode.getNode().getOp() instanceof Div and\n    \n    // Analyze left operand\n    binaryNode.getLeft().pointsTo(leftValue, leftOperand) and\n    leftValue.getClass() = ClassValue::int_() and\n    \n    // Analyze right operand\n    binaryNode.getRight().pointsTo(rightValue, rightOperand) and\n    rightValue.getClass() = ClassValue::int_() and\n    \n    // Exclude cases where division yields no remainder\n    not leftValue.(NumericValue).getIntValue() % rightValue.(NumericValue).getIntValue() = 0 and\n    \n    // Exclude modules using future division imports\n    not binaryNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // Exclude explicit integer conversions of the result\n    not exists(CallNode intConversion |\n      intConversion = ClassValue::int_().getACall() and\n_______________ // 补全条件\n    )\n  )\nselect divisionExpr, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftOperand, \"left\", rightOperand, \"right\"",
    "output": "intConversion.getAnArg() = binaryNode"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode\n * @description Identifies symmetric encryption operations using weak, obsolete, or unapproved block modes\n * @id py/weak-block-mode\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Select encryption operations and corresponding warning messages\nfrom CryptographicArtifact encryptionOperation, string warningMessage\nwhere\n  // Filter out false positives from cryptography/hazmat paths\n  // (e.g., ECB usage inside keywrap operations)\n  not encryptionOperation.asExpr()\n      .getLocation()\n      .getFile()\n_______________ // 补全条件\n      .toString()\n      .matches(\"%cryptography/hazmat/%\") and\n  (\n    // Case 1: Check for weak block modes\n    encryptionOperation instanceof BlockMode and\n    // ECB mode is only permitted in KeyWrapOperations\n    (encryptionOperation.(BlockMode).getBlockModeName() = \"ECB\" implies \n      not encryptionOperation instanceof KeyWrapOperation) and\n    exists(string blockModeName | blockModeName = encryptionOperation.(BlockMode).getBlockModeName() |\n      // Only CBC, CTS, and XTS modes are approved\n      // Ref: Microsoft.Security.Cryptography.10002\n      not blockModeName = [\"CBC\", \"CTS\", \"XTS\"] and\n      // Generate appropriate warning message based on the block mode\n      if blockModeName = unknownAlgorithm()\n      then warningMessage = \"Use of unrecognized block mode algorithm.\"\n      else\n        if blockModeName in [\"GCM\", \"CCM\"]\n        then\n          warningMessage =\n            \"Use of block mode algorithm \" + blockModeName +\n              \" requires special crypto board approval/review.\"\n        else warningMessage = \"Use of unapproved block mode algorithm or API \" + blockModeName + \".\"\n    )\n    or\n    // Case 2: Check for ciphers without specified block mode\n    encryptionOperation instanceof SymmetricCipher and\n    not encryptionOperation.(SymmetricCipher).hasBlockMode() and\n    warningMessage = \"Cipher has unspecified block mode algorithm.\"\n  )\nselect encryptionOperation, warningMessage",
    "output": ".getAbsolutePath()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Redundant comparison\n * @description Identifies comparisons with predetermined outcomes due to prior conditional checks.\n * @kind problem\n * @tags useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/redundant-comparison\n */\n\nimport python\nimport semmle.python.Comparisons\n\n/*\n * Determines if an expression contains chained comparison operators\n * (e.g., 'a < b < c' instead of simple binary comparisons).\n */\nprivate predicate hasChainedComparisons(Expr expression) {\n  // Check for expressions with multiple comparison operators\n  exists(expression.(Compare).getOp(1))\n  or\n  // Recursively examine operands of unary expressions\n  hasChainedComparisons(expression.(UnaryExpr).getOperand())\n}\n_______________ // 补全条件\n/**\n * Identifies redundant comparisons where a stricter condition\n * already governs the execution path.\n */\nprivate predicate isRedundantComparison(Comparison comparisonExpr, ComparisonControlBlock controlBlock, boolean outcome) {\n  // Verify the control block enforces a stricter condition\n  controlBlock.impliesThat(comparisonExpr.getBasicBlock(), comparisonExpr, outcome) and\n  // Exclude chained comparisons due to incomplete flow analysis\n  not hasChainedComparisons(controlBlock.getTest().getNode())\n}\n\nprivate predicate findRedundantComparison(AstNode currentNode, AstNode priorNode, boolean outcome) {\n  // Locate redundant comparisons through control flow analysis\n  exists(Comparison comparisonExpr, ConditionBlock conditionBlock |\n    comparisonExpr.getNode() = currentNode and\n    conditionBlock.getLastNode().getNode() = priorNode and\n    isRedundantComparison(comparisonExpr, conditionBlock, outcome)\n  )\n}\n\nfrom Expr currentTest, Expr priorTest, boolean evalResult\nwhere\n  // Identify redundant tests while excluding nested redundant tests\n  findRedundantComparison(currentTest, priorTest, evalResult) and \n  not findRedundantComparison(currentTest.getAChildNode+(), priorTest, _)\nselect currentTest, \"Test is always \" + evalResult + \", due to $@.\", priorTest, \"this condition\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/old-style-octal-literal]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects octal literals using the old-style notation (leading zero without '0o' prefix) which can be misinterpreted as decimal numbers. This query flags such literals while excluding common cases like '00' and file permission representations.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Confusing octal literal\n * @description Detects octal literals using the old-style notation (leading zero without '0o' prefix) which can be misinterpreted as decimal numbers. This query flags such literals while excluding common cases like '00' and file permission representations.\n * @kind problem\n * @tags readability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/old-style-octal-literal\n */\n\nimport python\n\n/**\n * Determines if an integer literal employs the outdated octal format (starting with zero but lacking the '0o' prefix).\n * These literals are problematic as they resemble decimal numbers but actually represent octal values.\n * The check excludes \"00\" and literals that typically represent file permissions (with lengths of 4, 5, or 7 characters).\n */\npredicate employs_legacy_octal_format(IntegerLiteral legacyOctalLiteral) {\n  exists(string literalText | \n    literalText = legacyOctalLiteral.getText() and\n    // Check basic octal format: starts with '0' and has valid octal digits\n    literalText.charAt(0) = \"0\" and\n    literalText.length() > 1 and\n    literalText.charAt(1) in [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\"] and\n    // Exclude special cases that are not actually confusing\n    not (literalText = \"00\" or literalText.length() in [4, 5, 7])\n  )\n}\n\n// Find all integer literals that use the ambiguous legacy octal notation\nfrom IntegerLiteral legacyOctalLiteral\nwhere employs_legacy_octal_format(legacyOctalLiteral)\nselect legacyOctalLiteral, \"Confusing octal literal, use 0o\" + legacyOctalLiteral.getText().suffix(1) + \" instead.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/elliptic-curve-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Discovers and catalogs elliptic curve cryptographic algorithm implementations",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Elliptic Curve Cryptography Implementation Detection\n * @description Discovers and catalogs elliptic curve cryptographic algorithm implementations\n *              within various Python cryptographic libraries\n * @kind problem\n * @id py/quantum-readiness/cbom/elliptic-curve-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import necessary Python language modules for code analysis\nimport python\n// Import experimental cryptographic framework with algorithm definitions\nimport experimental.cryptography.Concepts\n\n// Main query logic to identify elliptic curve cryptographic implementations\nfrom EllipticCurveAlgorithm ellipticCurveImpl\n// Generate formatted output with algorithm details\nselect ellipticCurveImpl,\n  // Construct detailed algorithm information string\n  \"Algorithm: \" + ellipticCurveImpl.getCurveName() + \n  // Append key size information to the result\n  \" | Key Size (bits): \" + ellipticCurveImpl.getCurveBitSize().toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Csv Injection\n * @description Detects potential CSV injection vulnerabilities where untrusted user input\n *              is written to CSV files without proper sanitization, allowing malicious\n *              formulas or commands to be executed when the CSV is opened in spreadsheet software\n * @kind path-problem\n * @problem.severity error\n * @id py/csv-injection\n * @tags security\n *       experimental\n *       external/cwe/cwe-1236\n */\n\n// Import necessary Python analysis libraries for code parsing and evaluation\nimport python\n\n// Import the path graph representation for CSV injection data flow tracking\nimport CsvInjectionFlow::PathGraph\n_______________ // 补全条件\n// Import data flow analysis framework to trace information movement through the program\nimport semmle.python.dataflow.new.DataFlow\n\n// Import experimental CSV injection detection utilities and configurations\nimport experimental.semmle.python.security.injection.CsvInjection\n\n// Define the entry and exit points of the data flow we're interested in\nfrom CsvInjectionFlow::PathNode untrustedSource, CsvInjectionFlow::PathNode csvSink\nwhere CsvInjectionFlow::flowPath(untrustedSource, csvSink)\n\n// Report the vulnerability with source and sink information\nselect \n  csvSink.getNode(), \n  untrustedSource, \n  csvSink, \n  \"Csv injection might include code from $@.\", \n  untrustedSource.getNode(),\n  \"this user input\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Quantifies the total number of lines deleted per file throughout the entire commit history stored in the database.\n * @kind treemap\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\n// Analyze source code files and calculate cumulative deletion metrics across their entire version history\nfrom Module sourceFile, int cumulativeDeletions\nwhere\n  // Calculate the sum of all deleted lines for each file across its commit history\n  exists(int deletionCount |\n    deletionCount = \n      sum(Commit versionCommit, int deletedLines |\n        // Retrieve deletion metrics from commits that modified the file\n        deletedLines = versionCommit.getRecentDeletionsForFile(sourceFile.getFile()) and\n        // Filter out commits that represent non-functional changes (e.g., automated refactoring operations)\n        not artificialChange(versionCommit)\n      |\n        deletedLines\n      ) and\n    cumulativeDeletions = deletionCount\n  ) and\n  // Verify that the file has valid code metrics available for analysis\n  exists(sourceFile.getMetrics().getNumberOfLinesOfCode())\nselect sourceFile, cumulativeDeletions order by cumulativeDeletions desc",
    "output": "* @name File Deletion Analysis"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 计算边际增加的指向关系事实、指向关系的总大小以及这两者相对于上下文深度的比例。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n_______________ // 补全条件\nint depth(ControlFlowNode f, Object value, ClassObject cls) {\n  // 存在一个指向上下文ctx，使得在ctx中f指向value且cls为指定类对象，并且结果为ctx的深度。\n  exists(PointsToContext ctx |\n    PointsTo::points_to(f, ctx, value, cls, _) and\n    result = ctx.getDepth()\n  )\n}\n\n// 定义一个函数，用于计算给定控制流节点、对象值和类对象的最浅深度。\nint shallowest(ControlFlowNode f, Object value, ClassObject cls) {\n  // 结果为所有可能深度中的最小值。\n  result = min(int x | x = depth(f, value, cls))\n}\n\n// 从total_facts（总事实数）、total_size（总大小）、depth（深度）和efficiency（效率）中选择数据。\nfrom int total_facts, int total_size, int depth, float efficiency\nwhere\n  // 计算总事实数，即满足条件的(f, value, cls)的数量，其中depth为shallowest(f, value, cls)。\n  total_facts =\n    strictcount(ControlFlowNode f, Object value, ClassObject cls | depth = shallowest(f, value, cls)) and\n  // 计算总大小，即满足条件的(f, value, cls, ctx, orig)的数量，其中在ctx中f指向value且cls为指定类对象，并且depth为ctx的深度。\n  total_size =\n    strictcount(ControlFlowNode f, Object value, ClassObject cls, PointsToContext ctx,\n      ControlFlowNode orig |\n      PointsTo::points_to(f, ctx, value, cls, orig) and\n      depth = ctx.getDepth()\n    ) and\n  // 计算效率，即总事实数占总大小的比例乘以100。\n  efficiency = 100.0 * total_facts / total_size\nselect depth, total_facts, total_size, efficiency",
    "output": "// 定义一个函数，用于计算给定控制流节点、对象值和类对象的上下文深度。"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测超类中定义的属性是否遮蔽了子类中同名的方法定义",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 检测超类中定义的属性是否遮蔽了子类中同名的方法定义\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 查询逻辑说明：\n * 本查询识别子类中被超类属性遮蔽的方法，具体条件包括：\n * 1. 存在继承关系的两个类（子类和超类）\n * 2. 子类声明了一个方法\n * 3. 超类在其__init__方法中定义了与子类方法同名的属性\n * 4. 超类本身没有定义同名的方法\n * 这种情况会导致子类方法被超类属性遮蔽，可能引起意外的行为\n */\n\nimport python\n\n// 判断子类方法是否被超类属性遮蔽的谓词\npredicate shadowed_by_super_class(\n  ClassObject derivedClass, ClassObject baseClass, Assign attributeAssignment, FunctionObject overriddenMethod\n) {\n  // 确立继承关系：derivedClass 继承自 baseClass\n  derivedClass.getASuperType() = baseClass and\n  \n  // 确认子类声明了目标方法\n  derivedClass.declaredAttribute(_) = overriddenMethod and\n  \n  // 验证超类在__init__中定义了同名属性\n  exists(FunctionObject initializer |\n    // 超类包含__init__方法\n    baseClass.declaredAttribute(\"__init__\") = initializer and\n    \n    // 检查__init__方法中的属性赋值\n    exists(Attribute assignedAttribute |\n      // 属性赋值语句的目标是self成员\n      assignedAttribute = attributeAssignment.getATarget() and\n      // 确保赋值对象是self实例\n      assignedAttribute.getObject().(Name).getId() = \"self\" and\n      // 属性名与子类方法名相同\n      assignedAttribute.getName() = overriddenMethod.getName() and\n      // 赋值发生在超类__init__作用域内\n      attributeAssignment.getScope() = initializer.getOrigin().(FunctionExpr).getInnerScope()\n    )\n  ) and\n  \n  // 排除超类已定义同名方法的情况\n  not baseClass.hasAttribute(overriddenMethod.getName())\n}\n\n// 查询被遮蔽的方法及其相关元素\nfrom ClassObject derivedClass, ClassObject baseClass, Assign attributeAssignment, FunctionObject overriddenMethod\n// 应用遮蔽检测谓词\nwhere shadowed_by_super_class(derivedClass, baseClass, attributeAssignment, overriddenMethod)\n// 输出结果：方法位置、描述信息、属性赋值位置和类型标签\nselect overriddenMethod.getOrigin(),\n  \"Method '\" + overriddenMethod.getName() + \"' is shadowed by $@ in superclass '\" + baseClass.getName() + \n    \"'.\", attributeAssignment, \"attribute definition\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/non-iterable-in-for-loop]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies for-loops that attempt to iterate over non-iterable objects,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-iterable used in for loop\n * @description Identifies for-loops that attempt to iterate over non-iterable objects,\n *              which would result in runtime TypeErrors during execution.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/non-iterable-in-for-loop\n */\n\nimport python\n\n// Identify for-loops that iterate over non-iterable objects\nfrom For loopStmt, \n     ControlFlowNode iterationNode, \n     Value iteratedObject, \n     ClassValue objectClass, \n     ControlFlowNode sourceNode\nwhere\n  // Connect the for-loop with its iteration expression\n  loopStmt.getIter().getAFlowNode() = iterationNode and\n  \n  // Track the value being iterated and its origin\n  iterationNode.pointsTo(_, iteratedObject, sourceNode) and\n  \n  // Determine the class of the iterated value\n  iteratedObject.getClass() = objectClass and\n  \n  // Ensure the class is not iterable\n  not objectClass.isIterable() and\n  \n  // Exclude false positives\n  not objectClass.failedInference(_) and  // Valid type inference\n  not iteratedObject = Value::named(\"None\") and  // Not None values\n  not objectClass.isDescriptorType()  // Not descriptor types\nselect loopStmt, \n       \"This for-loop may attempt to iterate over a $@ of class $@.\", \n       sourceNode, \n       \"non-iterable instance\", \n       objectClass, \n       objectClass.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 错误的类实例化参数数量\n * @description 在调用类的 `__init__` 方法时，使用过多或过少的参数将导致运行时出现 TypeError。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call invocation, ClassValue classObj, string errorMsg, string requirementPrefix, int paramLimit, FunctionValue initializer\nwhere\n  (\n    // 检测参数数量超过限制的情况\n    too_many_args(invocation, classObj, paramLimit) and\n_______________ // 补全条件\n    requirementPrefix = \"no more than \"\n    or\n    // 检测参数数量不足的情况\n    too_few_args(invocation, classObj, paramLimit) and\n    errorMsg = \"too few arguments\" and\n    requirementPrefix = \"no fewer than \"\n  ) and\n  // 获取目标类的构造函数或初始化方法\n  initializer = get_function_or_initializer(classObj)\nselect invocation, \"Call to $@ with \" + errorMsg + \"; should be \" + requirementPrefix + paramLimit.toString() + \".\", initializer,\n  // 返回调用节点、错误描述以及初始化方法的完整名称\n  initializer.getQualifiedName()",
    "output": "errorMsg = \"too many arguments\" and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-default-protocol]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Leaving the SSL/TLS version unspecified may result in an insecure",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Default version of SSL/TLS may be insecure\n * @description Leaving the SSL/TLS version unspecified may result in an insecure\n *              default protocol being used.\n * @id py/insecure-default-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\n// This query detects deprecated SSL socket creation methods that don't specify protocols.\n// When ssl.wrap_socket is called without ssl_version parameter, insecure defaults may be used.\n// Related secure context configuration issues are covered by py/insecure-protocol dataflow query.\nimport python\nimport semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode insecureSocketCall\nwhere\n  // Identify deprecated ssl.wrap_socket method calls\n  insecureSocketCall = API::moduleImport(\"ssl\").getMember(\"wrap_socket\").getACall()\n  // Verify ssl_version parameter is missing\n  and not exists(insecureSocketCall.getArgByName(\"ssl_version\"))\nselect insecureSocketCall,\n  \"Call to deprecated method ssl.wrap_socket does not specify a protocol, which may result in an insecure default being used.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-of-mutable-attribute]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects direct imports of mutable attribute values, which prevents local observation of global state changes.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Importing value of mutable attribute\n * @description Detects direct imports of mutable attribute values, which prevents local observation of global state changes.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity high\n * @precision medium\n * @id py/import-of-mutable-attribute\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom ImportMember importedAttr, ModuleValue srcModule, AttrNode writeNode, string attributeName\nwhere\n  // Ensure attribute name consistency between import and mutation operations\n  importedAttr.getName() = attributeName and\n  // Verify module equivalence through import aliasing mechanism\n  exists(string moduleName |\n    moduleName = importedAttr.getModule().(ImportExpr).getImportedModuleName() and\n    srcModule.importedAs(moduleName)\n  ) and\n  // Mutation must be a write operation targeting the source module\n  writeNode.isStore() and\n  writeNode.getObject(attributeName).pointsTo(srcModule) and\n  // Validate scope constraints: module-level import and function-level mutation\n  not importedAttr.getScope() instanceof Function and\n  writeNode.getScope() instanceof Function and\n  // Ensure import and mutation occur in different modules\n  not importedAttr.getEnclosingModule() = writeNode.getScope().getEnclosingModule() and\n  // Exclude mutations within test code scope\n  not writeNode.getScope().getScope*() instanceof TestScope\nselect importedAttr,\n  \"Importing the value of '\" + attributeName +\n    \"' from $@ means that any change made to $@ will be not be observed locally.\", srcModule,\n  \"module \" + srcModule.getName(), writeNode, srcModule.getName() + \".\" + writeNode.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/duplicated-lines-in-files  // 查询标识符：py/duplicated-lines-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates and quantifies the number of duplicate lines",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated  // 此查询已弃用，建议使用更新的替代方案\n * @name File line duplication analysis  // 查询名称：文件行重复分析\n * @description Calculates and quantifies the number of duplicate lines \n *              present in each file across the entire codebase, \n *              encompassing code, comments, and whitespace.  // 功能描述：计算并量化整个代码库中每个文件存在的重复行数量，包括代码、注释和空白\n * @kind treemap  // 可视化类型：树状图展示\n * @treemap.warnOn highValues  // 高值警告设置\n * @metricType file  // 指标类型：文件级别度量\n * @metricAggregate avg sum max  // 聚合方式：平均值、总和、最大值\n * @tags testability  // 适用标签：可测试性相关\n * @id py/duplicated-lines-in-files  // 查询标识符：py/duplicated-lines-in-files\n */\n\nimport python  // 导入Python代码分析模块\n\n// 主查询逻辑：识别包含重复行的源文件并计算重复行数\nfrom File sourceFile, int repetitionCount\nwhere \n  // 查询条件占位符（保留原始查询结构）\n  none()\n// 输出结果：源文件及其对应的重复行计数，按重复数量降序排列\nselect sourceFile, repetitionCount order by repetitionCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python Class Display Strings\n * @description Discovers and lists all Python classes throughout the codebase, \n *              displaying their names as formatted strings for easy identification.\n * @kind display-string\n * @id py/lgtm/class-display-strings\n * @metricType reftype\n */\n\nimport python\n\n// Retrieve all Python class definitions present in the analyzed codebase\nfrom Class pythonClass\n\n_______________ // 补全条件\nselect pythonClass, pythonClass.getName()",
    "output": "// Present each class entity along with its corresponding name as a display string"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/redundant-else]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects 'for' or 'while' loops with 'else' clauses that are unnecessary because the loop body doesn't contain a 'break' statement.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unnecessary 'else' clause in loop\n * @description Detects 'for' or 'while' loops with 'else' clauses that are unnecessary because the loop body doesn't contain a 'break' statement.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-else\n */\n\nimport python  // Import the Python library for code analysis\n\nfrom Stmt loopWithElse, StmtList bodyContent, StmtList elseContent, string loopKind  // Variables representing loop components\nwhere\n  // Process both for and while loops with else clauses\n  (loopWithElse instanceof For and \n    bodyContent = loopWithElse.(For).getBody() and \n    elseContent = loopWithElse.(For).getOrelse() and \n    loopKind = \"for\"\n  )\n  or\n  (loopWithElse instanceof While and \n    bodyContent = loopWithElse.(While).getBody() and \n    elseContent = loopWithElse.(While).getOrelse() and \n    loopKind = \"while\"\n  )\n  and\n  // Verify no break statements exist in the loop body\n  not exists(Break breakStmt | bodyContent.contains(breakStmt))\nselect loopWithElse,  // Select the problematic loop statement\n  \"This '\" + loopKind + \"' statement has a redundant 'else' as no 'break' is present in the body.\"  // Warning message"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unknown-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别在非对称加密算法中生成密钥时，密钥长度无法在静态分析阶段确定的安全漏洞",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 非对称密钥生成中的未知密钥大小\n * @description 识别在非对称加密算法中生成密钥时，密钥长度无法在静态分析阶段确定的安全漏洞\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 从非对称密钥生成操作中查找密钥大小无法静态确认的实例\nfrom AsymmetricKeyGen asymmetricKeyGeneration, DataFlow::Node keyConfigSource, string cryptoAlgorithmName\nwhere\n  // 提取密钥配置的来源节点\n  keyConfigSource = asymmetricKeyGeneration.getKeyConfigSrc() and\n  // 获取加密算法的名称信息\n  cryptoAlgorithmName = asymmetricKeyGeneration.getAlgorithm().getName() and\n  // 验证密钥生成操作是否缺少静态可验证的密钥大小参数\n  not asymmetricKeyGeneration.hasKeySize(keyConfigSource)\nselect asymmetricKeyGeneration,\n  // 构建包含算法详情和配置源的漏洞报告\n  \"在算法 \" + cryptoAlgorithmName.toString() + \" 的密钥生成过程中，使用了无法静态验证的密钥大小，配置源自 $@\", keyConfigSource, keyConfigSource.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Polynomial regular expression used on uncontrolled data\n * @description Detects regular expressions exhibiting polynomial-time complexity\n *              that could result in denial-of-service vulnerabilities.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @id py/polynomial-redos\n * @tags security\n *       external/cwe/cwe-1333\n *       external/cwe/cwe-730\n *       external/cwe/cwe-400\n */\n\n// Import core Python analysis framework\nimport python\n// Import specialized module for regex pattern backtracking vulnerability detection\nimport semmle.python.security.dataflow.PolynomialReDoSQuery\n// Import path visualization utilities for security data flow analysis\nimport PolynomialReDoSFlow::PathGraph\n\nfrom\n  // Define source and destination nodes for tracking untrusted input flow\n  PolynomialReDoSFlow::PathNode untrustedDataSource, PolynomialReDoSFlow::PathNode regexUsagePoint,\n  // Identify the specific sink where regex is applied to uncontrolled input\n  Sink regexSinkLocation,\n  // Extract the regex pattern component causing polynomial-time backtracking\n_______________ // 补全条件\nwhere\n  // Establish complete data flow path from untrusted source to regex usage\n  PolynomialReDoSFlow::flowPath(untrustedDataSource, regexUsagePoint) and\n  // Connect the destination node to the actual regex sink implementation\n  regexSinkLocation = regexUsagePoint.getNode() and\n  // Extract the problematic regex pattern term from the vulnerable sink\n  problematicRegexPattern = regexSinkLocation.getABacktrackingTerm()\n// Disabled filter: exclude URL sources with end-of-line matching regex\n//   not (\n//     untrustedDataSource.getNode().(Source).getKind() = \"url\" and\n//     problematicRegexPattern.isAtEndLine()\n//   )\nselect\n  // Output visualization components: vulnerable regex location and data flow endpoints\n  regexSinkLocation.getHighlight(), untrustedDataSource, regexUsagePoint,\n  // Generate comprehensive vulnerability description with contextual information\n  \"This $@ that uses a $@ may suffer from performance degradation \" + \n  \"when processing strings \" + problematicRegexPattern.getPrefixMessage() +\n  \"containing multiple repetitions of '\" + problematicRegexPattern.getPumpString() + \"'.\",\n  // Reference the problematic regex pattern for highlighting purposes\n  problematicRegexPattern, \"regular expression\",\n  // Reference the untrusted data source for tracking purposes\n  untrustedDataSource.getNode(), \"user-provided value\"",
    "output": "PolynomialBackTrackingTerm problematicRegexPattern"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'super' in old style class\n * @description 旧式类中不支持使用 super() 调用继承的方法。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * 谓词：识别在旧式类中发生的 super() 调用\n * @param superCall - 被检查的 super() 调用表达式\n */\npredicate isSuperCallInOldStyleClass(Call superCall) {\n  // 确认调用发生在某个函数内，且该函数定义在旧式类中\n  exists(Function containerFunction, ClassObject containerClass |\n    // super() 调用位于函数作用域内\n    superCall.getScope() = containerFunction and\n    // 函数定义在类的作用域内\n    containerFunction.getScope() = containerClass.getPyClass() and\n    // 类类型推断成功\n    not containerClass.failedInference() and\n    // 确认是旧式类（非新式类）\n    not containerClass.isNewStyle() and\n    // 调用的函数名为 \"super\"\n_______________ // 补全条件\n  )\n}\n\n// 检索所有在旧式类中无效的 super() 调用\nfrom Call problematicSuperCall\n// 筛选条件：确认调用发生在旧式类中\nwhere isSuperCallInOldStyleClass(problematicSuperCall)\n// 输出问题调用及错误描述\nselect problematicSuperCall, \"'super()' will not work in old-style classes.\"",
    "output": "superCall.getFunc().(Name).getId() = \"super\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-randomness]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects security vulnerabilities where cryptographically weak",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insecure randomness\n * @description Detects security vulnerabilities where cryptographically weak \n *              pseudo-random number generators are used to generate security-sensitive values,\n *              potentially allowing attackers to predict generated values.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// Import core Python library for code analysis support\nimport python\n\n// Import experimental security module specialized in detecting insecure random number generation patterns\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Import data flow analysis framework to enable tracking of data flow paths\nimport semmle.python.dataflow.new.DataFlow\n\n// Import path graph module for representing data flow path graphs\nimport InsecureRandomness::Flow::PathGraph\n\n// Query definition: Identify data flow paths involving insecure random number generation\nfrom InsecureRandomness::Flow::PathNode sourceNode, InsecureRandomness::Flow::PathNode sinkNode\n// Define the data flow condition between source and sink nodes\nwhere InsecureRandomness::Flow::flowPath(sourceNode, sinkNode)\n// Select results with the sink node, source node, path information, and descriptive message\nselect sinkNode.getNode(), sourceNode, sinkNode, \"Cryptographically insecure $@ in a security context.\",\n  sourceNode.getNode(), \"random value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-parameters-without-default-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This analysis identifies Python functions with parameters lacking default values.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of parameters without defaults\n * @description This analysis identifies Python functions with parameters lacking default values.\n *              Functions with many non-default parameters tend to be more complex and harder to test,\n *              as they require more arguments to be explicitly provided during invocation.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // Import Python module for static code analysis capabilities\n\n// Define the analysis scope: examine all Python functions to evaluate their parameter complexity\nfrom FunctionMetrics targetFunction\n// Calculate the count of parameters without default values for each function\nwhere exists(targetFunction.getNumberOfParametersWithoutDefault())\n// Select the target function and its count of non-default parameters for complexity assessment\nselect targetFunction, \n       targetFunction.getNumberOfParametersWithoutDefault() as nonDefaultParamCount \n// Order results by non-default parameter count in descending order to highlight most complex functions first\norder by nonDefaultParamCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/paramiko-missing-host-key-validation]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using Paramiko with unknown host key acceptance enables man-in-the-middle attacks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Accepting unknown SSH host keys when using Paramiko\n * @description Using Paramiko with unknown host key acceptance enables man-in-the-middle attacks.\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/paramiko-missing-host-key-validation\n * @tags security\n *       external/cwe/cwe-295\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Identifies insecure Paramiko policy implementations\nprivate API::Node insecureParamikoPolicy(string policyName) {\n  // Matches either 'AutoAddPolicy' or 'WarningPolicy' from paramiko.client or paramiko module\n  policyName in [\"AutoAddPolicy\", \"WarningPolicy\"] and\n  (\n    result = API::moduleImport(\"paramiko\").getMember(\"client\").getMember(policyName)\n    or\n    result = API::moduleImport(\"paramiko\").getMember(policyName)\n  )\n}\n\n// Retrieves Paramiko SSHClient instance nodes\nprivate API::Node getParamikoSshClient() {\n  // Captures both paramiko.client.SSHClient and paramiko.SSHClient instantiations\n  result = API::moduleImport(\"paramiko\").getMember(\"client\").getMember(\"SSHClient\").getReturn()\n  or\n  result = API::moduleImport(\"paramiko\").getMember(\"SSHClient\").getReturn()\n}\n\n// Detects vulnerable host key policy configurations\nfrom DataFlow::CallCfgNode methodCall, DataFlow::Node policyArg, string policyName\nwhere\n  // Reference: http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.set_missing_host_key_policy\n  // Locates set_missing_host_key_policy calls on Paramiko SSHClient instances\n  methodCall = getParamikoSshClient().getMember(\"set_missing_host_key_policy\").getACall() and\n  // Identifies policy arguments (both positional and keyword)\n  policyArg in [methodCall.getArg(0), methodCall.getArgByName(\"policy\")] and\n  // Checks if argument references an insecure policy\n  (\n    policyArg = insecureParamikoPolicy(policyName).getAValueReachableFromSource() or\n    policyArg = insecureParamikoPolicy(policyName).getReturn().getAValueReachableFromSource()\n  )\nselect methodCall, \"Configuring host key policy to \" + policyName + \" creates security vulnerability.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Timing attack against secret\n * @description Identifies verification routines that do not use constant-time comparison\n *              when validating secret values, which could allow timing attacks to\n *              extract sensitive information through response time differences.\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/possible-timing-attack-sensitive-info\n * @tags security\n *       external/cwe/cwe-208\n *       experimental\n */\n\n// Import Python language support\nimport python\n// Import data flow analysis framework\nimport semmle.python.dataflow.new.DataFlow\n// Import taint tracking capabilities\nimport semmle.python.dataflow.new.TaintTracking\n// Import timing attack security analysis module\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * Configuration module for tracking sensitive data flows to vulnerable comparison operations.\n * This module defines the sources (sensitive data) and sinks (non-constant-time comparisons)\n * for detecting potential timing attack vulnerabilities.\n */\nprivate module SensitiveDataTimingAnalysisConfig implements DataFlow::ConfigSig {\n  // Define sensitive data sources as flow origins\n  predicate isSource(DataFlow::Node sourceNode) { sourceNode instanceof SecretSource }\n\n  // Identify non-constant-time comparisons as vulnerable targets\n  predicate isSink(DataFlow::Node targetNode) { targetNode instanceof NonConstantTimeComparisonSink }\n\n  // Enable comprehensive differential analysis\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Establish global taint tracking using the defined configuration\nmodule SensitiveDataTimingFlow = TaintTracking::Global<SensitiveDataTimingAnalysisConfig>;\n\n_______________ // 补全条件\nimport SensitiveDataTimingFlow::PathGraph\n\n// Main query to detect timing attack vulnerability paths\nfrom\n  SensitiveDataTimingFlow::PathNode secretSourceNode,    // Origin point of sensitive data\n  SensitiveDataTimingFlow::PathNode vulnerabilityTargetNode  // Vulnerable comparison operation\nwhere \n  // Verify that a data flow path exists from source to sink\n  SensitiveDataTimingFlow::flowPath(secretSourceNode, vulnerabilityTargetNode)\nselect \n  vulnerabilityTargetNode.getNode(),  // Location of the vulnerable comparison\n  secretSourceNode,                   // Starting point of the vulnerability path\n  vulnerabilityTargetNode,            // Ending point of the vulnerability path\n  \"Timing attack against $@ validation.\", \n  secretSourceNode.getNode(),         // Annotated source of sensitive data\n  \"client-supplied token\"             // Description of the sensitive data source",
    "output": "// Import path graph for visualization of data flow paths"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Detects and examines alert suppression mechanisms in Python code, with emphasis on noqa-style comments.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import utilities for alert suppression handling\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import utilities for Python comment analysis\nprivate import semmle.python.Comment as P\n\n/**\n * Represents a Python AST node with precise location tracking.\n * This class extends the base AstNode class to provide detailed location information.\n */\nclass CodeNode instanceof P::AstNode {\n  /**\n   * Determines the precise location of this AST node in source code.\n   * @param sourceFile The path to the source file containing the node\n   * @param startLine The starting line number of the node\n   * @param startCol The starting column number of the node\n   * @param endLine The ending line number of the node\n   * @param endCol The ending column number of the node\n   */\n  predicate hasLocationInfo(\n    string sourceFile, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(sourceFile, startLine, startCol, endLine, endCol)\n  }\n\n  /**\n   * Provides a string representation of this AST node.\n   * @return A descriptive string representing the AST node\n   */\n  string toString() { result = super.toString() }\n}\n\n/**\n * Represents a Python single-line comment with enhanced location tracking.\n * This class extends the base Comment class to provide precise location information.\n */\nclass LineComment instanceof P::Comment {\n  /**\n   * Determines the precise location of this comment in source code.\n   * @param sourceFile The path to the source file containing the comment\n   * @param startLine The starting line number of the comment\n   * @param startCol The starting column number of the comment\n   * @param endLine The ending line number of the comment\n   * @param endCol The ending column number of the comment\n   */\n  predicate hasLocationInfo(\n    string sourceFile, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(sourceFile, startLine, startCol, endLine, endCol)\n  }\n\n  /**\n   * Retrieves the raw text content of this comment.\n_______________ // 补全条件\n   */\n  string getText() { result = super.getContents() }\n\n  /**\n   * Provides a string representation of this comment.\n   * @return A descriptive string representing the comment\n   */\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships using AS template for CodeNode and LineComment\nimport AS::Make<CodeNode, LineComment>\n\n/**\n * Represents a noqa-style suppression comment recognized by Python linters.\n * This class handles comments that suppress warnings using the noqa convention.\n */\nclass NoqaStyleSuppression extends SuppressionComment instanceof LineComment {\n  /**\n   * Matches comments containing the noqa keyword (case-insensitive), \n   * optionally followed by additional content.\n   */\n  NoqaStyleSuppression() {\n    LineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  /**\n   * Gets the annotation identifier for this suppression.\n   * @return The string \"lgtm\" as the annotation identifier\n   */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /**\n   * Determines the scope of the suppression: the entire line of the comment, \n   * starting from column 1.\n   * @param sourceFile Path to the source file\n   * @param startLine Starting line number of the suppression\n   * @param startCol Starting column number (always 1)\n   * @param endLine Ending line number\n   * @param endCol Ending column number\n   */\n  override predicate covers(\n    string sourceFile, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Enforce line-start position and match comment location\n    startCol = 1 and\n    this.hasLocationInfo(sourceFile, startLine, _, endLine, endCol)\n  }\n}",
    "output": "* @return The comment's text content as a string"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/reflective-xss]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects vulnerabilities where user input is directly",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Reflected server-side cross-site scripting\n * @description Detects vulnerabilities where user input is directly\n *              written to web pages without sanitization, enabling\n *              cross-site scripting attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @sub-severity high\n * @precision high\n * @id py/reflective-xss\n * @tags security\n *       external/cwe/cwe-079\n *       external/cwe/cwe-116\n */\n\n// Core Python analysis libraries\nimport python\n// Specialized module for detecting reflected XSS vulnerabilities\nimport semmle.python.security.dataflow.ReflectedXssQuery\n// Path visualization component for data flow analysis\nimport ReflectedXssFlow::PathGraph\n\n// Identify vulnerable data flow paths from user input to output\nfrom ReflectedXssFlow::PathNode origin, ReflectedXssFlow::PathNode destination\n// Verify existence of complete data flow path between origin and destination\nwhere ReflectedXssFlow::flowPath(origin, destination)\n// Report vulnerability with path details and contextual information\nselect destination.getNode(), origin, destination, \"Cross-site scripting vulnerability due to a $@.\",\n  origin.getNode(), \"user-provided value\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Mostly duplicate module\n * @description Detects files that are exact duplicates of another file. Consider merging duplicate files to improve maintainability.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-file\n */\n\nimport python\n\n// Identify duplicate modules by comparing file contents\nfrom Module sourceModule, Module targetModule, string alertMessage\n_______________ // 补全条件\n  // Ensure we're not comparing a module to itself\n  sourceModule != targetModule and\n  // Compare file contents for exact duplication\n  sourceModule.getFile().getContents() = targetModule.getFile().getContents() and\n  // Prevent duplicate reporting by enforcing consistent ordering\n  sourceModule.getFile().getAbsolutePath() < targetModule.getFile().getAbsolutePath() and\n  // Generate descriptive alert message\n  alertMessage = \"This file is an exact duplicate of \" + targetModule.getName()\nselect sourceModule, alertMessage, targetModule, targetModule.getName()",
    "output": "where"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 指向关系深度分布分析：\n * 本查询分析代码库中指向关系的深度分布特征，量化各深度层级的效率指标：\n * - 边际计数：在最小深度层级出现的唯一指向关系数量\n * - 总计数：特定深度层级上的所有指向关系总数\n * - 效率百分比：边际计数占总计数的比例，反映该深度层级的效率\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 计算控制流节点在特定对象和类对象下的上下文深度\nint getContextDepth(ControlFlowNode cfNode, Object pointedToObj, ClassObject classObj) {\n  // 当存在指向上下文使节点在该上下文中指向对象并关联类对象时，返回上下文深度\n  exists(PointsToContext ctx |\n    PointsTo::points_to(cfNode, ctx, pointedToObj, classObj, _) and\n    result = ctx.getDepth()\n  )\n}\n\n// 获取控制流节点在特定对象和类对象下的最小上下文深度\nint getMinContextDepth(ControlFlowNode cfNode, Object pointedToObj, ClassObject classObj) {\n  // 返回所有可能深度的最小值\n  result = min(int depth | depth = getContextDepth(cfNode, pointedToObj, classObj))\n}\n\n// 分析各深度层级的指向关系特征\nfrom int marginalCount, int totalCount, int depthLevel, float efficiencyPercentage\nwhere\n  // 计算边际计数：最小深度等于当前层级的唯一指向关系数量\n  marginalCount = strictcount(ControlFlowNode cfNode, Object pointedToObj, ClassObject classObj |\n    depthLevel = getMinContextDepth(cfNode, pointedToObj, classObj)\n  ) and\n  // 计算总计数：深度等于当前层级的所有指向关系数量\n  totalCount = strictcount(\n    ControlFlowNode cfNode,\n_______________ // 补全条件\n    ClassObject classObj,\n    PointsToContext ctx,\n    ControlFlowNode originNode\n  |\n    PointsTo::points_to(cfNode, ctx, pointedToObj, classObj, originNode) and\n    depthLevel = ctx.getDepth()\n  ) and\n  // 计算效率百分比：边际计数占总计数的百分比（避免除以零）\n  totalCount > 0 and\n  efficiencyPercentage = 100.0 * marginalCount / totalCount\n// 输出结果：深度层级、边际计数、总计数和效率百分比\nselect depthLevel, marginalCount, totalCount, efficiencyPercentage",
    "output": "Object pointedToObj,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Comparison of identical values\n * @description Detects comparisons where both operands are the same value, \n *              which often indicates unclear programming intent or potential bugs.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n_______________ // 补全条件\n */\n\nimport python\nimport Expressions.RedundantComparison\n\n/**\n * Filters out redundant comparisons that are either constant expressions\n * or potentially missing 'self' parameter, as these cases often represent\n * intentional behavior or require special handling.\n */\npredicate isValidRedundantComparison(RedundantComparison expr) {\n  not expr.isConstant() and\n  not expr.maybeMissingSelf()\n}\n\nfrom RedundantComparison redundantComparison\nwhere isValidRedundantComparison(redundantComparison)\nselect redundantComparison, \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\"",
    "output": "* @id py/comparison-of-identical-expressions"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Import shadowed by loop variable\n * @description A loop variable shadows an import.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/import-shadowed-loop-variable\n */\n\n_______________ // 补全条件\nimport python\n\n/**\n * 判断给定变量是否遮蔽了一个导入的模块名\n * @param loopVar - 待检查的变量\n * @returns 当变量遮蔽了导入的模块名时返回true\n */\npredicate shadowsImport(Variable loopVar) {\n  // 查找所有可能被遮蔽的导入语句和对应的名称\n  exists(Import importStmt, Name shadowedName |\n    // 确保shadowedName是导入语句中的别名\n    shadowedName = importStmt.getAName().getAsname() and\n    // 检查变量标识符与导入名称是否相同\n    shadowedName.getId() = loopVar.getId() and\n    // 验证导入的作用域包含变量的作用域\n    importStmt.getScope() = loopVar.getScope().getScope*()\n  )\n}\n\n// 查找所有被循环变量遮蔽的导入\nfrom Variable loopVar, Name varDefinition\n// 应用过滤条件：\n// 1. 变量遮蔽了导入\n// 2. 名称定义了该变量\n// 3. 该定义是for循环的目标\nwhere shadowsImport(loopVar) and\n      varDefinition.defines(loopVar) and\n      exists(For forLoop | varDefinition = forLoop.getTarget())\n// 生成警告信息，指出循环变量遮蔽了导入\nselect varDefinition, \"Loop variable '\" + loopVar.getId() + \"' shadows an import.\"",
    "output": "// 导入Python分析库，用于代码静态分析"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/classic-model/block-cipher-mode]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies cryptographic operations utilizing block cipher modes",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Block cipher mode detection\n * @description Identifies cryptographic operations utilizing block cipher modes\n *              in supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/block-cipher-mode\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport semmle.python.Concepts\n\n// Define cryptographic operation and its associated block cipher mode\nfrom Cryptography::CryptographicOperation cryptOperation, string modeIdentifier\nwhere \n  // Extract block cipher mode from the cryptographic operation\n  modeIdentifier = cryptOperation.getBlockMode()\nselect \n  cryptOperation, \n  \"Cryptographic operation uses block cipher mode: \" + modeIdentifier"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Ratio of jump-to-definitions computed",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Ratio of jump-to-definitions computed\n * 计算跳转到定义的比例\n */\n\nimport python\nimport analysis.DefinitionTracking\n\n// 定义一个谓词函数，用于判断表达式是否希望有定义\npredicate want_to_have_definition(Expr e) {\n  /* not builtin object like len, tuple, etc. */\n  // 排除内建对象如len、tuple等\n  not exists(Value builtin | e.pointsTo(builtin) and builtin.isBuiltin()) and\n  (\n    e instanceof Name and e.(Name).getCtx() instanceof Load\n    // 如果表达式是名称并且其上下文是加载操作\n    or\n    e instanceof Attribute and e.(Attribute).getCtx() instanceof Load\n    // 如果表达式是属性并且其上下文是加载操作\n    or\n    e instanceof ImportMember\n    // 如果表达式是导入成员\n    or\n    e instanceof ImportExpr\n    // 如果表达式是导入表达式\n  )\n}\n\nfrom int yes, int no\nwhere\n  yes = count(Expr e | want_to_have_definition(e) and exists(getUniqueDefinition(e))) and\n  // 统计有唯一定义的表达式数量\n  no = count(Expr e | want_to_have_definition(e) and not exists(getUniqueDefinition(e)))\n  // 统计没有唯一定义的表达式数量\nselect yes, no, yes * 100 / (yes + no) + \"%\"\n  // 选择有定义和无定义的数量以及它们的比例"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python File Code Line Analysis\n * @kind treemap\n * @description Analyzes and counts the effective lines of code in Python source files,\n *              excluding lines with only docstrings, comments, or whitespace.\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n_______________ // 补全条件\n */\n\nimport python\n\n// This query processes Python source files to calculate their effective code line counts,\n// filtering out documentation, comments, and whitespace-only lines\nfrom Module sourceFile, int effectiveLineCount\nwhere \n  // For each Python module, compute the count of lines containing actual code\n  effectiveLineCount = sourceFile.getMetrics().getNumberOfLinesOfCode()\n// Output the source files along with their respective code line counts,\n// ordered from highest to lowest line count\nselect sourceFile, effectiveLineCount order by effectiveLineCount desc",
    "output": "* @id py/lines-of-code-in-files"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-not-enclosing-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies super() invocations where the first parameter",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incorrect super() first argument\n * @description Identifies super() invocations where the first parameter\n *              does not correspond to the enclosing class name. This\n *              mismatch can result in improper initialization within\n *              object inheritance hierarchies.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-687\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/super-not-enclosing-class\n */\n\nimport python  // 导入Python库，用于分析Python代码\nimport semmle.python.dataflow.new.DataFlow  // 导入数据流分析模块\nimport semmle.python.ApiGraphs  // 导入API图模块\n\n// 定义查询的输入变量：super()调用节点和封闭类的名称\nfrom DataFlow::CallCfgNode superCallNode, string enclosingClassName\nwhere\n  // 确认是对super内置函数的调用\n  superCallNode = API::builtin(\"super\").getACall()\n  and\n  // 获取包含当前调用的类名\n  enclosingClassName = superCallNode.getScope().getScope().(Class).getName()\n  and\n  // 验证第一个参数存在且与类名不匹配\n  exists(DataFlow::Node firstArgument |\n    firstArgument = superCallNode.getArg(0)\n    and\n    firstArgument.getALocalSource().asExpr().(Name).getId() != enclosingClassName\n  )\n// 选择问题节点并生成报告消息\nselect superCallNode.getNode(), \"First argument to super() should be \" + enclosingClassName + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Number of co-committed files\n * @description Measures the average number of files modified together with files in a module\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Main analysis: Calculate co-modification patterns for modules with valid metrics\nfrom Module moduleOfInterest\nwhere exists(moduleOfInterest.getMetrics().getNumberOfLinesOfCode())\nselect moduleOfInterest,\n  // Compute average co-modified files per commit affecting this module\n  avg(Commit revision, int coModifiedCount |\n    // Identify commits that modify files in the target module\n    revision.getAnAffectedFile() = moduleOfInterest.getFile() and \n    // Calculate additional files modified in the same commit (excluding the module file)\n    coModifiedCount = count(revision.getAnAffectedFile()) - 1\n  |\n    coModifiedCount\n  )",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Direct imports per file\n * @description Measures the quantity of modules directly imported by each Python file.\n *              Elevated counts may signal excessive coupling, potentially undermining modularity and maintainability.\n_______________ // 补全条件\n * @id py/direct-imports-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg max\n * @tags modularity\n *       maintainability\n */\n\n// Leverage Python analysis framework for AST traversal and module inspection\nimport python\n\n// For each Python module, determine the count of its direct module dependencies\nfrom ModuleValue sourceModule, int importQuantity\nwhere \n  // Calculate the number of unique modules directly imported by the analyzed source module\n  importQuantity = count(ModuleValue dependency | \n                       dependency = sourceModule.getAnImportedModule())\n// Emit the source module's scope along with its corresponding direct import count\nselect sourceModule.getScope(), importQuantity",
    "output": "* @kind treemap"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-complex-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies `__del__` methods that have high cyclomatic complexity.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly complex `__del__` method\n * @description Identifies `__del__` methods that have high cyclomatic complexity.\n *              These special methods can be invoked at unpredictable times during\n *              garbage collection and should be implemented with minimal complexity\n *              to avoid potential issues with resource management and performance.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python\n\nfrom FunctionValue delFunction\nwhere\n  exists(ClassValue ownerClass |\n    // Confirm the method is the __del__ destructor of a class\n    ownerClass.declaredAttribute(\"__del__\") = delFunction and\n    // Evaluate method complexity against threshold\n    delFunction.getScope().getMetrics().getCyclomaticComplexity() > 3\n  )\nselect delFunction, \"Overly complex '__del__' method.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/property-in-old-style-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies properties defined in old-style classes, which are incompatible",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Property in old-style class\n * @description Identifies properties defined in old-style classes, which are incompatible \n *              with Python's property descriptor mechanism from version 2.1 onwards.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/property-in-old-style-class\n */\n\nimport python\n\n// 查找所有属性对象和类对象的组合\nfrom PropertyObject propertyObj, ClassObject classObj\n// 筛选条件1：属性被类声明\nwhere classObj.declaredAttribute(_) = propertyObj\n  // 筛选条件2：类的推断没有失败\n  and not classObj.failedInference()\n  // 筛选条件3：类是旧式类（非新式类）\n  and not classObj.isNewStyle()\n// 输出属性对象和相应的警告信息\nselect propertyObj,\n  \"Property \" + propertyObj.getName() + \" will not work properly, as class \" + classObj.getName() +\n    \" is an old-style class.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type metrics\n * @description Provides counts of different kinds of type annotations in Python code, \n *              including parameters, return types, and annotated assignments.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents a built-in type in Python\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr annotatedFunc) { exists(annotatedFunc.getReturns()) } or\n  TAnnotatedParameter(Parameter annotatedParam) { exists(annotatedParam.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign annotatedAssign) { exists(annotatedAssign.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr funcExpr;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(funcExpr) }\n  override Expr getAnnotation() { result = funcExpr.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter paramVar;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(paramVar) }\n  override Expr getAnnotation() { result = paramVar.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assignStmt;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assignStmt) }\n  override Expr getAnnotation() { result = assignStmt.getAnnotation() }\n}\n\n/** Holds if `expr` is a forward declaration (string literal) of a type */\npredicate is_forward_declaration(Expr expr) { expr instanceof StringLiteral }\n\n/** Holds if `expr` is a type that may be difficult to analyze */\npredicate is_complex_type(Expr expr) {\n  (expr instanceof Subscript and not is_optional_type(expr)) or\n  expr instanceof Tuple or\n  expr instanceof List\n}\n\n/** Holds if `expr` is a type of the form `Optional[...]` */\npredicate is_optional_type(Subscript expr) { expr.getObject().(Name).getId() = \"Optional\" }\n\n/** Holds if `expr` is a simple type (non-built-in identifier or attribute chain) */\npredicate is_simple_type(Expr expr) {\n  (expr instanceof Name and not expr instanceof BuiltinType) or\n  is_simple_type(expr.(Attribute).getObject())\n}\n\n/** Holds if `expr` is a built-in type */\npredicate is_builtin_type(Expr expr) { expr instanceof BuiltinType }\n\n// Computes type annotation metrics for different annotation categories\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  (\n    category = \"Parameter annotation\"\n    and\n    totalCount = count(AnnotatedParameter param)\n_______________ // 补全条件\n    builtinCount = count(AnnotatedParameter param | is_builtin_type(param.getAnnotation()))\n    and\n    forwardDeclCount = count(AnnotatedParameter param | is_forward_declaration(param.getAnnotation()))\n    and\n    simpleTypeCount = count(AnnotatedParameter param | is_simple_type(param.getAnnotation()))\n    and\n    complexTypeCount = count(AnnotatedParameter param | is_complex_type(param.getAnnotation()))\n    and\n    optionalTypeCount = count(AnnotatedParameter param | is_optional_type(param.getAnnotation()))\n  )\n  or\n  // Return type annotation metrics\n  (\n    category = \"Return type annotation\"\n    and\n    totalCount = count(AnnotatedFunction func)\n    and\n    builtinCount = count(AnnotatedFunction func | is_builtin_type(func.getAnnotation()))\n    and\n    forwardDeclCount = count(AnnotatedFunction func | is_forward_declaration(func.getAnnotation()))\n    and\n    simpleTypeCount = count(AnnotatedFunction func | is_simple_type(func.getAnnotation()))\n    and\n    complexTypeCount = count(AnnotatedFunction func | is_complex_type(func.getAnnotation()))\n    and\n    optionalTypeCount = count(AnnotatedFunction func | is_optional_type(func.getAnnotation()))\n  )\n  or\n  // Annotated assignment metrics\n  (\n    category = \"Annotated assignment\"\n    and\n    totalCount = count(AnnotatedAssignment assign)\n    and\n    builtinCount = count(AnnotatedAssignment assign | is_builtin_type(assign.getAnnotation()))\n    and\n    forwardDeclCount = count(AnnotatedAssignment assign | is_forward_declaration(assign.getAnnotation()))\n    and\n    simpleTypeCount = count(AnnotatedAssignment assign | is_simple_type(assign.getAnnotation()))\n    and\n    complexTypeCount = count(AnnotatedAssignment assign | is_complex_type(assign.getAnnotation()))\n    and\n    optionalTypeCount = count(AnnotatedAssignment assign | is_optional_type(assign.getAnnotation()))\n  )\n}\n\n// Query execution and output\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount",
    "output": "and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Symmetric Encryption Padding Detection\n * @description Identifies symmetric encryption algorithms that use padding schemes,\n *              which may be vulnerable to certain cryptographic attacks\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricPadding symmetricPadding\nselect symmetricPadding, \"Algorithm using padding scheme: \" + symmetricPadding.getPaddingName()",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Overly complex `__del__` method\n * @description The `__del__` method may be called at arbitrary times, perhaps never called at all, and should be kept simple.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n_______________ // 补全条件\nimport python\n\nfrom FunctionValue deleteMethod\nwhere\n  exists(ClassValue ownerClass | \n    ownerClass.declaredAttribute(\"__del__\") = deleteMethod\n  ) and\n  deleteMethod.getScope().getMetrics().getCyclomaticComplexity() > 3\nselect deleteMethod, \"Overly complex '__del__' method.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name NotImplemented is not an Exception\n * @description Detects raise statements using 'NotImplemented' instead of 'NotImplementedError', \n *              which causes runtime type errors since NotImplemented is not an exception type.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Import Python analysis framework\nimport python\n\n// Import specialized module for NotImplemented misuse detection\nimport Exceptions.NotImplemented\n\n// Identify problematic expressions in raise contexts\nfrom Expr problematicExpr\n// Filter expressions where NotImplemented is incorrectly used in raise statements\nwhere use_of_not_implemented_in_raise(_, problematicExpr)\n_______________ // 补全条件\nselect problematicExpr, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\"",
    "output": "// Report findings with corrective guidance"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Identifies cryptographic implementations that employ elliptic curve algorithms \n *              which are either unrecognized or classified as cryptographically weak, \n *              potentially leading to security vulnerabilities.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm cryptoOperation, string alertMessage, string curveIdentifier\nwhere\n  // Retrieve the specific curve identifier from the cryptographic operation\n  curveIdentifier = cryptoOperation.getCurveName() and\n  (\n    // Case 1: Handle unrecognized curve algorithms\n    curveIdentifier = unknownAlgorithm() and\n    alertMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: Handle recognized but cryptographically weak curve algorithms\n    curveIdentifier != unknownAlgorithm() and\n    not curveIdentifier =\n      [\n_______________ // 补全条件\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    alertMessage = \"Use of weak curve algorithm \" + curveIdentifier + \".\"\n  )\nselect cryptoOperation, alertMessage",
    "output": "\"SECP256R1\", \"PRIME256V1\", // P-256 curves"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Overwriting attribute in super-class or sub-class\n * @description Identifies assignments to instance attributes that overwrite attributes \n *              previously defined in subclass or superclass initializers.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision medium\n * @id py/overwritten-inherited-attribute\n */\n\nimport python\n\n// Represents statements that invoke the __init__ method\nclass InitializerCallStatement extends ExprStmt {\n  InitializerCallStatement() {\n    exists(Call initializerCall, Attribute initializerAttribute | \n      initializerCall = this.getValue() and \n      initializerAttribute = initializerCall.getFunc() and\n      initializerAttribute.getName() = \"__init__\"\n    )\n  }\n}\n\n// Detects statements that assign values to instance attributes via self\npredicate assignsToInstanceAttribute(Stmt statement, string attributeName) {\n  exists(Attribute instanceAttribute, Name selfVariable |\n    selfVariable = instanceAttribute.getObject() and\n    statement.contains(instanceAttribute) and\n    selfVariable.getId() = \"self\" and\n    instanceAttribute.getCtx() instanceof Store and\n    instanceAttribute.getName() = attributeName\n  )\n}\n\n// Determines the temporal relationship between attribute assignments and initializer calls\npredicate hasAssignmentRelativeToInitializerCall(\n  Function initializerMethod, \n  AssignStmt attributeAssignment, \n  string relationshipType\n) {\n  attributeAssignment.getScope() = initializerMethod and\n  assignsToInstanceAttribute(attributeAssignment, _) and\n  exists(Stmt container | \n    container.contains(attributeAssignment) or container = attributeAssignment\n  |\n    (\n      // Case 1: Assignment occurs after superclass __init__ invocation\n      exists(int assignmentPosition, int initializerPosition, InitializerCallStatement initializerCall | \n        initializerCall.getScope() = initializerMethod and\n        assignmentPosition > initializerPosition and\n        container = initializerMethod.getStmt(assignmentPosition) and\n        initializerCall = initializerMethod.getStmt(initializerPosition) and\n        relationshipType = \"superclass\"\n      )\n      or\n      // Case 2: Assignment occurs before subclass __init__ invocation\n      exists(int assignmentPosition, int initializerPosition, InitializerCallStatement initializerCall | \n        initializerCall.getScope() = initializerMethod and\n        assignmentPosition < initializerPosition and\n        container = initializerMethod.getStmt(assignmentPosition) and\n        initializerCall = initializerMethod.getStmt(initializerPosition) and\n        relationshipType = \"subclass\"\n      )\n    )\n  )\n}\n\n// Verifies if two functions assign to the same attribute name\npredicate assignToCommonAttribute(\n  Stmt firstStatement, \n  Stmt secondStatement, \n  Function firstFunction, \n  Function secondFunction\n) {\n  exists(string sharedAttributeName |\n    firstStatement.getScope() = firstFunction and\n    secondStatement.getScope() = secondFunction and\n    assignsToInstanceAttribute(firstStatement, sharedAttributeName) and\n    assignsToInstanceAttribute(secondStatement, sharedAttributeName)\n  )\n}\n\n// Identifies instances where attributes are overwritten in inheritance hierarchies\npredicate isInheritanceAttributeOverwrite(\n  AssignStmt overwritingAssignment, \n  AssignStmt overwrittenAssignment, \n  string attributeName, \n  string inheritanceRelationship, \n  string qualifiedClassName\n) {\n  exists(\n    FunctionObject superclassInitializer, \n    FunctionObject subclassInitializer, \n    ClassObject superclass, \n    ClassObject subclass,\n    AssignStmt subclassAttributeAssignment,\n    AssignStmt superclassAttributeAssignment\n  |\n    // Establish assignment relationships based on inheritance direction\n    (\n      inheritanceRelationship = \"superclass\" and\n      qualifiedClassName = superclass.getName() and\n      overwritingAssignment = subclassAttributeAssignment and\n      overwrittenAssignment = superclassAttributeAssignment\n      or\n      inheritanceRelationship = \"subclass\" and\n      qualifiedClassName = subclass.getName() and\n      overwritingAssignment = superclassAttributeAssignment and\n      overwrittenAssignment = subclassAttributeAssignment\n    ) and\n    // Exclude class attributes unless they are explicitly overwritten in subclass\n    (not exists(superclass.declaredAttribute(attributeName)) or inheritanceRelationship = \"subclass\") and\n    // Confirm both classes have initializer methods\n    superclass.declaredAttribute(\"__init__\") = superclassInitializer and\n    subclass.declaredAttribute(\"__init__\") = subclassInitializer and\n    // Validate inheritance relationship\n    superclass = subclass.getASuperType() and\n    // Check temporal relationship between assignment and initializer calls\n    hasAssignmentRelativeToInitializerCall(subclassInitializer.getFunction(), subclassAttributeAssignment, inheritanceRelationship) and\n    // Verify both assignments target the same attribute\n    assignToCommonAttribute(\n      subclassAttributeAssignment, \n      superclassAttributeAssignment, \n      subclassInitializer.getFunction(), \n      superclassInitializer.getFunction()\n    ) and\n    // Ensure the overwritten assignment targets an instance attribute\n    assignsToInstanceAttribute(superclassAttributeAssignment, attributeName)\n  )\n}\n\n// Query results: Report attribute overwrites with contextual information\nfrom string inheritanceRelationship, AssignStmt overwritingAssignment, AssignStmt overwrittenAssignment, string attributeName, string qualifiedClassName\nwhere isInheritanceAttributeOverwrite(overwritingAssignment, overwrittenAssignment, attributeName, inheritanceRelationship, qualifiedClassName)\nselect overwritingAssignment,\n_______________ // 补全条件\n    \" $@.\", overwrittenAssignment, qualifiedClassName",
    "output": "\"Assignment overwrites attribute \" + attributeName + \", which was previously defined in \" + inheritanceRelationship +"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of parameters without defaults\n * @description Identifies and counts parameters in Python functions that do not have default values,\n *              which can indicate higher complexity and reduced testability.\n * @kind treemap\n_______________ // 补全条件\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // 引入Python分析模块，提供对Python代码的静态分析能力\n\n// 从FunctionMetrics类中检索所有Python函数进行分析\nfrom FunctionMetrics analyzedFunction\n// 计算每个函数中无默认值的参数数量，这些参数是调用时必须提供的\nselect analyzedFunction, \n       analyzedFunction.getNumberOfParametersWithoutDefault() as nonDefaultParamCount \n// 按无默认值参数数量降序排序，优先显示复杂度较高的函数\norder by nonDefaultParamCount desc",
    "output": "* @id py/number-of-parameters-without-default-per-function"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Returning tuples with varying lengths\n * @description Identifies functions returning tuples of inconsistent sizes, potentially indicating design flaws.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       quality\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mixed-tuple-returns\n_______________ // 补全条件\n\nimport python\nimport semmle.python.ApiGraphs\n\n/**\n * Verifies if a function returns a tuple with a specific element count.\n * @param function - The analyzed function\n * @param tupleSize - The expected tuple length\n * @param tupleExpr - The tuple expression being returned\n */\npredicate returns_tuple_of_size(Function function, int tupleSize, Tuple tupleExpr) {\n  exists(Return returnStmt, DataFlow::Node returnFlowNode |\n    // Confirm the return statement belongs to the target function\n    returnStmt.getScope() = function and\n    // Map return value to data flow node\n    returnFlowNode.asExpr() = returnStmt.getValue() and\n    // Track data flow from tuple source to return node\n    exists(DataFlow::LocalSourceNode tupleSource |\n      tupleSource.asExpr() = tupleExpr and\n      tupleSource.flowsTo(returnFlowNode)\n    )\n  |\n    // Compute tuple element count\n    tupleSize = count(int index | exists(tupleExpr.getElt(index)))\n  )\n}\n\nfrom Function function, int size1, int size2, AstNode tuple1, AstNode tuple2\nwhere\n  // Identify distinct tuple return sizes from same function\n  returns_tuple_of_size(function, size1, tuple1) and\n  returns_tuple_of_size(function, size2, tuple2) and\n  // Ensure size variation exists\n  size1 < size2 and\n  // Exclude functions with explicit return type hints\n  not exists(function.getDefinition().(FunctionExpr).getReturns())\nselect \n  function, \n  function.getQualifiedName() + \" returns $@ and $@.\", \n  tuple1, \"tuple of size \" + size1, \n  tuple2, \"tuple of size \" + size2",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Misnamed function\n * @description Identifies functions with names starting with an uppercase letter, which can reduce code readability.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python\n\n// Define a predicate to determine if a function's name begins with an uppercase letter\npredicate hasUppercaseStart(Function fn) {\n  exists(string initialChar |\n    initialChar = fn.getName().prefix(1) and  // Extract the first character of the function name\n    initialChar = initialChar.toUpperCase()  // Verify if the first character is uppercase\n  )\n}\n\n// Identify functions that match our criteria\nfrom Function candidateFn\nwhere\n  // Ensure the function is present in the source code\n  candidateFn.inSource() and\n_______________ // 补全条件\n  hasUppercaseStart(candidateFn) and\n  // Ensure this is the only function with an uppercase-starting name in its file\n  not exists(Function similarFn |\n    similarFn != candidateFn and  // Exclude other functions with the same name\n    similarFn.getLocation().getFile() = candidateFn.getLocation().getFile() and  // Located in the same file\n    hasUppercaseStart(similarFn)  // And also starts with an uppercase letter\n  )\nselect candidateFn, \"Function names should start in lowercase.\"  // Report these functions with a recommendation",
    "output": "// Function name starts with an uppercase letter"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unused global variable\n * @description Global variable is defined but not used\n * @kind problem\n * @tags efficiency\n *       useless-code\n *       external/cwe/cwe-563\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/unused-global-variable\n */\n\nimport python\nimport Definition\n\n/**\n * 判断模块是否包含一个复杂的 __all__ 定义。\n * 复杂定义为：不是简单的字符串列表，或者列表中的元素不全是字符串字面量。\n * @param m 模块\n * @return 如果模块包含复杂的 __all__ 定义，返回 true；否则返回 false。\n */\npredicate complex_all(Module m) {\n  exists(Assign a, GlobalVariable all |\n    a.defines(all) and a.getScope() = m and all.getId() = \"__all__\"\n  |\n    not a.getValue() instanceof List // 检查 __all__ 是否为简单列表\n    or\n    exists(Expr e | e = a.getValue().(List).getAnElt() | not e instanceof StringLiteral) // 检查列表元素是否全为字符串字面量\n  )\n  or\n  exists(Call c, GlobalVariable all |\n    c.getFunc().(Attribute).getObject() = all.getALoad() and\n    c.getScope() = m and\n    all.getId() = \"__all__\" // 检查是否存在对 __all__ 的调用\n  )\n}\n\n/**\n * 判断名称是否在 forward declaration 中使用。\n * @param used 使用的名称\n * @param mod 模块\n * @return 如果名称在 forward declaration 中使用，返回 true；否则返回 false。\n */\npredicate used_in_forward_declaration(Name used, Module mod) {\n  exists(StringLiteral s, Annotation annotation |\n    s.getS() = used.getId() and\n_______________ // 补全条件\n    annotation.getASubExpression*() = s // 检查名称是否在注解中使用\n  )\n}\n\n/**\n * 判断全局变量是否未使用。\n * @param unused 未使用的名称\n * @param v 全局变量\n * @return 如果全局变量未使用，返回 true；否则返回 false。\n */\npredicate unused_global(Name unused, GlobalVariable v) {\n  not exists(ImportingStmt is | is.contains(unused)) and // 检查名称是否在导入语句中使用\n  forex(DefinitionNode defn | defn.getNode() = unused |\n    not defn.getValue().getNode() instanceof FunctionExpr and // 检查定义节点是否为函数表达式\n    not defn.getValue().getNode() instanceof ClassExpr and // 检查定义节点是否为类表达式\n    not exists(Name u |\n      // 变量的使用\n      u.uses(v)\n    |\n      // 直接可达的使用\n      defn.strictlyReaches(u.getAFlowNode())\n      or\n      // 间接可达的使用\n      defn.getBasicBlock().reachesExit() and u.getScope() != unused.getScope()\n    ) and\n    not unused.getEnclosingModule().getAnExport() = v.getId() and // 检查变量是否被导出\n    not exists(unused.getParentNode().(ClassDef).getDefinedClass().getADecorator()) and // 检查变量是否在类的装饰器中\n    not exists(unused.getParentNode().(FunctionDef).getDefinedFunction().getADecorator()) and // 检查变量是否在函数的装饰器中\n    unused.defines(v) and // 检查名称是否定义了全局变量\n    not name_acceptable_for_unused_variable(v) and // 检查变量名是否可接受为未使用的变量\n    not complex_all(unused.getEnclosingModule()) // 检查模块是否包含复杂的 __all__ 定义\n  ) and\n  not used_in_forward_declaration(unused, unused.getEnclosingModule()) // 检查名称是否在 forward declaration 中使用\n}\n\nfrom Name unused, GlobalVariable v\nwhere\n  unused_global(unused, v) and\n  // 如果未使用的名称是元组的一部分，则检查元组的所有元素是否都未使用。\n  forall(Name el | el = unused.getParentNode().(Tuple).getAnElt() | unused_global(el, _))\nselect unused, \"The global variable '\" + v.getId() + \"' is not used.\" // 选择未使用的全局变量并生成警告信息",
    "output": "s.getEnclosingModule() = mod and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Potential missing 'self' reference in comparison\n * @description Detects comparisons between identical values, which may indicate a missing 'self' reference.\n * @kind problem\n * @tags reliability\n_______________ // 补全条件\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-missing-self\n */\n\nimport python  // 提供Python源代码的静态分析基础功能，包括语法树、类型系统等核心分析能力\nimport Expressions.RedundantComparison  // 专门用于检测冗余比较表达式的分析模块，识别逻辑上可能存在问题的比较操作\n\nfrom RedundantComparison suspiciousSelfComparison  // 从所有冗余比较表达式中筛选出可疑的比较操作实例\nwhere suspiciousSelfComparison.maybeMissingSelf()  // 筛选条件：识别可能缺少'self'引用的比较操作，这类操作通常在类方法中出现，导致比较相同的值\nselect suspiciousSelfComparison, \"Comparison of identical values; may be missing 'self'.\"  // 输出结果：显示可疑的比较操作及其位置，并提供可能缺少'self'引用的提示信息",
    "output": "*       maintainability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of commits\n * @description Number of commits\n * @kind treemap\n * @id py/historical-number-of-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\n// 引入 Python 分析模块，提供 Python 代码分析功能\nimport python\n// 引入外部版本控制系统(VCS)分析模块，支持版本历史数据分析\nimport external.VCS\n_______________ // 补全条件\n// 遍历所有提交记录，排除非人工提交的记录，确保只统计真实的代码变更\nfrom Commit commitRecord\nwhere not artificialChange(commitRecord)\n// 提取提交的修订标识并计数，用于生成提交数量统计的树状图\nselect commitRecord.getRevisionName(), 1",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/azure-storage/unsafe-client-side-encryption-in-use]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using version v1 of Azure Storage client-side encryption is insecure, and may enable an attacker to decrypt encrypted data",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unsafe usage of v1 version of Azure Storage client-side encryption.\n * @description Using version v1 of Azure Storage client-side encryption is insecure, and may enable an attacker to decrypt encrypted data\n * @kind path-problem\n * @tags security\n *       experimental\n *       cryptography\n *       external/cwe/cwe-327\n * @id py/azure-storage/unsafe-client-side-encryption-in-use\n * @problem.severity error\n * @precision medium\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Azure Storage client initialization patterns\nAPI::Node blobServiceClientNode(boolean isDirect) {\n  // Direct BlobServiceClient instantiation\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getReturn()\n  or\n  // BlobServiceClient from connection string\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getMember(\"from_connection_string\")\n        .getReturn()\n}\n\nAPI::CallNode containerClientTransition() {\n  // Transition from BlobServiceClient to ContainerClient\n  result = blobServiceClientNode(_).getMember(\"get_container_client\").getACall()\n  or\n  // Transition from BlobClient to ContainerClient\n  result = blobClientNode(_).getMember(\"_get_container_client\").getACall()\n}\n\nAPI::Node containerClientNode(boolean isDirect) {\n  // ContainerClient obtained through transition\n  isDirect = false and\n  result = containerClientTransition().getReturn()\n  or\n  // Direct ContainerClient instantiation\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getReturn()\n  or\n  // ContainerClient from connection string or URL\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getMember([\"from_connection_string\", \"from_container_url\"])\n        .getReturn()\n}\n\nAPI::CallNode blobClientTransition() {\n  // Transition from BlobServiceClient or ContainerClient to BlobClient\n  result = [blobServiceClientNode(_), containerClientNode(_)]\n        .getMember(\"get_blob_client\")\n        .getACall()\n}\n\nAPI::Node blobClientNode(boolean isDirect) {\n  // BlobClient obtained through transition\n  isDirect = false and\n  result = blobClientTransition().getReturn()\n  or\n  // Direct BlobClient instantiation\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getReturn()\n  or\n  // BlobClient from connection string or URL\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getMember([\"from_connection_string\", \"from_blob_url\"])\n        .getReturn()\n}\n\n// Unified representation of Azure Storage client types\nAPI::Node anyStorageClient(boolean isDirect) {\n  result in [blobServiceClientNode(isDirect), containerClientNode(isDirect), blobClientNode(isDirect)]\n}\n\n// Encryption state definitions\nnewtype TEncryptionFlowState =\n  MkV1EncryptionState() or\n  MkNoEncryptionState()\n\n// Data flow configuration with encryption state tracking\nprivate module EncryptionFlowConfig implements DataFlow::StateConfigSig {\n  class FlowState = TEncryptionFlowState;\n\n  // Source nodes: uninitialized clients (no encryption configured)\n  predicate isSource(DataFlow::Node node, FlowState state) {\n    state = MkNoEncryptionState() and\n    node = anyStorageClient(true).asSource()\n  }\n\n  // Barrier nodes: clients explicitly configured with v2 encryption\n  predicate isBarrier(DataFlow::Node node, FlowState state) {\n    exists(state) and\n    exists(DataFlow::AttrWrite encryptionAttr |\n      node = anyStorageClient(_).getAValueReachableFromSource() and\n      encryptionAttr.accesses(node, \"encryption_version\") and\n      encryptionAttr.getValue().asExpr().(StringLiteral).getText() in [\"'2.0'\", \"2.0\"]\n    )\n    or\n    // Barrier for state transition when encryption is configured\n    isAdditionalFlowStep(_, MkNoEncryptionState(), node, MkV1EncryptionState()) and\n    state = MkNoEncryptionState()\n  }\n\n  // Flow transitions between client objects\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(DataFlow::MethodCallNode transitionCall |\n      transitionCall in [containerClientTransition(), blobClientTransition()] and\n      node1 = transitionCall.getObject() and\n      node2 = transitionCall\n    )\n  }\n\n  // State transition when encryption configuration is applied\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    node1 = node2.(DataFlow::PostUpdateNode).getPreUpdateNode() and\n    state1 = MkNoEncryptionState() and\n    state2 = MkV1EncryptionState() and\n    exists(DataFlow::AttrWrite encryptionAttr |\n      node1 = anyStorageClient(_).getAValueReachableFromSource() and\n      encryptionAttr.accesses(node1, [\"key_encryption_key\", \"key_resolver_function\"])\n    )\n  }\n\n  // Sink nodes: v1 encrypted blob upload operations\n  predicate isSink(DataFlow::Node node, FlowState state) {\n    state = MkV1EncryptionState() and\n    exists(DataFlow::MethodCallNode uploadCall |\n      uploadCall = blobClientNode(_).getMember(\"upload_blob\").getACall() and\n      node = uploadCall.getObject()\n    )\n  }\n\n  // No restrictions on incremental mode\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global data flow analysis with encryption state tracking\nmodule EncryptionDataFlow = DataFlow::GlobalWithState<EncryptionFlowConfig>;\n\nimport EncryptionDataFlow::PathGraph\n\n// Query: Identify unsafe v1 encryption usage paths\nfrom EncryptionDataFlow::PathNode sourceNode, EncryptionDataFlow::PathNode sinkNode\nwhere EncryptionDataFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode, sourceNode, sinkNode, \"Unsafe usage of v1 version of Azure Storage client-side encryption\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Documentation coverage ratio\n * @description Measures the ratio of docstring lines to total lines in Python source files.\n * @kind treemap\n * @id py/doc-string-ratio-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\n// Analyze Python source files to compute documentation coverage metrics\nfrom Module sourceFile, ModuleMetrics fileMetrics\nwhere \n  // Associate metrics with each module and exclude empty files\n  fileMetrics = sourceFile.getMetrics() and \n  fileMetrics.getNumberOfLines() > 0\nselect \n  sourceFile,\n  // Calculate documentation coverage percentage:\n  // (docstring lines / total lines) * 100\n  100.0 * \n    (fileMetrics.getNumberOfLinesOfDocStrings().(float) / \n     fileMetrics.getNumberOfLines().(float)) as documentationCoverage\norder by \n_______________ // 补全条件",
    "output": "documentationCoverage desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of insecure SSL/TLS version\n * @description Identifies deprecated SSL/TLS protocol versions that may expose connections to security vulnerabilities.\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n/* Represents configuration nodes enabling insecure SSL/TLS protocol versions */\nclass InsecureProtocolConfig extends DataFlow::Node {\n  InsecureProtocolConfig() {\n    /* Case 1: Insecure connections with context */\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    /* Case 2: Insecure connections without context */\n    unsafe_connection_creation_without_context(this, _)\n    or\n    /* Case 3: Insecure context creation */\n    unsafe_context_creation(this, _)\n  }\n\n  /* Retrieves the function associated with this configuration */\n  DataFlow::Node getAssociatedFunction() { \n    result = this.(DataFlow::CallCfgNode).getFunction() \n  }\n}\n\n/* Represents nodes that can be named (function calls or attribute references) */\nclass IdentifiableNode extends DataFlow::Node {\n  IdentifiableNode() {\n    /* Case 1: Function from protocol configuration */\n    this = any(InsecureProtocolConfig insecureConfig).getAssociatedFunction()\n    or\n    /* Case 2: Attribute reference chain */\n    this = any(IdentifiableNode attrNode).(DataFlow::AttrRef).getObject()\n  }\n}\n\n/* Constructs fully qualified name for identifiable nodes */\nstring getFullyQualifiedName(IdentifiableNode node) {\n  /* Case 1: Direct function name */\n  result = node.asExpr().(Name).getId()\n  or\n  /* Case 2: Attribute access path */\n  exists(DataFlow::AttrRef attrRefNode | \n    attrRefNode = node and\n    result = getFullyQualifiedName(attrRefNode.getObject()) + \".\" + attrRefNode.getAttributeName()\n  )\n}\n\n/* Generates descriptive label for protocol configuration */\nstring getConfigDescription(InsecureProtocolConfig configNode) {\n  /* Case 1: Function call configuration */\n  exists(DataFlow::CallCfgNode callNode | \n    callNode = configNode and\n    result = \"call to \" + getFullyQualifiedName(callNode.getFunction())\n  )\n  or\n  /* Case 2: Non-call context modification */\n  not configNode instanceof DataFlow::CallCfgNode and\n  not configNode instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n/* Selects appropriate verb based on configuration specificity */\nstring getAppropriateVerb(boolean isExplicit) {\n  isExplicit = true and result = \"specified\"\n  or\n  isExplicit = false and result = \"allowed\"\n}\n\n/* Main query: Detects insecure SSL/TLS protocol usage */\nfrom\n_______________ // 补全条件\n  InsecureProtocolConfig configNode, boolean isExplicit\nwhere\n  /* Case 1: Insecure connection with context */\n  unsafe_connection_creation_with_context(vulnerableNode, protocolVersion, configNode, isExplicit)\n  or\n  /* Case 2: Insecure connection without context */\n  (\n    unsafe_connection_creation_without_context(vulnerableNode, protocolVersion) and\n    configNode = vulnerableNode and\n    isExplicit = true\n  )\n  or\n  /* Case 3: Insecure context creation */\n  (\n    unsafe_context_creation(configNode, protocolVersion) and\n    vulnerableNode = configNode and\n    isExplicit = true\n  )\nselect vulnerableNode,\n  \"Insecure SSL/TLS protocol version \" + protocolVersion + \" \" + getAppropriateVerb(isExplicit) + \" by $@.\",\n  configNode, getConfigDescription(configNode)",
    "output": "DataFlow::Node vulnerableNode, string protocolVersion,"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-complex-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python classes with destructors (`__del__` methods) that exhibit",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly complex `__del__` method\n * @description Identifies Python classes with destructors (`__del__` methods) that exhibit \n *              high cyclomatic complexity. Python's destructor methods are invoked during\n *              object cleanup, which can occur at non-deterministic times or may be skipped\n *              entirely in specific scenarios. Overly complex destructors can cause performance\n *              issues and erratic behavior during garbage collection cycles. Best practices\n *              suggest maintaining minimal complexity in these special methods.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python  // 导入Python分析库，用于代码分析\n\nfrom FunctionValue destructorMethod  // 从FunctionValue类中获取destructorMethod对象\nwhere\n  // 检查是否存在一个拥有该析构方法的类\n  exists(ClassValue containingClass | \n    containingClass.declaredAttribute(\"__del__\") = destructorMethod\n  )\n  and\n  // 验证析构方法的圈复杂度超过阈值3\n  destructorMethod.getScope().getMetrics().getCyclomaticComplexity() > 3\nselect destructorMethod, \"Overly complex '__del__' method.\"  // 选择符合条件的destructorMethod并标记为\"过于复杂的`__del__`方法\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：超类中定义的属性与子类方法同名时，会导致子类方法无法正常访问。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 超类中定义的属性与子类方法同名时，会导致子类方法无法正常访问。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 本查询识别子类方法被超类初始化方法中定义的属性遮蔽的问题\n * 属性访问优先于方法查找，导致同名方法无法被正常调用\n */\n\nimport python\n\n// 定义谓词：判断子类方法是否被超类属性遮蔽\npredicate isMethodHiddenBySuperAttr(\n  ClassObject childClass, ClassObject superClass, Assign attributeAssignment, FunctionObject hiddenMethod\n) {\n  // 确认子类声明了被遮蔽的方法\n  childClass.declaredAttribute(_) = hiddenMethod and\n  \n  // 确认继承关系：childClass 继承自 superClass\n  childClass.getASuperType() = superClass and\n  \n  // 排除超类中定义同名方法的情况（视为有意设计）\n  not superClass.hasAttribute(hiddenMethod.getName()) and\n  \n  // 在超类初始化方法中查找同名属性赋值\n  exists(FunctionObject initializer, Attribute assignedAttribute |\n    // 超类定义了 __init__ 方法\n    superClass.declaredAttribute(\"__init__\") = initializer and\n    \n    // 属性赋值的目标是 assignedAttribute\n    assignedAttribute = attributeAssignment.getATarget() and\n    \n    // 属性赋值对象是 self\n    assignedAttribute.getObject().(Name).getId() = \"self\" and\n    \n    // 属性名称与子类方法名称相同\n    assignedAttribute.getName() = hiddenMethod.getName() and\n    \n    // 赋值操作发生在超类的初始化方法中\n    attributeAssignment.getScope() = initializer.getOrigin().(FunctionExpr).getInnerScope()\n  )\n}\n\n// 查询被遮蔽的方法及其相关信息\nfrom ClassObject childClass, ClassObject superClass, Assign attributeAssignment, FunctionObject hiddenMethod\nwhere isMethodHiddenBySuperAttr(childClass, superClass, attributeAssignment, hiddenMethod)\nselect hiddenMethod.getOrigin(),\n  \"Method \" + hiddenMethod.getName() + \" is shadowed by an $@ in super class '\" + superClass.getName() +\n    \"'.\", attributeAssignment, \"attribute\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Detection of weak or unidentified asymmetric padding\n * @description\n * Identifies cryptographic implementations using asymmetric padding schemes that are\n * either weak, unapproved, or unrecognized. Approved secure padding includes OAEP,\n * KEM, and PSS. Other schemes may introduce cryptographic vulnerabilities.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define approved secure padding schemes\nstring secureScheme() { result = [\"OAEP\", \"KEM\", \"PSS\"] }\n\n// Identify vulnerable asymmetric padding implementations\nfrom AsymmetricPadding vulnerablePadding\n\n// Check padding scheme against approved list\nwhere exists(string paddingName | \n    paddingName = vulnerablePadding.getPaddingName() and\n    not paddingName = secureScheme()\n)\n_______________ // 补全条件\n// Report findings with scheme identification\nselect vulnerablePadding, \n       \"Use of unapproved, weak, or unknown asymmetric padding algorithm or API: \" + \n       vulnerablePadding.getPaddingName()",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/asserts-tuple]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects assert statements that test tuples, which provide no meaningful validity checking.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Asserting a tuple\n * @description Detects assert statements that test tuples, which provide no meaningful validity checking.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-670\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/asserts-tuple\n */\n\nimport python\n\n// Identify all assert statements in the code that test tuple expressions.\nfrom Assert assertStatement, string evaluationResult, string tupleDescription\nwhere\n  // Check if the expression being asserted is a tuple.\n  assertStatement.getTest() instanceof Tuple and\n  (\n    // For non-empty tuples, the assertion always evaluates to True.\n    if exists(assertStatement.getTest().(Tuple).getAnElt())\n    then (\n      evaluationResult = \"True\" and tupleDescription = \"non-\"\n    ) else (\n      // For empty tuples, the assertion always evaluates to False.\n      evaluationResult = \"False\" and tupleDescription = \"\"\n    )\n  )\n// Generate a warning message for each identified assert statement.\nselect assertStatement, \"Assertion of \" + tupleDescription + \"empty tuple is always \" + evaluationResult + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-iterable used in for loop\n * @description Detects for loops that attempt to iterate over non-iterable objects, which would cause a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n_______________ // 补全条件\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/non-iterable-in-for-loop\n */\n\nimport python\n\n// 查找在for循环中使用的非可迭代对象\nfrom For loopStatement, ControlFlowNode iterExprNode, Value iteratedValue, ClassValue iteratedClass, ControlFlowNode sourceLocation\nwhere\n  // 关联for循环与其迭代表达式节点，并追溯到被迭代的值和源位置\n  loopStatement.getIter().getAFlowNode() = iterExprNode and\n  iterExprNode.pointsTo(_, iteratedValue, sourceLocation) and\n  // 获取被迭代值的类类型，并确保它是有效的不可迭代类（排除推断失败的情况）\n  iteratedValue.getClass() = iteratedClass and\n  not iteratedClass.isIterable() and\n  not iteratedClass.failedInference(_) and\n  // 排除特殊情况：None值和描述符类型，它们可能有特殊处理或不是真正的错误\n  not (iteratedValue = Value::named(\"None\") or iteratedClass.isDescriptorType())\nselect loopStatement, \"This for-loop may attempt to iterate over a $@ of class $@.\", sourceLocation,\n  \"non-iterable instance\", iteratedClass, iteratedClass.getName()",
    "output": "*       types"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-data-to-external-api]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects untrusted data from remote sources being passed to external APIs",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted data passed to external API\n * @description Detects untrusted data from remote sources being passed to external APIs\n *              without sanitization, potentially leading to security vulnerabilities.\n * @id py/untrusted-data-to-external-api\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 7.8\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport ExternalAPIs\nimport UntrustedDataToExternalApiFlow::PathGraph\n\nfrom\n  UntrustedDataToExternalApiFlow::PathNode untrustedSourceNode,  // Entry point of tainted data flow\n  UntrustedDataToExternalApiFlow::PathNode vulnerableSinkNode,   // API invocation consuming tainted data\n  ExternalApiUsedWithUntrustedData taintedApiCall                // External API handling untrusted input\nwhere\n  // Validate sink node corresponds to the API's tainted parameter\n  vulnerableSinkNode.getNode() = taintedApiCall.getUntrustedDataNode()\n  and\n  // Verify data propagation path exists from source to sink\n  UntrustedDataToExternalApiFlow::flowPath(untrustedSourceNode, vulnerableSinkNode)\nselect\n  // Maintain original output structure with renamed variables\n  vulnerableSinkNode.getNode(), untrustedSourceNode, vulnerableSinkNode,\n  \"Call to \" + taintedApiCall.toString() + \" with untrusted data from $@.\", untrustedSourceNode.getNode(),\n  untrustedSourceNode.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Lines of commented-out code in files\n * @description Counts and reports the number of lines containing commented-out code for each file\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// Import necessary CodeQL modules for Python code analysis and commented code detection\nimport python\nimport Lexical.CommentedOutCode\n\n// Define the main query to identify files with commented-out code\nfrom File codeFile, int commentedLinesTotal\nwhere \n    // Calculate the total number of commented lines in each file\n    commentedLinesTotal = count(CommentedOutCodeLine commentedCodeLine | \n        // Exclude potential example code from the count\n        not commentedCodeLine.maybeExampleCode() and \n_______________ // 补全条件\n        commentedCodeLine.getLocation().getFile() = codeFile)\n// Present results showing file paths and their respective counts of commented code lines\nselect codeFile, commentedLinesTotal \n// Sort the results by the number of commented lines in descending order\norder by commentedLinesTotal desc",
    "output": "// Ensure the commented line belongs to the current file"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/truncated-division]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects division operations where both arguments are integers,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Result of integer division may be truncated\n * @description Detects division operations where both arguments are integers,\n *              which may cause the result to be truncated in Python 2.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// 查找在Python 2中整数除法可能导致结果被截断的情况\nfrom BinaryExpr intDivisionExpr, ControlFlowNode leftArgNode, ControlFlowNode rightArgNode\nwhere\n  // 仅在Python 2中需要检查，因为Python 3实现了真正的除法\n  major_version() = 2 and\n  exists(BinaryExprNode binaryNode, Value leftVal, Value rightVal |\n    // 获取除法表达式的流程节点并确认操作符为除法\n    binaryNode = intDivisionExpr.getAFlowNode() and\n    binaryNode.getNode().getOp() instanceof Div and\n    \n    // 验证左右操作数均为整数类型\n    binaryNode.getLeft().pointsTo(leftVal, leftArgNode) and\n    binaryNode.getRight().pointsTo(rightVal, rightArgNode) and\n    leftVal.getClass() = ClassValue::int_() and\n    rightVal.getClass() = ClassValue::int_() and\n    \n    // 排除整除无余数的情况\n    not leftVal.(NumericValue).getIntValue() % rightVal.(NumericValue).getIntValue() = 0 and\n    \n    // 排除已导入`from __future__ import division`的模块\n    not binaryNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // 排除结果被显式转换为整数的情况\n    not exists(CallNode intConversionCall |\n      intConversionCall = ClassValue::int_().getACall() and\n      intConversionCall.getAnArg() = binaryNode\n    )\n  )\nselect intDivisionExpr, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftArgNode, \"left\", rightArgNode, \"right\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Similar function detection\n * @description Identifies functions that have significant code similarity with other functions. Refactoring shared logic into common functions improves maintainability and reduces duplication.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision very-high\n * @id py/similar-function\n */\n\nimport python\n\n// Define source elements: primary function, similar function, and description message\nfrom Function primaryFunc, Function similarFunc, string description\n// Apply filtering condition (currently none for demonstration purposes)\nwhere none()\n_______________ // 补全条件\nselect primaryFunc, description, similarFunc, similarFunc.getName()",
    "output": "// Output results including: primary function, description, similar function, and its name"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks on substrings of unparsed URLs are vulnerable to bypass\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Defines regex pattern for commonly used top-level domains (TLDs)\nprivate string getCommonTldPattern() { \n  result = \"com|org|edu|gov|uk|net|io\" \n}\n\n// Determines if a string literal exhibits URL-like characteristics\npredicate resemblesUrl(StringLiteral urlStr) {\n  exists(string strContent | strContent = urlStr.getText() |\n    strContent.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + getCommonTldPattern() +\n        \")(:[0-9]+)?/?\")\n    or\n    strContent.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Identifies unsafe prefix validation using startswith() method\npredicate hasUnsafePrefixCheck(Call methodInvocation, StringLiteral prefixStr) {\n  methodInvocation.getFunc().(Attribute).getName() = \"startswith\" and\n  methodInvocation.getArg(0) = prefixStr and\n  not prefixStr.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n}\n\n// Identifies unsafe suffix validation using endswith() method\npredicate hasUnsafeSuffixCheck(Call methodInvocation, StringLiteral suffixStr) {\n  methodInvocation.getFunc().(Attribute).getName() = \"endswith\" and\n  methodInvocation.getArg(0) = suffixStr and\n  not suffixStr.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n}\n\n// Find expressions performing incomplete URL substring sanitization\nfrom Expr validationOp, StringLiteral urlStr\nwhere \n  resemblesUrl(urlStr) and\n  (\n    validationOp.(Compare).compares(urlStr, any(In i), _)\n    or\n_______________ // 补全条件\n    or\n    hasUnsafeSuffixCheck(validationOp, urlStr)\n  )\nselect validationOp, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlStr,\n  urlStr.getText()",
    "output": "hasUnsafePrefixCheck(validationOp, urlStr)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Importing value of mutable attribute\n * @description Detects direct imports of mutable attributes which prevent local observation of global state changes.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity high\n * @precision medium\n * @id py/import-of-mutable-attribute\n */\n_______________ // 补全条件\nimport python\nimport semmle.python.filters.Tests\n\nfrom ImportMember importedAttr, ModuleValue sourceModule, AttrNode modifiedNode, string attrName\nwhere\n  // Attribute name must match between import and modification\n  importedAttr.getName() = attrName and\n  // Verify source module matches imported module's origin\n  sourceModule.importedAs(importedAttr.getModule().(ImportExpr).getImportedModuleName()) and\n  // Modification must be a store operation within function scope\n  modifiedNode.isStore() and\n  modifiedNode.getScope() instanceof Function and\n  // Modification must target the source module's attribute\n  modifiedNode.getObject(attrName).pointsTo(sourceModule) and\n  // Imported attribute must have module-level scope (not function-local)\n  not importedAttr.getScope() instanceof Function and\n  // Import and modification must occur in different modules\n  not importedAttr.getEnclosingModule() = modifiedNode.getScope().getEnclosingModule() and\n  // Exclude modifications within test code\n  not modifiedNode.getScope().getScope*() instanceof TestScope\nselect importedAttr,\n  \"Importing the value of '\" + attrName +\n    \"' from $@ means that any change made to $@ will not be observed locally.\", sourceModule,\n  \"module \" + sourceModule.getName(), modifiedNode, sourceModule.getName() + \".\" + modifiedNode.getName()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Initializing SECRET_KEY of Flask application with Constant value\n * @description Initializing SECRET_KEY of Flask application with Constant value\n * files can lead to Authentication bypass\n * @kind path-problem\n * @id py/flask-constant-secret-key\n * @problem.severity error\n * @security-severity 8.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport WebAppConstantSecretKeyDjango\nimport WebAppConstantSecretKeyFlask\nimport semmle.python.filters.Tests\n\n// 定义一个新的类型 TFrameWork，可以是 Flask 或 Django\nnewtype TFrameWork =\n  Flask() or\n  Django()\n\n// 私有模块 WebAppConstantSecretKeyConfig 实现了 DataFlow::StateConfigSig 接口\nprivate module WebAppConstantSecretKeyConfig implements DataFlow::StateConfigSig {\n  // 定义一个类 FlowState，其类型为 TFrameWork\n  class FlowState = TFrameWork;\n\n  // 定义 isSource 谓词，用于判断数据流的源节点\n  predicate isSource(DataFlow::Node source, FlowState state) {\n    // 如果状态是 Flask，则调用 FlaskConstantSecretKeyConfig::isSource 方法判断源节点\n    state = Flask() and FlaskConstantSecretKeyConfig::isSource(source)\n    // 如果状态是 Django，则调用 DjangoConstantSecretKeyConfig::isSource 方法判断源节点\n    or\n    state = Django() and DjangoConstantSecretKeyConfig::isSource(source)\n  }\n\n  // 定义 isBarrier 谓词，用于判断数据流的屏障节点\n  predicate isBarrier(DataFlow::Node node) {\n    // 如果节点在标准库中，则为屏障节点\n    node.getLocation().getFile().inStdlib()\n    // 为了减少误报率，添加以下条件\n    or\n    node.getLocation()\n        .getFile()\n        .getRelativePath()\n        .matches([\"%test%\", \"%demo%\", \"%example%\", \"%sample%\"]) and\n    // 但是这也意味着查询测试中的所有数据流节点都被排除了...因此我们添加了这个：\n    not node.getLocation().getFile().getRelativePath().matches(\"%query-tests/Security/CWE-287%\")\n  }\n\n  // 定义 isSink 谓词，用于判断数据流的汇节点\n  predicate isSink(DataFlow::Node sink, FlowState state) {\n    // 如果状态是 Flask，则调用 FlaskConstantSecretKeyConfig::isSink 方法判断汇节点\n    state = Flask() and FlaskConstantSecretKeyConfig::isSink(sink)\n    // 如果状态是 Django，则调用 DjangoConstantSecretKeyConfig::isSink 方法判断汇节点\n_______________ // 补全条件\n    state = Django() and DjangoConstantSecretKeyConfig::isSink(sink)\n  }\n\n  // 定义 observeDiffInformedIncrementalMode 谓词，用于观察差异信息增量模式\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// 定义 WebAppConstantSecretKeyFlow 模块，使用 TaintTracking::GlobalWithState 进行全局状态跟踪\nmodule WebAppConstantSecretKeyFlow = TaintTracking::GlobalWithState<WebAppConstantSecretKeyConfig>;\n\n// 导入 WebAppConstantSecretKeyFlow::PathGraph\nimport WebAppConstantSecretKeyFlow::PathGraph\n\n// 从 WebAppConstantSecretKeyFlow::PathNode 中选择源节点和汇节点，并生成相应的查询结果\nfrom WebAppConstantSecretKeyFlow::PathNode source, WebAppConstantSecretKeyFlow::PathNode sink\nwhere WebAppConstantSecretKeyFlow::flowPath(source, sink)\nselect sink, source, sink, \"The SECRET_KEY config variable is assigned by $@.\", source,\n  \" this constant String\"",
    "output": "or"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inconsistent-mro]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects class definitions that will raise a type error at runtime due to inconsistent method resolution order (MRO)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent method resolution order\n * @description Detects class definitions that will raise a type error at runtime due to inconsistent method resolution order (MRO)\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n// Retrieves the immediate predecessor base class in the inheritance hierarchy\n// This helper identifies the base class positioned immediately before the target base\n// in the class's base class list, which is critical for MRO validation\nClassObject getPredecessorBase(ClassObject cls, ClassObject targetBase) {\n  // Find a valid position index where the index-th base is targetBase,\n  // and return the preceding base at position (index-1)\n  exists(int position | \n    position > 0 and \n    cls.getBaseType(position) = targetBase and \n    result = cls.getBaseType(position - 1)\n  )\n}\n\n// Validates if a class has an invalid method resolution order (MRO)\n// This predicate checks inheritance hierarchy violations that would cause\n// runtime TypeError during class definition\npredicate hasInvalidMRO(ClassObject cls, ClassObject predecessorBase, ClassObject successorBase) {\n  // Ensure the class is new-style and predecessorBase is an improper supertype of successorBase\n  cls.isNewStyle() and\n  predecessorBase = getPredecessorBase(cls, successorBase) and\n  predecessorBase = successorBase.getAnImproperSuperType()\n}\n\n// Query classes with invalid MRO and generate diagnostic information\n// This identifies classes that fail at runtime due to MRO violations,\n// providing detailed error messages about problematic base classes\nfrom ClassObject cls, ClassObject predecessorBase, ClassObject successorBase\nwhere hasInvalidMRO(cls, predecessorBase, successorBase)\nselect cls,\n  \"Construction of class \" + cls.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", predecessorBase,\n  predecessorBase.getName(), successorBase, successorBase.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent equality and inequality implementation\n * @description Detects classes that violate the object model by implementing only one of the equality comparison methods (__eq__ or __ne__).\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-equality\n */\n\nimport python\n\n// Returns the names of equality comparison methods\nstring equalityMethodName() { \n  result in [\"__eq__\", \"__ne__\"] \n}\n\n// Checks if a class is decorated with total_ordering\npredicate hasTotalOrderingDecorator(Class cls) {\n  exists(Attribute decoratorNode | \n    decoratorNode = cls.getADecorator() | \n    decoratorNode.getName() = \"total_ordering\"\n  )\n  or\n  exists(Name nameNode | \n    nameNode = cls.getADecorator() | \n    nameNode.getId() = \"total_ordering\"\n  )\n}\n\n// Retrieves the implemented equality method from a class\nCallableValue getImplementedEqualityMethod(ClassValue cls, string methodName) { \n  result = cls.declaredAttribute(methodName) and \n  methodName = equalityMethodName()\n}\n\n// Determines the missing equality method in a class\nstring getUnimplementedEqualityMethod(ClassValue cls) { \n  not cls.declaresAttribute(result) and \n  result = equalityMethodName()\n}\n\n// Identifies classes violating the equality contract\npredicate violatesEqualityContract(\n  ClassValue violatingClass, string existingMethod, \n  string absentMethod, CallableValue equalityMethod\n_______________ // 补全条件\n  // Get the missing method in the class\n  absentMethod = getUnimplementedEqualityMethod(violatingClass) and\n  \n  // Get the implemented equality method\n  equalityMethod = getImplementedEqualityMethod(violatingClass, existingMethod) and\n  \n  // Exclude classes with failed inference\n  not violatingClass.failedInference(_) and\n  \n  // Exclude classes with total_ordering decorator\n  not hasTotalOrderingDecorator(violatingClass.getScope()) and\n  \n  // Python 3 auto-implements __ne__ when __eq__ is defined\n  not (major_version() = 3 and existingMethod = \"__eq__\" and absentMethod = \"__ne__\")\n}\n\n// Generate warnings for classes violating the equality contract\nfrom ClassValue violatingClass, string existingMethod, string absentMethod, CallableValue equalityMethod\nwhere violatesEqualityContract(violatingClass, existingMethod, absentMethod, equalityMethod)\nselect equalityMethod, \"Class $@ implements \" + existingMethod + \" but does not implement \" + absentMethod + \".\", violatingClass,\n  violatingClass.getName()",
    "output": ") {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies Python functions that do not adhere to PEP8 naming conventions by beginning with uppercase letters.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n * @convention PEP8\n */\n\nimport python  // Import Python analysis module for code inspection\n\n// Predicate that determines if a function name begins with an uppercase character\npredicate startsWithCapitalLetter(Function functionObj) {\n  exists(string firstChar |\n    firstChar = functionObj.getName().prefix(1) and  // Extract the first character of the function name\n    not firstChar = firstChar.toLowerCase()  // Confirm the character is uppercase\n  )\n}\n\n// Query to detect functions that violate the PEP8 naming convention\nfrom Function violatingFunction\nwhere\n  violatingFunction.inSource() and  // Verify the function is defined in source code\n  startsWithCapitalLetter(violatingFunction) and  // Confirm the function name starts with an uppercase letter\n  // Exclude results when multiple functions in the same file commit the same violation\n  not exists(Function otherFunction |\n    otherFunction != violatingFunction and  // Ensure it's a different function\n    otherFunction.getLocation().getFile() = violatingFunction.getLocation().getFile() and  // Both functions reside in the same file\n    startsWithCapitalLetter(otherFunction)  // The other function also violates the naming convention\n  )\nselect violatingFunction, \"Function names should start with lowercase letters according to PEP8.\"  // Display the violating function with an appropriate message",
    "output": "* @name Function Naming Convention Violation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Secondary server command execution vulnerability\n * @description Detects when user-supplied data can lead to arbitrary command execution\n *              on remote systems, potentially enabling lateral movement or privilege escalation\n_______________ // 补全条件\n * @problem.severity error\n * @security-severity 9.3\n * @precision high\n * @id py/paramiko-command-injection\n * @tags security\n *       experimental\n *       external/cwe/cwe-074\n */\n\n// Import core Python analysis framework\nimport python\n// Import experimental module for remote code execution detection\nimport experimental.semmle.python.security.RemoteCommandExecution\n// Import path graph utilities for data flow visualization\nimport RemoteCommandExecutionFlow::PathGraph\n\n// Identify data flow paths from untrusted sources to command execution sinks\nfrom RemoteCommandExecutionFlow::PathNode untrustedSource, RemoteCommandExecutionFlow::PathNode commandSink\n// Ensure a complete data flow path exists between source and sink\nwhere RemoteCommandExecutionFlow::flowPath(untrustedSource, commandSink)\n// Generate vulnerability report with source tracking\nselect commandSink.getNode(), untrustedSource, commandSink, \n       \"This command execution is influenced by $@.\", untrustedSource.getNode(),\n       \"untrusted user input\"",
    "output": "* @kind path-problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unknown-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测非对称加密算法生成密钥时，无法在静态分析阶段确定密钥长度的情况",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 非对称密钥生成中的未知密钥大小\n * @description 检测非对称加密算法生成密钥时，无法在静态分析阶段确定密钥长度的情况\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 检测非对称密钥生成操作中密钥大小无法静态确认的情况\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node keyConfigSource, string algoName\nwhere\n  // 获取密钥生成操作的配置源节点\n  keyConfigSource = keyGenOperation.getKeyConfigSrc()\n  and\n  // 获取使用的加密算法名称\n  algoName = keyGenOperation.getAlgorithm().getName()\n  and\n  // 验证密钥生成操作缺乏静态可验证的密钥大小参数\n  not keyGenOperation.hasKeySize(keyConfigSource)\nselect keyGenOperation,\n  // 生成包含算法信息和配置源的问题报告\n  \"用于算法 \" + algoName.toString() + \" 的密钥生成使用了无法静态验证的密钥大小，在配置源 $@\", keyConfigSource, keyConfigSource.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of 'global' at module level\n * @description Use of the 'global' statement at module level\n * @kind problem\n_______________ // 补全条件\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-global-declaration\n */\n\n// 导入Python代码分析库，提供对Python程序结构的访问能力\nimport python\n\n// 查询目标：识别在模块顶层作用域中声明的全局变量\n// 此类声明是冗余的，因为模块级别定义的变量默认具有全局作用域\nfrom Global redundantGlobalDecl\nwhere \n    // 检查全局声明是否位于模块作用域内\n    // 在模块级别使用global关键字是不必要的，因为此级别的变量天然就是全局的\n    redundantGlobalDecl.getScope() instanceof Module\nselect \n    redundantGlobalDecl, \n    // 构建警告消息，指明冗余的全局声明及其原因\n    \"Global declaration of '\" + redundantGlobalDecl.getAName() + \"' at module level is redundant. Module-level variables are global by default.\"",
    "output": "* @tags maintainability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Number of statements\n * @description Calculates and displays the total count of statements within each Python module\n * @kind treemap\n * @id py/number-of-statements-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\n\nfrom Module moduleObj, int statementCount\nwhere \n  // Define a variable to hold the count of statements per module\n  statementCount = count(Stmt stmt | \n    // Filter statements that belong to the current module\n    stmt.getEnclosingModule() = moduleObj\n  )\n// Select the module and its statement count, ordered by count in descending order\nselect moduleObj, statementCount order by statementCount desc",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects ambiguous use of '\\b' in regex character sets where it could be",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Regex Backspace Escape Confusion\n * @description Detects ambiguous use of '\\b' in regex character sets where it could be \n *              misinterpreted as word boundary instead of backspace character.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int escapePosition\nwhere\n  // Verify the escape sequence is within a character set\n  exists(int charSetBegin, int charSetEnd |\n    charSetBegin < escapePosition and \n    charSetEnd > escapePosition and\n    regexPattern.charSet(charSetBegin, charSetEnd)\n  ) and\n  // Confirm current position contains a backslash escape character\n  regexPattern.escapingChar(escapePosition) and\n  // Ensure the character following the backslash is 'b'\n  regexPattern.getChar(escapePosition + 1) = \"b\"\nselect regexPattern, \"Backspace escape in regular expression at offset \" + escapePosition + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unreachable-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies situations where a specific exception handler is positioned after a general one,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unreachable 'except' block\n * @description Identifies situations where a specific exception handler is positioned after a general one,\n *              causing it to be unreachable because the general handler will always intercept the exception first.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Identify unreachable exception handlers due to improper handler ordering\nfrom ExceptStmt generalExcept, ClassValue superType, \n     ExceptStmt specificExcept, ClassValue subType\nwhere \n  // Both exception handlers belong to the same try statement\n  exists(Try tryBlock, int generalPos, int specificPos |\n    generalExcept = tryBlock.getHandler(generalPos) and\n    specificExcept = tryBlock.getHandler(specificPos) and\n    // General handler precedes specific handler in the sequence\n    generalPos < specificPos\n  ) and\n  // Resolve exception types handled by each clause\n  generalExcept.getType().pointsTo(superType) and\n  specificExcept.getType().pointsTo(subType) and\n  // General handler catches a superclass of specific handler's exception\n  superType = subType.getASuperType()\n// Report the unreachable specific exception handler\nselect specificExcept,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  subType, subType.getName(), generalExcept, \"except block\", superType, superType.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-low-iteration-count]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects insufficient iteration counts in key derivation functions.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use iteration count at least 100k to prevent brute force attacks\n * @description Detects insufficient iteration counts in key derivation functions.\n * Cryptographic keys derived from user inputs (like passwords) should use a high iteration count\n * (minimum 100,000 iterations) to prevent brute force attacks.\n *\n * The query flags two potential issues:\n * 1. When the iteration count is a constant value less than 100,000\n * 2. When the iteration count source cannot be statically determined\n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import standard Python analysis library\nimport python\n// Import experimental cryptography concepts for key derivation operations\nimport experimental.cryptography.Concepts\n// Import utility functions for cryptography analysis, aliased as CryptoUtils\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Select key derivation operations with insufficient iteration counts\nfrom KeyDerivationOperation kdfOperation, string alertMessage, DataFlow::Node iterationCountSource\nwhere\n  // Focus on operations requiring iteration configuration\n  kdfOperation.requiresIteration() and\n  // Identify the source of iteration count configuration\n  iterationCountSource = kdfOperation.getIterationSizeSrc() and\n  (\n    // Case 1: Explicitly defined iteration count below threshold\n    exists(int iterationValue |\n      iterationCountSource.asExpr().(IntegerLiteral).getValue() = iterationValue and\n      iterationValue < 100000 and\n      alertMessage = \"Insufficient iteration count detected. \"\n    )\n    or\n    // Case 2: Iteration count cannot be statically verified\n    (\n      not iterationCountSource.asExpr() instanceof IntegerLiteral and\n      alertMessage = \"Iteration count cannot be statically verified. \"\n    )\n  )\nselect \n  // Report the key derivation operation with appropriate warning message\n  kdfOperation, \n  alertMessage + \"Minimum required iteration count is 100000. \" + \n  \"Configuration source: $@\",\n  iterationCountSource.asExpr(), \n  iterationCountSource.asExpr().toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-hashes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies cryptographic hash functions that are deprecated",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak cryptographic hash algorithms\n * @description Identifies cryptographic hash functions that are deprecated \n *              or considered insecure for security-sensitive contexts.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import Python language support and cryptographic analysis utilities\nimport python\nimport experimental.cryptography.Concepts\n\n// Find hash operations utilizing weak or deprecated cryptographic algorithms\nfrom HashAlgorithm hashOperation, string algorithmName, string alertMessage\nwhere\n  // Extract the algorithm name from the cryptographic hash operation\n  algorithmName = hashOperation.getHashName() and\n  \n  // Filter out approved strong hash algorithms\n  not algorithmName = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  \n  // Generate appropriate alert message based on algorithm status\n  (\n    // Case for recognized but unapproved algorithms\n    algorithmName != \"\" and\n    alertMessage = \"Use of unapproved hash algorithm or API \" + algorithmName + \".\"\n  )\n  or\n  (\n    // Case for unrecognized algorithm cases\n    algorithmName = \"\" and\n    alertMessage = \"Use of unrecognized hash algorithm.\"\n  )\nselect hashOperation, alertMessage"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-star-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of wildcard imports which can lead to namespace pollution",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' used\n * @description Detects usage of wildcard imports which can lead to namespace pollution\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\nimport python\n\nfrom ImportStar wildcardImport\nselect wildcardImport, \"Using 'from ... import *' pollutes the namespace.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Detection of Elliptic Curve Algorithms\n * @description Identifies all occurrences of elliptic curve cryptographic algorithms in the codebase.\n *              This query extracts the curve name and key size details to assist in evaluating quantum readiness.\n *              Due to the vulnerability of elliptic curve cryptography to quantum attacks, this detection\n *              is essential for cryptographic inventory and migration planning.\n * @kind problem\n * @id py/quantum-readiness/cbom/elliptic-curve-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import the Python language analysis module\nimport python\n\n// Import the experimental cryptography concepts module\nimport experimental.cryptography.Concepts\n\n// Identify all elliptic curve algorithm instances in the codebase\nfrom EllipticCurveAlgorithm curveAlgo\n\n_______________ // 补全条件\nselect curveAlgo,\n  \"Algorithm: \" + curveAlgo.getCurveName() + \n  \" | Key Size (bits): \" + curveAlgo.getCurveBitSize().toString()",
    "output": "// Generate a report for each instance including curve name and key size"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of a broken or weak cryptographic algorithm\n * @description Using broken or weak cryptographic algorithms can compromise security.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @id py/weak-cryptographic-algorithm\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.Concepts\n\n// Identify cryptographic operations that use weak algorithms or block modes\nfrom Cryptography::CryptographicOperation cryptoOperation, string warningMessagePrefix\nwhere\n  // Check if the cryptographic operation uses a weak encryption algorithm\n  exists(Cryptography::EncryptionAlgorithm weakAlgorithm | weakAlgorithm = cryptoOperation.getAlgorithm() |\n    weakAlgorithm.isWeak() and\n    warningMessagePrefix = \"The cryptographic algorithm \" + weakAlgorithm.getName()\n  )\n  // Alternatively, check if the cryptographic operation uses a weak block mode\n  or\n_______________ // 补全条件\nselect cryptoOperation, \"$@ is broken or weak, and should not be used.\", cryptoOperation.getInitialization(),\n  warningMessagePrefix",
    "output": "cryptoOperation.getBlockMode().isWeak() and warningMessagePrefix = \"The block mode \" + cryptoOperation.getBlockMode()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unreachable-statement]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code that cannot be executed",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Dead code detection\n * @description Identifies code that cannot be executed\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-statement\n */\n\nimport python\n\n// Determines if an import statement is used for type hints\n// Such imports should not be flagged as unreachable code\npredicate is_typing_related_import(ImportingStmt typingImport) {\n  exists(Module modScope |\n    typingImport.getScope() = modScope and\n    exists(TypeHintComment typeHintComment | typeHintComment.getLocation().getFile() = modScope.getFile())\n  )\n}\n\n// Checks if a statement contains the only yield expression in its function\n// Such code blocks may be intentionally designed as generator functions\npredicate contains_unique_yield_in_function(Stmt stmtContainingYield) {\n  exists(Yield yieldNode | stmtContainingYield.contains(yieldNode)) and\n  exists(Function funcScope |\n    funcScope = stmtContainingYield.getScope() and\n    strictcount(Yield yieldNode | funcScope.containsInScope(yieldNode)) = 1\n  )\n}\n\n// Verifies if a statement shares scope with contextlib.suppress\n// Code blocks using contextlib.suppress may intentionally catch exceptions\npredicate shares_scope_with_suppression(Stmt stmtInSuppressScope) {\n  exists(With suppressWithStmt |\n    suppressWithStmt.getContextExpr().(Call).getFunc().pointsTo(Value::named(\"contextlib.suppress\")) and\n    suppressWithStmt.getScope() = stmtInSuppressScope.getScope()\n  )\n}\n\n// Identifies statements marking impossible else branches\n// Defensive programming patterns may use unreachable else branches with assertions/exceptions\npredicate marks_impossible_else_branch(Stmt stmtInImpossibleElse) {\n  exists(If ifBlock | ifBlock.getOrelse().getItem(0) = stmtInImpossibleElse |\n    stmtInImpossibleElse.(Assert).getTest() instanceof False\n    or\n    stmtInImpossibleElse instanceof Raise\n  )\n}\n\n// Determines if a statement should be reported as unreachable\n// Combines multiple conditions to exclude legitimate unreachable code cases\npredicate is_reportable_unreachable(Stmt deadCode) {\n  // Base condition: statement must be unreachable\n  deadCode.isUnreachable() and\n  \n  // Exclude legitimate cases of unreachable code\n  not is_typing_related_import(deadCode) and\n  not shares_scope_with_suppression(deadCode) and\n  not contains_unique_yield_in_function(deadCode) and\n  not marks_impossible_else_branch(deadCode) and\n  \n  // Exclude statements contained within or following other unreachable statements\n  not exists(Stmt otherUnreachable | otherUnreachable.isUnreachable() |\n    otherUnreachable.contains(deadCode)\n    or\n    exists(StmtList statementList, int previousIndex, int currentIndex | \n      statementList.getItem(previousIndex) = otherUnreachable and \n      statementList.getItem(currentIndex) = deadCode and \n      previousIndex < currentIndex\n    )\n  )\n}\n\n// Query for all reportable unreachable code\nfrom Stmt deadCode\nwhere is_reportable_unreachable(deadCode)\nselect deadCode, \"This statement is unreachable.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Superclass attribute shadows subclass method\n * @description Detects when attributes in superclass initialization methods\n *              shadow methods defined in subclasses, causing the methods to become inaccessible.\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * Identifies scenarios where subclass methods are shadowed by attributes\n * defined in superclass initialization. This occurs because attribute access\n * takes precedence over method lookup during attribute resolution.\n */\n\nimport python\n\nfrom ClassObject subClass, ClassObject superClass, Assign attributeAssignment, FunctionObject overriddenMethod\nwhere\n  // Establish inheritance relationship\n  subClass.getASuperType() = superClass and\n  \n  // Verify subclass contains the potentially shadowed method\n  subClass.declaredAttribute(_) = overriddenMethod and\n  \n  // Locate matching attribute assignment in superclass initializer\n  exists(FunctionObject initializerMethod, Attribute assignedAttr |\n    // Confirm superclass defines __init__ method\n    superClass.declaredAttribute(\"__init__\") = initializerMethod and\n_______________ // 补全条件\n    // Attribute assignment target matches assignedAttr\n    assignedAttr = attributeAssignment.getATarget() and\n    \n    // Assignment target is 'self' instance\n    assignedAttr.getObject().(Name).getId() = \"self\" and\n    \n    // Attribute name matches subclass method name\n    assignedAttr.getName() = overriddenMethod.getName() and\n    \n    // Assignment occurs within superclass initializer scope\n    attributeAssignment.getScope() = initializerMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  \n  // Exclude cases where superclass intentionally defines同名 method\n  not superClass.hasAttribute(overriddenMethod.getName())\nselect overriddenMethod.getOrigin(),\n  \"Method \" + overriddenMethod.getName() + \" is shadowed by an $@ in super class '\" + superClass.getName() +\n    \"'.\", attributeAssignment, \"attribute\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-lines-deleted]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Quantifies the total number of lines deleted per file throughout the entire commit history stored in the database.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File Deletion Analysis\n * @description Quantifies the total number of lines deleted per file throughout the entire commit history stored in the database.\n * @kind treemap\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\n// Analyze source code files and calculate cumulative deletion metrics across their entire version history\nfrom Module sourceFile, int cumulativeDeletions\nwhere\n  // Calculate the sum of all deleted lines for each file across its commit history\n  exists(int deletionCount |\n    deletionCount = \n      sum(Commit versionCommit, int deletedLines |\n        // Retrieve deletion metrics from commits that modified the file\n        deletedLines = versionCommit.getRecentDeletionsForFile(sourceFile.getFile()) and\n        // Filter out commits that represent non-functional changes (e.g., automated refactoring operations)\n        not artificialChange(versionCommit)\n      |\n        deletedLines\n      ) and\n    cumulativeDeletions = deletionCount\n  ) and\n  // Verify that the file has valid code metrics available for analysis\n  exists(sourceFile.getMetrics().getNumberOfLinesOfCode())\nselect sourceFile, cumulativeDeletions order by cumulativeDeletions desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 已提取的Python源文件\n * @description 此查询用于识别并展示源代码树中所有成功提取的Python源文件。\n *              通过检查文件是否存在有效的相对路径，可以确认该文件是否已正确提取。\n *              这对于验证代码库的完整性和确保所有Python模块都被正确处理非常重要。\n * @kind diagnostic\n * @id py/diagnostics/successfully-extracted-files\n * @tags successfully-extracted-files\n */\n\nimport python\n\n// 定义查询范围：所有Python文件\nfrom File pyFile\nwhere \n    // 筛选条件：文件必须具有有效的相对路径\n_______________ // 补全条件\n    exists(pyFile.getRelativePath())\n// 输出结果：文件对象和空字符串（保持格式一致性）\nselect pyFile, \"\"",
    "output": "// 这表明文件已成功从源代码树中提取"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/diagnostics/successfully-extracted-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别并列出代码库中所有已成功提取的Python源文件。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python文件提取结果\n * @description 识别并列出代码库中所有已成功提取的Python源文件。\n * @kind diagnostic\n * @id py/diagnostics/successfully-extracted-files\n * @tags successfully-extracted-files\n */\n\nimport python\n\n/* \n * 本查询旨在检测并报告代码库中所有成功提取的Python源文件。\n * 成功提取的定义标准：文件在代码库中具有有效的相对路径。\n * 这类文件通常是指那些能够被正确解析和处理的有效Python源代码文件。\n */\nfrom File extractedPythonSource\nwhere exists(extractedPythonSource.getRelativePath())\nselect extractedPythonSource, \"\"  // 输出文件路径和空字符串（用于格式化）"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-inference-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query identifies cases where type inference fails for 'object' types,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type inference fails for 'object'\n * @description This query identifies cases where type inference fails for 'object' types, \n *              potentially reducing recall in security analysis. The issue occurs when \n *              control flow nodes reference objects without complete type information.\n * @kind problem\n * @problem.severity info\n * @id py/type-inference-failure\n * @deprecated\n */\n\nimport python\n\nfrom ControlFlowNode flowNode, Object targetObject\nwhere \n  // Step 1: Identify control flow nodes that reference objects\n  flowNode.refersTo(targetObject) \n  // Step 2: Exclude nodes with complete type information (3-argument form)\n  and not flowNode.refersTo(targetObject, _, _)\nselect targetObject, \"Type inference fails for 'object'.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of 'return' or 'yield' outside a function\n * @description Using 'return' or 'yield' outside a function causes a 'SyntaxError' at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/return-or-yield-outside-function\n */\n\nimport python\n\n_______________ // 补全条件\nfrom AstNode problematicNode, string statementType\nwhere\n  // 确保节点不在任何函数的作用域内\n  not problematicNode.getScope() instanceof Function and\n  (\n    // 检查节点是否为 return 语句\n    (problematicNode instanceof Return and statementType = \"return\")\n    or\n    // 检查节点是否为 yield 语句\n    (problematicNode instanceof Yield and statementType = \"yield\")\n    or\n    // 检查节点是否为 yield from 语句\n    (problematicNode instanceof YieldFrom and statementType = \"yield from\")\n  )\n// 输出匹配的节点和相应的错误信息\nselect problematicNode, \"'\" + statementType + \"' is used outside a function.\"",
    "output": "// 查找所有不在函数作用域内的 AST 节点"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides counts of different kinds of type annotations in Python code, including parameters, return types, and annotated assignments.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Provides counts of different kinds of type annotations in Python code, including parameters, return types, and annotated assignments.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents a built-in type in Python\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr func) { exists(func.getReturns()) } or\n  TAnnotatedParameter(Parameter param) { exists(param.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign assign) { exists(assign.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr funcExpr;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(funcExpr) }\n  override Expr getAnnotation() { result = funcExpr.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter paramVar;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(paramVar) }\n  override Expr getAnnotation() { result = paramVar.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assignStmt;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assignStmt) }\n  override Expr getAnnotation() { result = assignStmt.getAnnotation() }\n}\n\n/** Holds if `typeExpr` is a forward declaration (string literal) of a type */\npredicate is_forward_declaration(Expr typeExpr) { typeExpr instanceof StringLiteral }\n\n/** Holds if `typeExpr` is a type that may be difficult to analyze */\npredicate is_complex_type(Expr typeExpr) {\n  (typeExpr instanceof Subscript and not is_optional_type(typeExpr)) or\n  typeExpr instanceof Tuple or\n  typeExpr instanceof List\n}\n\n/** Holds if `typeExpr` is a type of the form `Optional[...]` */\npredicate is_optional_type(Subscript typeExpr) { typeExpr.getObject().(Name).getId() = \"Optional\" }\n\n/** Holds if `typeExpr` is a simple type (non-built-in identifier or attribute chain) */\npredicate is_simple_type(Expr typeExpr) {\n  (typeExpr instanceof Name and not typeExpr instanceof BuiltinType) or\n  is_simple_type(typeExpr.(Attribute).getObject())\n}\n\n/** Holds if `typeExpr` is a built-in type */\npredicate is_builtin_type(Expr typeExpr) { typeExpr instanceof BuiltinType }\n\n// Computes type annotation metrics for different annotation categories\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  category = \"Parameter annotation\" and\n  totalCount = count(AnnotatedParameter param) and\n  builtinCount = count(AnnotatedParameter param | is_builtin_type(param.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedParameter param | is_forward_declaration(param.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedParameter param | is_simple_type(param.getAnnotation())) and\n  complexTypeCount = count(AnnotatedParameter param | is_complex_type(param.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedParameter param | is_optional_type(param.getAnnotation()))\n  or\n  // Return type annotation metrics\n  category = \"Return type annotation\" and\n  totalCount = count(AnnotatedFunction func) and\n  builtinCount = count(AnnotatedFunction func | is_builtin_type(func.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedFunction func | is_forward_declaration(func.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedFunction func | is_simple_type(func.getAnnotation())) and\n  complexTypeCount = count(AnnotatedFunction func | is_complex_type(func.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedFunction func | is_optional_type(func.getAnnotation()))\n  or\n  // Annotated assignment metrics\n  category = \"Annotated assignment\" and\n  totalCount = count(AnnotatedAssignment assign) and\n  builtinCount = count(AnnotatedAssignment assign | is_builtin_type(assign.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedAssignment assign | is_forward_declaration(assign.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedAssignment assign | is_simple_type(assign.getAnnotation())) and\n  complexTypeCount = count(AnnotatedAssignment assign | is_complex_type(assign.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedAssignment assign | is_optional_type(assign.getAnnotation()))\n}\n\n// Query execution and output\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/encoding-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python code with encoding issues that may cause runtime failures",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Encoding error\n * @description Identifies Python code with encoding issues that may cause runtime failures\n *              and impede static analysis capabilities.\n * @kind problem\n * @id py/encoding-error\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n */\n\nimport python\n\n// Identify all Python encoding error instances\nfrom EncodingError encodingError\n\n// Output each encoding error with its diagnostic message\nselect encodingError, encodingError.getMessage()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称密钥生成源识别\n * @description 识别通过受支持库生成的非对称密钥，追踪其配置来源。\n *              本查询分析非对称密钥生成操作及其配置数据流，帮助发现\n *              潜在的密钥管理问题与安全风险。\n * @kind problem\n * @id py/quantum-readiness/cbom/asymmetric-key-generation\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找所有非对称密钥生成操作及其关联的配置源\n// 通过匹配密钥生成操作的配置源与数据流节点，识别密钥生成模式\nfrom \n  AsymmetricKeyGen keyGenOperation, \n  DataFlow::Node configSource\nwhere \n  // 确保配置源与密钥生成操作关联\n  keyGenOperation.getKeyConfigSrc() = configSource\nselect \n  keyGenOperation,\n  \"检测到非对称密钥生成，使用算法: \" + \n  keyGenOperation.getAlgorithm().getName() + \n  \"，密钥配置源: $@\", \n  configSource, \n_______________ // 补全条件",
    "output": "configSource.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/iter-returns-non-iterator]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The `__iter__` method returns a non-iterator which, if used in a 'for' loop, would raise a 'TypeError'.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__iter__` method returns a non-iterator\n * @description The `__iter__` method returns a non-iterator which, if used in a 'for' loop, would raise a 'TypeError'.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iter-returns-non-iterator\n */\n\nimport python  # 导入python模块，用于处理Python代码的静态分析\n\nfrom ClassValue iterable, FunctionValue iter, ClassValue iterator  # 从ClassValue和FunctionValue中引入iterable、iter和iterator\nwhere\n  iter = iterable.lookup(\"__iter__\") and  # 查找iterable类中的`__iter__`方法，并将其赋值给变量iter\n  iterator = iter.getAnInferredReturnType() and  # 获取`__iter__`方法的推断返回类型，并将其赋值给变量iterator\n  not iterator.isIterator()  # 检查iterator是否实现了迭代器接口，如果没有实现则继续执行\nselect iterator,  # 选择iterator作为查询结果的一部分\n  \"Class \" + iterator.getName() +  # 构建错误信息字符串，包含未实现迭代器接口的类名\n    \" is returned as an iterator (by $@) but does not fully implement the iterator interface.\",  # 完成错误信息字符串\n  iter, iter.getName()  # 选择iter及其名称作为查询结果的一部分"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/incorrect-overridden-signature]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies situations where a derived class method overrides a base class method",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Mismatch between signature and use of an overridden method\n * @description Identifies situations where a derived class method overrides a base class method\n *              with a different signature. When the derived method is called with arguments\n *              matching its signature but not the base method's signature, a runtime error\n *              could occur if the base method is invoked instead.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/inheritance/incorrect-overridden-signature\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call methodInvocation, FunctionValue baseMethod, FunctionValue derivedMethod, string signatureMismatchDetails\nwhere\n  // Filter out constructor methods as they require special handling\n  not baseMethod.getName() = \"__init__\" and\n  // Verify that the derived method overrides the base method\n  derivedMethod.overrides(baseMethod) and\n  // Identify the actual invocation point of the derived method\n  methodInvocation = derivedMethod.getAMethodCall().getNode() and\n  // Confirm that the call arguments match the derived method's signature\n  correct_args_if_called_as_method(methodInvocation, derivedMethod) and\n  // Detect specific signature mismatches between base and derived methods\n  (\n    // Case 1: Insufficient arguments for the base method\n    arg_count(methodInvocation) + 1 < baseMethod.minParameters() and \n    signatureMismatchDetails = \"too few arguments\"\n    or\n    // Case 2: Excessive arguments for the base method\n    arg_count(methodInvocation) >= baseMethod.maxParameters() and \n    signatureMismatchDetails = \"too many arguments\"\n    or\n    // Case 3: Keyword argument exists in derived method but not in base method\n    exists(string argName |\n      methodInvocation.getAKeyword().getArg() = argName and\n      derivedMethod.getScope().getAnArg().(Name).getId() = argName and\n      not baseMethod.getScope().getAnArg().(Name).getId() = argName and\n      signatureMismatchDetails = \"an argument named '\" + argName + \"'\"\n    )\n  )\nselect baseMethod,\n  \"Overridden method signature does not match $@, where it is passed \" + signatureMismatchDetails +\n    \". Overriding method $@ matches the call.\", methodInvocation, \"call\", derivedMethod,\n  derivedMethod.descriptiveString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name NotImplemented is not an Exception\n * @description Detects code that raises 'NotImplemented' instead of 'NotImplementedError'.\n_______________ // 补全条件\n *              an exception class, but rather a special value used for binary operations.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Core Python language analysis libraries\nimport python\n\n// Specialized module for identifying NotImplemented misuse in exception handling\nimport Exceptions.NotImplemented\n\n// Identify expressions where NotImplemented is incorrectly used in raise statements\nfrom Expr problematicNotImplementedRaise\nwhere \n    // Detect raise statements that misuse NotImplemented instead of the proper\n    // NotImplementedError exception class\n    use_of_not_implemented_in_raise(_, problematicNotImplementedRaise)\nselect \n    // Report the problematic expression with guidance for correction\n    problematicNotImplementedRaise, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\"",
    "output": "*              This pattern leads to runtime type errors because NotImplemented is not"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/decompression-bomb]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects potential decompression bomb attacks where uncontrolled input",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Decompression Bomb Vulnerability\n * @description Detects potential decompression bomb attacks where uncontrolled input\n *              flows into decompression APIs without proper compression rate checks\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.8\n * @precision high\n * @id py/decompression-bomb\n * @tags security\n *       experimental\n *       external/cwe/cwe-409\n */\n\n// Core Python analysis framework\nimport python\n// Specialized decompression bomb detection capabilities\nimport experimental.semmle.python.security.DecompressionBomb\n// Path graph utilities for visualizing data flows\nimport BombsFlow::PathGraph\n\n// Identify vulnerable data flow paths\nfrom BombsFlow::PathNode untrustedSource, BombsFlow::PathNode decompressionSink\n// Verify complete data flow path exists from source to sink\nwhere BombsFlow::flowPath(untrustedSource, decompressionSink)\n// Report security finding with flow context\nselect decompressionSink.getNode(), \n       untrustedSource, \n       decompressionSink, \n       \"This uncontrolled decompression operation originates from $@.\", \n       untrustedSource.getNode(),\n       \"untrusted user input that could cause excessive resource consumption\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary pass\n * @description Unnecessary 'pass' statement\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unnecessary-pass\n */\n\nimport python\n\n/**\n * Determines if an expression statement is a docstring.\n * Docstrings are typically the first statement in modules, classes, or functions.\n */\npredicate isDocString(ExprStmt exprStmt) {\n  // Check if the expression value is a Unicode or Bytes literal\n  exprStmt.getValue() instanceof Unicode or exprStmt.getValue() instanceof Bytes\n}\n\n/**\n * Checks if a statement list contains a docstring as its first element.\n * Docstrings must be the initial statement in a scope (module/class/function).\n_______________ // 补全条件\npredicate containsDocString(StmtList stmtList) {\n  // Verify parent is a scope and first statement is a docstring\n  stmtList.getParent() instanceof Scope and\n  isDocString(stmtList.getItem(0))\n}\n\nfrom Pass unnecessaryPass, StmtList enclosingStmtList\nwhere\n  // The pass statement must be contained in this statement list\n  enclosingStmtList.getAnItem() = unnecessaryPass and\n  (\n    // Case 1: Exactly 2 statements without docstring\n    strictcount(enclosingStmtList.getAnItem()) = 2 and \n    not containsDocString(enclosingStmtList)\n    or\n    // Case 2: More than 2 statements (docstring presence irrelevant)\n    strictcount(enclosingStmtList.getAnItem()) > 2\n  )\nselect unnecessaryPass, \"Unnecessary 'pass' statement.\"",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-temporary-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies deprecated temporary file creation methods that introduce security risks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insecure temporary file\n * @description Identifies deprecated temporary file creation methods that introduce security risks.\n * @kind problem\n * @id py/insecure-temporary-file\n * @problem.severity error\n * @security-severity 7.0\n * @sub-severity high\n * @precision high\n * @tags external/cwe/cwe-377\n *       security\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Define API nodes for insecure temporary file creation functions\nAPI::Node insecureTempFileFunction(string modName, string fnName) {\n  // Match known insecure tempfile functions by module and name\n  (\n    modName = \"tempfile\" and fnName = \"mktemp\"\n    or\n    modName = \"os\" and\n    (\n      fnName = \"tmpnam\"\n      or\n      fnName = \"tempnam\"\n    )\n  ) and\n  // Retrieve the corresponding function node from the module\n  result = API::moduleImport(modName).getMember(fnName)\n}\n\n// Identify all calls to insecure temporary file functions\nfrom Call insecureCall, string modName, string fnName\n// Ensure the call targets one of the identified insecure functions\nwhere insecureTempFileFunction(modName, fnName).getACall().asExpr() = insecureCall\n// Report the insecure call with detailed context\nselect insecureCall, \n       \"Use of deprecated function \" + modName + \".\" + fnName + \n       \" creates security vulnerability in temporary file handling\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Hardcoded SECRET_KEY in Web Applications\n * @description Static assignment of SECRET_KEY in Flask/Django applications\n * may enable authentication bypass attacks\n * @kind path-problem\n * @id py/webapp-hardcoded-secret\n * @problem.severity error\n * @security-severity 8.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.filters.Tests\n\n// Framework classification for web applications\nnewtype WebFrameworkType =\n  FlaskFramework() or\n  DjangoFramework()\n\n// Configuration for secret key analysis with framework tracking\nprivate module SecretKeyAnalysisConfig implements DataFlow::StateConfigSig {\n  // Framework state representation\n  class FlowState = WebFrameworkType;\n\n  // Identify hardcoded string sources\n  predicate isSource(DataFlow::Node sourceNode, FlowState framework) {\n    exists(string secretLiteral |\n      secretLiteral = sourceNode.asExpr().(StringLiteral).getText() and\n      secretLiteral.length() > 0 and\n      // Filter non-secret placeholder values\n      not secretLiteral.matches([\"\", \"changeme\", \"secret\", \"password\", \"default\"]) and\n      (framework = FlaskFramework() or framework = DjangoFramework())\n    )\n  }\n\n  // Identify secret key assignment sinks\n  predicate isSink(DataFlow::Node sinkNode, FlowState framework) {\n    exists(DataFlow::Node secretKeyAttr |\n      secretKeyAttr.asExpr().(Attribute).getName() = \"SECRET_KEY\" and\n      sinkNode.asExpr() = secretKeyAttr.asExpr().(Attribute).getObject() and\n      (framework = FlaskFramework() or framework = DjangoFramework())\n    )\n  }\n_______________ // 补全条件\n  // Define sanitization barriers\n  predicate isBarrier(DataFlow::Node node) {\n    // Exclude standard library components\n    node.getLocation().getFile().inStdlib()\n    or\n    // Exclude test/demo files except specific test cases\n    exists(string testFilePath |\n      testFilePath = node.getLocation().getFile().getRelativePath() and\n      testFilePath.matches([\"%test%\", \"%demo%\", \"%example%\", \"%sample%\"]) and\n      not testFilePath.matches(\"%query-tests/Security/CWE-287%\")\n    )\n    or\n    // Filter obvious non-secret values\n    exists(string placeholderLiteral |\n      placeholderLiteral = node.asExpr().(StringLiteral).getText() and\n      placeholderLiteral in [\"\", \"changeme\", \"secret\", \"password\", \"default\"]\n    )\n  }\n\n  // Enable differential analysis in incremental mode\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global taint tracking with framework state awareness\nmodule SecretKeyTaintFlow = TaintTracking::GlobalWithState<SecretKeyAnalysisConfig>;\n\n// Import path graph for vulnerability flow visualization\nimport SecretKeyTaintFlow::PathGraph\n\n// Query to identify hardcoded secret key assignments\nfrom SecretKeyTaintFlow::PathNode sourceNode, SecretKeyTaintFlow::PathNode sinkNode\nwhere SecretKeyTaintFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode, sourceNode, sinkNode, \"SECRET_KEY assigned from $@.\", sourceNode,\n  \" hardcoded value\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unknown-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测非对称密钥生成操作中使用了无法静态验证的密钥大小配置",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 非对称密钥生成中密钥大小不可静态验证\n * @description 检测非对称密钥生成操作中使用了无法静态验证的密钥大小配置\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查询所有非对称密钥生成操作，其中密钥大小无法静态验证\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node configSource, string algorithmName\nwhere\n  // 验证密钥生成操作是否存在静态验证的密钥大小\n  not keyGenOperation.hasKeySize(configSource) and\n  // 获取密钥配置源\n  configSource = keyGenOperation.getKeyConfigSrc() and\n  // 获取使用的加密算法名称\n  algorithmName = keyGenOperation.getAlgorithm().getName()\nselect keyGenOperation,\n  // 报告问题，显示算法名称和配置源位置\n  \"算法 \" + algorithmName + \" 的密钥生成使用了无法静态验证的密钥大小，配置源位于 $@\", configSource, configSource.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cookie poisoning vulnerabilities where cookies are built using",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cookie construction from user-controlled data\n * @description Detects cookie poisoning vulnerabilities where cookies are built using \n *              untrusted user input, allowing attackers to manipulate cookie values\n *              and compromise application security.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// Import core Python analysis framework\nimport python\n\n// Import specialized cookie injection vulnerability detection module\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Import path graph utilities for data flow visualization\nimport CookieInjectionFlow::PathGraph\n\n// Identify tainted input sources and vulnerable cookie sinks\nfrom CookieInjectionFlow::PathNode taintedSource, CookieInjectionFlow::PathNode cookieSink\n// Verify data flow propagation from user input to cookie creation\nwhere CookieInjectionFlow::flowPath(taintedSource, cookieSink)\n// Generate vulnerability report with detailed flow information\nselect \n  cookieSink.getNode(), \n  taintedSource, \n  cookieSink, \n  \"Cookie is constructed from a $@.\", \n  taintedSource.getNode(),\n  \"user-controlled input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-use-with]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects 'try-finally' blocks that only close a resource,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Should use a 'with' statement\n * @description Detects 'try-finally' blocks that only close a resource,\n *              which can be simplified using 'with' statements for better readability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/should-use-with\n */\n\nimport python\n\n// Determines if a call invokes the 'close' method\npredicate isCloseCall(Call call) { \n    exists(Attribute attr | call.getFunc() = attr and attr.getName() = \"close\") \n}\n\n// Checks if a finally block contains only a single close call\npredicate isFinallyBlockWithSingleClose(Try tryStmt, Call call) {\n    exists(ExprStmt stmt |\n        tryStmt.getAFinalstmt() = stmt and \n        stmt.getValue() = call and \n        strictcount(tryStmt.getAFinalstmt()) = 1\n    )\n}\n\n// Verifies if a control flow node references a context manager instance\npredicate referencesContextManager(ControlFlowNode flowNode, ClassValue cls) {\n    forex(Value v | flowNode.pointsTo(v) | v.getClass() = cls) and\n    cls.isContextManager()\n}\n\n// Identifies try-finally blocks that only close context managers\nfrom Call closeCall, Try tryStmt, ClassValue cls\nwhere\n    isFinallyBlockWithSingleClose(tryStmt, closeCall) and\n    isCloseCall(closeCall) and\n    exists(ControlFlowNode objFlowNode | \n        objFlowNode = closeCall.getFunc().getAFlowNode().(AttrNode).getObject() and\n        referencesContextManager(objFlowNode, cls)\n    )\nselect closeCall,\n    \"Instance of context-manager class $@ is closed in a finally block. Consider using 'with' statement.\",\n    cls, cls.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Model Editor Framework Endpoint Discovery\n * @description Identifies and catalogs all operational endpoints within the Model Editor's \n *              framework environment, excluding test implementations and auto-generated code.\n * @kind table\n * @id py/utils/modeleditor/framework-mode-endpoints\n * @tags modeleditor endpoints framework-mode\n */\n\nimport modeling.ModelEditor\n\n_______________ // 补全条件\nselect \n  modelEditorEndpoint,                     // Core endpoint reference\n  modelEditorEndpoint.getNamespace(),      // Namespace containing the endpoint\n  modelEditorEndpoint.getClass(),          // Parent class defining the endpoint\n  modelEditorEndpoint.getFunctionName(),   // Method/function name of the endpoint\n  modelEditorEndpoint.getParameters(),     // Parameter signature of the endpoint\n  modelEditorEndpoint.getSupportedStatus(), // Supported HTTP status codes\n  modelEditorEndpoint.getFileName(),       // Source file containing endpoint definition\n  modelEditorEndpoint.getSupportedType(),  // Supported data types for the endpoint\n  modelEditorEndpoint.getKind()            // Endpoint classification (method/attribute)",
    "output": "from Endpoint modelEditorEndpoint"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name 非对称密钥生成中的未知密钥大小\n * @description 检测非对称加密算法生成密钥时，无法在静态分析阶段确定密钥长度的情况\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 检测非对称密钥生成操作中密钥大小无法静态确认的情况\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node keyConfigSource, string algoName\nwhere\n  // 获取密钥生成操作的配置源节点\n  keyConfigSource = keyGenOperation.getKeyConfigSrc()\n  and\n  // 获取使用的加密算法名称\n  algoName = keyGenOperation.getAlgorithm().getName()\n  and\n  // 验证密钥生成操作缺乏静态可验证的密钥大小参数\n  not keyGenOperation.hasKeySize(keyConfigSource)\nselect keyGenOperation,\n  // 生成包含算法信息和配置源的问题报告\n  \"用于算法 \" + algoName.toString() + \" 的密钥生成使用了无法静态验证的密钥大小，在配置源 $@\", keyConfigSource, keyConfigSource.toString()",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/init-calls-subclass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a class's `__init__` method invokes another method that can be overridden",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Constructor calls overridable method\n * @description Detects when a class's `__init__` method invokes another method that can be overridden \n *              by subclasses, which may lead to observing a partially initialized object.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/init-calls-subclass\n */\n\nimport python\n\n// Identify potentially dangerous method calls within class constructors\n// that could be overridden by subclasses, leading to initialization issues\nfrom\n  ClassObject superClass, string targetMethodName, Call riskyConstructorCall,\n  FunctionObject overriddenMethod, FunctionObject baseMethod,\n  FunctionObject classConstructor, SelfAttribute instanceMethodRef\nwhere\n  // Locate the parent class constructor and identify the method being called\n  superClass.declaredAttribute(\"__init__\") = classConstructor and\n  baseMethod = superClass.declaredAttribute(targetMethodName) and\n  \n  // Verify the method call occurs inside the constructor's scope\n  riskyConstructorCall.getScope() = classConstructor.getFunction() and\n  \n  // Confirm the call is to a self attribute that matches our target method\n  riskyConstructorCall.getFunc() = instanceMethodRef and\n  instanceMethodRef.getName() = targetMethodName and\n  \n  // Ensure a subclass exists that overrides this parent method\n  overriddenMethod.overrides(baseMethod)\n// Report the risky constructor call with details about the overridden method\nselect riskyConstructorCall, \"Call to self.$@ in __init__ method, which is overridden by $@.\", \n  baseMethod, targetMethodName, overriddenMethod, overriddenMethod.descriptiveString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies cryptographic implementations that employ elliptic curve algorithms",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Identifies cryptographic implementations that employ elliptic curve algorithms \n *              which are either unauthorized or deemed cryptographically weak, potentially \n *              leading to security vulnerabilities.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm ellipticCurveOp, string securityWarning, string curveName\nwhere\n  // Define the set of cryptographically secure elliptic curves\n  exists(string secureCurve |\n    secureCurve = [\n      \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n      \"SECP384R1\",              // P-384 curve\n      \"SECP521R1\",              // P-521 curve\n      \"ED25519\",                // Ed25519 curve\n      \"X25519\"                  // X25519 curve\n    ]\n  |\n    // Retrieve the curve name from the elliptic curve cryptographic operation\n    curveName = ellipticCurveOp.getCurveName() and\n    (\n      // Scenario 1: The curve algorithm is not recognized\n      curveName = unknownAlgorithm() and\n      securityWarning = \"Use of unrecognized curve algorithm.\"\n      or\n      // Scenario 2: The curve algorithm is recognized but not secure\n      curveName != unknownAlgorithm() and\n      not curveName = secureCurve and\n      securityWarning = \"Use of weak curve algorithm \" + curveName + \".\"\n    )\n  )\nselect ellipticCurveOp, securityWarning"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/duplicate-key-dict-literal]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies dictionary literals containing duplicate keys, where earlier key-value pairs are silently overwritten by later ones.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Duplicate key in dict literal\n * @description Identifies dictionary literals containing duplicate keys, where earlier key-value pairs are silently overwritten by later ones.\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/duplicate-key-dict-literal\n */\n\nimport python\nimport semmle.python.strings\n\n/**\n * Converts dictionary keys to a normalized string format for comparison.\n * Handles numeric literals and string literals (including byte and unicode strings).\n */\npredicate normalizedKeyFormat(Dict dictLiteral, Expr key, string normalizedValue) {\n  key = dictLiteral.getAKey() and\n  (\n    // Numeric keys: convert directly to string representation\n    normalizedValue = key.(Num).getN()\n    or\n    // String literals: add type prefix and validate content\n    not \"�\" = normalizedValue.charAt(_) and\n    exists(StringLiteral str | \n      str = key and\n      (\n        // Unicode strings: prefix with 'u'\n        normalizedValue = \"u\\\"\" + str.getText() + \"\\\"\" and str.isUnicode()\n        or\n        // Byte strings: prefix with 'b'\n        normalizedValue = \"b\\\"\" + str.getText() + \"\\\"\" and not str.isUnicode()\n      )\n    )\n  )\n}\n\n// Find dictionary literals with duplicate keys\nfrom Dict dictLiteral, Expr originalKey, Expr duplicateKey\nwhere\n  // Both keys have identical normalized representations\n  exists(string normalizedValue | \n    normalizedKeyFormat(dictLiteral, originalKey, normalizedValue) and \n    normalizedKeyFormat(dictLiteral, duplicateKey, normalizedValue) and \n    originalKey != duplicateKey\n  ) and\n  // Verify the ordering relationship between keys\n  (\n    // Case 1: Keys in same basic block with originalKey before duplicateKey\n    exists(BasicBlock block, int originalPos, int duplicatePos |\n      originalKey.getAFlowNode() = block.getNode(originalPos) and\n      duplicateKey.getAFlowNode() = block.getNode(duplicatePos) and\n      originalPos < duplicatePos\n    )\n    or\n    // Case 2: Original key's block strictly dominates duplicate key's block\n    originalKey.getAFlowNode().getBasicBlock().strictlyDominates(\n      duplicateKey.getAFlowNode().getBasicBlock()\n    )\n  )\n\n// Report the first occurrence of the duplicate key and indicate which later key overwrites it\nselect originalKey, \n       \"Dictionary key \" + repr(originalKey) + \" is subsequently $@.\", \n       duplicateKey, \n       \"overwritten\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-of-constants]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies comparisons between two constant values in the code,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comparison of constants\n * @description Identifies comparisons between two constant values in the code,\n *              which always yield a fixed result but are less readable than\n *              directly using True or False.\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/comparison-of-constants\n */\n\nimport python\n\n// Define variables for the comparison expression and its operands\nfrom Compare constComparison, Expr lhsValue, Expr rhsValue\nwhere\n  // Ensure it's a comparison operation and get the left and right operands\n  constComparison.compares(lhsValue, _, rhsValue)\n  and\n  // Check that both operands are constant values\n  lhsValue.isConstant() and rhsValue.isConstant()\n  and\n  // Exclude constant comparisons used in assert statements (may have special purpose)\n  not exists(Assert assertion | assertion.getTest() = constComparison)\nselect constComparison, \"Comparison of constants; use 'True' or 'False' instead.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/command-line-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects command execution vulnerabilities where external input",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Uncontrolled command line\n * @description Detects command execution vulnerabilities where external input\n *              can manipulate command behavior through injection attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/command-line-injection\n * @tags correctness\n *       security\n *       external/cwe/cwe-078\n *       external/cwe/cwe-088\n */\n\n// Import Python language support for code analysis\nimport python\n\n// Import security dataflow framework for command injection detection\nimport semmle.python.security.dataflow.CommandInjectionQuery\n\n// Import path graph representation for vulnerability flow visualization\nimport CommandInjectionFlow::PathGraph\n\n// Identify untrusted input sources and command execution sinks\nfrom CommandInjectionFlow::PathNode maliciousInputSource, \n     CommandInjectionFlow::PathNode vulnerableCommandSink\n// Validate data flow path exists between source and sink\nwhere CommandInjectionFlow::flowPath(maliciousInputSource, vulnerableCommandSink)\n// Report vulnerability with context about tainted input\nselect vulnerableCommandSink.getNode(), \n       maliciousInputSource, \n       vulnerableCommandSink, \n       \"This command execution depends on a $@.\", \n       maliciousInputSource.getNode(),\n       \"user-controlled input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects functions that start with an uppercase letter,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed function\n * @description Detects functions that start with an uppercase letter,\n *              which contradicts Python naming conventions and reduces code clarity.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python\n\n// Helper predicate to identify functions with names starting with an uppercase letter\npredicate hasUppercaseName(Function func) {\n  exists(string firstChar |\n    firstChar = func.getName().prefix(1) and\n    not firstChar = firstChar.toLowerCase()\n  )\n}\n\n// Main query to find functions with naming convention violations\nfrom Function func\nwhere\n  // Check if the function is part of the source code\n  func.inSource() and\n  \n  // Verify the function name starts with an uppercase letter\n  hasUppercaseName(func) and\n  \n  // Exclude duplicate reports for functions with the same name in the same file\n  not exists(Function duplicateFunc |\n    duplicateFunc != func and\n    duplicateFunc.getLocation().getFile() = func.getLocation().getFile() and\n    hasUppercaseName(duplicateFunc)\n  )\nselect func, \"Function names should start in lowercase.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides details about alert suppressions in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Provides details about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import CodeQL's alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing utilities\nprivate import semmle.python.Comment as P\n\n// Represents a Python AST node that can track its location\nclass AstNode instanceof P::AstNode {\n  // Check if node has specific location information\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Verify location matches parent class location data\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Get string representation of the node\n  string toString() { result = super.toString() }\n}\n\n// Represents a single-line Python comment with location tracking\nclass SingleLineComment instanceof P::Comment {\n  // Check if comment has specific location information\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Verify location matches parent class location data\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Get the text content of the comment\n  string getText() { result = super.getContents() }\n\n  // Get string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships between AST nodes and comments\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Represents a noqa-style suppression comment that can suppress alerts\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Initialize by checking comment matches noqa pattern\n  NoqaSuppressionComment() {\n    // Match case-insensitive noqa with optional suffix\n    super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Get the annotation identifier for this suppression\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define the code range covered by this suppression\n  override predicate covers(\n    string sourceFile, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Get comment location and verify it starts at column 1\n    this.hasLocationInfo(sourceFile, beginLine, _, finishLine, finishColumn) and\n    beginColumn = 1\n  }\n}"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name JWT encoding with empty key or algorithm\n * @description Identifies JWT token encodings that employ an empty secret key or\n *              undefined algorithm, which can lead to security weaknesses in\n *              token verification processes.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-empty-secret-or-algorithm\n * @tags security\n *       experimental\n */\n\n// Import necessary modules for Python code analysis and JWT framework identification\nimport python\nimport experimental.semmle.python.Concepts\nimport experimental.semmle.python.frameworks.JWT\n\n// Declare variables representing JWT encoding operations and the identified vulnerability\nfrom JwtEncoding jwtEncodingOperation, string vulnerabilityType\nwhere\n  (\n    vulnerabilityType = \"algorithm\" and \n    isEmptyOrNone(jwtEncodingOperation.getAlgorithm())\n  )\n  or\n  (\n    vulnerabilityType = \"key\" and \n    isEmptyOrNone(jwtEncodingOperation.getKey())\n_______________ // 补全条件\nselect jwtEncodingOperation, \"This JWT encoding has an empty \" + vulnerabilityType + \", potentially compromising token security.\"",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Remote source URL redirection vulnerability\n * @description Detects potential security risks where URL redirection\n *              is performed using unvalidated user input, which could\n *              lead to redirects to malicious websites.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @sub-severity low\n * @id py/url-redirection\n * @tags security\n *       external/cwe/cwe-601\n * @precision high\n */\n\n// Import necessary CodeQL modules for Python security analysis\nimport python\n\n// Import the URL redirection data flow taint tracking module\nimport semmle.python.security.dataflow.UrlRedirectQuery\n\n// Import the path graph representation for visualization\nimport UrlRedirectFlow::PathGraph\n\n// Identify paths from untrusted input sources to URL redirection sinks\nfrom \n  // Source node representing untrusted user input\n  UrlRedirectFlow::PathNode untrustedInputSource, \n_______________ // 补全条件\n  UrlRedirectFlow::PathNode urlRedirectionSink\nwhere \n  // Verify that data flows from the untrusted input to the redirection sink\n  UrlRedirectFlow::flowPath(untrustedInputSource, urlRedirectionSink)\nselect \n  // The location where the potentially vulnerable redirection occurs\n  urlRedirectionSink.getNode(), \n  // The complete data flow path from source to sink\n  untrustedInputSource, urlRedirectionSink, \n  // Descriptive message highlighting the source of untrusted data\n  \"URL redirection vulnerability due to unvalidated $@.\", \n  untrustedInputSource.getNode(), \n  \"user input\"",
    "output": "// Sink node where URL redirection occurs"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak key generation key size (< 2048 bits)\n * @description\n * Identifies asymmetric cryptographic key generation operations\n * using insecure key sizes below 2048 bits, vulnerable to brute-force attacks.\n * @id py/weak-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Locate asymmetric key generation operations with weak cryptographic parameters\nfrom AsymmetricKeyGen keyGenOp, DataFlow::Node configNode, int keyBitSize, string algoName\nwhere\n  // Retrieve cryptographic configuration details\n  keyBitSize = keyGenOp.getKeySizeInBits(configNode) and\n  algoName = keyGenOp.getAlgorithm().getName() and\n  // Apply security constraints: check key strength and exclude elliptic curve algorithms\n  keyBitSize < 2048 and\n_______________ // 补全条件\n// Report findings with contextual vulnerability information\nselect keyGenOp,\n  \"Weak asymmetric key size (\" + keyBitSize.toString() + \" bits) for algorithm \" +\n    algoName + \" configured at $@\", configNode, configNode.toString()",
    "output": "not isEllipticCurveAlgorithm(algoName, _)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 指向关系分析有效性评估\n * @description 该查询评估指向关系分析的有效性指标，通过计算\"有价值的分析结果\"在\"总体分析结果\"中的比例，\n * 来衡量分析过程的精确度和信息密度。该指标有助于识别分析引擎的效率，特别是在排除无价值节点\n * （如参数、名称常量和不可变字面量）后的分析质量。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n_______________ // 补全条件\n * 判断控制流节点是否为无分析价值的节点。\n * 当节点属于以下情况时，认为其分析价值较低：函数参数、名称常量或不可变字面量。\n */\npredicate isTrivialNode(ControlFlowNode node) {\n  node.getNode() instanceof Parameter\n  or\n  node instanceof NameConstantNode\n  or\n  node.getNode() instanceof ImmutableLiteral\n}\n\n// 计算指向关系分析的质量指标\nfrom \n  int valuableAnalysisCount,      // 有价值的分析结果总数\n  int sourceValuableCount,        // 源文件中的有价值分析结果数量\n  int totalAnalysisCount,         // 所有指向关系分析结果的总数\n  float effectivenessScore        // 分析质量分数\nwhere\n  // 计算有价值的分析结果总数（排除无分析价值的节点）\n  valuableAnalysisCount =\n    strictcount(ControlFlowNode node, Object pointedObject, ClassObject pointedClass |\n      node.refersTo(pointedObject, pointedClass, _) and not isTrivialNode(node)\n    ) and\n  \n  // 计算源文件中的有价值分析结果数量\n  sourceValuableCount =\n    strictcount(ControlFlowNode node, Object pointedObject, ClassObject pointedClass |\n      node.refersTo(pointedObject, pointedClass, _) and\n      not isTrivialNode(node) and\n      exists(node.getScope().getEnclosingModule().getFile().getRelativePath())\n    ) and\n  \n  // 计算所有指向关系分析结果的总数\n  totalAnalysisCount =\n    strictcount(ControlFlowNode node, PointsToContext context, Object pointedObject, \n      ClassObject pointedClass, ControlFlowNode originalNode | \n      PointsTo::points_to(node, context, pointedObject, pointedClass, originalNode)\n    ) and\n  \n  // 计算分析质量分数：源文件有价值分析结果占总体分析结果的百分比\n  effectivenessScore = 100.0 * sourceValuableCount / totalAnalysisCount\nselect valuableAnalysisCount, sourceValuableCount, totalAnalysisCount, effectivenessScore",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects data flow from untrusted sources to cookie assignments,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted User Input Flow to Cookie Assignment\n * @description Detects data flow from untrusted sources to cookie assignments,\n *              which could lead to injection attacks affecting cookie security.\n * @id py/untrusted-cookie-injection\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 8.7\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\nfrom \n  CookieInjectionFlow::PathNode sourceNode, \n  CookieInjectionFlow::PathNode sinkNode\nwhere \n  CookieInjectionFlow::flowPath(sourceNode, sinkNode)\nselect \n  sinkNode.getNode(), \n  sourceNode, \n  sinkNode, \n  \"Cookie value constructed from $@.\", \n  sourceNode.getNode(), \n  \"untrusted user input\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name CSRF protection weakened or disabled\n * @description Identifies application configurations where Cross-Site Request Forgery (CSRF) \n *              safeguards are either deactivated or compromised, potentially exposing\n *              the system to CSRF-based attacks.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/csrf-protection-disabled\n * @tags security\n *       external/cwe/cwe-352\n */\n\nimport python\nimport semmle.python.Concepts\n\n// Filter to identify CSRF configurations from production environments (excluding test files)\n_______________ // 补全条件\n  // Exclude test files (files containing \"test\" in their path)\n  not csrfConfig.getLocation().getFile().getAbsolutePath().matches(\"%test%\")\n}\n\n// Filter to identify CSRF configurations with security vulnerabilities\npredicate hasCsrfVulnerability(Http::Server::CsrfProtectionSetting csrfConfig) {\n  // Verify if CSRF verification is disabled and no local CSRF protection is active\n  csrfConfig.getVerificationSetting() = false and\n  not exists(Http::Server::CsrfLocalProtectionSetting localCsrfProtection | \n             localCsrfProtection.csrfEnabled()) and\n  isProductionEnvironmentConfig(csrfConfig)\n}\n\n// Main query to detect vulnerable CSRF configurations while maintaining analysis consistency\n// This method reduces false positives by ensuring all production configs are vulnerable\nfrom Http::Server::CsrfProtectionSetting vulnerableCsrfConfig\nwhere\n  // Validate that all production configurations are vulnerable to eliminate false positives from virtual projects\n  forall(Http::Server::CsrfProtectionSetting productionCsrfConfig | \n         isProductionEnvironmentConfig(productionCsrfConfig) | \n         hasCsrfVulnerability(productionCsrfConfig)) and\n  // The current configuration is vulnerable\n  hasCsrfVulnerability(vulnerableCsrfConfig)\nselect vulnerableCsrfConfig, \"Potential CSRF vulnerability due to forgery protection being disabled or weakened.\"",
    "output": "predicate isProductionEnvironmentConfig(Http::Server::CsrfProtectionSetting csrfConfig) {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Analyzes and counts various type annotation patterns in Python code,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Analyzes and counts various type annotation patterns in Python code,\n *              focusing on parameters, return types, and variable annotations.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents a native type in Python (e.g., int, str, bool)\nclass NativeType extends Name {\n  NativeType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TypeAnnotatableElement =\n  TFunctionWithReturnType(FunctionExpr func) { exists(func.getReturns()) } or\n  TParameterWithType(Parameter param) { exists(param.getAnnotation()) } or\n  TAssignmentWithType(AnnAssign stmt) { exists(stmt.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class TypeAnnotatedElement extends TypeAnnotatableElement {\n  string toString() { result = \"TypeAnnotatedElement\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass FunctionWithReturnType extends TFunctionWithReturnType, TypeAnnotatedElement {\n  FunctionExpr func;\n\n  FunctionWithReturnType() { this = TFunctionWithReturnType(func) }\n  override Expr getAnnotation() { result = func.getReturns() }\n}\n\n// Parameters with type annotations\nclass ParameterWithType extends TParameterWithType, TypeAnnotatedElement {\n  Parameter param;\n\n  ParameterWithType() { this = TParameterWithType(param) }\n  override Expr getAnnotation() { result = param.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AssignmentWithType extends TAssignmentWithType, TypeAnnotatedElement {\n  AnnAssign assign;\n\n  AssignmentWithType() { this = TAssignmentWithType(assign) }\n  override Expr getAnnotation() { result = assign.getAnnotation() }\n}\n\n// Type classification predicates\n\n/** Holds if `expr` is a forward declaration (string literal) of a type. */\npredicate isStringLiteralType(Expr expr) { expr instanceof StringLiteral }\n\n/** Holds if `expr` is a type that may be difficult to analyze. */\npredicate isComplexTypeAnnotation(Expr expr) {\n  (expr instanceof Subscript and not isOptionalTypeAnnotation(expr)) or\n  expr instanceof Tuple or\n  expr instanceof List\n}\n\n/** Holds if `expr` is a type of the form `Optional[...]`. */\npredicate isOptionalTypeAnnotation(Subscript expr) { expr.getObject().(Name).getId() = \"Optional\" }\n\n/** Holds if `expr` is a simple type (non-built-in identifier or attribute chain). */\npredicate isSimpleTypeAnnotation(Expr expr) {\n  (expr instanceof Name and not expr instanceof NativeType) or\n  isSimpleTypeAnnotation(expr.(Attribute).getObject())\n}\n\n/** Holds if `expr` is a built-in type. */\npredicate isNativeTypeAnnotation(Expr expr) { expr instanceof NativeType }\n\n// Computes type annotation metrics for different annotation categories\npredicate calculateTypeMetrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  (\n    // Parameter annotation metrics\n    category = \"Parameter annotation\" and\n    totalCount = count(ParameterWithType param) and\n    builtinCount = count(ParameterWithType param | isNativeTypeAnnotation(param.getAnnotation())) and\n    forwardDeclCount = count(ParameterWithType param | isStringLiteralType(param.getAnnotation())) and\n    simpleTypeCount = count(ParameterWithType param | isSimpleTypeAnnotation(param.getAnnotation())) and\n    complexTypeCount = count(ParameterWithType param | isComplexTypeAnnotation(param.getAnnotation())) and\n    optionalTypeCount = count(ParameterWithType param | isOptionalTypeAnnotation(param.getAnnotation()))\n  )\n  or\n  (\n    // Return type annotation metrics\n    category = \"Return type annotation\" and\n    totalCount = count(FunctionWithReturnType func) and\n    builtinCount = count(FunctionWithReturnType func | isNativeTypeAnnotation(func.getAnnotation())) and\n    forwardDeclCount = count(FunctionWithReturnType func | isStringLiteralType(func.getAnnotation())) and\n    simpleTypeCount = count(FunctionWithReturnType func | isSimpleTypeAnnotation(func.getAnnotation())) and\n    complexTypeCount = count(FunctionWithReturnType func | isComplexTypeAnnotation(func.getAnnotation())) and\n    optionalTypeCount = count(FunctionWithReturnType func | isOptionalTypeAnnotation(func.getAnnotation()))\n  )\n  or\n  (\n    // Annotated assignment metrics\n    category = \"Annotated assignment\" and\n    totalCount = count(AssignmentWithType assign) and\n    builtinCount = count(AssignmentWithType assign | isNativeTypeAnnotation(assign.getAnnotation())) and\n    forwardDeclCount = count(AssignmentWithType assign | isStringLiteralType(assign.getAnnotation())) and\n    simpleTypeCount = count(AssignmentWithType assign | isSimpleTypeAnnotation(assign.getAnnotation())) and\n    complexTypeCount = count(AssignmentWithType assign | isComplexTypeAnnotation(assign.getAnnotation())) and\n    optionalTypeCount = count(AssignmentWithType assign | isOptionalTypeAnnotation(assign.getAnnotation()))\n  )\n}\n\n// Query execution and output\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  calculateTypeMetrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Import shadowed by loop variable\n * @description Identifies instances where a loop variable's name conflicts with an imported module alias,\n *              which can lead to code confusion and potential runtime errors.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n_______________ // 补全条件\n * @deprecated\n * @precision very-high\n * @id py/import-shadowed-loop-variable\n */\n\n// Import Python analysis library for examining Python code structures\nimport python\n\n// Find loop variables that have the same name as imported modules\nfrom Variable iterVar, Name varNode\nwhere \n  // Check if the variable is defined as a loop target in a for-statement\n  exists(For iterationStmt | varNode = iterationStmt.getTarget()) and\n  // Establish that the name definition corresponds to our iteration variable\n  varNode.defines(iterVar) and\n  // Verify there's a conflicting import in an enclosing scope\n  exists(Import moduleImport, Name importAlias |\n    // Ensure the iteration variable and import alias have matching identifiers\n    importAlias.getId() = iterVar.getId() and\n    // Confirm the alias comes from an import statement\n    importAlias = moduleImport.getAName().getAsname() and\n    // Check that the import's scope contains the variable's scope\n    moduleImport.getScope() = iterVar.getScope().getScope*()\n  )\n// Output the problematic definition with an informative message\nselect varNode, \"Loop variable '\" + iterVar.getId() + \"' shadows an import.\"",
    "output": "* @sub-severity low"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Comparison of constants\n * @description 检测代码中常量之间的比较操作。这种比较总是产生固定的布尔结果，\n *              直接使用布尔值更易读且减少代码复杂性。\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/comparison-of-constants\n */\n\nimport python\n\n// 识别常量比较表达式\n_______________ // 补全条件\nwhere\n  // 获取比较操作的两个操作数并验证它们都是常量\n  exists(Expr leftExpr, Expr rightExpr |\n    constantComparison.compares(leftExpr, _, rightExpr) and\n    leftExpr.isConstant() and\n    rightExpr.isConstant()\n  ) and\n  // 排除断言语句中的常量比较（断言中可能需要显式表达式来增强可读性）\n  not exists(Assert assertStmt | assertStmt.getTest() = constantComparison)\nselect constantComparison, \"常量比较表达式应替换为 'True' 或 'False'\"",
    "output": "from Compare constantComparison"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects super() calls in old-style classes where they are unsupported.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description Detects super() calls in old-style classes where they are unsupported.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n// Identifies super() calls within old-style class contexts\npredicate superCallInOldStyleClass(Call superCall) {\n  exists(ClassObject oldStyleClass, Function method |\n    // Verify the call targets the 'super' function\n    superCall.getFunc().(Name).getId() = \"super\" and\n    // Ensure call is inside a function\n    superCall.getScope() = method and\n    // Verify function is class member\n    method.getScope() = oldStyleClass.getPyClass() and\n    // Confirm class is successfully analyzed\n    not oldStyleClass.failedInference() and\n    // Identify old-style classes (non-new-style)\n    not oldStyleClass.isNewStyle()\n  )\n}\n\n// Query for problematic super() calls\nfrom Call problematicSuperCall\nwhere superCallInOldStyleClass(problematicSuperCall)\nselect problematicSuperCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/pythagorean]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculating hypotenuse length using standard formula may cause numeric overflow.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Pythagorean calculation with sub-optimal numerics\n * @description Calculating hypotenuse length using standard formula may cause numeric overflow.\n * @kind problem\n * @tags accuracy\n * @problem.severity warning\n * @sub-severity low\n * @precision medium\n * @id py/pythagorean\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Unified detector for squaring operations (exponentiation or multiplication)\nDataFlow::ExprNode squaringOperation() {\n  exists(BinaryExpr mathOp | mathOp = result.asExpr() |\n    // Case 1: Squaring via exponentiation operator (x**2)\n    (mathOp.getOp() instanceof Pow and \n     mathOp.getRight().(IntegerLiteral).getN() = \"2\")\n    or\n    // Case 2: Squaring via multiplication operator (x*x)\n    (mathOp.getOp() instanceof Mult and \n     mathOp.getRight().(Name).getId() = mathOp.getLeft().(Name).getId())\n  )\n}\n\n// Identify problematic Pythagorean calculations\nfrom \n  DataFlow::CallCfgNode sqrtInvocation, \n  BinaryExpr addExpr, \n  DataFlow::ExprNode leftSquaredOp, \n  DataFlow::ExprNode rightSquaredOp\nwhere\n  // Verify math.sqrt() function call\n  sqrtInvocation = API::moduleImport(\"math\").getMember(\"sqrt\").getACall() and\n  \n  // Confirm addition operation as first argument\n  sqrtInvocation.getArg(0).asExpr() = addExpr and\n  addExpr.getOp() instanceof Add and\n  \n  // Map operands to data flow nodes\n  leftSquaredOp.asExpr() = addExpr.getLeft() and\n  rightSquaredOp.asExpr() = addExpr.getRight() and\n  \n  // Verify both operands are squaring operations\n  leftSquaredOp.getALocalSource() = squaringOperation() and\n  rightSquaredOp.getALocalSource() = squaringOperation()\nselect sqrtInvocation, \"Pythagorean calculation with sub-optimal numerics.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all cryptographic algorithm implementations across supported libraries,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comprehensive Cryptographic Algorithm Detection\n * @description Identifies all cryptographic algorithm implementations across supported libraries,\n *              including both core algorithms and block cipher modes.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Core imports: Python language support and cryptographic security concepts\nimport python\nimport semmle.python.Concepts\n\n// Identify cryptographic operations and extract algorithm identifiers\nfrom Cryptography::CryptographicOperation cryptographicOperation, string algorithmIdentifier\nwhere \n  // Capture either the primary algorithm name or block cipher mode\n  algorithmIdentifier = cryptographicOperation.getAlgorithm().getName()\n  or\n  algorithmIdentifier = cryptographicOperation.getBlockMode()\nselect cryptographicOperation, \"Detected cryptographic algorithm: \" + algorithmIdentifier"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Displays a treemap visualization showing the total number of lines deleted from each source file throughout the project's commit history.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File Deletion Metrics\n * @description Displays a treemap visualization showing the total number of lines deleted from each source file throughout the project's commit history.\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\n// Identify code modules and calculate their accumulated deletion statistics\nfrom Module codeModule, int totalDeletions\nwhere\n  // Verify that the module contains measurable code content\n  exists(codeModule.getMetrics().getNumberOfLinesOfCode()) and\n  // Compute the aggregate count of lines removed across all commits\n  totalDeletions = \n    sum(Commit commitRecord, int deletedLines |\n      // Obtain the number of lines deleted in each commit affecting this module\n      deletedLines = commitRecord.getRecentDeletionsForFile(codeModule.getFile()) and\n      // Exclude artificial commits that don't represent actual development changes\n      not artificialChange(commitRecord)\n    |\n      deletedLines\n    )\nselect codeModule, totalDeletions order by totalDeletions desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/nested-loops-with-same-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies nested loops where both inner and outer loops utilize the same iteration variable.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Nested loops reusing iteration variable\n * @description Identifies nested loops where both inner and outer loops utilize the same iteration variable.\n *              This pattern can cause the inner loop to overwrite the outer loop's variable,\n *              resulting in unexpected behavior and diminished code maintainability.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\nfrom For nestedLoop, For enclosingLoop, Variable reusedVar\nwhere \n  // Establish direct nesting relationship between loops\n  enclosingLoop.getBody().contains(nestedLoop) and\n  // Verify both loops define the same iteration variable\n  nestedLoop.getTarget().defines(reusedVar) and\n  enclosingLoop.getTarget().defines(reusedVar) and\n  // Check for variable usage outside inner loop scope but within outer loop\n  // This indicates potential interference between loop iterations\n  exists(Name variableAccess | \n    variableAccess.uses(reusedVar) and \n    enclosingLoop.contains(variableAccess) and \n    not nestedLoop.contains(variableAccess)\n  )\nselect nestedLoop, \n  \"Nested for loop reuses iteration variable '\" + reusedVar.getId() + \n  \"' from enclosing $@.\", \n  enclosingLoop, \n  \"outer for loop\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称加密算法检测\n * @description 识别代码中所有通过受支持库使用非对称密钥执行加密或密钥交换操作的位置。\n * @kind 问题\n * @id py/quantum-readiness/cbom/all-asymmetric-encryption-algorithms\n * @problem.severity 错误\n * @tags cbom\n_______________ // 补全条件\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 检索所有非对称加密算法的使用情况并生成安全警告信息\nfrom AsymmetricEncryptionAlgorithm encryptionInstance\nselect encryptionInstance, \"Use of algorithm \" + encryptionInstance.getEncryptionName()",
    "output": "*       密码学"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Failure to use secure cookies\n * @description Detects cookies that lack proper security attributes,\n *              making them vulnerable to interception in cleartext.\n * @kind problem\n * @problem.severity warning\n * @security-severity 5.0\n * @precision high\n * @id py/insecure-cookie\n * @tags security\n *       external/cwe/cwe-614\n *       external/cwe/cwe-1004\n *       external/cwe/cwe-1275\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.Concepts\n\n// Predicate to identify specific security vulnerabilities in cookie configuration\npredicate hasCookieSecurityIssue(Http::Server::CookieWrite cookieWrite, string vulnerabilityType, int vulnerabilityIndex) {\n  // Detect missing Secure flag (index 0)\n  cookieWrite.hasSecureFlag(false) and\n  vulnerabilityType = \"Secure\" and\n  vulnerabilityIndex = 0\n  or\n  // Detect missing HttpOnly flag (index 1)\n  cookieWrite.hasHttpOnlyFlag(false) and\n  vulnerabilityType = \"HttpOnly\" and\n  vulnerabilityIndex = 1\n  or\n  // Detect SameSite=None setting (index 2)\n  cookieWrite.hasSameSiteAttribute(any(Http::Server::CookieWrite::SameSiteNone v)) and\n  vulnerabilityType = \"SameSite\" and\n  vulnerabilityIndex = 2\n}\n\n// Predicate to generate appropriate security alert messages based on detected vulnerabilities\npredicate generateSecurityAlert(Http::Server::CookieWrite cookieWrite, string securityAlert) {\n  // Count the total number of security vulnerabilities found for this cookie\n  exists(int vulnerabilityCount | \n    vulnerabilityCount = strictcount(string vulnType | hasCookieSecurityIssue(cookieWrite, vulnType, _)) |\n    // Handle different scenarios based on vulnerability count\n    (\n      // Single vulnerability case\n      vulnerabilityCount = 1 and\n      securityAlert = any(string singleVuln | hasCookieSecurityIssue(cookieWrite, singleVuln, _)) + \" attribute\"\n    )\n    or\n    (\n      // Two vulnerabilities case\n      vulnerabilityCount = 2 and\n      securityAlert =\n        strictconcat(string vulnType, int idx | \n          hasCookieSecurityIssue(cookieWrite, vulnType, idx) | \n          vulnType, \n          \" and \" \n          order by idx\n        ) + \" attributes\"\n    )\n    or\n    (\n      // Three vulnerabilities case\n      vulnerabilityCount = 3 and\n      securityAlert = \"Secure, HttpOnly, and SameSite attributes\"\n    )\n  )\n}\n_______________ // 补全条件\n// Main query to identify cookies with security vulnerabilities and generate corresponding alerts\nfrom Http::Server::CookieWrite cookieWrite, string securityAlert\nwhere generateSecurityAlert(cookieWrite, securityAlert)\nselect cookieWrite, \"Cookie is added without the \" + securityAlert + \" properly set.\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-global]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies global variables declared outside module scope.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of the 'global' statement.\n * @description Identifies global variables declared outside module scope.\n *              This practice violates encapsulation, making code harder to\n *              maintain and debug due to unintended state changes.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/use-of-global\n */\n\nimport python\n\n// Identify global variables declared in non-module scopes\nfrom Global nonModuleGlobalVar, Scope varScope\nwhere \n  // Extract variable's scope and verify it's not module-level\n  varScope = nonModuleGlobalVar.getScope() and\n  not varScope instanceof Module\nselect \n  nonModuleGlobalVar, \n  \"Updating global variables except at module initialization is discouraged.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'import *' used\n * @description Using import * prevents some analysis\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// 引入Python分析库，用于检测Python代码中的模式\nimport python\n_______________ // 补全条件\n// 查找所有使用通配符导入的实例\nfrom ImportStar wildcardImport\n\n// 输出结果：标记每个通配符导入，并提示其可能导致的命名空间污染问题\nselect wildcardImport, \"Using 'from ... import *' pollutes the namespace.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks that operate on substrings of unparsed URLs are vulnerable to bypass attacks,\n *              as they don't account for the entire URL structure\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Returns regex pattern for common top-level domains used in URL validation\nprivate string getCommonTldRegex() { result = \"com|org|edu|gov|uk|net|io\" }\n\n// Determines if a string literal exhibits URL-like characteristics\npredicate exhibitsUrlFeatures(StringLiteral urlStrLiteral) {\n  exists(string literalContent | literalContent = urlStrLiteral.getText() |\n    literalContent.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + getCommonTldRegex() + \")(:[0-9]+)?/?\")\n    or\n    literalContent.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Detects expressions performing incomplete URL substring sanitization\npredicate performsIncompleteSanitization(Expr sanitizationExpr, StringLiteral urlStrLiteral) {\n  exhibitsUrlFeatures(urlStrLiteral) and\n  (\n    // Case 1: Direct string comparison operations\n    exists(Compare cmp | cmp = sanitizationExpr and cmp.compares(urlStrLiteral, any(In i), _))\n    or\n    // Case 2: Unsafe startswith usage\n    exists(Call unsafeMethodCall |\n      unsafeMethodCall = sanitizationExpr and\n      unsafeMethodCall.getFunc().(Attribute).getName() = \"startswith\" and\n_______________ // 补全条件\n      not urlStrLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n    )\n    or\n    // Case 3: Unsafe endswith usage\n    exists(Call unsafeMethodCall |\n      unsafeMethodCall = sanitizationExpr and\n      unsafeMethodCall.getFunc().(Attribute).getName() = \"endswith\" and\n      unsafeMethodCall.getArg(0) = urlStrLiteral and\n      not urlStrLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n    )\n  )\n}\n\n// Find expressions exhibiting incomplete URL substring sanitization patterns\nfrom Expr sanitizationExpr, StringLiteral urlStrLiteral\nwhere performsIncompleteSanitization(sanitizationExpr, urlStrLiteral)\nselect sanitizationExpr, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlStrLiteral,\n  urlStrLiteral.getText()",
    "output": "unsafeMethodCall.getArg(0) = urlStrLiteral and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incoming class dependencies\n * @description The number of classes that depend on a class.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n_______________ // 补全条件\n\nimport python\n\n// 检索每个类的传入耦合度（即依赖于该类的其他类的数量），并按耦合度从高到低排序\nfrom ClassMetrics classObj\nselect classObj, classObj.getAfferentCoupling() as couplingCount order by couplingCount desc",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies exception handlers that are unreachable because general exceptions\n *              are caught before specific ones that inherit from them in the same try block.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n/**\n * Extracts the exception class referenced by an exception handler.\n * @param exceptClause - The exception handler to analyze\n * @return - The ClassValue representing the exception type handled by this clause\n */\nClassValue extractExceptionClass(ExceptStmt exceptClause) { \n  exceptClause.getType().pointsTo(result) \n}\n\n/**\n * Identifies pairs of exception handlers where a base exception is caught\n * before a derived exception in the same try block, making the latter unreachable.\n * @param precedingHandler - The exception handler that appears first\n * @param baseException - The general exception type handled by the preceding handler\n * @param followingHandler - The exception handler that appears later\n * @param derivedException - The specific exception type handled by the following handler\n */\npredicate findIncorrectExceptOrdering(ExceptStmt precedingHandler, ClassValue baseException, \n                                     ExceptStmt followingHandler, ClassValue derivedException) {\n  // Verify both handlers are in the same try block with correct ordering\n  exists(int precedingIndex, int followingIndex, Try tryBlock |\n    precedingHandler = tryBlock.getHandler(precedingIndex) and\n    followingHandler = tryBlock.getHandler(followingIndex) and\n    precedingIndex < followingIndex\n  ) and\n  // Extract exception types for both handlers\n  baseException = extractExceptionClass(precedingHandler) and\n  derivedException = extractExceptionClass(followingHandler) and\n  // Confirm inheritance relationship (baseException is a superclass of derivedException)\n  baseException = derivedException.getASuperType()\n}\n\n// Main query that identifies unreachable exception handlers due to incorrect ordering\nfrom ExceptStmt followingHandler, ClassValue derivedException, \n     ExceptStmt precedingHandler, ClassValue baseException\nwhere findIncorrectExceptOrdering(precedingHandler, baseException, \n                                followingHandler, derivedException)\nselect followingHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  derivedException, derivedException.getName(), precedingHandler, \"except block\", baseException, baseException.getName()",
    "output": "* @name Unreachable 'except' block"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Generates information about alert suppressions in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import AlertSuppression utilities for handling suppression logic\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing capabilities\nprivate import semmle.python.Comment as P\n\n// Represents AST nodes with location tracking capabilities\nclass AstNode instanceof P::AstNode {\n  // Provides location details for the AST node\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Returns string representation of the node\n  string toString() { result = super.toString() }\n}\n\n// Represents single-line comments with location tracking\nclass SingleLineComment instanceof P::Comment {\n  // Provides location details for the comment\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Retrieves the text content of the comment\n  string getText() { result = super.getContents() }\n\n  // Returns string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships between AST nodes and comments\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * Represents a noqa suppression comment recognized by both pylint and pyflakes.\n * This suppression mechanism should also be respected by lgtm.\n */\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Constructor identifying noqa-formatted comments (case-insensitive)\n  NoqaSuppressionComment() {\n    this.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Returns the annotation identifier used for suppression\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Defines the code coverage scope of this suppression comment\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Ensures suppression applies to entire lines starting from column 1\n    this.hasLocationInfo(filePath, startLine, _, endLine, endCol) and\n    startCol = 1\n  }\n}"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Raising a tuple\n * @description Raising a tuple will result in all but the first element being discarded\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// Identify raise statements where the exception originates from a tuple\nfrom Raise raiseNode, DataFlow::LocalSourceNode tupleSource\nwhere\n  // Only applicable in Python 2 (Python 3 handles this as a type error)\n  major_version() = 2 and\n  // The source node must be a tuple expression\n_______________ // 补全条件\n  // Verify data flow from tuple to the exception being raised\n  exists(DataFlow::Node exceptionNode |\n    exceptionNode.asExpr() = raiseNode.getException() and\n    tupleSource.flowsTo(exceptionNode)\n  )\n/* Raising a tuple is a type error in Python 3, so is handled by the IllegalRaise query. */\nselect raiseNode,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleSource, \"tuple\"",
    "output": "tupleSource.asExpr() instanceof Tuple and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-ldap-auth]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies LDAP authentication implementations vulnerable due to missing security controls",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python Insecure LDAP Authentication\n * @description Identifies LDAP authentication implementations vulnerable due to missing security controls\n * @kind path-problem\n * @problem.severity error\n * @id py/insecure-ldap-auth\n * @tags security\n *       experimental\n *       external/cwe/cwe-522\n *       external/cwe/cwe-523\n */\n\n// Core analysis modules for LDAP vulnerability detection\nimport python\nimport experimental.semmle.python.security.LdapInsecureAuth\nimport LdapInsecureAuthFlow::PathGraph\n\n// Locate vulnerable authentication paths in LDAP configurations\nfrom \n  LdapInsecureAuthFlow::PathNode insecureAuthSource,\n  LdapInsecureAuthFlow::PathNode insecureAuthTarget\nwhere \n  LdapInsecureAuthFlow::flowPath(insecureAuthSource, insecureAuthTarget)\nselect \n  insecureAuthTarget.getNode(), \n  insecureAuthSource, \n  insecureAuthTarget, \n  \"Insecure LDAP authentication detected for this host\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call-to-non-callable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects invocations of objects that lack callability,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-callable invoked\n * @description Detects invocations of objects that lack callability,\n *              which would trigger runtime TypeError exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom \n  Call invocation, \n  Value referencedObject, \n  ClassValue objectType, \n  Expr callableExpr, \n  AstNode sourceLocation\nwhere\n  // Identify the expression being invoked in the call\n  callableExpr = invocation.getFunc() and\n  \n  // Resolve the expression to its concrete value and origin\n  callableExpr.pointsTo(referencedObject, sourceLocation) and\n  \n  // Determine the class type of the referenced object\n  objectType = referencedObject.getClass() and\n  \n  // Verify the object's class lacks callability\n  not objectType.isCallable() and\n  \n  // Ensure type inference was successful for accurate analysis\n  not objectType.failedInference(_) and\n  \n  // Exclude descriptor objects implementing __get__ method\n  // These objects might be callable through the descriptor protocol\n  not objectType.hasAttribute(\"__get__\") and\n  \n  // Filter out None values as they are explicitly non-callable\n  not referencedObject = Value::named(\"None\") and\n  \n  // Special case: exclude NotImplemented when used in raise statements\n  not use_of_not_implemented_in_raise(_, callableExpr)\nselect \n  invocation, \n  \"Call to a $@ of $@.\", \n  sourceLocation, \n  \"non-callable\", \n  objectType, \n  objectType.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/afferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the afferent coupling metric for each class, indicating how many other classes depend on it.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class Afferent Coupling Analysis\n * @description Measures the afferent coupling metric for each class, indicating how many other classes depend on it.\n *              High afferent coupling values suggest central components that may require careful modification\n *              due to their widespread impact on the system's modularity and maintainability.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\nfrom ClassMetrics targetClass\nwhere exists(targetClass.getAfferentCoupling())\nselect \n  targetClass,\n  targetClass.getAfferentCoupling() as dependencyCount\norder by dependencyCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects imports that cannot be resolved, potentially reducing analysis coverage and accuracy.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unresolved import\n * @description Detects imports that cannot be resolved, potentially reducing analysis coverage and accuracy.\n * @kind problem\n * @problem.severity info\n * @id py/import-failure\n */\n\n// Import the Python analysis library\nimport python\n\n/**\n * Locates alternative import expressions used as fallbacks in conditional or exception handling contexts.\n * This function identifies imports used in if/else branches or try/except blocks as alternatives to each other.\n */\nImportExpr getAlternativeImport(ImportExpr primaryImport) {\n  // Verify aliases exist for both the primary and alternative imports\n  exists(Alias primaryAlias, Alias alternativeAlias |\n    // Primary alias mapping\n    (primaryAlias.getValue() = primaryImport or primaryAlias.getValue().(ImportMember).getModule() = primaryImport) and\n    // Alternative alias mapping\n    (alternativeAlias.getValue() = result or alternativeAlias.getValue().(ImportMember).getModule() = result) and\n    (\n      // Check if imports are in different branches of conditional statements\n      exists(If conditional | \n        (conditional.getBody().contains(primaryImport) and conditional.getOrelse().contains(result))\n        or\n        (conditional.getBody().contains(result) and conditional.getOrelse().contains(primaryImport))\n      )\n      or\n      // Check if imports are in try and except blocks\n      exists(Try tryBlock | \n        (tryBlock.getBody().contains(primaryImport) and tryBlock.getAHandler().contains(result))\n        or\n        (tryBlock.getBody().contains(result) and tryBlock.getAHandler().contains(primaryImport))\n      )\n    )\n  )\n}\n\n/**\n * Determines if an import is specific to a particular operating system.\n * Returns the OS name if the import is platform-specific.\n */\nstring determineOSSpecificImport(ImportExpr platformImport) {\n  // Check if the imported module name matches OS-specific patterns\n  exists(string importedName | importedName = platformImport.getImportedModuleName() |\n    // Java-related imports\n    (importedName.matches(\"org.python.%\") or importedName.matches(\"java.%\")) and result = \"java\"\n    or\n    // macOS imports\n    importedName.matches(\"Carbon.%\") and result = \"darwin\"\n    or\n    // Windows imports\n    result = \"win32\" and\n    (\n      importedName = \"_winapi\" or\n      importedName = \"_win32api\" or\n      importedName = \"_winreg\" or\n      importedName = \"nt\" or\n      importedName.matches(\"win32%\") or\n      importedName = \"ntpath\"\n    )\n    or\n    // Linux imports\n    result = \"linux2\" and\n    (importedName = \"posix\" or importedName = \"posixpath\")\n    or\n    // Unsupported platform imports\n    result = \"unsupported\" and\n    (importedName = \"__pypy__\" or importedName = \"ce\" or importedName.matches(\"riscos%\"))\n  )\n}\n\n/**\n * Retrieves the current operating system platform from the Python interpreter.\n */\nstring getCurrentPlatform() { \n  py_flags_versioned(\"sys.platform\", result, major_version().toString()) \n}\n\n/**\n * Determines if an import is allowed to fail without being flagged.\n * An import is acceptable to fail if it has a working alternative or is OS-specific\n * for a different OS than the current one.\n */\npredicate isImportAcceptableToFail(ImportExpr importExpr) {\n  // Check if there's a working alternative import\n  getAlternativeImport(importExpr).refersTo(_)\n  or\n  // Check if the import is OS-specific but not for the current OS\n  determineOSSpecificImport(importExpr) != getCurrentPlatform()\n}\n\n/**\n * Represents a control flow node that tests the Python interpreter version.\n * These nodes typically conditionally import modules based on version compatibility.\n */\nclass InterpreterVersionTest extends ControlFlowNode {\n  InterpreterVersionTest() {\n    exists(string versionAttr |\n      versionAttr.matches(\"%version%\") and\n      this.(CompareNode).getAChild+().pointsTo(Module::named(\"sys\").attr(versionAttr))\n    )\n  }\n\n  override string toString() { result = \"VersionTest\" }\n}\n\n/**\n * Represents a conditional block that guards code based on the Python interpreter version.\n * Used to identify version-specific imports that should not be flagged.\n */\nclass VersionBasedGuard extends ConditionBlock {\n  VersionBasedGuard() { this.getLastNode() instanceof InterpreterVersionTest }\n}\n\n// Main query: Identify unresolved imports that should be flagged as issues\nfrom ImportExpr unresolvedImport\nwhere\n  not unresolvedImport.refersTo(_) and // Import cannot be resolved\n  exists(Context validContext | validContext.appliesTo(unresolvedImport.getAFlowNode())) and // Import is in a valid context\n  not isImportAcceptableToFail(unresolvedImport) and // Import is not allowed to fail\n  not exists(VersionBasedGuard versionCheck | versionCheck.controls(unresolvedImport.getAFlowNode().getBasicBlock(), _)) // Not protected by version guard\nselect unresolvedImport, \"Unable to resolve import of '\" + unresolvedImport.getImportedModuleName() + \"'.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/ineffectual-statement]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A statement has no effect",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Statement has no effect\n * @description A statement has no effect\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/ineffectual-statement\n */\n\nimport python\n\n// ===== 属性理解相关谓词 =====\n\n/**\n * 判断属性是否被理解的谓词函数\n * 检查属性是否属于某个类，并且该属性的类是否已知\n */\npredicate understood_attribute(Attribute attribute, ClassValue classValue, ClassValue attributeClass) {\n  exists(string attributeName | attribute.getName() = attributeName |\n    attribute.getObject().pointsTo().getClass() = classValue and\n    classValue.attr(attributeName).getClass() = attributeClass\n  )\n}\n\n/**\n * 保守估计属性查找是否有副作用\n * 如果属性被理解且其描述符类型有副作用，则认为属性有副作用\n */\npredicate side_effecting_attribute(Attribute attribute) {\n  exists(ClassValue attributeClass |\n    understood_attribute(attribute, _, attributeClass) and\n    side_effecting_descriptor_type(attributeClass)\n  )\n}\n\n/**\n * 判断属性是否可能有副作用\n * 如果属性不被理解或不指向任何值，或者已知有副作用，则认为可能有副作用\n */\npredicate maybe_side_effecting_attribute(Attribute attribute) {\n  not understood_attribute(attribute, _, _) and not attribute.pointsTo(_)\n  or\n  side_effecting_attribute(attribute)\n}\n\n// ===== 描述符类型相关谓词 =====\n\n/**\n * 判断描述符类型是否有副作用的谓词函数\n * 技术上所有描述符获取都有副作用，但有些表示缺少调用，我们希望将它们视为没有效果。\n */\npredicate side_effecting_descriptor_type(ClassValue descriptor) {\n  descriptor.isDescriptorType() and\n  // 排除一些常见的不产生副作用的描述符类型\n  not descriptor = ClassValue::functionType() and\n  not descriptor = ClassValue::staticmethod() and\n  not descriptor = ClassValue::classmethod()\n}\n\n// ===== 二元运算符相关谓词 =====\n\n/**\n * 有副作用的二元运算符很少见，所以我们假设它们没有副作用，除非我们知道它们有。\n */\npredicate side_effecting_binary(Expr expr) {\n  exists(Expr subExpr, ClassValue classValue, string methodName |\n    binary_operator_special_method(expr, subExpr, classValue, methodName)\n    or\n    comparison_special_method(expr, subExpr, classValue, methodName)\n  |\n    methodName = special_method() and\n    classValue.hasAttribute(methodName) and\n    not exists(ClassValue declaring |\n      declaring.declaresAttribute(methodName) and\n      declaring = classValue.getASuperType() and\n      declaring.isBuiltin() and\n      not declaring = ClassValue::object()\n    )\n  )\n}\n\n/**\n * 获取二元运算符的特殊方法\n */\npragma[nomagic]\nprivate predicate binary_operator_special_method(\n  BinaryExpr binaryExpr, Expr subExpr, ClassValue classValue, string methodName\n) {\n  methodName = special_method() and\n  subExpr = binaryExpr.getLeft() and\n  methodName = binaryExpr.getOp().getSpecialMethodName() and\n  subExpr.pointsTo().getClass() = classValue\n}\n\n/**\n * 获取比较运算符的特殊方法\n */\npragma[nomagic]\nprivate predicate comparison_special_method(Compare compareExpr, Expr subExpr, ClassValue classValue, string methodName) {\n  exists(Cmpop op |\n    compareExpr.compares(subExpr, op, _) and\n    methodName = op.getSpecialMethodName()\n  ) and\n  subExpr.pointsTo().getClass() = classValue\n}\n\n/**\n * 获取特殊方法名称\n */\nprivate string special_method() {\n  result = any(Cmpop c).getSpecialMethodName()\n  or\n  result = any(BinaryExpr b).getOp().getSpecialMethodName()\n}\n\n// ===== 环境相关谓词 =====\n\n/**\n * 判断文件是否是Jupyter/IPython笔记本的谓词函数\n */\npredicate is_notebook(File file) {\n  exists(Comment comment | comment.getLocation().getFile() = file |\n    comment.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\n/**\n * Jupyter/IPython笔记本中的表达式（语句）\n */\npredicate in_notebook(Expr expr) { is_notebook(expr.getScope().(Module).getFile()) }\n\n// ===== 测试相关谓词 =====\n\n/**\n * 获取unittest.TestCase类中的assertRaises方法的FunctionValue对象\n */\nFunctionValue assertRaises() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\n/**\n * 如果表达式`expr`在测试异常引发的`with`块中，则成立。\n */\npredicate in_raises_test(Expr expr) {\n  exists(With withStmt |\n    withStmt.contains(expr) and\n    withStmt.getContextExpr() = assertRaises().getACall().getNode()\n  )\n}\n\n// ===== Python 2 兼容性相关谓词 =====\n\n/**\n * 如果表达式具有Python 2 `print >> out, ...`语句的形式，则成立\n */\npredicate python2_print(Expr expr) {\n  expr.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n  expr.(BinaryExpr).getOp() instanceof RShift\n  or\n  python2_print(expr.(Tuple).getElt(0))\n}\n\n// ===== 主逻辑谓词 =====\n\n/**\n * 判断表达式是否没有效果的谓词函数\n */\npredicate no_effect(Expr expr) {\n  // 字符串可以用作注释\n  not expr instanceof StringLiteral and\n  not expr.hasSideEffects() and\n  forall(Expr subExpr | subExpr = expr.getASubExpression*() |\n    not side_effecting_binary(subExpr) and\n    not maybe_side_effecting_attribute(subExpr)\n  ) and\n  not in_notebook(expr) and\n  not in_raises_test(expr) and\n  not python2_print(expr)\n}\n\n// ===== 主查询 =====\n\n/**\n * 从表达式语句中选择没有效果的语句并报告问题\n */\nfrom ExprStmt exprStmt\nwhere no_effect(exprStmt.getValue())\nselect exprStmt, \"This statement has no effect.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-named-class-argument]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects class instantiations using keyword arguments that do not match",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Wrong name for an argument in a class instantiation\n * @description Detects class instantiations using keyword arguments that do not match \n *              any parameter in the class's __init__ method, which causes runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call instanceCall, ClassValue targetCls, string invalidArg, FunctionValue initMethod\nwhere\n  // Identify class instantiations with invalid keyword arguments\n  illegally_named_parameter(instanceCall, targetCls, invalidArg) and\n  // Retrieve the corresponding initializer method for the target class\n  initMethod = get_function_or_initializer(targetCls)\nselect instanceCall, \n       \"Keyword argument '\" + invalidArg + \"' is not a supported parameter name of $@.\", \n       initMethod,\n       initMethod.getQualifiedName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert Suppression Handling\n * @description Detects and manages alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import utilities for alert suppression handling from CodeQL\nprivate import codeql.util.suppression.AlertSuppression as SuppressionUtils\n// Import utilities for processing Python comments\nprivate import semmle.python.Comment as CommentProcessor\n\n// Base class for Python AST syntax nodes\nclass PySyntaxNode instanceof CommentProcessor::AstNode {\n  /** Gets the location information of this syntax node */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Forward location retrieval to the parent class\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  /** Returns a string representation of this syntax node */\n  string toString() { result = super.toString() }\n}\n\n// Represents a single-line comment in Python source code\nclass PySingleLineComment instanceof CommentProcessor::Comment {\n  /** Gets the location information of this comment */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Delegate location retrieval to the parent class\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  /** Gets the text content of this comment */\n  string getText() { result = super.getContents() }\n\n  /** Returns a string representation of this comment */\n  string toString() { result = super.toString() }\n}\n\n// Apply template to establish suppression relationships between AST nodes and comments\nimport SuppressionUtils::Make<PySyntaxNode, PySingleLineComment>\n\n/**\n * Represents suppression comments in the noqa format, which is compatible with Pylint and Pyflakes.\n * LGTM analyzer recognizes these comments for suppressing alerts.\n */\nclass NoqaSuppression extends SuppressionComment instanceof PySingleLineComment {\n  /** Constructs a NoqaSuppression by checking the comment format */\n  NoqaSuppression() {\n_______________ // 补全条件\n    PySingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  /** Returns the annotation identifier \"lgtm\" */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /** Defines the code range that this suppression comment covers */\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Ensure the comment is at the beginning of the line and matches the location\n    this.hasLocationInfo(filePath, startLine, _, endLine, endCol) and\n    startCol = 1\n  }\n}",
    "output": "// Verify that the comment text matches the noqa pattern (case-insensitive, with optional surrounding whitespace)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/deprecated-slice-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies usage of obsolete slice methods (__getslice__, __setslice__, __delslice__)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Deprecated slice method\n * @description Identifies usage of obsolete slice methods (__getslice__, __setslice__, __delslice__)\n *              that have been deprecated since Python 2.0 and should be replaced with modern slicing syntax.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/deprecated-slice-method\n */\n\nimport python\n\n// Helper predicate to check if a method name is one of the deprecated slice operations\npredicate slice_method_name(string methodName) {\n  methodName = \"__getslice__\" or methodName = \"__setslice__\" or methodName = \"__delslice__\"\n}\n\n// Main query to locate functions implementing deprecated slice methods\nfrom PythonFunctionValue targetMethod, string methodName\nwhere\n  // Verify the function is a class method (not a standalone function)\n  targetMethod.getScope().isMethod() and\n  // Exclude methods that are overrides from parent classes\n  not targetMethod.isOverridingMethod() and\n  // Confirm the method name matches one of our deprecated slice methods\n  targetMethod.getName() = methodName and\n  // Validate the method name is in our list of deprecated slice methods\n  slice_method_name(methodName)\n// Generate alert with the deprecated method and explanatory message\nselect targetMethod, methodName + \" method has been deprecated since Python 2.0.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Tar extraction with arbitrary file write\n * @description 检测tar文件解压过程中的路径遍历漏洞。当解压操作未验证目标路径是否位于预期目录内时，\n *              攻击者可能通过构造恶意路径覆盖系统任意文件。\n * @kind path-problem\n * @id py/tarslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\n// 定义漏洞检测核心变量\nfrom TarSlipFlow::PathNode maliciousInputSource, TarSlipFlow::PathNode vulnerableExtractionPoint\n// 验证存在从恶意输入源到易受攻击解压点的数据流路径\nwhere TarSlipFlow::flowPath(maliciousInputSource, vulnerableExtractionPoint)\n// 输出漏洞结果：解压点位置、输入源位置、解压点详情及安全警告\nselect vulnerableExtractionPoint.getNode(), maliciousInputSource, vulnerableExtractionPoint, \n  \"This file extraction depends on a $@.\", maliciousInputSource.getNode(),\n  \"potentially untrusted source\"",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cryptographic implementations using elliptic curve algorithms that are",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak elliptic curve\n * @description Detects cryptographic implementations using elliptic curve algorithms that are \n *              either unrecognized or known to be weak, which may lead to security vulnerabilities.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm cryptoOperation, string alertMessage, string ellipticCurveIdentifier\nwhere\n  // Retrieve the elliptic curve identifier from the cryptographic operation\n  ellipticCurveIdentifier = cryptoOperation.getCurveName() and\n  (\n    // First condition: Algorithm is not recognized\n    ellipticCurveIdentifier = unknownAlgorithm() and\n    alertMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Second condition: Algorithm is recognized but considered weak\n    ellipticCurveIdentifier != unknownAlgorithm() and\n    not ellipticCurveIdentifier in\n      [\n        // Approved secure elliptic curves\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curve\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    alertMessage = \"Use of weak curve algorithm \" + ellipticCurveIdentifier + \".\"\n  )\nselect cryptoOperation, alertMessage"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 评估指向关系图的数据压缩效能：通过计算唯一事实条目数、关系图总体积，\n * 并确定它们相对于上下文层级的压缩效率百分比。\n * 此查询为点对分析中数据结构的空间优化提供量化评估依据。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 声明查询输出参数：唯一事实计数、关系总体积、上下文层级和压缩效率百分比\nfrom int uniqueFactsCount, int totalRelationsSize, int ctxDepth, float compressionRate\nwhere\n  // 确定当前分析的上下文层级深度\n  exists(PointsToContext context | ctxDepth = context.getDepth()) and\n  // 计算唯一事实数量：统计不同的(流控制节点, 目标对象, 类对象)元组\n  uniqueFactsCount =\n    strictcount(ControlFlowNode flowNode, Object targetObject, ClassObject clsObject |\n      exists(PointsToContext context |\n        // 验证在指定上下文中，流控制节点指向目标对象，且该对象是类对象的实例\n        PointsTo::points_to(flowNode, context, targetObject, clsObject, _) and\n        context.getDepth() = ctxDepth\n      )\n    ) and\n  // 计算关系总体积：统计所有(流控制节点, 目标对象, 类对象, 上下文, 源流控制节点)元组\n  totalRelationsSize =\n_______________ // 补全条件\n      PointsToContext context, ControlFlowNode sourceFlowNode |\n      // 验证在指定上下文中，流控制节点指向目标对象，且该对象是类对象的实例，并记录源流控制节点\n      PointsTo::points_to(flowNode, context, targetObject, clsObject, sourceFlowNode) and\n      context.getDepth() = ctxDepth\n    ) and\n  // 计算压缩效率百分比：唯一事实数量占关系总体积的比例\n  compressionRate = 100.0 * uniqueFactsCount / totalRelationsSize\n// 输出结果：上下文层级、唯一事实计数、关系总体积和压缩效率百分比\nselect ctxDepth, uniqueFactsCount, totalRelationsSize, compressionRate",
    "output": "strictcount(ControlFlowNode flowNode, Object targetObject, ClassObject clsObject,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "import python  // 导入Python代码分析模块，提供Python语言的语法树和语义模型\nimport semmle.python.pointsto.PointsTo  // 导入指向分析模块，用于分析变量的引用关系和代码可达性\n\n// 此查询用于识别并统计Python代码中的不可达基本块数量\n// 不可达基本块表示在程序执行过程中永远不会被访问的代码区域\n// 这些不可达代码通常是由逻辑错误、条件分支冗余或未使用的代码路径导致的\n// 检测不可达代码有助于提高代码质量和减少潜在的安全风险\nfrom int unreachableBasicBlockTotal  // 声明整型变量，用于存储统计的不可达基本块总数\nwhere \n  // 计算所有不可达基本块的数量\n  // 通过筛选所有控制流节点，并检查其所属的基本块是否可达\n  unreachableBasicBlockTotal = count(ControlFlowNode controlFlowNode | \n    // 筛选条件：识别所有不可达的基本块\n    // PointsToInternal::reachableBlock() 方法用于判断基本块在程序执行过程中是否可达\n    // 如果该方法返回false，则表示该基本块是不可达的\n    not PointsToInternal::reachableBlock(controlFlowNode.getBasicBlock(), _)\n_______________ // 补全条件\nselect unreachableBasicBlockTotal  // 输出统计结果：不可达基本块的总数",
    "output": ")"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/nested-loops-with-same-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Finds nested for loops that share the same iteration variable. This can lead to",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Nested loops reusing the same iteration variable\n * @description Finds nested for loops that share the same iteration variable. This can lead to\n *              unexpected behavior because the inner loop will overwrite the variable used by the\n *              outer loop, and it also reduces code readability.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\n// Identifies nested loops sharing the same iteration variable where the variable is referenced\n// outside the inner loop's scope within the outer loop\npredicate nestedLoopsWithSameVariable(For innerForLoop, For outerForLoop, Variable sharedIterationVar) {\n  // Verify inner loop is directly nested in outer loop's body (excluding else clauses)\n  outerForLoop.getBody().contains(innerForLoop) and\n  // Confirm both loops use the same iteration variable\n  innerForLoop.getTarget().defines(sharedIterationVar) and\n  outerForLoop.getTarget().defines(sharedIterationVar) and\n  // Ensure the variable is used in the outer loop beyond the inner loop's scope\n  exists(Name usage | \n    usage.uses(sharedIterationVar) and \n    outerForLoop.contains(usage) and \n    not innerForLoop.contains(usage)\n  )\n}\n\n// Query: Detect problematic nested loops with shared iteration variables\nfrom For innerForLoop, For outerForLoop, Variable sharedIterationVar\nwhere nestedLoopsWithSameVariable(innerForLoop, outerForLoop, sharedIterationVar)\nselect innerForLoop, \n  \"Nested for loop reuses iteration variable '\" + sharedIterationVar.getId() + \n  \"' from enclosing $@.\", \n  outerForLoop, \n  \"outer for loop\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-hostname-regexp]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects security weaknesses in regular expressions used for URL or hostname validation. This query specifically identifies patterns where dots (.) are not correctly escaped, leading to excessively broad hostname matching and potential security bypasses.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incomplete regular expression for hostnames\n * @description Detects security weaknesses in regular expressions used for URL or hostname validation. This query specifically identifies patterns where dots (.) are not correctly escaped, leading to excessively broad hostname matching and potential security bypasses.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-hostname-regexp\n * @tags correctness\n *       security\n *       external/cwe/cwe-020\n */\n\n// Import the specialized module for examining hostname regex security vulnerabilities\nprivate import semmle.python.security.regexp.HostnameRegex as HostnameRegexSecurityModule\n\n// Primary query predicate for identifying defective hostname validation patterns\n// This detects regex patterns that might permit unauthorized hostname matches\n// resulting from incorrect escaping of special characters, especially dots\nquery predicate vulnerableHostnameRegex = HostnameRegexSecurityModule::incompleteHostnameRegExp/4;"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 错误的类实例化参数数量\n * @description 检测类实例化时参数数量不匹配的问题。当调用类的 `__init__` 方法时，\n *              传入过多或过少的参数会导致运行时 TypeError 异常。\n * @kind problem\n_______________ // 补全条件\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstantiation, ClassValue targetClass, string errorType, string requirement, int argLimit, FunctionValue initializer\nwhere\n  (\n    // 检测参数过多的情况\n    too_many_args(classInstantiation, targetClass, argLimit) and\n    errorType = \"too many arguments\" and\n    requirement = \"no more than \"\n    or\n    // 检测参数过少的情况\n    too_few_args(classInstantiation, targetClass, argLimit) and\n    errorType = \"too few arguments\" and\n    requirement = \"no fewer than \"\n  ) and\n  // 获取目标类的构造函数或初始化方法\n  initializer = get_function_or_initializer(targetClass)\nselect classInstantiation, \"Call to $@ with \" + errorType + \"; should be \" + requirement + argLimit.toString() + \".\", initializer,\n  initializer.getQualifiedName()",
    "output": "* @tags reliability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name XML external entity expansion\n * @description Detects when user-controlled input flows into an XML parser without\n *              proper protection against external entity expansion attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision high\n * @id py/xxe\n * @tags security\n *       external/cwe/cwe-611\n *       external/cwe/cwe-827\n */\n\n// Import core Python analysis framework\nimport python\n\n// Import specialized XXE vulnerability detection modules\nimport semmle.python.security.dataflow.XxeQuery\n\n// Import path graph utilities for data flow visualization\nimport XxeFlow::PathGraph\n\n// Define tainted input source and vulnerable XML parsing sink\nfrom XxeFlow::PathNode taintedSource, XxeFlow::PathNode vulnerableSink\n_______________ // 补全条件\nwhere XxeFlow::flowPath(taintedSource, vulnerableSink)\n\n// Generate security alert with complete data flow path\nselect vulnerableSink.getNode(), taintedSource, vulnerableSink,\n  \"XML document parsing uses a $@ without safeguards against external entity expansion.\",\n  taintedSource.getNode(), \"user-controlled input\"",
    "output": "// Verify data flow exists between user input and insecure XML processing"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测函数名以大写字母开头的情况，这违反了Python命名约定并降低代码可读性。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed function\n * @description 检测函数名以大写字母开头的情况，这违反了Python命名约定并降低代码可读性。\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python\n\n/**\n * 判断函数名是否以大写字母开头。\n * 通过提取函数名的首字母并检查其是否不等于小写形式来确定。\n */\npredicate hasCapitalizedName(Function targetFunction) {\n  exists(string initialChar |\n    initialChar = targetFunction.getName().prefix(1) and  // 获取函数名的首字符\n    not initialChar = initialChar.toLowerCase()  // 验证首字符是否为大写\n  )\n}\n\n// 查找所有以大写字母开头且在文件中唯一的函数\nfrom Function targetFunction\nwhere\n  targetFunction.inSource() and  // 确保函数存在于源代码中\n  hasCapitalizedName(targetFunction) and  // 函数名以大写字母开头\n  not exists(Function otherFunction |\n    otherFunction != targetFunction and  // 排除当前函数本身\n    otherFunction.getLocation().getFile() = targetFunction.getLocation().getFile() and  // 确保在同一文件中\n    hasCapitalizedName(otherFunction)  // 其他函数也以大写字母开头\n  )\nselect targetFunction, \"Function names should start in lowercase.\"  // 报告这些函数，提示函数名应以小写开头"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name String concatenation in loop\n * @description Identifies inefficient string concatenation within loops causing quadratic performance degradation.\n * @kind problem\n * @tags efficiency\n *       maintainability\n_______________ // 补全条件\n * @sub-severity low\n * @precision low\n * @id py/string-concatenation-in-loop\n */\n\nimport python\n\n// Predicate using SSA variable relationships to detect performance-impacting string concatenation in loops\npredicate inefficient_string_concat(BinaryExpr concatOperation) {\n  // Verify the operation uses string concatenation (addition operator)\n  concatOperation.getOp() instanceof Add and\n  // Establish SSA variable relationships between definition and usage\n  exists(SsaVariable sourceVar, SsaVariable targetVar, BinaryExprNode exprNode |\n    // Map expression node to current concatenation operation\n    exprNode.getNode() = concatOperation and \n    // Trace SSA variable definition chain\n    sourceVar = targetVar.getAnUltimateDefinition()\n  |\n    // Confirm definition originates from this concatenation\n    sourceVar.getDefinition().(DefinitionNode).getValue() = exprNode and\n    // Verify variable is reused as operand in concatenation\n    targetVar.getAUse() = exprNode.getAnOperand() and\n    // Ensure at least one operand has string type\n    exprNode.getAnOperand().pointsTo().getClass() = ClassValue::str()\n  )\n}\n\n// Query to identify statements containing problematic concatenation patterns\nfrom BinaryExpr concatOperation, Stmt parentStatement\nwhere \n  // Apply concatenation detection predicate\n  inefficient_string_concat(concatOperation) and\n  // Locate the statement containing the concatenation expression\n  parentStatement.getASubExpression() = concatOperation\n// Report findings with consistent output format\nselect parentStatement, \"String concatenation in a loop is quadratic in the number of iterations.\"",
    "output": "* @problem.severity recommendation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/property-in-old-style-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects property descriptors defined within old-style classes, which are incompatible",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Property in old-style class\n * @description Detects property descriptors defined within old-style classes, which are incompatible \n *              with Python versions 2.1 and later. Properties in old-style classes do not function \n *              as expected due to implementation differences in the Python object model.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/property-in-old-style-class\n */\n\nimport python\n\n// Identify property objects defined within old-style classes\nfrom PropertyObject prop, ClassObject cls\nwhere\n  // Verify the class successfully declared this property\n  cls.declaredAttribute(_) = prop and\n  // Ensure the class inference was successful (no analysis failures)\n  not cls.failedInference() and\n  // Confirm the class uses old-style semantics (not inheriting from 'object')\n  not cls.isNewStyle()\n// Generate alert with details about the incompatible property usage\nselect prop,\n  \"Property '\" + prop.getName() + \"' in class '\" + cls.getName() +\n    \"' will not function correctly because old-style classes do not support property descriptors.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/similar-lines-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Placeholder query designed to assess similarity metrics between files.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name File Similarity Evaluation\n * @description Placeholder query designed to assess similarity metrics between files.\n *              This implementation is intended for Python source files but currently analyzes all files\n *              and assigns arbitrary similarity scores.\n *              Important: The actual similarity computation algorithm is not implemented in this version.\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags testability\n * @id py/similar-lines-in-files\n */\n\nimport python // Python module for code analysis and query operations\n\n// Define the target file for analysis and its corresponding similarity metric\nfrom File targetFile, int similarityMetric\n\n// No filtering conditions are applied in this placeholder implementation\nwhere \n  none()\n\n// Return the analysis results, ordered by similarity metric in descending order\nselect targetFile, similarityMetric order by similarityMetric desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent equality and inequality implementation\n * @description Detects classes violating object model contracts by implementing only one of the equality comparison methods (__eq__ or __ne__)\n * @kind problem\n_______________ // 补全条件\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-equality\n */\n\nimport python\n\n// Returns valid equality comparison method names\nstring equalityMethodName() { \n  result = [\"__eq__\", \"__ne__\"] \n}\n\n// Checks if class has total_ordering decorator applied\npredicate hasTotalOrderingDecorator(Class cls) {\n  exists(Attribute decorator | \n    decorator = cls.getADecorator() | \n    decorator.getName() = \"total_ordering\"\n  )\n  or\n  exists(Name decorator | \n    decorator = cls.getADecorator() | \n    decorator.getId() = \"total_ordering\"\n  )\n}\n\n// Retrieves implemented equality method from class\nCallableValue getImplementedEqualityMethod(ClassValue cls, string method) { \n  result = cls.declaredAttribute(method) and \n  method = equalityMethodName()\n}\n\n// Identifies missing equality method in class\nstring getUnimplementedEqualityMethod(ClassValue cls) { \n  not cls.declaresAttribute(result) and \n  result = equalityMethodName()\n}\n\n// Detects classes violating equality contract\npredicate violatesEqualityContract(\n  ClassValue cls, string implementedMethod, \n  string missingMethod, CallableValue methodImpl\n) {\n  missingMethod = getUnimplementedEqualityMethod(cls) and\n  methodImpl = getImplementedEqualityMethod(cls, implementedMethod) and\n  not cls.failedInference(_) and\n  not hasTotalOrderingDecorator(cls.getScope()) and\n  /* Python 3 auto-implements __ne__ when __eq__ is defined, but not vice-versa */\n  not (major_version() = 3 and implementedMethod = \"__eq__\" and missingMethod = \"__ne__\")\n}\n\n// Report classes with inconsistent equality implementations\nfrom ClassValue cls, string implementedMethod, string missingMethod, CallableValue methodImpl\nwhere violatesEqualityContract(cls, implementedMethod, missingMethod, methodImpl)\nselect methodImpl, \"Class $@ implements \" + implementedMethod + \" but does not implement \" + missingMethod + \".\", cls,\n  cls.getName()",
    "output": "* @tags reliability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python extraction warnings\n * @description Identifies extraction warnings for Python files in the source code directory.\n * @kind diagnostic\n * @id py/diagnostics/extraction-warnings\n */\n\nimport python\n\n/**\n * Determines the SARIF severity level for warnings.\n * \n * Reference: https://docs.oasis-open.org/sarif/sarif/v2.1.0/csprd01/sarif-v2.1.0-csprd01.html#_Toc10541338\n */\nint getWarningSeverity() { result = 1 }\n\n// SARIF specification (https://docs.oasis-open.org/sarif/sarif/v2.1.0/csprd01/sarif-v2.1.0-csprd01.html#_Toc10541338) defines error levels:\n//\n// \"error\": A critical issue was found. The tool encountered a condition that caused analysis to be aborted or results to be incorrect/incomplete.\n//\n// \"warning\": A non-critical issue was found. The tool encountered a condition where it's uncertain if a problem occurred, or analysis may be incomplete but generated results are potentially valid.\n//\n// SyntaxErrors are reported as warnings since analysis may be incomplete but generated results remain potentially valid.\n\n// Identify Python syntax errors that occurred in source files\nfrom SyntaxError syntaxError, File errorFile\nwhere\n  // Establish the relationship between the syntax error and its containing file\n  errorFile = syntaxError.getFile() and\n_______________ // 补全条件\n  exists(errorFile.getRelativePath())\nselect \n  syntaxError, \n  // Construct a descriptive diagnostic message containing file location and error details\n  \"Extraction failed in \" + errorFile + \" with error \" + syntaxError.getMessage(),\n  // Assign the appropriate warning severity level according to SARIF specification\n  getWarningSeverity()",
    "output": "// Verify the file is within the source code directory by checking for a valid relative path"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides counts of different kinds of type annotations in Python code,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Provides counts of different kinds of type annotations in Python code, \n *              including parameters, return types, and annotated assignments.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents a built-in type in Python\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr annotatedFunc) { exists(annotatedFunc.getReturns()) } or\n  TAnnotatedParameter(Parameter annotatedParam) { exists(annotatedParam.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign annotatedAssign) { exists(annotatedAssign.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr funcExpr;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(funcExpr) }\n  override Expr getAnnotation() { result = funcExpr.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter paramVar;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(paramVar) }\n  override Expr getAnnotation() { result = paramVar.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assignStmt;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assignStmt) }\n  override Expr getAnnotation() { result = assignStmt.getAnnotation() }\n}\n\n/** Holds if `expr` is a forward declaration (string literal) of a type */\npredicate is_forward_declaration(Expr expr) { expr instanceof StringLiteral }\n\n/** Holds if `expr` is a type that may be difficult to analyze */\npredicate is_complex_type(Expr expr) {\n  (expr instanceof Subscript and not is_optional_type(expr)) or\n  expr instanceof Tuple or\n  expr instanceof List\n}\n\n/** Holds if `expr` is a type of the form `Optional[...]` */\npredicate is_optional_type(Subscript expr) { expr.getObject().(Name).getId() = \"Optional\" }\n\n/** Holds if `expr` is a simple type (non-built-in identifier or attribute chain) */\npredicate is_simple_type(Expr expr) {\n  (expr instanceof Name and not expr instanceof BuiltinType) or\n  is_simple_type(expr.(Attribute).getObject())\n}\n\n/** Holds if `expr` is a built-in type */\npredicate is_builtin_type(Expr expr) { expr instanceof BuiltinType }\n\n// Computes type annotation metrics for different annotation categories\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  (\n    category = \"Parameter annotation\"\n    and\n    totalCount = count(AnnotatedParameter param)\n    and\n    builtinCount = count(AnnotatedParameter param | is_builtin_type(param.getAnnotation()))\n    and\n    forwardDeclCount = count(AnnotatedParameter param | is_forward_declaration(param.getAnnotation()))\n    and\n    simpleTypeCount = count(AnnotatedParameter param | is_simple_type(param.getAnnotation()))\n    and\n    complexTypeCount = count(AnnotatedParameter param | is_complex_type(param.getAnnotation()))\n    and\n    optionalTypeCount = count(AnnotatedParameter param | is_optional_type(param.getAnnotation()))\n  )\n  or\n  // Return type annotation metrics\n  (\n    category = \"Return type annotation\"\n    and\n    totalCount = count(AnnotatedFunction func)\n    and\n    builtinCount = count(AnnotatedFunction func | is_builtin_type(func.getAnnotation()))\n    and\n    forwardDeclCount = count(AnnotatedFunction func | is_forward_declaration(func.getAnnotation()))\n    and\n    simpleTypeCount = count(AnnotatedFunction func | is_simple_type(func.getAnnotation()))\n    and\n    complexTypeCount = count(AnnotatedFunction func | is_complex_type(func.getAnnotation()))\n    and\n    optionalTypeCount = count(AnnotatedFunction func | is_optional_type(func.getAnnotation()))\n  )\n  or\n  // Annotated assignment metrics\n  (\n    category = \"Annotated assignment\"\n    and\n    totalCount = count(AnnotatedAssignment assign)\n    and\n    builtinCount = count(AnnotatedAssignment assign | is_builtin_type(assign.getAnnotation()))\n    and\n    forwardDeclCount = count(AnnotatedAssignment assign | is_forward_declaration(assign.getAnnotation()))\n    and\n    simpleTypeCount = count(AnnotatedAssignment assign | is_simple_type(assign.getAnnotation()))\n    and\n    complexTypeCount = count(AnnotatedAssignment assign | is_complex_type(assign.getAnnotation()))\n    and\n    optionalTypeCount = count(AnnotatedAssignment assign | is_optional_type(assign.getAnnotation()))\n  )\n}\n\n// Query execution and output\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Total lines of Python code in the database\n * @description The total number of lines of Python code across all files, including\n *   external libraries and auto-generated files. This is a useful metric of the size of a\n *   database. This query counts the lines of code, excluding whitespace or comments.\n * @kind metric\n * @tags summary\n *       telemetry\n * @id py/summary/lines-of-code\n */\n\nimport python // 导入python模块，用于处理Python代码相关的查询\n\n// 选择所有Module m，并计算其行数的总和\nselect sum(Module m | | m.getMetrics().getNumberOfLinesOfCode())\n// 解释：\n// - `Module` 是一个类，表示一个代码模块。\n// - `m` 是 `Module` 类的一个实例。\n// - `m.getMetrics().getNumberOfLinesOfCode()` 是一个方法调用，用于获取模块的代码行数。\n_______________ // 补全条件",
    "output": "// - `sum(...)` 是一个聚合函数，用于计算所有模块代码行数的总和。"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unhashable Object Hashed\n * @description Detects attempts to hash an unhashable object, which would cause a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/hash-unhashable-value\n */\n\nimport python\n\n/**\n * Checks whether a given class is a numpy array type, \n * including those inheriting from numpy.ndarray or numpy.core.ndarray.\n */\npredicate numpy_array_type(ClassValue ndarrayCls) {\n  exists(ModuleValue numpyMod | \n    (numpyMod.getName() = \"numpy\" or numpyMod.getName() = \"numpy.core\") and\n    ndarrayCls.getASuperType() = numpyMod.attr(\"ndarray\")\n  )\n}\n\n/**\n * Determines if a value has custom indexing behavior, \n * such as a custom __getitem__ method or being a numpy array.\n */\npredicate has_custom_getitem(Value value) {\n  value.getClass().lookup(\"__getitem__\") instanceof PythonFunctionValue\n  or\n  numpy_array_type(value.getClass())\n}\n\n/**\n * Finds control flow nodes that are explicitly passed as arguments \n * to the built-in hash() function.\n */\npredicate explicitly_hashed(ControlFlowNode cfNode) {\n  exists(CallNode hashCall, GlobalVariable hashGlobal |\n    hashCall.getArg(0) = cfNode and \n    hashCall.getFunction().(NameNode).uses(hashGlobal) and \n    hashGlobal.getId() = \"hash\"\n  )\n}\n\n/**\n * Identifies subscript operations that use an unhashable index, \n * where the target object does not have custom indexing behavior.\n */\npredicate unhashable_subscript(ControlFlowNode indexNode, ClassValue unhashableClass, ControlFlowNode originNode) {\n  is_unhashable(indexNode, unhashableClass, originNode) and\n  exists(SubscriptNode subscript | subscript.getIndex() = indexNode |\n    exists(Value targetObj |\n      subscript.getObject().pointsTo(targetObj) and\n      not has_custom_getitem(targetObj)\n    )\n  )\n}\n\n/**\n_______________ // 补全条件\n * that lack a __hash__ method or have __hash__ explicitly set to None.\n */\npredicate is_unhashable(ControlFlowNode node, ClassValue targetClass, ControlFlowNode originNode) {\n  exists(Value objValue | node.pointsTo(objValue, originNode) and objValue.getClass() = targetClass |\n    (not targetClass.hasAttribute(\"__hash__\") and \n     not targetClass.failedInference(_) and \n     targetClass.isNewStyle())\n    or\n    targetClass.lookup(\"__hash__\") = Value::named(\"None\")\n  )\n}\n\n/**\n * Determines if a control flow node is within a try block that catches TypeError, \n * used to filter out false positives where the TypeError is handled.\n */\npredicate typeerror_is_caught(ControlFlowNode node) {\n  exists(Try tryBlock |\n    tryBlock.getBody().contains(node.getNode()) and\n    tryBlock.getAHandler().getType().pointsTo(ClassValue::typeError())\n  )\n}\n\n// Main query identifying unhandled unhashable operations\nfrom ControlFlowNode problemCfNode, ClassValue problemCls, ControlFlowNode originCfNode\nwhere\n  not typeerror_is_caught(problemCfNode) and\n  (\n    explicitly_hashed(problemCfNode) and \n    is_unhashable(problemCfNode, problemCls, originCfNode)\n    or\n    unhashable_subscript(problemCfNode, problemCls, originCfNode)\n  )\nselect problemCfNode.getNode(), \"This $@ of $@ is unhashable.\", originCfNode, \"instance\", problemCls, problemCls.getQualifiedName()",
    "output": "* Determines if an object is unhashable, which is true for new-style classes"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/zipslip]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects insecure archive extraction allowing malicious paths with '..'",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file access during archive extraction (\"Zip Slip\")\n * @description Detects insecure archive extraction allowing malicious paths with '..' \n *              to escape target directory restrictions, enabling unauthorized \n *              file system writes.\n * @kind path-problem\n * @id py/zipslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.semmle.python.security.ZipSlip\nimport ZipSlipFlow::PathGraph\n\n// Identify vulnerable data flows from archive entries to file operations\nfrom ZipSlipFlow::PathNode entryNode, ZipSlipFlow::PathNode fileOpNode\nwhere ZipSlipFlow::flowPath(entryNode, fileOpNode)\n\n// Generate vulnerability report with complete path context\nselect entryNode.getNode(), entryNode, fileOpNode,\n  \"This unsanitized archive entry (potentially containing '..') flows to a $@.\", fileOpNode.getNode(),\n  \"file system operation\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Conflicting attributes in base classes\n * @description Detects classes inheriting from multiple base classes defining the same attribute,\n *              which may cause unexpected behavior due to attribute resolution conflicts.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n/**\n * Determines if a function implementation is effectively empty.\n * A function is considered empty if its body contains only pass statements\n * or its docstring expression.\n */\npredicate isEffectivelyEmptyFunction(PyFunctionObject funcObj) {\n  not exists(Stmt stmt | stmt.getScope() = funcObj.getFunction() |\n    not stmt instanceof Pass and \n    not stmt.(ExprStmt).getValue() = funcObj.getFunction().getDocString()\n  )\n}\n\n/**\n * Checks if a function contains a super() call for its own name.\n * This indicates proper inheritance handling by invoking the parent class's implementation.\n */\npredicate containsSuperCall(FunctionObject funcObj) {\n  exists(Call superCall, Call methodCall, Attribute attrRef, GlobalVariable superGlobal |\n    methodCall.getScope() = funcObj.getFunction() and\n    methodCall.getFunc() = attrRef and\n    attrRef.getObject() = superCall and\n    attrRef.getName() = funcObj.getName() and\n    superCall.getFunc() = superGlobal.getAnAccess() and\n    superGlobal.getId() = \"super\"\n  )\n}\n\n/**\n * Specifies attribute names exempt from conflict detection.\n * Currently only 'process_request' is exempt due to special handling\n_______________ // 补全条件\n */\npredicate isExemptAttribute(string exemptAttr) {\n  exemptAttr = \"process_request\"  // Recommended in Python docs for async mixins\n}\n\nfrom\n  ClassObject derivedClass, \n  ClassObject firstBase, \n  ClassObject secondBase, \n  string attributeName, \n  int firstBaseIndex, \n  int secondBaseIndex, \n  Object attributeInFirstBase, \n  Object attributeInSecondBase\nwhere\n  // Establish inheritance relationships with distinct base classes\n  derivedClass.getBaseType(firstBaseIndex) = firstBase and\n  derivedClass.getBaseType(secondBaseIndex) = secondBase and\n  firstBaseIndex < secondBaseIndex and\n  \n  // Locate conflicting attributes in different base classes\n  attributeInFirstBase = firstBase.lookupAttribute(attributeName) and\n  attributeInSecondBase = secondBase.lookupAttribute(attributeName) and\n  attributeInFirstBase != attributeInSecondBase and\n  \n  // Filter special method names and exempt attributes\n  not attributeName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  not isExemptAttribute(attributeName) and\n  \n  // Exclude cases where inheritance is properly handled\n  (not containsSuperCall(attributeInFirstBase) and\n   not isEffectivelyEmptyFunction(attributeInSecondBase) and\n   not attributeInFirstBase.overrides(attributeInSecondBase) and\n   not attributeInSecondBase.overrides(attributeInFirstBase)) and\n  \n  // Ensure the derived class doesn't resolve the conflict\n  not derivedClass.declaresAttribute(attributeName)\nselect \n  derivedClass, \n  \"Base classes have conflicting values for attribute '\" + attributeName + \"': $@ and $@.\", \n  attributeInFirstBase, attributeInFirstBase.toString(), \n  attributeInSecondBase, attributeInSecondBase.toString()",
    "output": "* in Python's socketserver module (as per documentation)."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incorrect named argument in class instantiation\n * @description Identifies class instantiations using named arguments that don't correspond\n *              to any parameter in the class's __init__ method, leading to runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\n// Import Python analysis and call argument modules\nimport python\nimport Expressions.CallArgs\n_______________ // 补全条件\n// Identify problematic class instantiations with invalid named arguments\nfrom Call instantiationCall, ClassValue targetClass, string invalidArgumentName, FunctionValue initializerMethod\nwhere\n  // Locate class instantiations containing unrecognized named parameters\n  illegally_named_parameter(instantiationCall, targetClass, invalidArgumentName)\n  and\n  // Resolve the initialization method of the target class\n  initializerMethod = get_function_or_initializer(targetClass)\nselect \n  // Report location: problematic class instantiation call\n  instantiationCall, \n  // Error message: specify the unsupported argument name\n  \"Keyword argument '\" + invalidArgumentName + \"' is not a supported parameter name of $@.\", \n  // Related element: initialization method\n  initializerMethod,\n  // Initialization method's qualified name\n  initializerMethod.getQualifiedName()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Function similarity detection\n * @description Identifies functions exhibiting high similarity patterns, indicating potential code duplication. \n *              Recommended action: Refactor by extracting shared logic into reusable components.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision very-high\n * @id py/similar-function\n */\n_______________ // 补全条件\nimport python\n\n// Define core analysis components: target function, reference function, and analysis result message\nfrom Function targetFunction, \n     Function referenceFunction, \n     string analysisResult\n// Apply analysis constraints (currently inactive)\nwhere none()\n// Generate output with function details and similarity analysis\nselect targetFunction, \n       analysisResult, \n       referenceFunction, \n       referenceFunction.getName()",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raise-not-implemented]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code that raises 'NotImplemented' rather than 'NotImplementedError',",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name NotImplemented is not an Exception\n * @description Identifies code that raises 'NotImplemented' rather than 'NotImplementedError',\n *              which leads to runtime type errors because NotImplemented is not an exception class.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Import fundamental Python language analysis capabilities\nimport python\n\n// Import specialized functionality for detecting NotImplemented misuse in exception handling\nimport Exceptions.NotImplemented\n\n// Find expressions where NotImplemented is incorrectly used in raise statements\nfrom Expr incorrectNotImplementedUsage\nwhere \n    // Identify raise statements that utilize NotImplemented instead of the correct NotImplementedError\n    use_of_not_implemented_in_raise(_, incorrectNotImplementedUsage)\nselect \n    // Report the problematic expression along with guidance for correction\n    incorrectNotImplementedUsage, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/percent-format/unsupported-character]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python format strings containing illegal conversion specifiers",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unsupported format character\n * @description Identifies Python format strings containing illegal conversion specifiers\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/percent-format/unsupported-character\n */\n\n// Core Python analysis imports\nimport python\n// String processing utilities\nimport semmle.python.strings\n\n// Detect format expressions with invalid conversion specifiers\nfrom Expr formatExpr, int invalidIndex\nwhere \n  // Calculate position of the illegal conversion specifier\n  invalidIndex = illegal_conversion_specifier(formatExpr)\nselect \n  formatExpr, \n  \"Illegal conversion specifier at position \" + invalidIndex + \n  \" in format string: \" + repr(formatExpr) + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Missing part of special group in regular expression\n * @description Incomplete special groups are parsed as normal groups and are unlikely to match the intended strings.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/regex/incomplete-special-group\n */\n\nimport python  // 导入Python分析模块，提供基础代码分析能力\nimport semmle.python.regex  // 导入正则表达式专用分析模块，支持正则模式检测\n\n// 查询定义：检测正则表达式中特殊组的不完整语法\n_______________ // 补全条件\nwhere \n  // 识别正则表达式文本中包含命名组语法但缺少问号的情况\n  // 模式解释：查找包含 \\(P<单词字符> 结构的正则表达式\n  exists(string patternText | \n    patternText = regexPattern.getText() and \n    patternText.regexpMatch(\".*\\\\(P<\\\\w+>.*\")\n  )\n  // 指定缺失的字符是问号\n  and missingCharacter = \"?\" \n  // 指定涉及的组类型是命名组\n  and specialGroupType = \"named group\"\n// 输出结果：返回问题正则表达式并生成描述性警告信息\nselect regexPattern, \"Regular expression is missing '\" + missingCharacter + \"' in \" + specialGroupType + \".\"",
    "output": "from RegExp regexPattern, string missingCharacter, string specialGroupType"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable 'except' block\n * @description Handling general exceptions before specific exceptions means that the specific\n *              handlers are never executed.\n * @kind problem\n * @tags reliability\n_______________ // 补全条件\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// 辅助谓词：获取异常处理块（except语句）所处理的异常类型\nClassValue getExceptionClass(ExceptStmt exceptionHandler) { \n  // 从异常处理块中提取类型信息，并获取其指向的类值\n  exceptionHandler.getType().pointsTo(result) \n}\n\n// 检测异常处理顺序问题的谓词：当父类异常处理块位于子类异常处理块之前时\npredicate hasIncorrectExceptOrder(ExceptStmt precedingHandler, ClassValue generalException, \n                                 ExceptStmt subsequentHandler, ClassValue particularException) {\n  exists(int precedingIndex, int subsequentIndex, Try tryStatement |\n    // 确保两个异常处理块属于同一个try语句\n    precedingHandler = tryStatement.getHandler(precedingIndex) and\n    subsequentHandler = tryStatement.getHandler(subsequentIndex) and\n    // 验证处理块在代码中的顺序（先出现的在前）\n    precedingIndex < subsequentIndex and\n    // 获取两个异常处理块分别处理的异常类型\n    generalException = getExceptionClass(precedingHandler) and\n    particularException = getExceptionClass(subsequentHandler) and\n    // 检查异常类型之间的继承关系（确认前一个处理的是更一般的异常）\n    generalException = particularException.getASuperType()\n  )\n}\n\n// 主查询：查找所有不可达的异常处理块\nfrom ExceptStmt subsequentHandler, ClassValue particularException, \n     ExceptStmt precedingHandler, ClassValue generalException\nwhere hasIncorrectExceptOrder(precedingHandler, generalException, \n                             subsequentHandler, particularException)\nselect subsequentHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  particularException, particularException.getName(), precedingHandler, \"except block\", generalException, generalException.getName()",
    "output": "*       maintainability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode IV or nonce\n * @description Detects block cipher operations that use insecure initialization vectors or nonces.\n *              The query identifies IVs/nonces not generated through cryptographically secure methods (os.urandom).\n *\n *            NOTE: \n *              1. Simplified detection: All IV/nonce sources are flagged except os.urandom\n *              2. Special cases:\n *                 - GCM mode: Requires unique nonce handling (addressed in a separate query)\n_______________ // 补全条件\n *              3. Functions that infer mode/IV might generate false positives (manual review recommended)\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify vulnerable block cipher operations\nfrom BlockMode blockCipherOp, string alertMessage, DataFlow::Node weakSourceNode\nwhere\n  // Exclude Fernet (secure IV generation handled internally)\n  not blockCipherOp instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet and\n  (\n    // Case 1: Missing IV/Nonce initialization\n    not blockCipherOp.hasIVorNonce() and\n    weakSourceNode = blockCipherOp and\n    alertMessage = \"Block mode is missing IV/Nonce initialization\"\n    or\n    // Case 2: Non-cryptographic IV/Nonce source\n    blockCipherOp.hasIVorNonce() and\n    not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = blockCipherOp.getIVorNonce() and\n    weakSourceNode = blockCipherOp.getIVorNonce() and\n    alertMessage = \"Block mode uses non-cryptographic IV/Nonce source: $@\"\n  )\nselect blockCipherOp, alertMessage, weakSourceNode, weakSourceNode.toString()",
    "output": "*                 - Fernet: Excluded from analysis (manages secure IV generation internally)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-input]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：使用了内置函数'input'，在Python 2中，该函数允许执行任意代码。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python 2中使用的'input'函数\n * @description 使用了内置函数'input'，在Python 2中，该函数允许执行任意代码。\n * @kind problem\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/use-of-input\n */\n\nimport python  // Python代码分析基础库\nimport semmle.python.dataflow.new.DataFlow  // 数据流分析功能\nimport semmle.python.ApiGraphs  // API图分析工具\n\n// 检测Python 2中的危险'input'函数调用\nfrom DataFlow::CallCfgNode dangerousInputCall\nwhere\n  // 确保目标代码为Python 2版本\n  major_version() = 2\n  and\n  // 识别对'input'函数的调用\n  dangerousInputCall = API::builtin(\"input\").getACall()\n  and\n  // 排除安全的'raw_input'函数调用\n  dangerousInputCall != API::builtin(\"raw_input\").getACall()\nselect dangerousInputCall, \"Python 2中使用了不安全的内置函数'input'。\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Generates information about alert suppressions in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import AlertSuppression utilities for handling warning suppression mechanisms\nprivate import codeql.util.suppression.AlertSuppression as SuppressionUtil\n// Import Python comment processing utilities for parsing and manipulating code comments\nprivate import semmle.python.Comment as CommentProcessor\n\n/**\n * Represents a single-line comment in Python code\n * Inherits from CommentProcessor::Comment, providing location and content access\n */\nclass SingleLineComment instanceof CommentProcessor::Comment {\n  /** Generates a textual description of the comment */\n  string toString() { result = super.toString() }\n\n  /**\n   * Provides detailed location information for the comment\n   * @param filePath - Source file path\n   * @param startLine - Starting line number\n   * @param startColumn - Starting column number\n   * @param endLine - Ending line number\n   * @param endColumn - Ending column number\n   */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startColumn, int endLine, int endColumn\n  ) {\n    // Leverage parent class location information retrieval method\n    super.getLocation().hasLocationInfo(filePath, startLine, startColumn, endLine, endColumn)\n  }\n\n  /** Retrieves the full text content of the comment */\n  string getText() { result = super.getContents() }\n}\n\n/**\n * Represents an abstract syntax tree node in Python code\n * Inherits from CommentProcessor::AstNode, providing location and string representation\n */\nclass PythonAstNode instanceof CommentProcessor::AstNode {\n  /** Generates a textual description of the node */\n  string toString() { result = super.toString() }\n\n  /**\n   * Provides detailed location information for the node\n   * @param filePath - Source file path\n   * @param startLine - Starting line number\n   * @param startColumn - Starting column number\n   * @param endLine - Ending line number\n   * @param endColumn - Ending column number\n   */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startColumn, int endLine, int endColumn\n  ) {\n    // Leverage parent class location information retrieval method\n    super.getLocation().hasLocationInfo(filePath, startLine, startColumn, endLine, endColumn)\n  }\n}\n\n// Apply template to generate suppression relationships between AST nodes and single-line comments\nimport SuppressionUtil::Make<PythonAstNode, SingleLineComment>\n\n/**\n * Represents Pylint and Pyflakes compatible noqa-style suppression comments\n * These comments are recognized by LGTM analyzer for warning suppression\n */\nclass NoqaStyleSuppressor extends SuppressionComment instanceof SingleLineComment {\n  /** Returns the annotation name used for identification */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /**\n   * Specifies the code range covered by the comment\n   * @param filePath - Source file path\n   * @param startLine - Starting line number\n   * @param startColumn - Starting column number\n   * @param endLine - Ending line number\n   * @param endColumn - Ending column number\n   */\n  override predicate covers(\n    string filePath, int startLine, int startColumn, int endLine, int endColumn\n  ) {\n    // Ensure comment is at line start and location information matches\n    startColumn = 1 and\n    this.hasLocationInfo(filePath, startLine, _, endLine, endColumn)\n  }\n\n  /** Validates comment compliance with noqa format specifications */\n  NoqaStyleSuppressor() {\n    // Check if comment content matches noqa format (case-insensitive, optional surrounding whitespace)\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n}"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Key Exchange Algorithms Detection\n * @description Identifies cryptographic key exchange algorithm implementations across supported libraries.\n *              These algorithms may pose security risks in quantum computing contexts.\n * @kind problem\n * @id py/quantum-readiness/cbom/key-exchange\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Core Python analysis framework for code examination\nimport python\n\n// Cryptographic concepts and primitives for security analysis\nimport experimental.cryptography.Concepts\n\n_______________ // 补全条件\n// These algorithms require security evaluation against quantum threats\nfrom KeyExchangeAlgorithm cryptoKeyExchange\n\n// Generate results showing each identified key exchange algorithm\n// with contextual information about its cryptographic implementation\nselect cryptoKeyExchange, \"Cryptographic key exchange algorithm detected: \" + cryptoKeyExchange.getName()",
    "output": "// Identify all cryptographic key exchange algorithm implementations"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Identification of vulnerable asymmetric cryptographic padding\n * @description\n * This analysis detects the implementation of asymmetric cryptographic padding techniques that are considered\n * weak, unauthorized for secure applications, or possess undetermined security characteristics. For robust\n * cryptographic systems, only particular padding methodologies should be employed. The sanctioned secure\n * asymmetric padding methodologies consist of:\n * - OAEP (Optimal Asymmetric Encryption Padding)\n * - KEM (Key Encapsulation Mechanism)\n * - PSS (Probabilistic Signature Scheme)\n * Implementation of alternative padding methodologies may lead to security weaknesses. This analysis assists\n * in identifying such potentially insecure padding selections by highlighting any asymmetric padding technique\n * that does not belong to the sanctioned secure methodologies.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n_______________ // 补全条件\nfrom AsymmetricPadding vulnerablePaddingScheme, string paddingAlgorithmName\nwhere \n  // Phase 1: Retrieve the identifier of the padding algorithm in use\n  paddingAlgorithmName = vulnerablePaddingScheme.getPaddingName()\n  // Phase 2: Verify that the algorithm is not among the approved secure methodologies\n  and not paddingAlgorithmName = \"OAEP\"  // OAEP is sanctioned for encryption operations\n  and not paddingAlgorithmName = \"KEM\"   // KEM is sanctioned for key encapsulation mechanisms\n  and not paddingAlgorithmName = \"PSS\"   // PSS is sanctioned for digital signature schemes\nselect vulnerablePaddingScheme, \"Use of unapproved, weak, or unknown asymmetric padding algorithm or API: \" + paddingAlgorithmName",
    "output": "// Locate all asymmetric padding techniques that utilize non-approved secure methodologies"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/member-test-non-container]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects membership operations ('in'/'not in') where the right-hand operand",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Membership test with a non-container\n * @description Detects membership operations ('in'/'not in') where the right-hand operand \n *              is a non-container type, which may cause runtime TypeError.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n * Identifies nodes acting as the right operand in membership tests.\n * @param rhsNode - Control flow node being evaluated\n * @param cmpExpr - Comparison expression containing the membership test\n */\npredicate isRightOperandOfMembershipTest(ControlFlowNode rhsNode, Compare cmpExpr) {\n  exists(Cmpop operation, int index |\n    cmpExpr.getOp(index) = operation and \n    cmpExpr.getComparator(index) = rhsNode.getNode() and\n    (operation instanceof In or operation instanceof NotIn)\n  )\n}\n\nfrom \n  ControlFlowNode rhsNode, \n  Compare cmpExpr, \n  Value referencedValue, \n  ClassValue nonContainerClass, \n  ControlFlowNode originNode\nwhere\n  // Confirm node is right operand of membership test\n  isRightOperandOfMembershipTest(rhsNode, cmpExpr) and\n  \n  // Resolve pointed value and class information\n  rhsNode.pointsTo(_, referencedValue, originNode) and\n  referencedValue.getClass() = nonContainerClass and\n  \n  // Exclude cases with failed type inference\n  not Types::failedInference(nonContainerClass, _) and\n  \n  // Verify class lacks container interface methods\n  not nonContainerClass.hasAttribute(\"__contains__\") and\n  not nonContainerClass.hasAttribute(\"__iter__\") and\n  not nonContainerClass.hasAttribute(\"__getitem__\") and\n  \n  // Exclude special pseudo-container types\n  not nonContainerClass = ClassValue::nonetype() and\n  not nonContainerClass = Value::named(\"types.MappingProxyType\")\nselect \n  cmpExpr, \n  \"This test may raise an Exception as the $@ may be of non-container class $@.\", \n  originNode, \"target\", nonContainerClass, nonContainerClass.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of an undefined placeholder variable\n * @description Detects placeholder variables that are used without proper initialization,\n *              which could result in runtime errors during program execution.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/undefined-placeholder-variable\n */\n\nimport python\nimport Variables.MonkeyPatched\n\n// Check if a placeholder variable is properly initialized within its local function scope\npredicate isInitializedLocally(PlaceHolder placeholderVar) {\n  exists(SsaVariable ssaVarDefinition, Function enclosingFunction | \n    enclosingFunction = placeholderVar.getScope() and \n    ssaVarDefinition.getAUse() = placeholderVar.getAFlowNode() |\n    ssaVarDefinition.getVariable() instanceof LocalVariable and\n    not ssaVarDefinition.maybeUndefined()\n  )\n}\n\n// Find the class that encloses the placeholder variable\nClass getEnclosingClass(PlaceHolder placeholderVar) { \n  result.getAMethod() = placeholderVar.getScope() \n}\n\n// Determine if the placeholder is defined as an attribute within its enclosing class\npredicate isDefinedAsClassAttribute(PlaceHolder placeholderVar) {\n  exists(ImportTimeScope enclosingClass | \n    enclosingClass = getEnclosingClass(placeholderVar) | \n    enclosingClass.definesName(placeholderVar.getId())\n  )\n}\n\n_______________ // 补全条件\n// a monkey-patched builtin, or a globally defined name\npredicate isNotGloballyAccessible(PlaceHolder placeholderVar) {\n  not exists(PythonModuleObject globalModule |\n    globalModule.hasAttribute(placeholderVar.getId()) and \n    globalModule.getModule() = placeholderVar.getEnclosingModule()\n  ) and\n  not globallyDefinedName(placeholderVar.getId()) and\n  not monkey_patched_builtin(placeholderVar.getId())\n}\n\n// Main query: Identify and report placeholder variables that may be undefined\nfrom PlaceHolder problematicPlaceholder\nwhere\n  not isInitializedLocally(problematicPlaceholder) and\n  not isDefinedAsClassAttribute(problematicPlaceholder) and\n  isNotGloballyAccessible(problematicPlaceholder)\nselect problematicPlaceholder, \"This use of placeholder variable '\" + problematicPlaceholder.getId() + \"' may be undefined.\"",
    "output": "// Ensure the placeholder is not accessible globally, either as a module attribute,"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/iteration-string-and-sequence]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects for-loops that iterate over values which can be either strings or sequences (like lists).",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Iteration over both string and sequence types\n * @description Detects for-loops that iterate over values which can be either strings or sequences (like lists).\n * This pattern is problematic because strings iterate over individual characters while sequences iterate over elements,\n * leading to inconsistent behavior and potential runtime errors.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       non-local\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iteration-string-and-sequence\n */\n\nimport python\nimport semmle.python.filters.Tests\n\n// Checks if a value is of string type (str or Python 2 unicode)\npredicate isStringType(Value value) {\n  value.getClass() = ClassValue::str() \n  or \n  value.getClass() = ClassValue::unicode() and major_version() = 2\n}\n\nfrom \n  For problematicForLoop, \n  ControlFlowNode iteratorNode, \n  Value strValue, \n  Value seqValue, \n  ControlFlowNode seqSource,\n  ControlFlowNode strSource\nwhere \n  // The iterator node in the for-loop points to both string and sequence values\n  problematicForLoop.getIter().getAFlowNode() = iteratorNode and\n  iteratorNode.pointsTo(strValue, strSource) and\n  iteratorNode.pointsTo(seqValue, seqSource) and\n  \n  // Type validation: one value is a string, the other is a non-string iterable\n  isStringType(strValue) and\n  seqValue.getClass().isIterable() and\n  not isStringType(seqValue) and\n  \n  // Exclude test code from the analysis\n  not seqSource.getScope().getScope*() instanceof TestScope and\n  not strSource.getScope().getScope*() instanceof TestScope\nselect problematicForLoop,\n  \"Iteration over $@, of class \" + seqValue.getClass().getName() + \n  \", may also iterate over $@.\",\n  seqSource, \"sequence\", strSource, \"string\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-of-constants]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测代码中常量之间的比较操作。这种比较总是产生固定的布尔结果，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comparison of constants\n * @description 检测代码中常量之间的比较操作。这种比较总是产生固定的布尔结果，\n *              直接使用布尔值更易读且减少代码复杂性。\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/comparison-of-constants\n */\n\nimport python\n\n// 识别常量比较表达式\nfrom Compare constantComparison\nwhere\n  // 获取比较操作的两个操作数并验证它们都是常量\n  exists(Expr leftExpr, Expr rightExpr |\n    constantComparison.compares(leftExpr, _, rightExpr) and\n    leftExpr.isConstant() and\n    rightExpr.isConstant()\n  ) and\n  // 排除断言语句中的常量比较（断言中可能需要显式表达式来增强可读性）\n  not exists(Assert assertStmt | assertStmt.getTest() = constantComparison)\nselect constantComparison, \"常量比较表达式应替换为 'True' 或 'False'\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Vulnerable asymmetric encryption padding\n * @description\n * This query detects padding schemes in asymmetric encryption that are\n * either cryptographically insecure or not recognized as secure by\n * established security standards. The analysis employs a whitelist-based\n * approach, exclusively accepting strong padding methods (OAEP, KEM, PSS)\n * while marking all other schemes as potential security risks.\n * \n * The detection targets padding implementations that could be vulnerable\n * to cryptographic attacks when used in asymmetric encryption scenarios.\n * \n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n_______________ // 补全条件\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify and flag insecure padding schemes for asymmetric encryption\nfrom AsymmetricPadding insecurePadding, string paddingName\nwhere\n  // Extract the padding algorithm identifier from the implementation\n  paddingName = insecurePadding.getPaddingName()\n  // Exclude implementations that use cryptographically secure padding methods\n  and not paddingName = [\"OAEP\", \"KEM\", \"PSS\"]\nselect insecurePadding, \"Identified unapproved, weak, or unknown asymmetric padding algorithm: \" + paddingName",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete ordering\n * @description Class defines one or more ordering method but does not define all 4 ordering comparison methods\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/incomplete-ordering\n */\n\nimport python\n\n// Determines if a class is decorated with total_ordering\npredicate usesTotalOrderingDecorator(Class cls) {\n  exists(Attribute decorator | decorator = cls.getADecorator() | decorator.getName() = \"total_ordering\") // Check for decorator attribute\n  or\n  exists(Name decoratorName | decoratorName = cls.getADecorator() | decoratorName.getId() = \"total_ordering\") // Check for decorator name\n}\n\n// Maps an index to the corresponding comparison method name\nstring getComparisonMethodName(int index) {\n  result = \"__lt__\" and index = 1 // Less than method\n  or\n  result = \"__le__\" and index = 2 // Less than or equal method\n  or\n  result = \"__gt__\" and index = 3 // Greater than method\n  or\n  result = \"__ge__\" and index = 4 // Greater than or equal method\n}\n\n// Checks if a class or its superclass implements a specific comparison method\npredicate implementsComparisonMethod(ClassValue targetClass, string methodName) {\n  methodName = getComparisonMethodName(_) and ( // Verify valid comparison method name\n    targetClass.declaresAttribute(methodName) // Check if class directly implements the method\n    or\n    exists(ClassValue ancestor | ancestor = targetClass.getASuperType() and not ancestor = Value::named(\"object\") | // Check superclass (excluding object)\n      ancestor.declaresAttribute(methodName)\n    )\n  )\n}\n\n// Retrieves the name of a comparison method not implemented by the class\nstring findMissingComparisonMethod(ClassValue targetClass, int index) {\n  not targetClass = Value::named(\"object\") and // Exclude the base object class\n  not implementsComparisonMethod(targetClass, result) and // Ensure method is not implemented\n  result = getComparisonMethodName(index) // Get method name for the index\n}\n\n// Constructs a string listing all missing comparison methods\nstring buildMissingMethodsString(ClassValue targetClass, int index) {\n  index = 0 and result = \"\" and exists(findMissingComparisonMethod(targetClass, _)) // Initialize and check for missing methods\n  or\n  exists(string accumulated, int prevIndex | index = prevIndex + 1 and accumulated = buildMissingMethodsString(targetClass, prevIndex) | // Recursively build string\n    accumulated = \"\" and result = findMissingComparisonMethod(targetClass, index) // First method in list\n    or\n    result = accumulated and not exists(findMissingComparisonMethod(targetClass, index)) and index < 5 // Skip implemented methods\n    or\n    accumulated != \"\" and result = accumulated + \" or \" + findMissingComparisonMethod(targetClass, index) // Add separator and next method\n  )\n}\n\n// Retrieves a comparison method declared by the class\nValue getDeclaredComparisonMethod(ClassValue targetClass, string methodName) {\n  /* If class doesn't declare a method then don't blame this class (the superclass will be blamed). */\n  methodName = getComparisonMethodName(_) and result = targetClass.declaredAttribute(methodName) // Return declared method\n}\n_______________ // 补全条件\n// Main query to find classes with incomplete ordering methods\nfrom ClassValue targetClass, Value comparisonMethod, string methodName\nwhere\n  not targetClass.failedInference(_) and // Exclude classes with inference failures\n  not usesTotalOrderingDecorator(targetClass.getScope()) and // Exclude classes using total_ordering decorator\n  comparisonMethod = getDeclaredComparisonMethod(targetClass, methodName) and // Get a declared comparison method\n  exists(findMissingComparisonMethod(targetClass, _)) // Ensure there are missing methods\nselect targetClass,\n  \"Class \" + targetClass.getName() + \" implements $@, but does not implement \" + // Report the issue\n    buildMissingMethodsString(targetClass, 4) + \".\", comparisonMethod, methodName // List missing methods",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Property in old-style class\n * @description Detects usage of property descriptors in old-style classes, which is non-functional since Python 2.1.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n_______________ // 补全条件\n */\n\nimport python\n\n// 查找在旧式类中定义的属性对象\nfrom PropertyObject propObj, ClassObject oldStyleClass\nwhere\n  // 验证属性确实在该类中声明\n  oldStyleClass.declaredAttribute(_) = propObj and\n  // 确保类的类型推断成功，避免误报\n  not oldStyleClass.failedInference() and\n  // 确认类是旧式类（未继承自object或新式类）\n  not oldStyleClass.isNewStyle()\n// 输出问题属性及其错误描述\nselect propObj,\n  \"Property \" + propObj.getName() + \" will not work properly, as class \" + oldStyleClass.getName() +\n    \" is an old-style class.\"",
    "output": "* @id py/property-in-old-style-class"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unhashable object hashed\n * @description Hashing an object which is not hashable will result in a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/hash-unhashable-value\n */\n\nimport python\n\n/*\n * This analysis assumes indexing operations involve hashing when:\n * 1. The container is not a sequence (which requires integer indices)\n * 2. The container is not a numpy array (which allows list indices)\n * Other container types require hashable indices for proper operation.\n */\n\n// Identifies numpy array classes through inheritance from numpy.ndarray\npredicate isNumpyArrayType(ClassValue numpyClass) {\n  exists(ModuleValue numpyModule | \n    numpyModule.getName() = \"numpy\" or numpyModule.getName() = \"numpy.core\" |\n    numpyClass.getASuperType() = numpyModule.attr(\"ndarray\")\n  )\n}\n\n// Checks if a container has custom indexing behavior\npredicate hasCustomGetitem(Value containerValue) {\n  containerValue.getClass().lookup(\"__getitem__\") instanceof PythonFunctionValue\n  or\n  isNumpyArrayType(containerValue.getClass())\n}\n\n// Detects direct hashing operations using built-in hash()\npredicate isExplicitlyHashed(ControlFlowNode node) {\n  exists(CallNode hashCall, GlobalVariable hashVar |\n    hashCall.getArg(0) = node and \n    hashCall.getFunction().(NameNode).uses(hashVar) and \n    hashVar.getId() = \"hash\"\n  )\n}\n\n// Finds unhashable values used as indices in standard containers\npredicate isUnhashableSubscript(ControlFlowNode indexNode, ClassValue unhashableClass, ControlFlowNode origin) {\n  isUnhashable(indexNode, unhashableClass, origin) and\n  exists(SubscriptNode subscriptNode | subscriptNode.getIndex() = indexNode |\n    exists(Value container |\n      subscriptNode.getObject().pointsTo(container) and\n      not hasCustomGetitem(container)\n    )\n  )\n}\n\n// Determines if a value belongs to an unhashable class\npredicate isUnhashable(ControlFlowNode node, ClassValue unhashableClass, ControlFlowNode origin) {\n  exists(Value value | node.pointsTo(value, origin) and value.getClass() = unhashableClass |\n    (not unhashableClass.hasAttribute(\"__hash__\") and \n     not unhashableClass.failedInference(_) and \n     unhashableClass.isNewStyle())\n    or\n    unhashableClass.lookup(\"__hash__\") = Value::named(\"None\")\n  )\n}\n\n/**\n * Identifies nodes protected by TypeError handlers. For example:\n *\n *    try:\n *       ... node ...\n *    except TypeError:\n *       ...\n *\n_______________ // 补全条件\n * TypeErrors from unhashable operations are explicitly handled.\n */\npredicate isTypeErrorCaught(ControlFlowNode node) {\n  exists(Try tryBlock |\n    tryBlock.getBody().contains(node.getNode()) and\n    tryBlock.getAHandler().getType().pointsTo(ClassValue::typeError())\n  )\n}\n\n// Main detection logic for unhandled unhashable operations\nfrom ControlFlowNode node, ClassValue unhashableClass, ControlFlowNode origin\nwhere\n  not isTypeErrorCaught(node) and\n  (\n    isExplicitlyHashed(node) and isUnhashable(node, unhashableClass, origin)\n    or\n    isUnhashableSubscript(node, unhashableClass, origin)\n  )\nselect node.getNode(), \"This $@ of $@ is unhashable.\", origin, \"instance\", unhashableClass, unhashableClass.getQualifiedName()",
    "output": "* This reduces false positives by excluding cases where potential"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call-to-non-callable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies calls to objects that are not callable, which will raise a TypeError at runtime.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-callable called\n * @description Identifies calls to objects that are not callable, which will raise a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom \n  Call invocation, \n  Value targetValue, \n  ClassValue targetClass, \n  Expr funcExpression, \n  AstNode valueOrigin\nwhere\n  // Extract the function expression being invoked at the call site\n  funcExpression = invocation.getFunc() and\n  \n  // Resolve the function expression to its concrete value and origin\n  funcExpression.pointsTo(targetValue, valueOrigin) and\n  \n  // Determine the class type of the resolved value\n  targetClass = targetValue.getClass() and\n  \n  // Verify the class is not callable and type inference succeeded\n  not targetClass.isCallable() and\n  not targetClass.failedInference(_) and\n  \n  // Exclude descriptor objects with __get__ (callable via protocol)\n  not targetClass.hasAttribute(\"__get__\") and\n  \n  // Exclude explicit None values (known non-callable)\n  not targetValue = Value::named(\"None\") and\n  \n  // Exclude NotImplemented in raise statements (special case)\n  not use_of_not_implemented_in_raise(_, funcExpression)\nselect \n  invocation, \n  \"Call to a $@ of $@.\", \n  valueOrigin, \n  \"non-callable\", \n  targetClass, \n  targetClass.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/truncated-division]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects division operations with integer operands that could truncate",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Result of integer division may be truncated\n * @description Detects division operations with integer operands that could truncate \n *              the result in Python 2 due to floor division behavior.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// Identify division operations with potential truncation in Python 2\nfrom BinaryExpr divisionExpr, ControlFlowNode leftIntOperand, ControlFlowNode rightIntOperand\nwhere\n  // Restrict analysis to Python 2 where integer division truncates\n  major_version() = 2 and\n  exists(BinaryExprNode divisionNode, Value leftIntValue, Value rightIntValue |\n    // Core division operation identification\n    divisionNode = divisionExpr.getAFlowNode() and\n    divisionNode.getNode().getOp() instanceof Div and\n    \n    // Verify both operands are integers\n    divisionNode.getLeft().pointsTo(leftIntValue, leftIntOperand) and\n    leftIntValue.getClass() = ClassValue::int_() and\n    divisionNode.getRight().pointsTo(rightIntValue, rightIntOperand) and\n    rightIntValue.getClass() = ClassValue::int_() and\n    \n    // Exclude exact divisions (no remainder)\n    not leftIntValue.(NumericValue).getIntValue() % rightIntValue.(NumericValue).getIntValue() = 0 and\n    \n    // Exclusion criteria for false positives\n    not divisionNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    not exists(CallNode intConversionCall |\n      intConversionCall = ClassValue::int_().getACall() and\n      intConversionCall.getAnArg() = divisionNode\n    )\n  )\nselect divisionExpr, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftIntOperand, \"left\", rightIntOperand, \"right\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-exception in 'except' clause\n * @description Detects exception handlers that use non-exception types which are incapable of catching actual exceptions\n * @kind problem\n * @tags reliability\n_______________ // 补全条件\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\nfrom ExceptFlowNode exceptionHandler,\n     Value caughtType,\n     ClassValue caughtClass,\n     ControlFlowNode typeSource,\n     string typeInfo\nwhere\n  // Establish the relationship between exception handler and caught exception\n  exceptionHandler.handledException(caughtType, caughtClass, typeSource) and\n  (\n    // Scenario 1: Exception type is a class that doesn't inherit from BaseException\n    exists(ClassValue invalidExceptionClass | \n      invalidExceptionClass = caughtType and\n      not invalidExceptionClass.isLegalExceptionType() and\n      not invalidExceptionClass.failedInference(_) and\n      typeInfo = \"class '\" + invalidExceptionClass.getName() + \"'\"\n    )\n    or\n    // Scenario 2: Exception type is not a class (e.g., an instance)\n    not caughtType instanceof ClassValue and\n    typeInfo = \"instance of '\" + caughtClass.getName() + \"'\"\n  )\nselect exceptionHandler.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  typeSource, \n  typeInfo",
    "output": "*       correctness"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/csv-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects potential CSV injection vulnerabilities arising from embedding",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Csv Injection\n * @description Detects potential CSV injection vulnerabilities arising from embedding\n *              unvalidated user input into CSV files. Such vulnerabilities can lead\n *              to execution of arbitrary formulas or commands when the CSV is opened\n *              in spreadsheet applications like Excel.\n * @kind path-problem\n * @problem.severity error\n * @id py/csv-injection\n * @tags security\n *       experimental\n *       external/cwe/cwe-1236\n */\n\n// Import essential Python analysis modules for AST parsing and semantic evaluation\nimport python\n\n// Import path graph module for visualizing CSV injection data flow trajectories\nimport CsvInjectionFlow::PathGraph\n\n// Import data flow framework to trace information propagation through the codebase\nimport semmle.python.dataflow.new.DataFlow\n\n// Import specialized utilities for CSV injection vulnerability detection\nimport experimental.semmle.python.security.injection.CsvInjection\n\n// Identify data flow paths that could lead to CSV injection\nfrom CsvInjectionFlow::PathNode untrustedDataSource, CsvInjectionFlow::PathNode csvInjectionSink\nwhere \n  // Confirm that untrusted data flows to a CSV output without proper sanitization\n  CsvInjectionFlow::flowPath(untrustedDataSource, csvInjectionSink)\n\n// Report the vulnerability with details about the source and sink\nselect \n  csvInjectionSink.getNode(), \n  untrustedDataSource, \n  csvInjectionSink, \n  \"CSV injection may execute code from $@.\", \n  untrustedDataSource.getNode(),\n  \"this untrusted data source\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mostly-duplicate-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects files containing significant code duplication. Consolidating these files enhances code maintainability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Mostly duplicate module\n * @description Detects files containing significant code duplication. Consolidating these files enhances code maintainability.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-file\n */\n\nimport python\n\n// Query identifies module pairs and generates warning messages\n// Current implementation has no filtering logic applied\nfrom Module originalModule, Module clonedModule, string warningText\nwhere \n  none()  // Placeholder for future filtering conditions\nselect \n  originalModule, \n  warningText, \n  clonedModule, \n  clonedModule.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable 'except' block\n * @description Identifies except blocks that can never be executed due to improper ordering.\n *              When a general exception handler (catching a parent exception class) is placed\n *              before a specific exception handler (catching a child exception class), the specific\n *              handler becomes unreachable because the general handler will always catch the exception first.\n * @kind problem\n * @tags reliability\n_______________ // 补全条件\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Detects exception handlers where a general exception class handler\n// precedes a more specific exception class handler in the same try block\npredicate findUnreachableExceptionHandler(ExceptStmt generalHandler, ClassValue baseException, \n                                        ExceptStmt specificHandler, ClassValue derivedException) {\n  exists(int generalIdx, int specificIdx, Try tryBlock |\n    // Both handlers must belong to the same try statement\n    generalHandler = tryBlock.getHandler(generalIdx) and\n    specificHandler = tryBlock.getHandler(specificIdx) and\n    // General handler must appear before specific handler\n    generalIdx < specificIdx and\n    // Extract exception types directly from handlers\n    generalHandler.getType().pointsTo(baseException) and\n    specificHandler.getType().pointsTo(derivedException) and\n    // Verify inheritance relationship (base is superclass of derived)\n    baseException = derivedException.getASuperType()\n  )\n}\n\n// Identify all unreachable exception handlers due to incorrect ordering\nfrom ExceptStmt specificHandler, ClassValue derivedException, \n     ExceptStmt generalHandler, ClassValue baseException\nwhere findUnreachableExceptionHandler(generalHandler, baseException, \n                                    specificHandler, derivedException)\nselect specificHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  derivedException, derivedException.getName(), generalHandler, \"except block\", baseException, baseException.getName()",
    "output": "*       maintainability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'exec' used\n * @description Detects usage of 'exec' statement/function which can execute arbitrary code\n * @kind problem\n * @tags security\n *       correctness\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec\n */\n\nimport python\n\n// Generates version-specific warning message for exec usage\nstring getExecWarningMessage() {\n  result = \"The 'exec' statement is used.\" and major_version() = 2\n  or\n  result = \"The 'exec' function is used.\" and major_version() = 3\n}\n\n// Identifies calls to the global 'exec' function\npredicate isExecFunctionCall(Call callNode) {\n  exists(GlobalVariable execVar | \n    execVar = callNode.getFunc().(Name).getVariable() and \n    execVar.getId() = \"exec\"\n  )\n}\n\n// Select all AST nodes representing exec usage\nfrom AstNode execNode\n_______________ // 补全条件\nselect execNode, getExecWarningMessage()",
    "output": "where isExecFunctionCall(execNode) or execNode instanceof Exec"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-and-import-from]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects modules imported using both direct import and from-import statements",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imported using both 'import' and 'import from' statements\n * @description Detects modules imported using both direct import and from-import statements\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision very-high\n * @id py/import-and-import-from\n */\n\n// Import Python analysis library for code examination\nimport python\n\n// Predicate to identify modules imported via both import styles\npredicate dualImportStyle(Import directImport, Import fromImport, Module targetModule) {\n  // Verify both imports belong to the same enclosing module\n  directImport.getEnclosingModule() = fromImport.getEnclosingModule() and\n  // Extract import expressions and validate module name consistency\n  exists(ImportExpr directExpr, ImportExpr fromExpr, ImportMember importedMember |\n    // Direct import expression retrieval\n    directExpr = directImport.getAName().getValue() and \n    // From-import member extraction\n    importedMember = fromImport.getAName().getValue() and \n    // Module expression from from-import\n    fromExpr = importedMember.getModule()\n  |\n    // Confirm both expressions reference the target module\n    directExpr.getName() = targetModule.getName() and \n    fromExpr.getName() = targetModule.getName()\n  )\n}\n\n// Query execution with filtered imports and modules\nfrom Import directImport, Import fromImport, Module targetModule\n// Apply predicate to identify dual import patterns\nwhere dualImportStyle(directImport, fromImport, targetModule)\n// Generate alert for the first import occurrence\nselect directImport, \"Module '\" + targetModule.getName() + \"' uses both 'import' and 'import from' statements.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Key Exchange Algorithms Detection\n * @description Discovers all cryptographic key exchange algorithm implementations across supported libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/key-exchange\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import core Python analysis framework for code examination\nimport python\n\n// Import experimental cryptography concepts and primitives for security analysis\nimport experimental.cryptography.Concepts\n\n// Query to identify all cryptographic key exchange algorithm implementations\n// These algorithms are potential security concerns in the context of quantum computing\n_______________ // 补全条件\n\n// Generate results showing each identified key exchange algorithm\n// with a descriptive message indicating its usage\nselect keyExchangeAlgo, \"Use of algorithm \" + keyExchangeAlgo.getName()",
    "output": "from KeyExchangeAlgorithm keyExchangeAlgo"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Outgoing class dependencies\n * @description Measures the count of external dependencies for each class to evaluate coupling.\n * @kind treemap\n * @id py/efferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags testability\n *       modularity\n */\n\nimport python\n\n// 分析传出耦合：衡量一个类依赖其他类的程度\n// 高传出耦合值表明类对外部依赖较多，可能降低模块化和可测试性\n// 通过量化这些依赖，可以识别需要重构的紧密耦合类\n// 结果按传出耦合数量降序排列，优先显示高耦合类\nfrom ClassMetrics examinedClass\n_______________ // 补全条件\nselect examinedClass, \n       examinedClass.getEfferentCoupling() as efferentCouplingValue \norder by efferentCouplingValue desc",
    "output": "where exists(examinedClass.getEfferentCoupling())"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/improper-ldap-auth]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A user-controlled query carries no authentication",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Improper LDAP Authentication\n * @description A user-controlled query carries no authentication\n * @kind problem\n * @problem.severity warning\n * @id py/improper-ldap-auth\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\n// 确定精度的导入语句\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\n\n// 定义一个谓词函数，用于判断是否存在不当的LDAP认证\npredicate authenticatesImproperly(LdapBind ldapBind) {\n  // 如果存在从任意None值到ldapBind密码的局部数据流，或者ldapBind没有设置密码，则返回true\n  (\n    DataFlow::localFlow(DataFlow::exprNode(any(None noneName)), ldapBind.getPassword()) or\n    not exists(ldapBind.getPassword())\n  )\n  // 或者存在一个空字符串，并且存在从该空字符串到ldapBind密码的局部数据流，则返回true\n  or\n  exists(StringLiteral emptyString |\n    emptyString.getText() = \"\" and\n    DataFlow::localFlow(DataFlow::exprNode(emptyString), ldapBind.getPassword())\n  )\n}\n\n// 查询所有不当的LDAP绑定操作\nfrom LdapBind ldapBind\nwhere authenticatesImproperly(ldapBind)\nselect ldapBind, \"The following LDAP bind operation is executed without authentication.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Redundant 'global' statement at module level\n * @description Identifies unnecessary use of the 'global' keyword at module scope in Python.\n *              Module-level variables are inherently global, making explicit declarations redundant.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-global-declaration\n */\n\n// Import Python analysis library for accessing code structure and semantic information\nimport python\n\n// Detect all redundant global variable declarations located at module scope\n// The 'global' keyword is unnecessary at module level since variables have global scope by default\nfrom Global moduleLevelGlobal\nwhere \n    // Confirm that the global declaration exists within module-level scope\n_______________ // 补全条件\n    moduleLevelGlobal.getScope() instanceof Module\nselect \n    moduleLevelGlobal, \n    // Create warning message highlighting the redundant global declaration\n    \"Redundant global declaration: '\" + moduleLevelGlobal.getAName() + \"' at module level is unnecessary.\"",
    "output": "// Variables defined at module level automatically have global scope"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/syntax-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects syntax errors in Python code that can lead to runtime failures and hinder code analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Syntax error\n * @description Detects syntax errors in Python code that can lead to runtime failures and hinder code analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import Python language analysis module for syntax error detection capabilities\nimport python\n\n// Query to identify syntax errors excluding encoding-related issues\nfrom SyntaxError syntaxIssue\nwhere \n  // Filter out encoding errors as they are handled separately\n  not syntaxIssue instanceof EncodingError\nselect \n  // Output syntax error details along with the current Python major version\n  syntaxIssue, \n  syntaxIssue.getMessage() + \" (in Python \" + major_version() + \").\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unsafe-unpacking]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：提取来自用户控制源的tar文件时，未验证目标文件路径是否在目标目录内，可能导致目标目录外的文件被覆盖。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file write during a tarball extraction from a user controlled source\n * @description 提取来自用户控制源的tar文件时，未验证目标文件路径是否在目标目录内，可能导致目标目录外的文件被覆盖。\n *             更具体地说，如果tar文件来自用户控制的位置（无论是远程位置还是命令行参数），则可能发生这种情况。\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// 定义恶意tarball源节点和不安全提取目标节点\nfrom UnsafeUnpackFlow::PathNode maliciousTarballSource, \n     UnsafeUnpackFlow::PathNode unsafeExtractionSink\n// 验证从恶意源到不安全目标的路径存在性\nwhere UnsafeUnpackFlow::flowPath(maliciousTarballSource, unsafeExtractionSink)\n// 生成安全警告，包含源节点、目标节点及风险描述\nselect unsafeExtractionSink.getNode(), \n       maliciousTarballSource, \n       unsafeExtractionSink,\n       \"Unsafe extraction from a malicious tarball retrieved from a remote location.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Callable Entity Extents\n * @description Identifies all callable entities (functions/methods) in Python code\n * @kind extent\n * @id py/callable-extents\n * @metricType callable\n */\n\nimport python\n\nfrom Function callableEntity\nselect callableEntity.getLocation(), callableEntity",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Explicit invocation of `__del__` method\n * @description Detects explicit calls to Python's special method `__del__`, which should only be invoked by the runtime during garbage collection. Explicit invocation may cause unexpected behavior.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/explicit-call-to-delete\n */\n\nimport python\n\nclass ExplicitDelMethodCall extends Call {\n  ExplicitDelMethodCall() {\n    // Identify calls targeting the __del__ method via attribute access\n    exists(Attribute delAttr | \n      delAttr = this.getFunc() and \n      delAttr.getName() = \"__del__\"\n    )\n  }\n\n  predicate isSuperInvocation() {\n    // Determine if call occurs within a __del__ method context\n    exists(Function containingDelMethod | \n      containingDelMethod = this.getScope() and \n_______________ // 补全条件\n      // Case 1: Direct self-reference invocation (e.g., self.__del__())\n      containingDelMethod.getArg(0).asName().getVariable() = this.getArg(0).(Name).getVariable()\n      or\n      // Case 2: Superclass invocation (e.g., super().__del__() or super(Class, self).__del__())\n      exists(Call superInvocation | \n        superInvocation = this.getFunc().(Attribute).getObject() and\n        superInvocation.getFunc().(Name).getId() = \"super\"\n      )\n    )\n  }\n}\n\nfrom ExplicitDelMethodCall explicitDelCall\nwhere not explicitDelCall.isSuperInvocation()\nselect explicitDelCall, \"The __del__ special method is called explicitly.\"",
    "output": "containingDelMethod.getName() = \"__del__\" |"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lgtm/class-display-strings]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all Python classes within the codebase",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Display string representations for Python classes\n * @description Identifies all Python classes within the codebase\n *              and presents them along with their names as display strings.\n * @kind display-string\n * @id py/lgtm/class-display-strings\n * @metricType reftype\n */\n\nimport python\n\n// Retrieve every Python class definition found in the codebase\nfrom Class pyCls\n// Output the class entity and its name as the display string representation\nselect pyCls, pyCls.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Overly complex `__del__` method\n * @description This rule identifies Python classes containing `__del__` methods with high cyclomatic complexity.\n *              The `__del__` method in Python is invoked during object destruction, a process that\n *              can occur unpredictably or may be skipped entirely in certain scenarios.\n *              Methods with high complexity in `__del__` can cause performance issues and\n *              erratic behavior during garbage collection cycles. Best practices suggest\n *              maintaining minimal complexity in these special methods.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python\n\nfrom FunctionValue destructorMethod\nwhere\n  exists(ClassValue ownerClass |\n    // Verify the method is the __del__ method of a class\n    ownerClass.declaredAttribute(\"__del__\") = destructorMethod\n  ) and\n  // Check if the method's cyclomatic complexity exceeds the threshold of 3\n  destructorMethod.getScope().getMetrics().getCyclomaticComplexity() > 3\nselect destructorMethod, \"Overly complex '__del__' method.\"",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/summarized-callable-call-sites]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies call sites invoking summarized callables",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Summarized callable call sites\n * @description Identifies call sites invoking summarized callables\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/summarized-callable-call-sites\n * @tags meta\n * @precision very-low\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\nimport meta.MetaMetrics\n\n// Define analysis variables: invocation node, summarized target, and call type\nfrom DataFlow::Node invocationNode, SummarizedCallable summarizedTarget, string callType\nwhere\n  // Exclude call sites located in ignored files\n  not invocationNode.getLocation().getFile() instanceof IgnoredFile\n  and\n  (\n    // Direct invocation scenario: matches call sites of the summarized callable\n    (invocationNode = summarizedTarget.getACall() and callType = \"Call\")\n    or\n    // Callback invocation scenario: matches callback sites of the summarized callable\n    (invocationNode = summarizedTarget.getACallback() and callType = \"Callback\")\n  )\n// Output invocation node with formatted call type and target information\nselect invocationNode, callType + \" to \" + summarizedTarget"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raise-not-implemented]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code that raises 'NotImplemented' instead of 'NotImplementedError',",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name NotImplemented is not an Exception\n * @description Detects code that raises 'NotImplemented' instead of 'NotImplementedError',\n *              which causes runtime type errors since NotImplemented is not an exception class.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Core Python language analysis modules\nimport python\n\n// Specialized analysis for NotImplemented misuse detection\nimport Exceptions.NotImplemented\n\n// Identify problematic raise statements using NotImplemented\nfrom Expr problematicRaiseExpr\nwhere \n    // Match raise statements incorrectly using NotImplemented\n    // instead of the proper exception class NotImplementedError\n    use_of_not_implemented_in_raise(_, problematicRaiseExpr)\nselect \n    // Report the problematic expression with remediation advice\n    problematicRaiseExpr, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Reuse of loop variable in nested loops after inner loop redefinition\n * @description Identifies scenarios where a loop variable is redefined in an inner loop\n *              and then used in the outer loop, which can cause unintended behavior.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/nested-loops-with-same-variable-reused\n */\n\nimport python\n\n_______________ // 补全条件\npredicate findNestedLoopVarReuse(For innerLoop, For outerLoop, Variable reusedVar, Name varUsage) {\n  /* Verify variable is used in outer loop but not in inner loop */\n  outerLoop.contains(varUsage) and \n  not innerLoop.contains(varUsage) and \n  /* Ensure inner loop is directly nested within outer loop's body (excluding else blocks) */\n  outerLoop.getBody().contains(innerLoop) and \n  exists(SsaVariable ssaDefinition |\n    // Confirm inner loop redefines the variable\n    innerLoop.getTarget().getAFlowNode() = ssaDefinition.getAnUltimateDefinition().getDefinition() and \n    reusedVar = ssaDefinition.getVariable() and \n    // Verify outer loop also uses the same variable\n    exists(SsaVariable outerSsaDef |\n      outerLoop.getTarget().getAFlowNode() = outerSsaDef.getDefinition() and \n      reusedVar = outerSsaDef.getVariable()\n    ) and \n    // Ensure the variable usage corresponds to the SSA definition\n    ssaDefinition.getAUse().getNode() = varUsage\n  )\n}\n\n// Main query: Identify problematic nested loop variable reuse patterns\nfrom For innerLoop, For outerLoop, Variable reusedVar, Name varUsage\nwhere findNestedLoopVarReuse(innerLoop, outerLoop, reusedVar, varUsage)\nselect innerLoop, \"Nested for statement $@ loop variable '\" + reusedVar.getId() + \"' of enclosing $@.\", \n       varUsage, \"uses\", outerLoop, \"for statement\"",
    "output": "// Detects nested loop structures where a variable is reused after redefinition"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and processes alert suppression mechanisms in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Identifies and processes alert suppression mechanisms in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import the CodeQL library for handling alert suppression functionality\nprivate import codeql.util.suppression.AlertSuppression as AlertSupp\n// Import the CodeQL module for processing Python comments\nprivate import semmle.python.Comment as PyComment\n\n// Defines a class representing AST nodes that can be tracked by their source location\nclass AstNode instanceof PyComment::AstNode {\n  // Determines if the node's location matches the specified file path and coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startColumn, int endLine, int endColumn\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startColumn, endLine, endColumn)\n  }\n\n  // Provides a textual representation of the AST node\n  string toString() { result = super.toString() }\n}\n\n// Defines a class representing single-line comments with location tracking capabilities\nclass SingleLineComment instanceof PyComment::Comment {\n  // Determines if the comment's location matches the specified file path and coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startColumn, int endLine, int endColumn\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startColumn, endLine, endColumn)\n  }\n\n  // Retrieves the textual content of the comment\n  string getText() { result = super.getContents() }\n\n  // Provides a textual representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Creates the suppression relationship framework using the AlertSupp template\nimport AlertSupp::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Defines a class for handling noqa-style suppression comments commonly used in Python\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Constructor that identifies comments matching the noqa pattern\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Specifies the annotation identifier for this suppression type\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Defines the scope of code that this suppression comment covers\n  override predicate covers(\n    string filePath, int startLine, int startColumn, int endLine, int endColumn\n  ) {\n    exists(int commentStartLine, int commentEndLine, int commentEndColumn |\n      this.hasLocationInfo(filePath, commentStartLine, _, commentEndLine, commentEndColumn) and\n      // Ensure the suppression covers from the beginning of the line to the comment's end\n      startLine = commentStartLine and\n      endLine = commentEndLine and\n      startColumn = 1 and\n      endColumn = commentEndColumn\n    )\n  }\n}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/direct-imports-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the quantity of modules that are directly imported by each Python file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Direct imports per file\n * @description Measures the quantity of modules that are directly imported by each Python file.\n *              Elevated counts might suggest strong coupling between modules, which could\n *              compromise modularity and make maintenance more challenging.\n * @kind treemap\n * @id py/direct-imports-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg max\n * @tags modularity\n *       maintainability\n */\n\n// Import the necessary Python analysis framework for AST traversal and module examination\nimport python\n\n// For every Python source file, determine how many modules it directly imports\nfrom ModuleValue sourceModule, int importCount\nwhere \n  // Calculate the total number of distinct modules that the current file imports directly\n  importCount = count(ModuleValue dependency | \n                    dependency = sourceModule.getAnImportedModule())\n// Display the file's scope along with its corresponding direct import count\nselect sourceModule.getScope(), importCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Count of non-default parameters\n * @description This analysis identifies Python functions containing parameters\n *              that do not have default values assigned. Functions with numerous\n *              non-default parameters often become harder to maintain and test,\n *              as they require more explicit arguments during invocation. By\n *              quantifying this metric, developers can pinpoint functions that\n *              may benefit from refactoring, such as introducing default values\n *              or parameter objects to improve code quality.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n_______________ // 补全条件\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // Provides static analysis capabilities for Python code\n\n// Retrieve function metrics to analyze parameter patterns\nfrom FunctionMetrics funcMetric\n// For each function, calculate and display the count of parameters without default values\n// Results are ordered from highest to lowest to prioritize functions needing attention\nselect funcMetric, \n       funcMetric.getNumberOfParametersWithoutDefault() as nonDefaultParamCount \norder by nonDefaultParamCount desc",
    "output": "* @metricType callable"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Integer division result may be truncated in Python 2\n * @description Detects integer division operations in Python 2 that may truncate results.\n *              In Python 2, the '/' operator performs floor division when both operands\n *              are integers, which can lead to unexpected truncation of fractional parts.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// Identify division operations in Python 2 that may truncate results\nfrom BinaryExpr divisionExpr, ControlFlowNode leftOperand, ControlFlowNode rightOperand\nwhere\n  // Only applicable in Python 2 where '/' does floor division for integers\n  major_version() = 2 and\n  \n  // Check if this is a division operation with integer operands\n  exists(BinaryExprNode binaryNode, Value leftVal, Value rightVal |\n    // Verify this is a division operation\n    binaryNode = divisionExpr.getAFlowNode() and\n    binaryNode.getNode().getOp() instanceof Div and\n    \n    // Verify both operands are integers\n    binaryNode.getLeft().pointsTo(leftVal, leftOperand) and\n    leftVal.getClass() = ClassValue::int_() and\n    binaryNode.getRight().pointsTo(rightVal, rightOperand) and\n    rightVal.getClass() = ClassValue::int_() and\n    \n    // Ensure the division would actually truncate (has a remainder)\n    not leftVal.(NumericValue).getIntValue() % rightVal.(NumericValue).getIntValue() = 0 and\n    \n    // Exclude modules that have enabled true division via future import\n    not binaryNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // Exclude cases where the result is explicitly converted to int\n    not exists(CallNode intCast |\n      intCast = ClassValue::int_().getACall() and\n      intCast.getAnArg() = binaryNode\n_______________ // 补全条件\n  )\nselect divisionExpr, \n  \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftOperand, \"left\", rightOperand, \"right\"",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name CORS Misconfiguration with Credentials\n * @description Disabling or weakening Same-Origin Policy (SOP) protection may expose\n *              the application to CORS attacks when credentials are allowed.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n// 检查来源配置是否包含通配符或空值\npredicate hasWildcardOrigin(DataFlow::Node originConfigNode) {\n  // 情况1：来源配置直接是 \"*\" 或 \"null\" 字符串\n  exists(StringLiteral literal |\n    literal = originConfigNode.asExpr() and\n    literal.getText() in [\"*\", \"null\"]\n  )\n_______________ // 补全条件\n  or\n  originConfigNode.asExpr() instanceof List and\n  exists(StringLiteral literal |\n    literal = originConfigNode.asExpr().getASubExpression() and\n    literal.getText() in [\"*\", \"null\"]\n  )\n}\n\n// 验证中间件是否为 CORS 类型\npredicate isCorsMiddlewareType(Http::Server::CorsMiddleware corsConfig) {\n  corsConfig.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n// 检查中间件是否启用了凭证支持\npredicate supportsCredentials(Http::Server::CorsMiddleware corsConfig) {\n  corsConfig.getCredentialsAllowed().asExpr() instanceof True\n}\n\n// 查询存在安全风险的 CORS 中间件配置\nfrom Http::Server::CorsMiddleware corsConfig\nwhere\n  // 条件组合：确认中间件类型 + 启用凭证 + 使用通配符来源\n  isCorsMiddlewareType(corsConfig) and\n  supportsCredentials(corsConfig) and\n  hasWildcardOrigin(corsConfig.getOrigins().getALocalSource())\nselect corsConfig,\n  // 安全风险说明：允许任意来源的认证请求可能导致敏感数据泄露\n  \"This CORS middleware configuration allows authenticated cross-origin requests from any source, potentially exposing sensitive data\"",
    "output": "// 情况2：来源配置是列表且包含 \"*\" 或 \"null\" 元素"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/tests-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes the total number of test functions present in each Python module",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Test Method Count\n * @description Computes the total number of test functions present in each Python module\n * @kind treemap\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg sum max\n * @id py/tests-in-files\n */\n\n// Import Python language analysis capabilities\nimport python\n// Import test case identification utilities\nimport semmle.python.filters.Tests\n\n// Define the main query to count test methods per module\nfrom Module pyModule, int numTests\nwhere \n  // Compute the precise count of test methods in each module\n  numTests = strictcount(Test testCase | \n    testCase.getEnclosingModule() = pyModule\n  )\n// Return the module file and its test count, sorted by count (descending)\nselect pyModule.getFile(), numTests order by numTests desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-global]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies global variables accessed outside module initialization scope.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of the 'global' statement.\n * @description Identifies global variables accessed outside module initialization scope.\n *              This practice violates encapsulation principles and may lead to \n *              maintenance challenges and debugging difficulties.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/use-of-global\n */\n\nimport python\n\n// Identify global variable declarations occurring outside module scope\nfrom Global nonModuleGlobalVar\n// Verify the variable's scope is not module-level initialization\nwhere not (nonModuleGlobalVar.getScope() instanceof Module)\n// Report instances with contextual warning message\nselect nonModuleGlobalVar, \"Modifying global variables outside module initialization is discouraged.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-star-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of wildcard imports which can lead to namespace pollution",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' used\n * @description Detects usage of wildcard imports which can lead to namespace pollution\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// Import the Python analysis library to enable code pattern detection\nimport python\n\n// Identify all instances where wildcard imports are used in the codebase\nfrom ImportStar starImport\n\n// Report each wildcard import instance with a warning about namespace pollution\nselect starImport, \"Using 'from ... import *' pollutes the namespace.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A module imports itself",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description A module imports itself\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n/**\n * Detects when a module imports itself through any import mechanism\n * \n * This predicate identifies cases where a Python module performs a self-import operation,\n * which can lead to circular dependencies and unnecessary complexity. Self-imports are\n * considered anti-patterns as they don't provide any functional benefit while potentially\n * causing maintenance issues.\n * \n * Parameters:\n * - importStmt: The import statement that performs the self-import\n * - importedModule: The module value representing the imported module\n */\npredicate isSelfImport(ImportingStmt importStmt, ModuleValue importedModule) {\n  // Verify that the module containing the import statement is the same as the module being imported\n  importStmt.getEnclosingModule() = importedModule.getScope() and\n  // Find the most appropriate module value by prioritizing longer module names\n  // This approach ensures correct handling of relative imports by matching the longest possible name\n  importedModule = \n    max(string importedName, ModuleValue candidateModule |\n      // Extract the module name from the import statement\n      importedName = importStmt.getAnImportedModuleName() and\n      // Ensure the candidate module matches the imported name\n      candidateModule.importedAs(importedName)\n    |\n      // Order by name length descending to prioritize longest matches\n      candidateModule order by importedName.length() desc\n    )\n}\n\n// Query execution: Find all instances where modules import themselves\n// \n// This query analyzes import statements across the codebase to detect self-import patterns.\n// Each identified instance is reported with a descriptive message indicating which module\n// is performing the self-import operation.\nfrom ImportingStmt importStmt, ModuleValue importedModule\nwhere isSelfImport(importStmt, importedModule)\nselect importStmt, \"The module '\" + importedModule.getName() + \"' imports itself.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-number-class-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测类实例化时传入参数数量与`__init__`方法定义不匹配的情况，这会导致运行时TypeError异常。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 错误的类实例化参数数量\n * @description 检测类实例化时传入参数数量与`__init__`方法定义不匹配的情况，这会导致运行时TypeError异常。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call callSite, ClassValue targetClass, string issueDescription, string requirementPrefix, int allowedArgCount, FunctionValue classInitializer\nwhere\n  // 获取目标类的初始化方法（构造函数）\n  classInitializer = get_function_or_initializer(targetClass) and\n  (\n    // 处理参数数量超过上限的情况\n    too_many_args(callSite, targetClass, allowedArgCount) and\n    issueDescription = \"too many arguments\" and\n    requirementPrefix = \"no more than \"\n    or\n    // 处理参数数量低于下限的情况\n    too_few_args(callSite, targetClass, allowedArgCount) and\n    issueDescription = \"too few arguments\" and\n    requirementPrefix = \"no fewer than \"\n  )\nselect callSite, \"Call to $@ with \" + issueDescription + \"; should be \" + requirementPrefix + allowedArgCount.toString() + \".\", classInitializer,\n  // 输出调用点、错误消息及初始化方法的完全限定名\n  classInitializer.getQualifiedName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Timing attack against Hash\n * @description Identifies potential timing vulnerabilities in hash verification processes.\n *              Non-constant-time comparisons allow attackers to forge valid message hashes\n *              through timing analysis when they can submit verification requests.\n *              Successful exploitation may lead to authentication bypass.\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/timing-attack-against-hash\n * @tags security\n *       external/cwe/cwe-208\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * Configuration module for tracking data flow from cryptographic operations\n * to non-constant-time comparisons, enabling timing attack detection.\n */\nprivate module CryptoTimingFlowConfiguration implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node originNode) { \n    originNode instanceof ProduceCryptoCall \n  }\n\n  predicate isSink(DataFlow::Node targetNode) { \n    targetNode instanceof NonConstantTimeComparisonSink \n  }\n}\n\n/**\n * Global taint tracking module for identifying timing attack paths\n * from cryptographic sources to vulnerable comparison sinks.\n */\nmodule CryptoTimingFlow = TaintTracking::Global<CryptoTimingFlowConfiguration>;\nimport CryptoTimingFlow::PathGraph\n_______________ // 补全条件\n/**\n * Detects timing attack vulnerabilities where cryptographic outputs\n * are compared using non-constant-time operations that involve user input.\n */\nfrom CryptoTimingFlow::PathNode originPathNode, CryptoTimingFlow::PathNode targetPathNode\nwhere\n  CryptoTimingFlow::flowPath(originPathNode, targetPathNode) and\n  targetPathNode.getNode().(NonConstantTimeComparisonSink).includesUserInput()\nselect \n  targetPathNode.getNode(), \n  originPathNode, \n  targetPathNode, \n  \"Timing attack against $@ validation.\", \n  originPathNode.getNode().(ProduceCryptoCall).getResultType(), \n  \"message\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/multiple-imports-on-line]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Defining multiple imports on one line makes code more difficult to read;",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Multiple imports on one line\n * @description Defining multiple imports on one line makes code more difficult to read;\n *              PEP8 states that imports should usually be on separate lines.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/multiple-imports-on-line\n */\n\nimport python\n\n// Identify import statements that violate PEP 8's one-import-per-line guideline\n// by importing multiple modules on a single line (excluding 'from ... import ...' style)\nfrom Import stmt\nwhere \n    // Count imported modules and verify multiple modules exist\n    count(stmt.getAName()) > 1 and\n    // Exclude 'from ... import ...' constructs\n    not stmt.isFromImport()\nselect stmt, \"Multiple imports on one line.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure randomness\n * @description Detects the use of cryptographically weak pseudo-random number generators\n *              for generating security-sensitive values, which could enable attackers\n *              to predict the generated values.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// Core Python language support for analysis\nimport python\n\n// Data flow tracking modules for vulnerability detection\nimport semmle.python.dataflow.new.DataFlow\nimport InsecureRandomness::Flow::PathGraph\n\n// Security analysis module for identifying insecure random number generation\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Query to trace data flow from insecure random sources to security-sensitive sinks\nfrom InsecureRandomness::Flow::PathNode insecureRandomSource, InsecureRandomness::Flow::PathNode securitySensitiveSink\nwhere InsecureRandomness::Flow::flowPath(insecureRandomSource, securitySensitiveSink)\nselect securitySensitiveSink.getNode(), insecureRandomSource, securitySensitiveSink, \n_______________ // 补全条件\n       insecureRandomSource.getNode(), \"random value\"",
    "output": "\"Cryptographically insecure $@ in a security context.\","
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/redundant-comparison]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects comparisons whose outcomes are predetermined by prior conditional checks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Redundant comparison\n * @description Detects comparisons whose outcomes are predetermined by prior conditional checks.\n * @kind problem\n * @tags useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/redundant-comparison\n */\n\nimport python\nimport semmle.python.Comparisons\n\n/*\n * Checks if a comparison expression uses chained operators (e.g., 'a < b < c')\n * instead of a simple binary comparison.\n */\nprivate predicate containsChainedOperators(Expr expr) {\n  // Identify expressions with multiple comparison operators\n  exists(expr.(Compare).getOp(1))\n  or\n  // Recursively check operands of unary expressions\n  containsChainedOperators(expr.(UnaryExpr).getOperand())\n}\n\n/**\n * Determines if a comparison is redundant when a stricter condition\n * already controls the same execution path.\n */\nprivate predicate isRedundantComparison(Comparison cmpExpr, ComparisonControlBlock ctrlBlock, boolean outcome) {\n  // Verify the control block enforces a stricter condition\n  ctrlBlock.impliesThat(cmpExpr.getBasicBlock(), cmpExpr, outcome) and\n  /* Exclude chained comparisons due to incomplete flow analysis */\n  // Skip expressions with chained operators\n  not containsChainedOperators(ctrlBlock.getTest().getNode())\n}\n\nprivate predicate locatesRedundantComparison(AstNode testNode, AstNode prevNode, boolean outcome) {\n  // Find all redundant comparisons by examining control flow\n  forex(Comparison cmpExpr, ConditionBlock condBlock |\n    cmpExpr.getNode() = testNode and\n    condBlock.getLastNode().getNode() = prevNode\n  |\n    isRedundantComparison(cmpExpr, condBlock, outcome)\n  )\n}\n\nfrom Expr currentTest, Expr priorTest, boolean evalResult\nwhere\n  // Identify redundant tests while excluding nested redundant tests\n  locatesRedundantComparison(currentTest, priorTest, evalResult) and \n  not locatesRedundantComparison(currentTest.getAChildNode+(), priorTest, _)\nselect currentTest, \"Test is always \" + evalResult + \", due to $@.\", priorTest, \"this condition\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 跨域资源共享（CORS）策略绕过\n * @description 通过使用弱字符串比较方法（如 'string.startswith'）验证用户提供的 Origin 头部，\n *              可能导致 CORS 安全策略被绕过。\n * @kind path-problem\n * @problem.severity warning\n * @id py/cors-bypass\n * @tags security\n *       externa/cwe/CWE-346\n */\n\nimport python\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.Flow\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n/**\n * 判断输入字符串是否包含与 CORS 相关的关键词\n */\nbindingset[inputStr]\npredicate containsCorsKeywords(string inputStr) { \n  inputStr.matches([\"%origin%\", \"%cors%\"]) \n}\n\n/**\n * 表示字符串前缀检查方法调用\n */\nprivate class PrefixCheckCall extends ControlFlowNode {\n  PrefixCheckCall() { \n    this.(CallNode).getFunction().(AttrNode).getName() = \"startswith\" \n  }\n}\n\n/**\n * 检查控制流节点是否与 CORS 相关\n * \n * 使用启发式方法识别可能涉及 CORS 验证的代码节点：\n * 1. 检查调用函数的变量名（如 origin.startswith(\"...\")）\n * 2. 检查作为参数的变量名（如 \"...\".startswith(origin)）\n * 3. 检查值写入的变量名（如 origin = ...）\n */\nprivate predicate isCorsRelated(ControlFlowNode flowNode) {\n  // 情况1：调用函数的变量名包含 CORS 关键词（汇点）\n  exists(string identifier | \n    containsCorsKeywords(identifier) and \n    flowNode.(CallNode).getFunction().(AttrNode).getObject().(NameNode).getId() = identifier\n  )\n  or\n  // 情况2：作为参数的变量名包含 CORS 关键词（汇点）\n  exists(string identifier | \n    containsCorsKeywords(identifier) and \n_______________ // 补全条件\n  )\n  or\n  // 情况3：值写入的变量名包含 CORS 关键词（源点）\n  exists(Variable var | \n    containsCorsKeywords(var.getId()) and \n    flowNode.getASuccessor*().getNode() = var.getAStore()\n  )\n}\n\n/**\n * 表示 CherryPy 框架的请求对象成员\n * 作为远程流源被识别\n */\nclass CherryPyRequestSource extends RemoteFlowSource::Range {\n  CherryPyRequestSource() {\n    this =\n      API::moduleImport(\"cherrypy\")\n          .getMember(\"request\")\n          .getMember([\n              \"charset\", \"content_type\", \"filename\", \"fp\", \"name\", \"params\", \"headers\", \"length\"\n            ])\n          .asSource()\n  }\n\n  override string getSourceType() { \n    result = \"cherrypy.request\" \n  }\n}\n\n/**\n * CORS 安全绕过分析配置\n */\nmodule CorsSecurityConfig implements DataFlow::ConfigSig {\n  /**\n   * 定义数据流源：所有远程流源\n   */\n  predicate isSource(DataFlow::Node dataFlowNode) { \n    dataFlowNode instanceof RemoteFlowSource \n  }\n\n  /**\n   * 定义数据流汇：startswith 方法的参数或调用对象\n   */\n  predicate isSink(DataFlow::Node dataFlowNode) {\n    exists(PrefixCheckCall prefixCheck |\n      dataFlowNode.asCfgNode() = prefixCheck.(CallNode).getArg(0) or\n      dataFlowNode.asCfgNode() = prefixCheck.(CallNode).getFunction().(AttrNode).getObject()\n    )\n  }\n\n  /**\n   * 定义额外流步骤：处理 cherrypy.request.headers.get() 调用\n   */\n  predicate isAdditionalFlowStep(DataFlow::Node sourceNode, DataFlow::Node targetNode) {\n    exists(API::CallNode apiInvocation, API::Node requestHeadersNode |\n      requestHeadersNode = API::moduleImport(\"cherrypy\").getMember(\"request\").getMember(\"headers\") and\n      apiInvocation = requestHeadersNode.getMember(\"get\").getACall()\n    |\n      apiInvocation.getReturn().asSource() = targetNode and \n      requestHeadersNode.asSource() = sourceNode\n    )\n  }\n\n  // 启用增量模式差异观察\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// 全局污点跟踪模块\nmodule CorsSecurityFlow = TaintTracking::Global<CorsSecurityConfig>;\n\nimport CorsSecurityFlow::PathGraph\n\n/**\n * 查询潜在 CORS 策略绕过漏洞\n */\nfrom CorsSecurityFlow::PathNode pathSource, CorsSecurityFlow::PathNode pathSink\nwhere\n  CorsSecurityFlow::flowPath(pathSource, pathSink) and\n  (\n    isCorsRelated(pathSource.getNode().asCfgNode())\n    or\n    isCorsRelated(pathSink.getNode().asCfgNode())\n  )\nselect pathSink, pathSource, pathSink,\n  \"使用弱字符串比较验证 Origin 头部，可能导致 CORS 安全策略被绕过。\"",
    "output": "flowNode.(CallNode).getArg(0).(NameNode).getId() = identifier"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/explicit-call-to-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The `__del__` method is a special method in Python that gets invoked by the garbage collector",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Explicit invocation of `__del__` method\n * @description The `__del__` method is a special method in Python that gets invoked by the garbage collector\n *              when an object is about to be destroyed. Explicitly calling this method is generally considered\n *              bad practice as it can lead to unexpected behavior and violates the intended lifecycle management\n *              of Python objects.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/explicit-call-to-delete\n */\n\nimport python\n\n// 定义类用于识别所有显式调用__del__方法的情况\nclass DelMethodCall extends Call {\n  // 构造函数：筛选出所有调用__del__方法的Call节点\n  DelMethodCall() { \n    // 确保被调用的方法名是\"__del__\"\n    this.getFunc().(Attribute).getName() = \"__del__\" \n  }\n\n  // 判断当前调用是否为合法的super调用场景（通常发生在子类__del__方法中调用父类__del__）\n  predicate isValidSuperInvocation() {\n    // 检查调用是否发生在某个__del__方法的作用域内\n    exists(Function parentFunction | \n      parentFunction = this.getScope() and \n      parentFunction.getName() = \"__del__\" \n    |\n      // 合法场景1: 调用者使用当前实例的self参数\n      parentFunction.getArg(0).asName().getVariable() = this.getArg(0).(Name).getVariable()\n      or\n      // 合法场景2: 调用形式为super().__del__()或super(Type, self).__del__()\n      exists(Call superCall | \n        superCall = this.getFunc().(Attribute).getObject() |\n        superCall.getFunc().(Name).getId() = \"super\"\n      )\n    )\n  }\n}\n\n// 查询所有非法的显式__del__方法调用（排除合法的super调用场景）\nfrom DelMethodCall explicitDelInvocation\nwhere not explicitDelInvocation.isValidSuperInvocation()\nselect explicitDelInvocation, \"The __del__ special method is called explicitly.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of 'global' at module level\n * @description Use of the 'global' statement at module level\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n_______________ // 补全条件\n */\n\n// 导入Python分析库，用于解析Python代码结构\nimport python\n\n// 识别在模块作用域中使用global关键字声明的变量\n// 此类声明是不必要的，因为模块级变量天然具有全局作用域\nfrom Global moduleLevelGlobal\nwhere \n    // 验证全局声明是否位于模块作用域内\n    // 在模块作用域中使用global是多余的，因为该作用域内的变量默认为全局变量\n    moduleLevelGlobal.getScope() instanceof Module\nselect \n    moduleLevelGlobal, \n    // 生成警告信息，提示冗余的全局声明\n    \"Declaring '\" + moduleLevelGlobal.getAName() + \"' as global at module-level is redundant.\"",
    "output": "* @id py/redundant-global-declaration"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Binding a socket to all network interfaces\n * @description Binding a socket to all interfaces exposes it to traffic from any IPv4/IPv6 address,\n * creating significant security risks.\n * @kind problem\n * @tags security\n *       external/cwe/cwe-200\n * @problem.severity error\n * @security-severity 6.5\n * @sub-severity low\n * @precision high\n * @id py/bind-socket-all-network-interfaces\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n/** Defines all possible wildcard addresses representing all network interfaces */\nprivate string getWildcardAddress() {\n  result in [\n      // IPv4 wildcards\n      \"0.0.0.0\", \"\",\n      // IPv6 wildcards\n      \"::\", \"::0\"\n    ]\n}\n\n/** Propagates wildcard address references through data flow */\nprivate DataFlow::TypeTrackingNode propagateWildcardAddress(DataFlow::TypeTracker tracker, string wildcardAddr) {\n  tracker.start() and\n  exists(StringLiteral addressLiteral | \n    wildcardAddr = getWildcardAddress() and\n    addressLiteral.getText() = wildcardAddr and\n    result.asExpr() = addressLiteral\n  )\n  or\n  exists(DataFlow::TypeTracker prevTracker | \n    result = propagateWildcardAddress(prevTracker, wildcardAddr).track(prevTracker, tracker)\n  )\n}\n\n/** Retrieves data flow nodes containing wildcard address references */\nDataFlow::Node getWildcardAddressNode(string wildcardAddr) {\n  propagateWildcardAddress(DataFlow::TypeTracker::end(), wildcardAddr).flowsTo(result)\n}\n\n/** Tracks address tuples where the first element is a wildcard address */\nprivate DataFlow::TypeTrackingNode propagateAddressTupleWithWildcard(DataFlow::TypeTracker tracker, string wildcardAddr) {\n  tracker.start() and\n  exists(Tuple addressTuple | \n    addressTuple.getElt(0) = getWildcardAddressNode(wildcardAddr).asExpr() and\n    result.asExpr() = addressTuple\n_______________ // 补全条件\n  or\n  exists(DataFlow::TypeTracker prevTracker | \n    result = propagateAddressTupleWithWildcard(prevTracker, wildcardAddr).track(prevTracker, tracker)\n  )\n}\n\n/** Retrieves data flow nodes containing address tuples with wildcard addresses */\nDataFlow::Node getAddressTupleWithWildcardNode(string wildcardAddr) {\n  propagateAddressTupleWithWildcard(DataFlow::TypeTracker::end(), wildcardAddr).flowsTo(result)\n}\n\n/**\n * Identifies socket instances created with specific address families.\n * \n * Reference: https://docs.python.org/3/library/socket.html\n */\nAPI::Node getSocketCreation() { \n  result = API::moduleImport(\"socket\").getMember(\"socket\").getReturn() \n}\n\nfrom DataFlow::CallCfgNode socketBindCall, DataFlow::Node bindAddressArg, string wildcardAddr\nwhere\n  socketBindCall = getSocketCreation().getMember(\"bind\").getACall() and\n  bindAddressArg = socketBindCall.getArg(0) and\n  bindAddressArg = getAddressTupleWithWildcardNode(wildcardAddr)\nselect socketBindCall.asExpr(), \"Socket bound to all interfaces using '\" + wildcardAddr + \"'.\"",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "import python  // 导入Python语言分析库，提供代码分析的基础功能支持\nimport semmle.python.pointsto.PointsTo  // 导入PointsTo分析模块，支持变量指向关系的分析\n\n_______________ // 补全条件\nfrom ClassValue failedTypeClass, string failureReason\nwhere Types::failedInference(failedTypeClass, failureReason)\nselect failedTypeClass, failureReason",
    "output": "// 检测类型推断失败的类，并捕获对应的失败原因"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Substantial code duplication identifier\n * @description Identifies modules containing substantial code duplication. Refactoring these modules enhances maintainability and reduces technical debt.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-file\n */\n_______________ // 补全条件\nimport python\n\n// Define analysis variables for duplicate detection\nfrom \n  Module originalModule,\n  Module duplicateModule,\n  string duplicationDetails\nwhere \n  // Query disabled to prevent execution (no results generated)\n  none()\nselect \n  originalModule,\n  duplicationDetails,\n  duplicateModule,\n  duplicateModule.getName()",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/alerts/remote-flow-sources]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies external input sources that could introduce untrusted data",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Remote flow sources\n * @description Identifies external input sources that could introduce untrusted data\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/alerts/remote-flow-sources\n * @tags meta\n * @precision very-low\n */\n\n// Core Python analysis framework for AST processing\nprivate import python\n\n// Data flow tracking engine for taint analysis\nprivate import semmle.python.dataflow.new.DataFlow\n\n// Remote input source classification module\nprivate import semmle.python.dataflow.new.RemoteFlowSources\n\n// Metadata reporting utilities\nprivate import meta.MetaMetrics\n\n// Identify all remote input sources while excluding ignored files\nfrom RemoteFlowSource remoteSource\nwhere \n  // Filter out sources located in ignored files\n  not remoteSource.getLocation().getFile() instanceof IgnoredFile\n\n// Generate alerts with source type classification\nselect remoteSource, \"RemoteFlowSource: \" + remoteSource.getSourceType()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/clear-text-storage-sensitive-data]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别系统中以明文形式存储敏感数据的安全问题，这些数据未经加密或哈希处理，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 敏感信息明文存储检测\n * @description 识别系统中以明文形式存储敏感数据的安全问题，这些数据未经加密或哈希处理，\n *              可能导致敏感信息泄露给未授权访问者。\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/clear-text-storage-sensitive-data\n * @tags security\n *       external/cwe/cwe-312\n *       external/cwe/cwe-315\n *       external/cwe/cwe-359\n */\n\nimport python  // 导入Python代码分析基础库\nprivate import semmle.python.dataflow.new.DataFlow  // 私有导入数据流分析模块\nimport CleartextStorageFlow::PathGraph  // 导入敏感数据流路径图\nimport semmle.python.security.dataflow.CleartextStorageQuery  // 导入明文存储安全查询模块\n\nfrom \n  CleartextStorageFlow::PathNode sourceNode,  // 敏感数据源节点\n  CleartextStorageFlow::PathNode sinkNode,    // 明文存储位置节点\n  string dataCategory                         // 敏感数据分类标识\nwhere \n  // 验证存在从数据源到存储位置的完整数据流路径\n  CleartextStorageFlow::flowPath(sourceNode, sinkNode)\n  and \n  // 提取敏感数据的具体分类类型\n  dataCategory = sourceNode.getNode().(Source).getClassification()\nselect \n  sinkNode.getNode(),                    // 报告位置：明文存储点\n  sourceNode, sinkNode,                  // 数据流路径：源节点 -> 目标节点\n  \"This expression stores $@ as clear text.\",  // 警告消息模板\n  sourceNode.getNode(),                  // 消息参数：敏感数据源位置\n  \"sensitive data (\" + dataCategory + \")\"  // 敏感数据分类详情"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Quantum-Vulnerable Symmetric Encryption with Padding\n * @description Identifies symmetric encryption implementations employing padding mechanisms.\n *              Padding schemes in symmetric encryption can introduce security weaknesses\n *              that are particularly susceptible to exploitation in quantum computing environments. \n *              Conventional symmetric ciphers with padding may become inadequate against quantum attacks,\n *              requiring detection and replacement with quantum-resistant alternatives.\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n_______________ // 补全条件\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricPadding vulnerableCipher\nselect vulnerableCipher, \n       \"Identified symmetric encryption with padding: \" + vulnerableCipher.getPaddingName()",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'super' call in legacy class\n * @description Identifies super() invocations within legacy-style classes where such functionality is not supported.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n_______________ // 补全条件\n * @id py/super-in-old-style\n */\n\nimport python\n\n// Identifies super() invocations within legacy-style class contexts\npredicate superCallInOldStyleClass(Call superInvocation) {\n  exists(Function parentFunction, ClassObject parentClass |\n    // Verify the invocation targets the 'super' function\n    superInvocation.getFunc().(Name).getId() = \"super\" and\n    // Ensure invocation is inside a function\n    superInvocation.getScope() = parentFunction and\n    // Verify function is class member\n    parentFunction.getScope() = parentClass.getPyClass() and\n    // Confirm class is successfully analyzed\n    not parentClass.failedInference() and\n    // Identify legacy-style classes (non-new-style)\n    not parentClass.isNewStyle()\n  )\n}\n\n// Query for problematic super() invocations\nfrom Call invalidSuperCall\nwhere superCallInOldStyleClass(invalidSuperCall)\nselect invalidSuperCall, \"'super()' will not work in old-style classes.\"",
    "output": "* @precision very-high"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/modification-of-locals]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code that modifies the dictionary returned by locals(), which has no effect on actual local variables.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Modification of dictionary returned by locals()\n * @description Detects code that modifies the dictionary returned by locals(), which has no effect on actual local variables.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/modification-of-locals\n */\n\nimport python\n\n// Identifies control flow nodes referencing the result of a locals() call\npredicate referencesLocalsCall(ControlFlowNode node) { \n    node.pointsTo(_, _, Value::named(\"locals\").getACall()) \n}\n\n// Detects dictionary subscript operations (assignment/deletion) on locals() dictionary\npredicate modifiesLocalsViaSubscript(ControlFlowNode subscriptNode) {\n    exists(SubscriptNode subscript |\n        subscript = subscriptNode and\n        referencesLocalsCall(subscript.getObject()) and\n        (subscript.isStore() or subscript.isDelete())\n    )\n}\n\n// Detects dictionary method calls that modify content of locals() dictionary\npredicate modifiesLocalsViaMethod(ControlFlowNode methodCallNode) {\n    exists(CallNode call, AttrNode attributeNode, string methodName |\n        call = methodCallNode and\n        attributeNode = call.getFunction() and\n        referencesLocalsCall(attributeNode.getObject(methodName)) and\n        methodName in [\"pop\", \"popitem\", \"update\", \"clear\"]\n    )\n}\n\n// Detects any modification operation on the dictionary returned by locals()\npredicate modifiesLocalsDictionary(ControlFlowNode modificationNode) {\n    modifiesLocalsViaSubscript(modificationNode) or\n    modifiesLocalsViaMethod(modificationNode)\n}\n\nfrom AstNode astNode, ControlFlowNode modificationNode\nwhere\n    // Identify operations modifying the locals() dictionary\n    modifiesLocalsDictionary(modificationNode) and\n    // Map control flow node to corresponding AST node\n    astNode = modificationNode.getNode() and\n    // Exclude module-level scope where locals() is equivalent to globals()\n    not astNode.getScope() instanceof ModuleScope\n// Output results with warning message\nselect astNode, \"Modification of the locals() dictionary will have no effect on the local variables.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name SQL query constructed from user-controlled input\n * @description Building SQL statements with user-controlled data allows attackers\n *              to execute arbitrary SQL commands, leading to SQL injection flaws.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 8.8\n * @precision high\n * @id py/sql-injection\n * @tags security\n *       external/cwe/cwe-089\n */\n\n// 导入Python语言分析的核心组件\nimport python\n\n// 导入SQL注入漏洞的数据流分析模块\nimport semmle.python.security.dataflow.SqlInjectionQuery\n\n// 导入用于路径可视化的图形表示工具\nimport SqlInjectionFlow::PathGraph\n\n// 定义数据流追踪：识别从用户输入到SQL查询构建的完整数据流路径\nfrom \n_______________ // 补全条件\n  SqlInjectionFlow::PathNode vulnerableSink        // 表示存在SQL注入风险的接收点节点\nwhere \n  // 确认存在从用户输入到SQL查询的数据流\n  SqlInjectionFlow::flowPath(taintedSource, vulnerableSink)\nselect \n  vulnerableSink.getNode(),        // 定位SQL注入漏洞的具体代码位置\n  taintedSource,                   // 标识污染数据的来源节点\n  vulnerableSink,                  // 标识数据流的终点（即漏洞点）\n  \"此SQL查询依赖于$@。\",           // 漏洞描述消息模板\n  taintedSource.getNode(),         // 用于消息占位符替换的源节点\n  \"用户提供的输入\"                // 污染源的类别标签",
    "output": "SqlInjectionFlow::PathNode taintedSource,       // 表示用户控制的输入源节点"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/duplicate-key-dict-literal]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects dictionary literals with duplicate keys where earlier values are silently overwritten",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Duplicate key in dict literal\n * @description Detects dictionary literals with duplicate keys where earlier values are silently overwritten\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/duplicate-key-dict-literal\n */\n\nimport python\nimport semmle.python.strings\n\n/**\n * Converts dictionary key expressions to canonical string representations.\n * Handles numeric keys directly and string keys with Unicode/byte prefixes.\n * Excludes keys containing special characters to avoid false positives.\n */\npredicate canonicalKeyRepresentation(Dict dictObj, Expr keyNode, string canonicalKey) {\n  // Verify key belongs to the dictionary\n  keyNode = dictObj.getAKey() and\n  (\n    // Numeric keys use their numeric value as canonical form\n    canonicalKey = keyNode.(Num).getN()\n    or\n    // String keys: exclude those with special characters\n    not \"�\" = canonicalKey.charAt(_) and\n    // Handle string literals with proper Unicode/byte prefixes\n    exists(StringLiteral strLit | strLit = keyNode |\n      canonicalKey = \"u\\\"\" + strLit.getText() + \"\\\"\" and strLit.isUnicode()\n      or\n      canonicalKey = \"b\\\"\" + strLit.getText() + \"\\\"\" and not strLit.isUnicode()\n    )\n  )\n}\n\n// Identify duplicate key pairs within the same dictionary\nfrom Dict dictObj, Expr initialKey, Expr subsequentKey\nwhere\n  // Keys must have identical canonical forms but be distinct expressions\n  exists(string canonicalKey | \n    canonicalKeyRepresentation(dictObj, initialKey, canonicalKey) and \n    canonicalKeyRepresentation(dictObj, subsequentKey, canonicalKey) and \n    initialKey != subsequentKey\n  ) and\n  (\n    // Case 1: Keys in same basic block with initialKey preceding subsequentKey\n    exists(BasicBlock commonBlock, int initialIdx, int subsequentIdx |\n      initialKey.getAFlowNode() = commonBlock.getNode(initialIdx) and\n      subsequentKey.getAFlowNode() = commonBlock.getNode(subsequentIdx) and\n      initialIdx < subsequentIdx\n    )\n    or\n    // Case 2: initialKey's block strictly dominates subsequentKey's block\n    initialKey.getAFlowNode().getBasicBlock().strictlyDominates(\n      subsequentKey.getAFlowNode().getBasicBlock()\n    )\n  )\n// Generate warning highlighting the overwrite location\nselect initialKey, \n  \"Dictionary key \" + repr(initialKey) + \" is subsequently $@.\", \n  subsequentKey, \n  \"overwritten\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/summarized-callable-call-sites]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A call site for which we have a summarized callable",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Summarized callable call sites\n * @description A call site for which we have a summarized callable\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/summarized-callable-call-sites\n * @tags meta\n * @precision very-low\n */\n\n// 导入Python语言库\nimport python\n// 导入数据流分析相关的模块\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\n// 导入元度量模块\nimport meta.MetaMetrics\n\n// 从DataFlow::Node中引入useSite, SummarizedCallable target, string kind\nfrom DataFlow::Node useSite, SummarizedCallable target, string kind\nwhere\n  // 条件1：useSite是target的一个调用，并且kind为\"Call\"\n  (\n    useSite = target.getACall() and kind = \"Call\"\n    // 条件2：useSite是target的一个回调，并且kind为\"Callback\"\n    or\n    useSite = target.getACallback() and kind = \"Callback\"\n  ) and\n  // 排除忽略文件中的调用位置\n  not useSite.getLocation().getFile() instanceof IgnoredFile\n// 选择useSite和kind + \" to \" + target作为结果输出\nselect useSite, kind + \" to \" + target"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Identifies asymmetric cryptographic key generation processes that utilize",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak key generation key size (< 2048 bits)\n * @description\n * Identifies asymmetric cryptographic key generation processes that utilize\n * inadequate key lengths (under 2048 bits), making them susceptible to\n * computational brute-force attacks.\n * @id py/weak-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify asymmetric cryptographic key generation with insufficient security strength\nfrom AsymmetricKeyGen keyGenInstance, DataFlow::Node configLocation, int keySizeBits, string algorithmName\nwhere\n  // Extract cryptographic configuration parameters\n  keySizeBits = keyGenInstance.getKeySizeInBits(configLocation) and\n  algorithmName = keyGenInstance.getAlgorithm().getName() and\n  // Apply security validation: check key length and exclude ECC algorithms\n  keySizeBits < 2048 and\n  not isEllipticCurveAlgorithm(algorithmName, _)\n// Generate security alert with cryptographic context details\nselect keyGenInstance,\n  \"Insufficient asymmetric key length (\" + keySizeBits.toString() + \" bits) detected for \" +\n    algorithmName + \" algorithm, configured at $@\", configLocation, configLocation.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/function-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：建立Python函数与其源代码文件之间的关联关系",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python函数源文件映射\n * @description 建立Python函数与其源代码文件之间的关联关系\n * @kind source-link\n * @id py/function-source-links\n * @metricType callable\n */\n\nimport python\n\n// 查询所有Python函数定义，并获取每个函数在源代码中的位置信息\n// 通过函数的位置信息进一步定位到函数所在的源文件\nfrom Function funcDef, Location codeLocation\nwhere codeLocation = funcDef.getLocation()\nselect funcDef, codeLocation.getFile()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Python函数源代码位置映射\n * @description 映射Python可调用对象到其定义所在的源代码文件路径\n * @kind source-link\n * @id py/function-source-links\n * @metricType callable\n */\n\nimport python\n\n// 查询所有Python函数，并获取它们在源代码中的位置信息\nfrom Function callableObj\nselect callableObj, callableObj.getLocation().getFile()",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/exit-from-finally]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测在finally块中使用break或return语句的情况，这些语句会导致Try-finally块异常退出并丢弃原有异常。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'break' or 'return' statement in finally\n * @description 检测在finally块中使用break或return语句的情况，这些语句会导致Try-finally块异常退出并丢弃原有异常。\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-584\n * @problem.severity warning\n * @sub-severity low\n * @precision medium\n * @id py/exit-from-finally\n */\n\nimport python\n\n// 主查询：定位finally块中的问题语句\nfrom Stmt problematicStmt, string stmtType\nwhere\n  // 检测场景1：finally块中的return语句\n  (\n    problematicStmt instanceof Return and \n    stmtType = \"return\" and \n    exists(Try enclosingTry | \n      enclosingTry.getFinalbody().contains(problematicStmt)\n    )\n  )\n  or\n  // 检测场景2：finally块中的break语句（且不在循环内）\n  (\n    problematicStmt instanceof Break and \n    stmtType = \"break\" and \n    exists(Try enclosingTry | \n      enclosingTry.getFinalbody().contains(problematicStmt) and\n      // 确认break语句不在任何循环结构内（既不在for循环也不在while循环中）\n      not exists(Stmt enclosingLoop | \n        (enclosingLoop instanceof For or enclosingLoop instanceof While) and\n        enclosingLoop.contains(problematicStmt) and \n        enclosingTry.getFinalbody().contains(enclosingLoop)\n      )\n    )\n  )\n// 输出格式：问题语句及相应警告信息\nselect problematicStmt, \"'\" + stmtType + \"' in a finally block will swallow any exceptions raised.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Key Exchange Algorithms\n * @description Detects all key exchange algorithm implementations in supported cryptographic libraries.\n * @kind problem\n_______________ // 补全条件\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import the Python analysis framework\nimport python\n\n// Import the experimental cryptographic concepts module\nimport experimental.cryptography.Concepts\n\n// Data source: key exchange algorithm implementations\nfrom KeyExchangeAlgorithm algorithm\n\n// Output: algorithm identification and alert message\nselect algorithm, \"Use of algorithm \" + algorithm.getName()",
    "output": "* @id py/quantum-readiness/cbom/key-exchange"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'import *' used\n * @description Detects wildcard imports that can pollute the namespace and impede code analysis\n * @kind problem\n_______________ // 补全条件\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// Import the Python analysis module for parsing and analyzing Python code\nimport python\n\n// Identify all statements that utilize wildcard imports\nfrom ImportStar wildcardImport\n\n// Report findings: flag each wildcard import with a descriptive warning message\nselect wildcardImport, \"Wildcard import 'from ... import *' introduces all names into the current namespace, potentially causing name conflicts and making code analysis more difficult.\"",
    "output": "* @tags maintainability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python functions that start with uppercase letters,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Function Naming Convention Violation\n * @description Detects Python functions that start with uppercase letters,\n *              which goes against PEP8 naming conventions for function names.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n * @convention PEP8\n */\n\nimport python  // Import the Python library for code analysis\n\n// Find functions that violate PEP8 naming convention\nfrom Function func\nwhere\n  // Ensure the function is part of the source code\n  func.inSource() and\n  \n  // Check if the function name starts with an uppercase letter\n  func.getName().prefix(1).toUpperCase() = func.getName().prefix(1) and\n  \n  // Avoid duplicate reports: only report one violation per file\n  not exists(Function anotherFunc |\n    anotherFunc != func and  // Different function\n    anotherFunc.getLocation().getFile() = func.getLocation().getFile() and  // Same file\n    anotherFunc.getName().prefix(1).toUpperCase() = anotherFunc.getName().prefix(1)  // Also violates naming\n  )\nselect func, \"Function names should start with lowercase letters according to PEP8.\"  // Report violation with suggestion"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Assert statement tests the truth value of a literal constant\n * @description Detects assert statements that test literal constant values,\n *              which may behave differently when compiler optimizations are enabled.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/assert-literal-constant\n */\n_______________ // 补全条件\nimport python\nimport semmle.python.filters.Tests\n\nfrom Assert assertionStatement, string constantLiteral\nwhere\n  // Exclude assertions in test contexts to reduce false positives\n  not assertionStatement.getScope().getScope*() instanceof TestScope and\n  // Extract the literal constant value from the assertion expression\n  exists(Expr assertionExpression | \n    assertionExpression = assertionStatement.getTest() and (\n      // Handle integer literals in assertions\n      constantLiteral = assertionExpression.(IntegerLiteral).getN() or\n      // Handle string literals with proper quote escaping\n      constantLiteral = \"\\\"\" + assertionExpression.(StringLiteral).getS() + \"\\\"\" or\n      // Handle boolean and None constants\n      constantLiteral = assertionExpression.(NameConstant).toString()\n    )\n  ) and\n  // Filter out assertions that are the final branch in an elif chain\n  not exists(If conditionalBlock | \n    conditionalBlock.getElif().getAnOrelse() = assertionStatement\n  )\nselect assertionStatement, \"Assert of literal constant \" + constantLiteral + \".\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/duplicate-key-dict-literal]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies dictionary literals containing duplicate keys, where earlier key-value pairs are silently overwritten by later ones.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Duplicate key in dict literal\n * @description Identifies dictionary literals containing duplicate keys, where earlier key-value pairs are silently overwritten by later ones.\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/duplicate-key-dict-literal\n */\n\nimport python\nimport semmle.python.strings\n\n// Normalize dictionary keys to consistent string representation\n// Handles numeric literals and string literals (including byte/unicode strings)\npredicate normalizeKeyRepresentation(Dict dictLiteral, Expr keyExpr, string normalizedKey) {\n  keyExpr = dictLiteral.getAKey() and\n  (\n    // Numeric keys: direct value-to-string conversion\n    normalizedKey = keyExpr.(Num).getN()\n    or\n    // String literals: add type prefix and validate content\n    not \"�\" = normalizedKey.charAt(_) and\n    exists(StringLiteral strLiteral | \n      strLiteral = keyExpr and\n      (\n        // Unicode strings: add 'u' prefix\n        normalizedKey = \"u\\\"\" + strLiteral.getText() + \"\\\"\" and strLiteral.isUnicode()\n        or\n        // Byte strings: add 'b' prefix\n        normalizedKey = \"b\\\"\" + strLiteral.getText() + \"\\\"\" and not strLiteral.isUnicode()\n      )\n    )\n  )\n}\n\n// Identify dictionaries with duplicate keys and their positional relationships\nfrom Dict dictLiteral, Expr firstKey, Expr secondKey\nwhere\n  // Both keys share identical normalized representation\n  exists(string normalizedKey | \n    normalizeKeyRepresentation(dictLiteral, firstKey, normalizedKey) and \n    normalizeKeyRepresentation(dictLiteral, secondKey, normalizedKey) and \n    firstKey != secondKey\n  ) and\n  // Verify key ordering relationship\n  (\n    // Case 1: Keys in same basic block with firstKey before secondKey\n    exists(BasicBlock block, int firstPos, int secondPos |\n      firstKey.getAFlowNode() = block.getNode(firstPos) and\n      secondKey.getAFlowNode() = block.getNode(secondPos) and\n      firstPos < secondPos\n    )\n    or\n    // Case 2: First key's block strictly dominates second key's block\n    firstKey.getAFlowNode().getBasicBlock().strictlyDominates(\n      secondKey.getAFlowNode().getBasicBlock()\n    )\n  )\n\n// Report the first occurrence of duplicate key and indicate its overwriter\nselect firstKey, \n       \"Dictionary key \" + repr(firstKey) + \" is subsequently $@.\", \n       secondKey, \n       \"overwritten\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure randomness\n * @description Detects security-critical operations utilizing \n *              cryptographically weak pseudo-random number generators, \n *              which allow attackers to forecast generated values and \n *              undermine system security.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// Fundamental Python language analysis infrastructure\nimport python\n\n// Specialized security module for identifying weak random number generation\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Data flow propagation and tracking framework\nimport semmle.python.dataflow.new.DataFlow\n_______________ // 补全条件\n// Path visualization components for data flow analysis\nimport InsecureRandomness::Flow::PathGraph\n\n// Query identifying insecure random value propagation paths\nfrom \n  InsecureRandomness::Flow::PathNode weakRndSource,      // Origin of insecure random value\n  InsecureRandomness::Flow::PathNode sensitiveSink        // Security-sensitive consumption point\nwhere \n  // Verify data flow propagation from source to sink\n  InsecureRandomness::Flow::flowPath(weakRndSource, sensitiveSink)\nselect \n  sensitiveSink.getNode(),                              // Vulnerable usage location\n  weakRndSource,                                        // Path origin for tracking\n  sensitiveSink,                                        // Visualization sink node\n  \"Cryptographically insecure $@ in security context.\", // Alert message\n  weakRndSource.getNode(),                              // Reference node for alert\n  \"random value\"                                        // Vulnerable element description",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects Python syntax errors that could cause runtime failures\n *              and hinder static analysis. This query excludes encoding-related\n *              issues to focus specifically on actual syntax problems.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import the Python module for analyzing source code\nimport python\n\n// Find syntax errors in Python source files\nfrom SyntaxError syntaxIssue\n// Exclude encoding-related errors to concentrate on pure syntax issues\nwhere not (syntaxIssue instanceof EncodingError)\n// Present the syntax error along with its message and Python version\nselect syntaxIssue, syntaxIssue.getMessage() + \" (in Python \" + major_version() + \").\"",
    "output": "* @name Syntax error detection"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unsafe-unpacking]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Extracting archives without sanitizing file paths from untrusted sources",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Path traversal vulnerability in tarball extraction from untrusted sources\n * @description Extracting archives without sanitizing file paths from untrusted sources \n *              (e.g., network sources or user-provided arguments) can lead to writing files \n *              outside the target directory, resulting in a path traversal vulnerability.\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// Define data flow components for vulnerability detection\nfrom \n  UnsafeUnpackFlow::PathNode maliciousInput,  // Untrusted data entry point\n  UnsafeUnpackFlow::PathNode extractionTarget  // Vulnerable extraction operation\n// Establish tainted data flow path between components\nwhere \n  UnsafeUnpackFlow::flowPath(maliciousInput, extractionTarget)\n// Report vulnerability with complete flow context\nselect \n  extractionTarget.getNode(), \n  maliciousInput, \n  extractionTarget,\n  \"Path traversal via unsanitized archive extraction from untrusted origin\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of 'return' or 'yield' outside a function\n * @description Using 'return' or 'yield' outside a function causes a 'SyntaxError' at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n_______________ // 补全条件\n * @precision medium\n * @id py/return-or-yield-outside-function\n */\n\nimport python\n\n// 查找在函数作用域外使用 return 或 yield 相关语句的 AST 节点\nfrom AstNode stmtNode, string stmtType\nwhere\n  // 确保节点不在任何函数的作用域内\n  not stmtNode.getScope() instanceof Function and\n  // 检查节点是否为 return、yield 或 yield from 语句\n  (\n    (stmtNode instanceof Return and stmtType = \"return\") or\n    (stmtNode instanceof Yield and stmtType = \"yield\") or\n    (stmtNode instanceof YieldFrom and stmtType = \"yield from\")\n  )\n// 输出问题节点和相应的错误信息\nselect stmtNode, \"'\" + stmtType + \"' is used outside a function.\"",
    "output": "* @sub-severity low"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 代码库活跃度分析\n * @description 评估过去六个月（180天）内的代码提交频率，用于衡量代码库的开发活跃程度\n * @kind treemap\n_______________ // 补全条件\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\nimport python // 导入Python语言支持模块\nimport external.VCS // 导入外部版本控制系统接口\n\n// 查询最近半年内的人工提交记录\nfrom Commit recentCommit\nwhere \n  // 确保提交发生在最近180天内\n  recentCommit.daysToNow() <= 180\n  // 并且不是系统自动生成的提交\n  and not artificialChange(recentCommit)\n// 返回提交的修订标识符和计数（用于聚合统计）\nselect recentCommit.getRevisionName(), 1",
    "output": "* @id py/historical-number-of-recent-commits"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jump-to-definition]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Advanced navigation query that maps Python expression usages to their corresponding definition points,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Navigate to Definitions\n * @description Advanced navigation query that maps Python expression usages to their corresponding definition points,\n *              enabling precise code traversal and analysis of variable, function, and class relationships.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import core Python static analysis capabilities for source code examination\nimport python\n\n// Import definition tracking functionality to establish connections between usages and their origin points\nimport analysis.DefinitionTracking\n\n// Select source expressions with precise location data, their corresponding target definitions, and definition categories\nfrom NiceLocationExpr sourceExpr, Definition targetDefinition, string definitionType\n// Establish the relationship between usage and definition while ensuring type compatibility\nwhere \n  targetDefinition = definitionOf(sourceExpr, definitionType)\n// Generate output containing usage location, definition location, and definition classification for navigation\nselect sourceExpr, targetDefinition, definitionType"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Comprehensive Cryptographic Algorithm Enumeration\n * @description Discovers and documents all cryptographic algorithm implementations\n *              present within the analyzed cryptographic libraries\n * @kind problem\n * @id py/quantum-readiness/cbom/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n_______________ // 补全条件\nimport python\n// Import experimental cryptography module for algorithm detection\nimport experimental.cryptography.Concepts\n\n// Define the main query to identify cryptographic implementations\nfrom CryptographicAlgorithm cryptoImpl\n// Extract algorithm name for reporting purposes\nwhere exists(cryptoImpl.getName())\n// Generate alert with algorithm identification\nselect cryptoImpl, \"Implementation detected: \" + cryptoImpl.getName()",
    "output": "// Import Python analysis framework for code inspection"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-recent-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：近期提交的数量",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 近期变更\n * @description 近期提交的数量\n * @kind treemap\n * @id py/historical-number-of-recent-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\nimport python // 导入python库\nimport external.VCS // 导入外部版本控制系统(VCS)库\n\n// 从Commit类中选择数据\nfrom Commit c\n// 过滤条件：提交日期在180天以内且不是人工更改的提交\nwhere c.daysToNow() <= 180 and not artificialChange(c)\n// 选择提交的修订名称和计数1\nselect c.getRevisionName(), 1"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-parameters-without-default-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes the quantity of function parameters that do not have default values assigned.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of parameters without defaults\n * @description Computes the quantity of function parameters that do not have default values assigned.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // Import the Python analysis module to enable code processing capabilities\n\n// Extract function metrics and determine the count of parameters lacking default values\nfrom FunctionMetrics functionMetric, int nonDefaultCount\nwhere nonDefaultCount = functionMetric.getNumberOfParametersWithoutDefault()\nselect \n  functionMetric, \n  nonDefaultCount \norder by \n  nonDefaultCount desc\n// Display function entities along with their respective counts of parameters without defaults, sorted in descending order"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/command-line-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Execution of commands with externally controlled strings can enable",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Uncontrolled command line\n * @description Execution of commands with externally controlled strings can enable\n *              attackers to manipulate command behavior, leading to potential system compromise.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/command-line-injection\n * @tags correctness\n *       security\n *       external/cwe/cwe-078\n *       external/cwe/cwe-088\n */\n\n// 导入Python分析基础库\nimport python\n\n// 导入命令注入数据流分析模块\nimport semmle.python.security.dataflow.CommandInjectionQuery\n\n// 导入命令注入流路径可视化模块\nimport CommandInjectionFlow::PathGraph\n\n// 定义数据流路径分析：从源头节点(source)到汇聚点节点(sink)\nfrom CommandInjectionFlow::PathNode source, CommandInjectionFlow::PathNode sink\n// 筛选存在有效数据流路径的节点对\nwhere CommandInjectionFlow::flowPath(source, sink)\n// 输出结果：包含汇聚点、源头节点、完整路径及安全描述\nselect sink.getNode(), source, sink, \"This command line depends on a $@.\", source.getNode(),\n  // 补充说明：标识该命令行依赖外部输入的用户可控值\n  \"user-provided value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/catch-base-exception]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects exception handlers that catch BaseException without re-raising,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Exception block catches 'BaseException'\n * @description Detects exception handlers that catch BaseException without re-raising,\n *              which may improperly handle system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Main query: Identify exception handlers catching BaseException without re-raising\nfrom ExceptStmt exceptionHandler\nwhere\n  // Check if exception handler catches BaseException or unspecified exception type\n  (\n    exceptionHandler.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n    or\n    not exists(exceptionHandler.getType())\n  )\n  and\n  // Verify exception handler doesn't re-raise the exception\n  exceptionHandler.getAFlowNode().getBasicBlock().reachesExit()\nselect exceptionHandler, \"Except block directly handles BaseException.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/similar-lines-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The number of lines in a file, including code, comment and whitespace lines,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Similar lines in files\n * @description The number of lines in a file, including code, comment and whitespace lines,\n *              which are similar in at least one other place.\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags testability\n * @id py/similar-lines-in-files\n */\n\nimport python\n\n// Define source variables for file analysis\nfrom File targetFile, int similarityCount\n\n// Apply unconditional filter (retains original logic)\nwhere none()\n\n// Select results with ordering\nselect targetFile, similarityCount \norder by similarityCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/signature-mismatch]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects methods that override parent methods with incompatible signatures.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Signature mismatch in overriding method\n * @description Detects methods that override parent methods with incompatible signatures.\n *              Such mismatches may cause runtime errors when method calls expect arguments\n *              accepted by the parent but rejected by the child, or vice versa.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Find methods in subclasses that override superclass methods with incompatible signatures\nfrom FunctionValue superClassMethod, PythonFunctionValue subClassMethod\nwhere\n  // Establish inheritance relationship between methods\n  subClassMethod.overrides(superClassMethod) and\n  \n  // Ensure that neither the superclass method nor any ancestor methods are called in the codebase\n  not exists(FunctionValue ancestorMethod |\n    (ancestorMethod = superClassMethod or ancestorMethod.overrides(superClassMethod)) and\n    exists(ancestorMethod.getACall())\n  ) and\n  \n  // Filter out special methods, constructors, and non-normal methods\n  subClassMethod.isNormalMethod() and\n  not subClassMethod.getScope().isSpecialMethod() and\n  subClassMethod.getName() != \"__init__\" and\n  \n  // Check for parameter count incompatibility between subclass and superclass methods\n  (\n    // Subclass method requires more parameters than superclass method maximum\n    subClassMethod.minParameters() > superClassMethod.maxParameters() or\n    // Subclass method accepts fewer parameters than superclass method minimum\n    subClassMethod.maxParameters() < superClassMethod.minParameters()\n  )\nselect subClassMethod, \"Overriding method '\" + subClassMethod.getName() + \"' has signature mismatch with $@.\",\n  superClassMethod, \"overridden method\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Elliptic Curve Algorithms\n * @description Detects elliptic curve algorithm implementations across cryptographic libraries.\n *              Reports algorithm names and corresponding key sizes for quantum readiness assessment.\n * @kind problem\n * @id py/quantum-readiness/cbom/elliptic-curve-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import core Python language support\nimport python\n// Import cryptographic concepts library for algorithm definitions\nimport experimental.cryptography.Concepts\n\n// Identify elliptic curve algorithm instances\nfrom EllipticCurveAlgorithm ecAlgorithm\n_______________ // 补全条件\nselect ecAlgorithm,\n  \"Algorithm: \" + ecAlgorithm.getCurveName() + \n  \" | Key Size (bits): \" + ecAlgorithm.getCurveBitSize().toString()",
    "output": "// Generate detailed algorithm description"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-callable called\n * @description Identifies calls to objects that are not callable, which will raise a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom \n  Call callNode, \n  Value calleeValue, \n  ClassValue targetClass, \n  Expr calleeExpr, \n_______________ // 补全条件\nwhere\n  // Extract the callee expression from the call site\n  calleeExpr = callNode.getFunc() and\n  \n  // Resolve the callee expression to its concrete value and origin\n  calleeExpr.pointsTo(calleeValue, originNode) and\n  \n  // Determine the class type of the callee value\n  targetClass = calleeValue.getClass() and\n  \n  // Pre-filter common non-callable cases before type inference\n  not calleeValue = Value::named(\"None\") and\n  not use_of_not_implemented_in_raise(_, calleeExpr) and\n  \n  // Verify type inference succeeded and the class is not callable\n  not targetClass.failedInference(_) and\n  not targetClass.isCallable() and\n  \n  // Exclude descriptor objects callable via protocol\n  not targetClass.hasAttribute(\"__get__\")\nselect \n  callNode, \n  \"Call to a $@ of $@.\", \n  originNode, \n  \"non-callable\", \n  targetClass, \n  targetClass.toString()",
    "output": "AstNode originNode"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Definition Navigator\n * @description A specialized query that enables navigation from expression references to their source definitions within Python code.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import the essential Python analysis library for examining Python source code\nimport python\n\n// Import the definition tracking functionality to follow variable, function, and class definitions\nimport analysis.DefinitionTracking\n\n// Identify expressions with location information, their corresponding definitions, and definition classifications\n_______________ // 补全条件\n// Verify that the definition properly matches the usage and maintains type compatibility\nwhere \n  defSite = definitionOf(usedExpr, defCategory)\n// Present the reference location, definition location, and definition category for navigation\nselect usedExpr, defSite, defCategory",
    "output": "from NiceLocationExpr usedExpr, Definition defSite, string defCategory"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Partial server-side request forgery\n * @description Identifies potential SSRF vulnerabilities where user input influences parts of a URL\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision medium\n * @id py/partial-ssrf\n * @tags security\n *       external/cwe/cwe-918\n */\n\n// Import Python standard library\nimport python\n// Import SSRF detection utilities\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\n_______________ // 补全条件\nimport PartialServerSideRequestForgeryFlow::PathGraph\n\n// Detect HTTP requests with URL components derived from untrusted user input\nfrom\n  PartialServerSideRequestForgeryFlow::PathNode untrustedDataSource, // Entry point of untrusted data\n  PartialServerSideRequestForgeryFlow::PathNode vulnerableSink,      // Point where data is used in request\n  Http::Client::Request targetRequest                                // The HTTP request under analysis\nwhere\n  // Establish relationship between the sink and the HTTP request\n  targetRequest = vulnerableSink.getNode().(Sink).getRequest()\n  and\n  // Confirm data flows from untrusted source to the vulnerable sink\n  PartialServerSideRequestForgeryFlow::flowPath(untrustedDataSource, vulnerableSink)\n  and\n  // Filter out requests where the entire URL is controlled by user input\n  not fullyControlledRequest(targetRequest)\nselect targetRequest, untrustedDataSource, vulnerableSink, \"URL component in this request originates from $@.\", untrustedDataSource.getNode(),\n  \"user-provided input\"",
    "output": "// Import partial SSRF flow path graph"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak key generation key size (< 2048 bits)\n * @description\n * Identifies asymmetric cryptographic key generation operations\n * using keys with insufficient length (below 2048 bits).\n * @id py/weak-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify asymmetric key generation operations with inadequate key sizes\nfrom AsymmetricKeyGen keyGenerationOp, \n     DataFlow::Node keySizeNode, \n     int keySizeValue, \n     string algoName\nwhere\n  // Retrieve the cryptographic algorithm name\n  algoName = keyGenerationOp.getAlgorithm().getName() and\n  // Exclude elliptic curve algorithms (different security paradigms apply)\n  not isEllipticCurveAlgorithm(algoName, _) and\n  // Extract key size from configuration node\n_______________ // 补全条件\n  // Verify key size meets minimum security requirement\n  keySizeValue < 2048\n// Generate alert with detailed context about weak key generation\nselect keyGenerationOp,\n  \"Insufficient asymmetric key length (\" + keySizeValue.toString() + \" bits) for \" +\n    algoName + \" algorithm specified at $@\", keySizeNode, keySizeNode.toString()",
    "output": "keySizeValue = keyGenerationOp.getKeySizeInBits(keySizeNode) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/summary/lines-of-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：提供数据库中所有Python源文件的代码行总数统计，涵盖外部库和自动生成的代码。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Total lines of Python code in the database\n * @description 提供数据库中所有Python源文件的代码行总数统计，涵盖外部库和自动生成的代码。\n *   此指标用于评估代码库的整体规模，仅计算实际代码行，不包括空白行和注释。\n * @kind metric\n * @tags summary\n *       telemetry\n * @id py/summary/lines-of-code\n */\n\nimport python // 引入Python分析模块，用于处理Python代码库的度量分析\n\n// 统计所有Python模块的有效代码行数\n// 遍历数据库中的每个Python模块，获取其有效代码行数（排除空白行和注释），然后计算总和\nfrom Module sourceModule, int codeLines\nwhere codeLines = sourceModule.getMetrics().getNumberOfLinesOfCode()\nselect sum(codeLines)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raises-tuple]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：In Python 2, raising a tuple causes only the first element (recursively) to be raised while discarding all other elements",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Raising a tuple\n * @description In Python 2, raising a tuple causes only the first element (recursively) to be raised while discarding all other elements\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// Identify raise statements where the exception originates from a tuple\nfrom Raise raiseStmt, DataFlow::LocalSourceNode tupleSource, DataFlow::Node exceptionFlowNode\nwhere\n  // Restrict analysis to Python 2 (Python 3 handles this as a type error)\n  major_version() = 2 and\n  // Ensure the source node represents a tuple expression\n  tupleSource.asExpr() instanceof Tuple and\n  // Verify data flow path from tuple to the raised exception\n  exceptionFlowNode.asExpr() = raiseStmt.getException() and\n  tupleSource.flowsTo(exceptionFlowNode)\n/* Note: Raising a tuple is a type error in Python 3 and is handled by the IllegalRaise query. */\nselect raiseStmt,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleSource, \"tuple\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mutable-descriptor]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Since descriptor objects are shared across multiple instances, any mutation within their protocol methods can result in unexpected side effects or race conditions.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Descriptor mutation in protocol methods (__get__, __set__, __delete__)\n * @description Since descriptor objects are shared across multiple instances, any mutation within their protocol methods can result in unexpected side effects or race conditions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Identifies classes implementing the descriptor protocol that perform mutation operations within their protocol methods\npredicate has_descriptor_mutation(ClassObject descClass, SelfAttributeStore mutationOp) {\n  // Verify the class implements descriptor protocol\n  descClass.isDescriptorType() and\n  // Find descriptor protocol methods (__get__/__set__/__delete__)\n  exists(string methodName, PyFunctionObject descMethod |\n    descClass.lookupAttribute(methodName) = descMethod and\n    (methodName = \"__get__\" or methodName = \"__set__\" or methodName = \"__delete__\") and\n    // Locate methods called by descriptor protocol methods\n    exists(PyFunctionObject calleeMethod |\n      // Called method belongs to the same class\n      descClass.lookupAttribute(_) = calleeMethod and\n      // Trace call chain from descriptor method to called method\n      descMethod.getACallee*() = calleeMethod and\n      // Exclude initialization methods\n      not calleeMethod.getName() = \"__init__\" and\n      // Mutation occurs within the called method's scope\n      mutationOp.getScope() = calleeMethod.getFunction()\n    )\n  )\n}\n\n// Identify classes and operations where descriptor mutation occurs\nfrom ClassObject descClass, SelfAttributeStore mutationOp\nwhere has_descriptor_mutation(descClass, mutationOp)\n// Output mutation location, warning message, and related class details\nselect mutationOp,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descClass, descClass.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/efferent-coupling-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：分析每个 Python 模块所依赖的其他模块数量，用于评估模块间的耦合程度。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python 模块传出耦合分析\n * @description 分析每个 Python 模块所依赖的其他模块数量，用于评估模块间的耦合程度。\n * @kind 树状图\n * @id py/efferent-coupling-per-file\n * @treemap.warnOn 高值警告\n * @metricType 文件\n * @metricAggregate 平均值 最大值\n * @tags 可测试性\n *       模块化\n */\n\nimport python // 导入Python语言库\n\nfrom ModuleMetrics moduleMetrics // 从ModuleMetrics类中选择变量moduleMetrics\nselect moduleMetrics, moduleMetrics.getEfferentCoupling() as couplingCount order by couplingCount desc // 选择模块和其传出耦合度，并按降序排列"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Substantial code duplication identifier\n * @description Identifies modules containing substantial code duplication. Refactoring these modules enhances maintainability and reduces technical debt.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-file\n */\n\nimport python\n\n// Define variables for duplicate analysis\nfrom \n  Module originalModule,\n  Module duplicatedModule,\n  string message\n_______________ // 补全条件\n  // Query intentionally disabled to prevent execution\n  none()\nselect \n  originalModule,\n  message,\n  duplicatedModule,\n  duplicatedModule.getName()",
    "output": "where"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Iterable can be either a string or a sequence\n * @description Iteration over either a string or a sequence in the same loop can cause errors that are hard to find.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       non-local\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iteration-string-and-sequence\n */\n\nimport python  // 导入Python库，用于分析Python代码\nimport semmle.python.filters.Tests  // 导入测试过滤器，用于排除测试代码中的问题\n\n// 定义一个谓词函数，判断给定的值是否为字符串类型\npredicate has_string_type(Value v) {\n  v.getClass() = ClassValue::str()  // 如果值的类是str\n  or\n  v.getClass() = ClassValue::unicode() and major_version() = 2  // 或者在Python 2中值为unicode\n}\n\nfrom\n  For loop, ControlFlowNode iter, Value str, Value seq, ControlFlowNode seq_origin,\n  ControlFlowNode str_origin  // 从循环、控制流节点、字符串值、序列值及其来源节点中选择数据\nwhere\n  loop.getIter().getAFlowNode() = iter and  // 获取循环的迭代器节点\n  iter.pointsTo(str, str_origin) and  // 迭代器指向字符串值及其来源节点\n_______________ // 补全条件\n  has_string_type(str) and  // 判断字符串值是否为字符串类型\n  seq.getClass().isIterable() and  // 判断序列值是否为可迭代对象\n  not has_string_type(seq) and  // 确保序列值不是字符串类型\n  // suppress occurrences from tests  // 抑制来自测试代码的出现\n  not seq_origin.getScope().getScope*() instanceof TestScope and  // 排除序列值来源节点在测试范围内的情况\n  not str_origin.getScope().getScope*() instanceof TestScope  // 排除字符串值来源节点在测试范围内的情况\nselect loop,\n  \"Iteration over $@, of class \" + seq.getClass().getName() + \", may also iterate over $@.\",\n  seq_origin, \"sequence\", str_origin, \"string\"  // 选择并报告问题：循环可能同时迭代序列和字符串",
    "output": "iter.pointsTo(seq, seq_origin) and  // 迭代器指向序列值及其来源节点"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Deprecated 'apply' function usage\n * @description Detects calls to the deprecated 'apply' builtin function in Python 2.\n *              This function is obsolete and should be replaced with modern constructs.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n_______________ // 补全条件\n */\n\nimport python\nprivate import semmle.python.types.Builtins\n\n// Select function call nodes and their corresponding target functions\nfrom CallNode funcCall, ControlFlowNode calledFunc\nwhere \n  // Restrict analysis to Python 2 code where 'apply' was available\n  major_version() = 2\n  and \n  // Verify the call node references the target function\n  funcCall.getFunction() = calledFunc\n  and \n  // Confirm the target function points to the builtin 'apply' value\n  calledFunc.pointsTo(Value::named(\"apply\"))\n// Output matching call nodes with a descriptive warning message\nselect funcCall, \"Call to the obsolete builtin function 'apply'.\"",
    "output": "* @id py/use-of-apply"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-bypass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：使用不安全的字符串前缀比较（如 'startswith'）验证用户提供的 Origin 头部，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 跨域资源共享（CORS）策略配置缺陷\n * @description 使用不安全的字符串前缀比较（如 'startswith'）验证用户提供的 Origin 头部，\n *              可能导致 CORS 安全机制被绕过，引发跨域攻击风险。\n * @kind path-problem\n * @problem.severity warning\n * @id py/cors-bypass\n * @tags security\n *       externa/cwe/CWE-346\n */\n\nimport python\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.Flow\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n/**\n * 判断输入字符串是否匹配 CORS 相关标识符模式\n */\nbindingset[inputStr]\npredicate containsCorsIdentifiers(string inputStr) { \n  inputStr.matches([\"%origin%\", \"%cors%\"]) \n}\n\n/**\n * 表示使用不安全的字符串前缀比较（如startswith）的代码节点\n */\nprivate class InsecurePrefixCheck extends ControlFlowNode {\n  InsecurePrefixCheck() { \n    this.(CallNode).getFunction().(AttrNode).getName() = \"startswith\" \n  }\n}\n\n/**\n * 识别与 CORS 处理逻辑相关的代码节点\n * \n * 通过以下启发式规则检测 CORS 验证逻辑：\n * 1. 调用对象包含 CORS 关键字（作为汇点）\n * 2. 方法参数包含 CORS 关键字（作为汇点）\n * 3. 变量赋值涉及 CORS 关键字（作为源点）\n */\nprivate predicate isCorsRelatedNode(ControlFlowNode node) {\n  // 场景1：调用对象包含 CORS 关键字（汇点）\n  exists(string corsKeyword | \n    containsCorsIdentifiers(corsKeyword) and \n    node.(CallNode).getFunction().(AttrNode).getObject().(NameNode).getId() = corsKeyword\n  )\n  or\n  // 场景2：方法参数包含 CORS 关键字（汇点）\n  exists(string corsKeyword | \n    containsCorsIdentifiers(corsKeyword) and \n    node.(CallNode).getArg(0).(NameNode).getId() = corsKeyword\n  )\n  or\n  // 场景3：变量赋值包含 CORS 关键字（源点）\n  exists(Variable corsVar | \n    containsCorsIdentifiers(corsVar.getId()) and \n    node.getASuccessor*().getNode() = corsVar.getAStore()\n  )\n}\n\n/**\n * 表示 CherryPy 框架的请求对象成员\n * 作为远程输入源被识别\n */\nclass CherryPyRequestMember extends RemoteFlowSource::Range {\n  CherryPyRequestMember() {\n    this =\n      API::moduleImport(\"cherrypy\")\n          .getMember(\"request\")\n          .getMember([\n              \"charset\", \"content_type\", \"filename\", \"fp\", \"name\", \n              \"params\", \"headers\", \"length\"\n            ])\n          .asSource()\n  }\n\n  override string getSourceType() { \n    result = \"cherrypy.request\" \n  }\n}\n\n/**\n * CORS 安全策略绕过分析配置模块\n */\nmodule CorsBypassAnalysisConfig implements DataFlow::ConfigSig {\n  /**\n   * 定义数据流源：所有远程输入源\n   */\n  predicate isSource(DataFlow::Node node) { \n    node instanceof RemoteFlowSource \n  }\n\n  /**\n   * 定义数据流汇：startswith 方法的参数或调用对象\n   */\n  predicate isSink(DataFlow::Node node) {\n    exists(InsecurePrefixCheck prefixCheck |\n      node.asCfgNode() = prefixCheck.(CallNode).getArg(0) or\n      node.asCfgNode() = prefixCheck.(CallNode).getFunction().(AttrNode).getObject()\n    )\n  }\n\n  /**\n   * 定义额外流步骤：处理 cherrypy.request.headers.get() 调用链\n   */\n  predicate isAdditionalFlowStep(DataFlow::Node sourceNode, DataFlow::Node targetNode) {\n    exists(API::CallNode headersGetMethodCall, API::Node cherrypyRequestHeaders |\n      cherrypyRequestHeaders = API::moduleImport(\"cherrypy\")\n                          .getMember(\"request\")\n                          .getMember(\"headers\") and\n      headersGetMethodCall = cherrypyRequestHeaders.getMember(\"get\").getACall()\n    |\n      headersGetMethodCall.getReturn().asSource() = targetNode and \n      cherrypyRequestHeaders.asSource() = sourceNode\n    )\n  }\n\n  // 启用增量模式差异观察\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// 全局污点跟踪模块\nmodule CorsBypassFlow = TaintTracking::Global<CorsBypassAnalysisConfig>;\n\nimport CorsBypassFlow::PathGraph\n\n/**\n * 检测潜在的 CORS 策略配置缺陷（使用不安全的字符串前缀比较）\n */\nfrom CorsBypassFlow::PathNode sourceNode, CorsBypassFlow::PathNode sinkNode\nwhere\n  CorsBypassFlow::flowPath(sourceNode, sinkNode) and\n  (\n    isCorsRelatedNode(sourceNode.getNode().asCfgNode())\n    or\n    isCorsRelatedNode(sinkNode.getNode().asCfgNode())\n  )\nselect sinkNode, sourceNode, sinkNode,\n  \"使用弱字符串比较验证 Origin 头部，可能导致 CORS 安全策略被绕过。\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inconsistent-equality]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects classes that violate the object model by implementing only one of the equality comparison methods (__eq__ or __ne__).",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent equality and inequality implementation\n * @description Detects classes that violate the object model by implementing only one of the equality comparison methods (__eq__ or __ne__).\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-equality\n */\n\nimport python\n\n// Returns the names of equality comparison methods\nstring equalityMethodName() { \n  result in [\"__eq__\", \"__ne__\"] \n}\n\n// Checks if a class is decorated with total_ordering\npredicate hasTotalOrderingDecorator(Class cls) {\n  exists(Attribute decoratorNode | \n    decoratorNode = cls.getADecorator() | \n    decoratorNode.getName() = \"total_ordering\"\n  )\n  or\n  exists(Name nameNode | \n    nameNode = cls.getADecorator() | \n    nameNode.getId() = \"total_ordering\"\n  )\n}\n\n// Retrieves the implemented equality method from a class\nCallableValue getImplementedEqualityMethod(ClassValue cls, string methodName) { \n  result = cls.declaredAttribute(methodName) and \n  methodName = equalityMethodName()\n}\n\n// Determines the missing equality method in a class\nstring getUnimplementedEqualityMethod(ClassValue cls) { \n  not cls.declaresAttribute(result) and \n  result = equalityMethodName()\n}\n\n// Identifies classes violating the equality contract\npredicate violatesEqualityContract(\n  ClassValue violatingClass, string existingMethod, \n  string absentMethod, CallableValue equalityMethod\n) {\n  // Get the missing method in the class\n  absentMethod = getUnimplementedEqualityMethod(violatingClass) and\n  \n  // Get the implemented equality method\n  equalityMethod = getImplementedEqualityMethod(violatingClass, existingMethod) and\n  \n  // Exclude classes with failed inference\n  not violatingClass.failedInference(_) and\n  \n  // Exclude classes with total_ordering decorator\n  not hasTotalOrderingDecorator(violatingClass.getScope()) and\n  \n  // Python 3 auto-implements __ne__ when __eq__ is defined\n  not (major_version() = 3 and existingMethod = \"__eq__\" and absentMethod = \"__ne__\")\n}\n\n// Generate warnings for classes violating the equality contract\nfrom ClassValue violatingClass, string existingMethod, string absentMethod, CallableValue equalityMethod\nwhere violatesEqualityContract(violatingClass, existingMethod, absentMethod, equalityMethod)\nselect equalityMethod, \"Class $@ implements \" + existingMethod + \" but does not implement \" + absentMethod + \".\", violatingClass,\n  violatingClass.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Membership test with a non-container\n * @description Identifies membership operations ('in'/'not in') where the right-hand operand \n *              is a non-container type, causing runtime TypeError.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n * Identifies nodes serving as the right operand in membership tests.\n * @param operandNode - Control flow node being evaluated\n_______________ // 补全条件\n */\npredicate isRightOperandOfMembershipTest(ControlFlowNode operandNode, Compare comparisonNode) {\n  exists(Cmpop operation, int index |\n    comparisonNode.getOp(index) = operation and \n    comparisonNode.getComparator(index) = operandNode.getNode() and\n    (operation instanceof In or operation instanceof NotIn)\n  )\n}\n\nfrom \n  ControlFlowNode rightOperand, \n  Compare comparisonExpr, \n  Value referencedValue, \n  ClassValue nonContainerType, \n  ControlFlowNode originNode\nwhere\n  // Verify node is right operand of membership test\n  isRightOperandOfMembershipTest(rightOperand, comparisonExpr) and\n  \n  // Resolve pointed value and class information\n  rightOperand.pointsTo(_, referencedValue, originNode) and\n  referencedValue.getClass() = nonContainerType and\n  \n  // Exclude cases with failed type inference\n  not Types::failedInference(nonContainerType, _) and\n  \n  // Confirm class lacks container interface methods\n  not nonContainerType.hasAttribute(\"__contains__\") and\n  not nonContainerType.hasAttribute(\"__iter__\") and\n  not nonContainerType.hasAttribute(\"__getitem__\") and\n  \n  // Exclude special pseudo-container types\n  not nonContainerType = ClassValue::nonetype() and\n  not nonContainerType = Value::named(\"types.MappingProxyType\")\nselect \n  comparisonExpr, \n  \"This test may raise an Exception as the $@ may be of non-container class $@.\", \n  originNode, \"target\", nonContainerType, nonContainerType.getName()",
    "output": "* @param comparisonNode - Comparison expression containing the membership test"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects and reports generator usage (yield/yield from) within class initialization methods.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/init-method-is-generator\n */\n\nimport python\n\nfrom Function initMethod\nwhere\n  // Identify class initialization methods\n  initMethod.isInitMethod() and\n  // Check for generator expressions within the method scope\n  exists(Expr yieldExpr | \n    yieldExpr.getScope() = initMethod and\n    (yieldExpr instanceof Yield or yieldExpr instanceof YieldFrom))\nselect initMethod, \"__init__ method is a generator.\"",
    "output": "* @name Generator in `__init__` method"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/conflicting-attributes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a class inherits multiple base classes defining the same attribute, which may lead to unexpected behavior due to attribute overriding.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Conflicting attributes in base classes\n * @description Detects when a class inherits multiple base classes defining the same attribute, which may lead to unexpected behavior due to attribute overriding.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n/**\n * Identifies functions that contain only pass statements and docstrings.\n * These are considered empty implementations without meaningful operations.\n */\npredicate is_empty_function(PyFunctionObject funcObj) {\n  not exists(Stmt statement | statement.getScope() = funcObj.getFunction() |\n    not statement instanceof Pass and \n    not statement.(ExprStmt).getValue() = funcObj.getFunction().getDocString()\n  )\n}\n\n/**\n * Determines if a function explicitly invokes parent class methods using super().\n * This indicates intentional method chaining in inheritance hierarchies.\n */\npredicate calls_super_method(FunctionObject funcObj) {\n  exists(Call superCall, Call methodCall, Attribute attr, GlobalVariable superVar |\n    methodCall.getScope() = funcObj.getFunction() and\n    methodCall.getFunc() = attr and\n    attr.getObject() = superCall and\n    attr.getName() = funcObj.getName() and\n    superCall.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/**\n * Identifies attribute names excluded from conflict detection due to special cases.\n * These exemptions follow documented patterns or library-specific conventions.\n */\npredicate is_attribute_exempted(string attributeName) {\n  /*\n   * Exemption for standard library recommendation:\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   */\n  attributeName = \"process_request\"\n}\n\nfrom\n  ClassObject childClass, ClassObject baseClass1, ClassObject baseClass2, \n  string attrName, int baseIndex1, int baseIndex2, \n  Object attrInBase1, Object attrInBase2\nwhere\n  // Ensure distinct base classes with ordered inheritance positions\n  childClass.getBaseType(baseIndex1) = baseClass1 and\n  childClass.getBaseType(baseIndex2) = baseClass2 and\n  baseIndex1 < baseIndex2 and\n  \n  // Locate conflicting attributes in base classes\n  attrInBase1 = baseClass1.lookupAttribute(attrName) and\n  attrInBase2 = baseClass2.lookupAttribute(attrName) and\n  attrInBase1 != attrInBase2 and\n  \n  // Exclude special methods (dunder methods) which are expected to be overridden\n  not attrName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  \n  // Exclude cases where first base class properly calls super()\n  not calls_super_method(attrInBase1) and\n  \n  // Ignore empty functions in second base class (no real conflict)\n  not is_empty_function(attrInBase2) and\n  \n  // Skip exempted attributes with special handling patterns\n  not is_attribute_exempted(attrName) and\n  \n  // Ensure no override relationship exists between attributes\n  not attrInBase1.overrides(attrInBase2) and\n  not attrInBase2.overrides(attrInBase1) and\n  \n  // Verify derived class doesn't explicitly declare the attribute\n  not childClass.declaresAttribute(attrName)\nselect childClass, \n  \"Base classes have conflicting values for attribute '\" + attrName + \"': $@ and $@.\", \n  attrInBase1, attrInBase1.toString(), \n  attrInBase2, attrInBase2.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/elliptic-curve-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects and reports the usage of elliptic curve cryptographic algorithms",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Elliptic Curve Algorithms Detection\n * @description Detects and reports the usage of elliptic curve cryptographic algorithms \n *              within various supported cryptographic libraries in Python codebases\n * @kind problem\n * @id py/quantum-readiness/cbom/elliptic-curve-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import core Python language support for analysis\nimport python\n// Import experimental cryptographic concepts and definitions\nimport experimental.cryptography.Concepts\n\n// Main query to identify elliptic curve algorithm implementations\nfrom EllipticCurveAlgorithm ecAlgorithm\n// Format the output message with algorithm details\nselect ecAlgorithm,\n  // Construct detailed algorithm information string\n  \"Algorithm: \" + ecAlgorithm.getCurveName() + \n  // Append key size information to the output\n  \" | Key Size (bits): \" + ecAlgorithm.getCurveBitSize().toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name HTTP Response Splitting\n * @description Directly writing user-controlled input to HTTP headers\n *              enables header splitting attacks through injection.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @precision high\n * @id py/http-response-splitting\n * @tags security\n *       external/cwe/cwe-113\n *       external/cwe/cwe-079\n */\n\n// Import core Python analysis capabilities\nimport python\n\n// Import specialized HTTP header injection flow analysis module\nimport semmle.python.security.dataflow.HttpHeaderInjectionQuery\n\n// Import path graph representation for data flow visualization\nimport HeaderInjectionFlow::PathGraph\n\n// Define data flow source and sink nodes representing tainted origins and vulnerable endpoints\nfrom HeaderInjectionFlow::PathNode taintedSource, HeaderInjectionFlow::PathNode vulnerableSink\n\n// Identify complete data flow paths where tainted input reaches HTTP header sinks\nwhere HeaderInjectionFlow::flowPath(taintedSource, vulnerableSink)\n\n// Report vulnerable header locations with taint source details and contextual warning\nselect vulnerableSink.getNode(), taintedSource, vulnerableSink, \n       \"This HTTP header incorporates untrusted $@.\", taintedSource.getNode(), \n       \"user-controlled input\"",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incorrect keyword argument in class instantiation\n * @description Detects class instantiations that use keyword arguments\n *              which do not correspond to any parameter in the class's __init__ method.\n *              These mismatches result in runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n_______________ // 补全条件\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classCreation, ClassValue instantiatedClass, string invalidParameterName, FunctionValue classInitializer\nwhere\n  // First, find the initializer method of the target class\n  classInitializer = get_function_or_initializer(instantiatedClass) and\n  // Then, identify any keyword arguments in the class instantiation that don't match parameters\n  illegally_named_parameter(classCreation, instantiatedClass, invalidParameterName)\nselect classCreation, \n       \"Keyword argument '\" + invalidParameterName + \"' is not a supported parameter name of $@.\", \n       classInitializer,\n       classInitializer.getQualifiedName()",
    "output": "* @id py/call/wrong-named-class-argument"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Wrong number of arguments for format\n * @description Detects string formatting operations where the number of conversion specifiers \n *              in the format string doesn't match the number of provided values. \n *              Example: '\"%s: %s, %s\" % (a,b)' will raise a TypeError.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/percent-format/wrong-arguments\n */\n\nimport python\nimport semmle.python.strings\n\n// Identifies string formatting operations using the % operator\npredicate format_operation(BinaryExpr expr, StringLiteral fmt, Value args, AstNode source) {\n  // Verify the operator is modulo (%)\n  expr.getOp() instanceof Mod and\n  exists(Context ctx |\n    // Check left operand points to the format string\n    expr.getLeft().pointsTo(ctx, _, fmt) and\n    // Check right operand points to the argument value\n    expr.getRight().pointsTo(ctx, args, source)\n  )\n}\n\n// Calculates the length of the argument sequence\nint argument_count(Value args) {\n  /* Handle tuple arguments */\n  exists(Tuple tuple | tuple.pointsTo(args, _) |\n    result = strictcount(tuple.getAnElt()) and\n    // Exclude starred expressions from count\n    not tuple.getAnElt() instanceof Starred\n  )\n  or\n  /* Handle single literal arguments */\n  exists(ImmutableLiteral literal | literal.getLiteralValue() = args | result = 1)\n}\n_______________ // 补全条件\nfrom\n  BinaryExpr formatExpr, StringLiteral formatStr, Value argValue, \n  int argCount, int formatItemCount, AstNode argSource, string messageSuffix\nwhere\n  // Identify format operation\n  format_operation(formatExpr, formatStr, argValue, argSource) and\n  // Calculate argument count\n  argCount = argument_count(argValue) and\n  // Calculate format item count\n  formatItemCount = format_items(formatStr) and\n  // Validate mismatch\n  argCount != formatItemCount and\n  // Generate appropriate message suffix\n  (if argCount = 1 then messageSuffix = \" is provided.\" else messageSuffix = \" are provided.\")\nselect formatExpr,\n  // Construct error message\n  \"Wrong number of $@ for string format. Format $@ takes \" + formatItemCount.toString() + \n  \", but \" + argCount.toString() + messageSuffix, \n  argSource, \"arguments\", formatStr, formatStr.getText()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression analysis\n * @description Detects and evaluates alert suppression mechanisms in Python source code,\n *              with special focus on 'noqa' style suppression comments. This analysis\n *              helps identify where warnings or alerts are intentionally suppressed\n *              by developers, which is crucial for security auditing.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression utilities for analysis\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing utilities for comment extraction\nprivate import semmle.python.Comment as PythonComment\n\n// Represents a single-line Python comment with location tracking capabilities\nclass SingleLineComment instanceof PythonComment::Comment {\n  // Check if comment has specific location information\n  predicate hasLocationInfo(\n    string sourceFilePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Verify location matches parent class location data\n    super.getLocation().hasLocationInfo(sourceFilePath, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Get the text content of the comment\n  string getText() { result = super.getContents() }\n\n  // Get string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Represents a Python AST node with location tracking capabilities\nclass AstNode instanceof PythonComment::AstNode {\n  // Check if node has specific location information\n  predicate hasLocationInfo(\n    string sourceFilePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Verify location matches parent class location data\n    super.getLocation().hasLocationInfo(sourceFilePath, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Get string representation of the node\n  string toString() { result = super.toString() }\n_______________ // 补全条件\n\n// Generate suppression relationships between AST nodes and comments\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n * This class identifies and processes comments that suppress warnings in Python code.\n */\n// Represents a noqa-style suppression comment that disables warnings\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Initialize by checking comment matches noqa pattern\n  NoqaSuppressionComment() {\n    // Match case-insensitive noqa with optional suffix\n    super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Get the annotation identifier for this suppression\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define the code range covered by this suppression\n  override predicate covers(\n    string sourceFilePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Get comment location and verify it starts at column 1\n    this.hasLocationInfo(sourceFilePath, beginLine, _, finishLine, finishColumn) and\n    beginColumn = 1\n  }\n}",
    "output": "}"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure randomness vulnerability\n * @description Identifies usage of cryptographically weak pseudo-random number generators\n *              for creating security-sensitive values, potentially allowing attackers\n *              to predict generated values and compromise security.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n_______________ // 补全条件\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// Import core Python analysis capabilities for code examination\nimport python\n\n// Import specialized security analysis module for detecting insecure random\n// number generation patterns in Python applications\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Import data flow analysis framework to trace value propagation\n// through program execution paths\nimport semmle.python.dataflow.new.DataFlow\n\n// Import path graph module for visualizing and representing data\n// flow connections between source and sink points\nimport InsecureRandomness::Flow::PathGraph\n\n// Query to trace insecure random value propagation:\n// - insecureRandomSource: Origin point of cryptographically weak random values\n// - securitySensitiveSink: Security-critical usage point of these values\nfrom InsecureRandomness::Flow::PathNode insecureRandomSource, \n     InsecureRandomness::Flow::PathNode securitySensitiveSink\nwhere \n  // Establish data flow connection between source and sink\n  InsecureRandomness::Flow::flowPath(insecureRandomSource, securitySensitiveSink)\nselect \n  // Output the sink node as primary result\n  securitySensitiveSink.getNode(), \n  // Include source and sink nodes for path visualization\n  insecureRandomSource, \n  securitySensitiveSink, \n  // Generate alert message with source node reference\n  \"Cryptographically insecure $@ in a security context.\",\n  insecureRandomSource.getNode(), \n  \"random value\"",
    "output": "* @precision high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Cyclomatic complexity of functions\n * @description Measures the cyclomatic complexity for each Python function. This metric\n *              indicates the number of linearly independent paths through a function's code.\n *              Higher complexity values suggest more branching logic, necessitating more\n *              comprehensive testing and potentially impacting code maintainability.\n * @kind treemap\n * @id py/cyclomatic-complexity-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max sum\n * @tags testability\n_______________ // 补全条件\n *       maintainability\n */\n\nimport python\n\n// This query processes all Python functions to determine their cyclomatic complexity metric\nfrom Function targetFunction, int cyclomaticComplexityValue\n// Calculate the complexity score by accessing the function's metrics and retrieving the cyclomatic complexity value\nwhere cyclomaticComplexityValue = targetFunction.getMetrics().getCyclomaticComplexity()\n// Output includes each function and its corresponding complexity metric, with results sorted by complexity in descending order\nselect targetFunction, cyclomaticComplexityValue order by cyclomaticComplexityValue desc",
    "output": "*       complexity"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Partial server-side request forgery\n * @description Detects network requests where URL components are influenced by user input, enabling request forgery attacks\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision medium\n * @id py/partial-ssrf\n * @tags security\n *       external/cwe/cwe-918\n_______________ // 补全条件\n\n// Import Python standard library\nimport python\n// Import SSRF detection utilities\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\n// Import partial SSRF flow path graph\nimport PartialServerSideRequestForgeryFlow::PathGraph\n\n// Identify vulnerable HTTP requests with user-controlled URL components\nfrom\n  PartialServerSideRequestForgeryFlow::PathNode sourceNode, // Origin of untrusted data\n  PartialServerSideRequestForgeryFlow::PathNode sinkNode,   // Destination where data is used\n  Http::Client::Request httpRequest                        // HTTP request being analyzed\nwhere\n  // Ensure the request matches the sink location\n  httpRequest = sinkNode.getNode().(Sink).getRequest() and\n  // Verify data flow path exists from source to sink\n  PartialServerSideRequestForgeryFlow::flowPath(sourceNode, sinkNode) and\n  // Exclude requests with fully controlled URLs\n  not fullyControlledRequest(httpRequest)\nselect httpRequest, sourceNode, sinkNode, \"URL component in this request originates from $@.\", sourceNode.getNode(),\n  \"user-provided input\"",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/modification-of-default-value]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects modifications of parameters that have default values, which can cause unexpected behavior since default values are shared across function calls.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Parameter with default value modification\n * @description Detects modifications of parameters that have default values, which can cause unexpected behavior since default values are shared across function calls.\n * @kind path-problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/modification-of-default-value\n */\n\nimport python\nimport semmle.python.functions.ModificationOfParameterWithDefault\nimport ModificationOfParameterWithDefault::Flow::PathGraph\n\nfrom\n  ModificationOfParameterWithDefault::Flow::PathNode sourceNode,\n  ModificationOfParameterWithDefault::Flow::PathNode targetNode\nwhere \n  ModificationOfParameterWithDefault::Flow::flowPath(sourceNode, targetNode)\nselect \n  targetNode.getNode(), \n  sourceNode, \n  targetNode, \n  \"This expression mutates a $@.\", \n  sourceNode.getNode(),\n  \"default value\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Identical Value Comparison\n * @description Identifies redundant comparisons where both operands are identical,\n *              which may indicate unclear programming intent or logical errors.\n *              This check excludes constant expressions and potential missing self references.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n_______________ // 补全条件\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\nimport python\nimport Expressions.RedundantComparison\n\nfrom RedundantComparison redundantExpr\nwhere \n  /* Exclude constant expressions from analysis */\n  not redundantExpr.isConstant() \n  /* Filter out cases where 'self' might be missing */\n  and not redundantExpr.maybeMissingSelf()\nselect \n  redundantExpr, \n  \"Comparison of identical values detected; consider using cmath.isnan() for NaN checks.\"",
    "output": "*       external/cwe/cwe-570"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure temporary file\n * @description Detects usage of deprecated temporary file creation methods that pose security risks.\n * @kind problem\n * @id py/insecure-temporary-file\n * @problem.severity error\n * @security-severity 7.0\n * @sub-severity high\n * @precision high\n * @tags external/cwe/cwe-377\n *       security\n */\n\nimport python\nimport semmle.python.ApiGraphs\n_______________ // 补全条件\n// Define API nodes for insecure temporary file creation functions\nAPI::Node insecureTempFileFunction(string modName, string funcName) {\n  // Check if the function is from the tempfile module and is mktemp\n  (modName = \"tempfile\" and funcName = \"mktemp\" and\n   result = API::moduleImport(modName).getMember(funcName))\n  or\n  // Check if the function is from the os module and is either tmpnam or tempnam\n  (modName = \"os\" and\n   (funcName = \"tmpnam\" or funcName = \"tempnam\") and\n   result = API::moduleImport(modName).getMember(funcName)\n  )\n}\n\n// Identify all calls to insecure temporary file functions\nfrom Call insecureCall, string modName, string funcName\n// Get the insecure API node and check if the call targets it\nwhere insecureTempFileFunction(modName, funcName).getACall().asExpr() = insecureCall\n// Report the insecure call with detailed context\nselect insecureCall, \n       \"Use of deprecated function \" + modName + \".\" + funcName + \n       \" creates security vulnerability in temporary file handling\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name PAM授权绕过问题由于不正确使用\n * @description 检测在`pam_authenticate`认证后未调用`pam_acct_mgmt`验证账户有效性的场景，\n *              此缺陷可能导致未授权访问（CWE-285）\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 8.1\n * @precision high\n * @id py/pam-auth-bypass\n * @tags security\n *       external/cwe/cwe-285\n_______________ // 补全条件\n\nimport python\nimport PamAuthorizationFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.security.dataflow.PamAuthorizationQuery\n\n// 定义关键节点：认证入口点与潜在漏洞点\nfrom PamAuthorizationFlow::PathNode authEntry, PamAuthorizationFlow::PathNode vulnSink\n// 验证授权流程路径完整性：从认证入口到漏洞点存在完整数据流\nwhere PamAuthorizationFlow::flowPath(authEntry, vulnSink)\n// 生成漏洞报告，包含路径追踪和问题描述\nselect vulnSink.getNode(), authEntry, vulnSink,\n  \"PAM认证依赖$@，但后续未调用'pam_acct_mgmt'进行账户有效性验证\",\n  authEntry.getNode(), \"用户提供的凭证值\"",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type inference fails for 'object'\n * @description Identifies cases where type inference fails for 'object', reducing recall in many queries.\n * @kind problem\n * @problem.severity info\n * @id py/type-inference-failure\n * @deprecated\n */\n\n// Import Python module for code analysis\nimport python\n\n_______________ // 补全条件\nfrom ControlFlowNode node, Object targetObj\nwhere\n  // Condition 1: Node directly references the object\n  node.refersTo(targetObj) and\n  // Condition 2: Node lacks additional reference metadata\n  not node.refersTo(targetObj, _, _)\n// Report the target object with diagnostic message\nselect targetObj, \"Type inference fails for 'object'.\"",
    "output": "// Select control flow nodes and objects meeting specific conditions"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Module dependency analysis\n * @description Quantifies and displays the count of incoming dependencies for each module, helping identify highly coupled components.\n * @kind treemap\n * @id py/afferent-coupling-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       modularity\n */\n\nimport python\n\n// Analyze module connectivity by calculating inbound dependency relationships\nfrom ModuleMetrics moduleInfo, int dependencyCount\nwhere \n  // Calculate the afferent coupling metric (number of modules that depend on this one)\n_______________ // 补全条件\n  // Filter out modules with zero incoming dependencies to focus on meaningful connections\n  and dependencyCount > 0\nselect \n  moduleInfo, \n  dependencyCount as couplingMetric \norder by \n  couplingMetric desc",
    "output": "dependencyCount = moduleInfo.getAfferentCoupling()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jwt-empty-secret-or-algorithm]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies security vulnerabilities where JWT tokens are encoded with empty secrets or missing algorithms.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name JWT encoding using empty key or algorithm\n * @description Identifies security vulnerabilities where JWT tokens are encoded with empty secrets or missing algorithms.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-empty-secret-or-algorithm\n * @tags security\n *       experimental\n */\n\n// Import required Python analysis modules and JWT framework detection capabilities\nimport python\nimport experimental.semmle.python.Concepts\nimport experimental.semmle.python.frameworks.JWT\n\nfrom JwtEncoding jwtEncodingOperation, string insecureParameter  // Identify JWT encoding operations and their vulnerable parameters\nwhere\n  // Check for empty or missing algorithm in JWT encoding\n  (insecureParameter = \"algorithm\" and \n   isEmptyOrNone(jwtEncodingOperation.getAlgorithm()))\n  or\n  // Check for empty or missing key in JWT encoding\n  (insecureParameter = \"key\" and \n   isEmptyOrNone(jwtEncodingOperation.getKey()))\nselect jwtEncodingOperation, \"This JWT encoding has an empty \" + insecureParameter + \".\"  // Report the vulnerable encoding operation with specific parameter issue"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mostly-duplicate-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies modules containing substantial code duplication. Refactoring these modules enhances maintainability and reduces technical debt.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Substantial code duplication identifier\n * @description Identifies modules containing substantial code duplication. Refactoring these modules enhances maintainability and reduces technical debt.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-file\n */\n\nimport python\n\n// Define variables for duplicate analysis\nfrom \n  Module sourceModule,\n  Module cloneModule,\n  string duplicationMessage\nwhere \n  // Query intentionally disabled to prevent execution\n  none()\nselect \n  sourceModule,\n  duplicationMessage,\n  cloneModule,\n  cloneModule.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n/**\n * 检测描述符类在其方法中发生的变异操作\n * @param descriptorClass - 被检查的描述符类对象\n_______________ // 补全条件\n */\npredicate mutates_descriptor(ClassObject descriptorClass, SelfAttributeStore selfMutation) {\n  // 确保目标类是描述符类型\n  descriptorClass.isDescriptorType() and\n  \n  // 检查描述符方法中是否存在变异操作\n  exists(PyFunctionObject calledFunction, PyFunctionObject descriptorMethod |\n    // 验证类中存在描述符协议方法\n    exists(string methodName | \n      descriptorClass.lookupAttribute(methodName) = descriptorMethod and\n      (methodName = \"__get__\" or methodName = \"__set__\" or methodName = \"__delete__\")\n    ) and\n    \n    // 确保变异操作发生在描述符方法调用的函数中\n    descriptorClass.lookupAttribute(_) = calledFunction and\n    descriptorMethod.getACallee*() = calledFunction and\n    \n    // 排除初始化方法，因为初始化时的变异是预期的\n    not calledFunction.getName() = \"__init__\" and\n    \n    // 确认变异操作的作用域是当前函数\n    selfMutation.getScope() = calledFunction.getFunction()\n  )\n}\n\n// 查询所有在描述符方法中发生变异的类和操作\nfrom ClassObject descriptorClass, SelfAttributeStore selfMutation\nwhere mutates_descriptor(descriptorClass, selfMutation)\nselect selfMutation,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorClass, descriptorClass.getName()",
    "output": "* @param selfMutation - 对self属性的变异操作"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：超类属性遮蔽子类方法是指在继承体系中，超类的 __init__ 方法中定义的实例属性",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 超类属性遮蔽子类方法是指在继承体系中，超类的 __init__ 方法中定义的实例属性\n *              与子类中定义的方法同名，导致子类方法无法正常访问的问题。这种情况会导致\n *              运行时行为异常，因为属性赋值会覆盖方法引用。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 本查询通过分析类继承体系、属性定义和方法声明，检测子类方法是否被超类\n * 初始化方法中定义的属性遮蔽的情况。核心检测逻辑包括：\n * 1. 验证类之间的直接继承关系\n * 2. 确认子类声明了被遮蔽的方法\n * 3. 在超类初始化方法中定位同名属性赋值\n * 4. 排除超类中存在同名方法的情况（视为有意设计）\n */\n\nimport python\n\n// 定义谓词：判断子类方法是否被超类属性遮蔽\npredicate isMethodShadowedBySuperAttribute(\n  ClassObject subClass, ClassObject superClass, Assign attrAssign, FunctionObject shadowedMethod\n) {\n  // 验证继承关系：subClass 直接继承自 superClass\n  subClass.getASuperType() = superClass and\n  \n  // 确认子类声明了被遮蔽的方法\n  subClass.declaredAttribute(shadowedMethod.getName()) = shadowedMethod and\n  \n  // 在超类初始化方法中查找同名属性赋值\n  exists(FunctionObject superInitMethod, Attribute attrTarget |\n    // 超类定义了 __init__ 方法\n    superClass.declaredAttribute(\"__init__\") = superInitMethod and\n    \n    // 属性赋值的目标是 attrTarget\n    attrTarget = attrAssign.getATarget() and\n    \n    // 属性赋值对象是 self\n    attrTarget.getObject().(Name).getId() = \"self\" and\n    \n    // 属性名称与子类方法名称相同\n    attrTarget.getName() = shadowedMethod.getName() and\n    \n    // 赋值操作发生在超类的初始化方法中\n    attrAssign.getScope() = superInitMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  \n  // 排除超类中定义同名方法的情况（视为有意设计）\n  not superClass.hasAttribute(shadowedMethod.getName())\n}\n\n// 查询被遮蔽的方法及其相关信息\nfrom ClassObject subClass, ClassObject superClass, Assign attrAssign, FunctionObject shadowedMethod\nwhere isMethodShadowedBySuperAttribute(subClass, superClass, attrAssign, shadowedMethod)\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superClass.getName() +\n    \"'.\", attrAssign, \"attribute\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak cryptographic hashes\n * @description Detects usage of cryptographic hash algorithms that are either unapproved or considered weak.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import required Python libraries and experimental cryptography concepts\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify weak hash operations and generate corresponding warnings\nfrom HashAlgorithm cryptoHash, string algorithmName, string alertMessage\nwhere\n  // Extract the algorithm name from the hash operation\n  algorithmName = cryptoHash.getHashName() and\n  // Exclude approved strong hash algorithms (SHA256, SHA384, SHA512)\n  not algorithmName in [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // Generate alert message based on algorithm recognition status\n  (\n    // Case: Recognized but unapproved algorithm\n_______________ // 补全条件\n    alertMessage = \"Use of unapproved hash algorithm or API \" + algorithmName + \".\"\n  )\n  or\n  (\n    // Case: Unrecognized algorithm\n    algorithmName = \"\" and\n    alertMessage = \"Use of unrecognized hash algorithm.\"\n  )\nselect cryptoHash, alertMessage",
    "output": "algorithmName != \"\" and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python 模块传出耦合分析\n * @description 此查询用于量化每个 Python 模块的传出耦合度，即该模块所依赖的其他模块数量。\n *              传出耦合度高可能表明模块职责过多，降低了代码的可维护性和可测试性。\n_______________ // 补全条件\n * @id py/efferent-coupling-per-file\n * @treemap.warnOn 高值警告\n * @metricType 文件\n * @metricAggregate 平均值 最大值\n * @tags 可测试性\n *       模块化\n */\n\nimport python // 导入Python语言分析库\n\n// 从ModuleMetrics类中获取每个模块的分析对象\nfrom ModuleMetrics moduleAnalysis\n\n// 选择模块及其传出耦合度，按耦合度降序排列\nselect moduleAnalysis, \n       moduleAnalysis.getEfferentCoupling() as dependencyCount \norder by dependencyCount desc",
    "output": "* @kind 树状图"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unguarded-next-in-generator]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects unguarded next() calls in generators that may cause unintended iteration termination.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unguarded next in generator\n * @description Detects unguarded next() calls in generators that may cause unintended iteration termination.\n * @kind problem\n * @tags maintainability\n *       portability\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unguarded-next-in-generator\n */\n\nimport python\nprivate import semmle.python.ApiGraphs\n\n// API node for built-in iter() function\nAPI::Node builtinIter() { result = API::builtin(\"iter\") }\n\n// API node for built-in next() function\nAPI::Node builtinNext() { result = API::builtin(\"next\") }\n\n// API node for built-in StopIteration exception\nAPI::Node builtinStopIteration() { result = API::builtin(\"StopIteration\") }\n\n// Identifies iter() calls with specified sequence argument\npredicate iterCallOnSequence(CallNode iterCall, EssaVariable sequenceVar) {\n  iterCall = builtinIter().getACall().asCfgNode() and\n  iterCall.getArg(0) = sequenceVar.getAUse()\n}\n\n// Identifies next() calls with specified iterator argument\npredicate nextCallOnIterator(CallNode nextCall, ControlFlowNode iteratorNode) {\n  nextCall = builtinNext().getACall().asCfgNode() and\n  nextCall.getArg(0) = iteratorNode\n}\n\n// Checks if next() call provides a default value\npredicate nextCallWithDefault(CallNode nextCall) {\n  exists(nextCall.getArg(1)) or exists(nextCall.getArgByName(\"default\"))\n}\n\n/**\n * Holds if iterator is guaranteed non-exhausted.\n * \n * Common pattern: next(iter(x)) where x is known non-empty.\n */\npredicate isNonExhaustedIterator(EssaVariable iteratorVar) {\n  exists(EssaVariable sequenceVar |\n    iterCallOnSequence(iteratorVar.getDefinition().(AssignmentDefinition).getValue(), sequenceVar) and\n    sequenceVar.getDefinition() instanceof EssaEdgeRefinement\n  )\n}\n\n// Checks if StopIteration exception is handled in scope\npredicate isStopIterationHandled(CallNode nextCall) {\n  exists(Try tryStmt |\n    tryStmt.containsInScope(nextCall.getNode()) and\n    tryStmt.getAHandler().getType() = builtinStopIteration().getAValueReachableFromSource().asExpr()\n  )\n}\n\n// Find unguarded next() calls in generators without default value or exception handling\nfrom CallNode nextCall, ControlFlowNode iteratorNode\nwhere\n  // Verify next() call with iterator argument\n  nextCallOnIterator(nextCall, iteratorNode) and\n  // Ensure no default value provided\n  not nextCallWithDefault(nextCall) and\n  // Confirm iterator might be exhausted\n  not exists(EssaVariable iteratorVar |\n    iteratorNode = iteratorVar.getAUse() and\n    isNonExhaustedIterator(iteratorVar)\n  ) and\n  // Restrict to generator functions\n  nextCall.getNode().getScope().(Function).isGenerator() and\n  // Exclude comprehensions\n  not exists(Comp comp | comp.contains(nextCall.getNode())) and\n  // Verify no StopIteration handling\n  not isStopIterationHandled(nextCall) and\n  // PEP 479 resolves this in Python 3.7+\n  // Only alert for Python 2 since minor version is unknown\n  major_version() = 2\nselect nextCall, \"Call to 'next()' in a generator.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Wrong name for an argument in a class instantiation\n * @description Detects class instantiations that use named arguments which do not\n *              correspond to any parameter in the class's __init__ method.\n *              Such usage leads to TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\n_______________ // 补全条件\nimport python\nimport Expressions.CallArgs\n\n// Query for class instantiations with invalid named arguments\nfrom Call classInstantiation, ClassValue targetClass, string invalidArgName, FunctionValue initializerMethod\nwhere\n  // Verify if the call uses an illegally named parameter for the class\n  illegally_named_parameter(classInstantiation, targetClass, invalidArgName) and\n  // Retrieve the initializer method (__init__) of the target class\n  initializerMethod = get_function_or_initializer(targetClass)\nselect classInstantiation, \"Keyword argument '\" + invalidArgName + \"' is not a supported parameter name of $@.\", initializerMethod,\n  // Output the class instantiation, error message, initializer method, and its qualified name\n  initializerMethod.getQualifiedName()",
    "output": "// Import necessary Python and expression call argument modules"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insecure default SSL/TLS protocol version\n * @description Applications that fail to explicitly specify an SSL/TLS protocol version\n *              may rely on insecure default protocol versions, exposing them to known vulnerabilities.\n * @id py/insecure-default-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n_______________ // 补全条件\n *       external/cwe/cwe-327\n */\n\n// This query detects deprecated SSL socket creation methods that do not explicitly define protocol versions.\n// The ssl.wrap_socket function, when called without the ssl_version parameter, can default to insecure protocols.\n// Related secure context configuration issues are covered by the py/insecure-protocol dataflow query.\nimport python\nimport semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode insecureSocketCall\nwhere\n  // Identify deprecated ssl.wrap_socket method calls\n  insecureSocketCall = API::moduleImport(\"ssl\").getMember(\"wrap_socket\").getACall()\n  // Verify that the ssl_version parameter is missing\n  and not exists(insecureSocketCall.getArgByName(\"ssl_version\"))\nselect insecureSocketCall,\n  \"Use of deprecated ssl.wrap_socket without explicit protocol version may result in insecure default protocol selection.\"",
    "output": "* @tags security"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Code injection vulnerability detection\n * @description Identifies potential code injection risks where unsanitized user input \n *              gets executed as code, allowing attackers to run arbitrary commands.\n_______________ // 补全条件\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.3\n * @sub-severity high\n * @precision high\n * @id py/code-injection\n * @tags security\n *       external/cwe/cwe-094\n *       external/cwe/cwe-095\n *       external/cwe/cwe-116\n */\n\n// Import core Python analysis capabilities for AST processing\nimport python\n\n// Import specialized data flow tracking for code injection detection\nimport semmle.python.security.dataflow.CodeInjectionQuery\n\n// Import path visualization utilities for data flow analysis\nimport CodeInjectionFlow::PathGraph\n\n// Define vulnerability detection logic by tracing data paths\nfrom CodeInjectionFlow::PathNode userInputSource, CodeInjectionFlow::PathNode codeExecutionSink\n// Validate data flow connection between source and sink\nwhere CodeInjectionFlow::flowPath(userInputSource, codeExecutionSink)\n// Output vulnerability details with contextual information\nselect codeExecutionSink.getNode(), userInputSource, codeExecutionSink,\n  \"This code execution depends on a $@.\", userInputSource.getNode(),\n  \"user-provided value\"",
    "output": "*              This analysis tracks data flow from user-controlled sources to critical code execution points."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insufficient KDF Salt Length\n * @description Identifies key derivation functions using salt values with inadequate length.\n * \n * This rule detects scenarios where a KDF operation is configured with a salt size\n * below the recommended 128-bit (16-byte) threshold, or when the salt size\n * cannot be determined through static analysis.\n * @kind problem\n * @id py/kdf-small-salt-size\n_______________ // 补全条件\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\nfrom KeyDerivationOperation keyDerivationFunc, DataFlow::Node saltSizeSource, API::CallNode randomGeneratorCall, string alertMessage\nwhere\n  // Focus on KDF operations that require salt configuration\n  keyDerivationFunc.requiresSalt() and\n  \n  // Identify os.urandom calls used for salt generation\n  API::moduleImport(\"os\").getMember(\"urandom\").getACall() = randomGeneratorCall and\n  randomGeneratorCall = keyDerivationFunc.getSaltConfigSrc() and\n  \n  // Trace the source of the size parameter passed to os.urandom\n  saltSizeSource = Utils::getUltimateSrcFromApiNode(randomGeneratorCall.getParameter(0, \"size\")) and\n  \n  // Determine if salt size is insufficient or cannot be statically verified\n  (\n    // Case 1: Salt size is not statically verifiable\n    not exists(saltSizeSource.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Salt configuration is not a statically verifiable size. \"\n    or\n    // Case 2: Salt size is less than the required minimum (16 bytes)\n    saltSizeSource.asExpr().(IntegerLiteral).getValue() < 16 and\n    alertMessage = \"Salt configuration is insufficiently large. \"\n  )\nselect keyDerivationFunc,\n  alertMessage + \"Salt size must be a minimum of 16 (bytes). os.urandom Config: $@, Size Config: $@\", \n  randomGeneratorCall, randomGeneratorCall.toString(), \n  saltSizeSource, saltSizeSource.toString()",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name File Deletion Metrics\n * @description Generates a treemap visualization that illustrates the cumulative count of lines removed from each source file across the entire commit history of the project.\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\n// Locate source modules and compute their cumulative deletion metrics\nfrom Module sourceModule, int deletedLinesCount\nwhere\n  // Ensure the module has quantifiable code content\n  exists(sourceModule.getMetrics().getNumberOfLinesOfCode()) and\n  // Calculate the total number of lines eliminated in all relevant commits\n  deletedLinesCount = sum(\n    Commit commitEntry, int linesRemoved |\n      // Retrieve the count of lines removed in each commit that modifies this module\n      linesRemoved = commitEntry.getRecentDeletionsForFile(sourceModule.getFile()) and\n_______________ // 补全条件\n      not artificialChange(commitEntry)\n    |\n      linesRemoved\n  )\nselect sourceModule, deletedLinesCount order by deletedLinesCount desc",
    "output": "// Filter out synthetic commits that do not represent genuine development activities"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jump-to-definition]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Enhanced helper query for navigating from expression usage to their corresponding definition locations in Python source code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Navigate to Definitions\n * @description Enhanced helper query for navigating from expression usage to their corresponding definition locations in Python source code.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import the core Python library for static analysis of Python source code\nimport python\n\n// Import the definition tracking module to enable tracing of variable, function, and class definitions\nimport analysis.DefinitionTracking\n\n// Select expressions with precise locations, their associated definitions, and the category of each definition\nfrom NiceLocationExpr usageExpr, Definition definition, string definitionCategory\n// Ensure that the definition correctly corresponds to the usage and that their types are compatible\nwhere \n  definition = definitionOf(usageExpr, definitionCategory)\n// Output the usage location, definition location, and definition type for navigation purposes\nselect usageExpr, definition, definitionCategory"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inconsistent-equality]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes violating the object model by implementing only one of the equality comparison methods (__eq__ or __ne__)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent equality and inequality\n * @description Identifies classes violating the object model by implementing only one of the equality comparison methods (__eq__ or __ne__)\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-equality\n */\n\nimport python\n\n// Helper function returning valid equality comparison method names\nstring getEqualityMethodName() { result = \"__eq__\" or result = \"__ne__\" }\n\n// Predicate checking if a class uses the total_ordering decorator\npredicate isDecoratedWithTotalOrdering(Class cls) {\n  exists(Attribute decorator | \n    decorator = cls.getADecorator() | \n    decorator.getName() = \"total_ordering\"\n  )\n  or\n  exists(Name decorator | \n    decorator = cls.getADecorator() | \n    decorator.getId() = \"total_ordering\"\n  )\n}\n\n// Function retrieving an implemented equality method from a class\nCallableValue getEqualityMethod(ClassValue targetClass, string methodName) {\n  result = targetClass.declaredAttribute(methodName) and \n  methodName = getEqualityMethodName()\n}\n\n// Function determining which equality method is missing in a class\nstring getMissingEqualityMethod(ClassValue targetClass) {\n  not targetClass.declaresAttribute(result) and \n  result = getEqualityMethodName()\n}\n\n// Predicate identifying classes violating the equality contract\npredicate violatesEqualityContract(\n  ClassValue targetClass, string implementedMethodName, \n  string missingMethodName, CallableValue equalityMethod\n) {\n  missingMethodName = getMissingEqualityMethod(targetClass) and\n  equalityMethod = getEqualityMethod(targetClass, implementedMethodName) and\n  not targetClass.failedInference(_) and\n  not isDecoratedWithTotalOrdering(targetClass.getScope()) and\n  /* Python 3 auto-implements __ne__ when __eq__ is defined, but not vice-versa */\n  not (major_version() = 3 and implementedMethodName = \"__eq__\" and missingMethodName = \"__ne__\")\n}\n\n// Select classes violating the equality contract with warning messages\nfrom ClassValue targetClass, string implementedMethodName, string missingMethodName, CallableValue equalityMethod\nwhere violatesEqualityContract(targetClass, implementedMethodName, missingMethodName, equalityMethod)\nselect equalityMethod, \"Class $@ implements \" + implementedMethodName + \" but does not implement \" + missingMethodName + \".\", targetClass,\n  targetClass.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Function Naming Convention Violation\n * @description Identifies Python functions that begin with uppercase letters,\n *              which contradicts the PEP8 naming conventions for function names.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n * @convention PEP8\n */\n\nimport python  // Import the Python library for code analysis\n\n// Find functions that violate PEP8 naming convention\nfrom Function targetFunction\nwhere\n  // Verify the function is part of the source code\n  targetFunction.inSource() and\n  \n  // Check if the function name starts with an uppercase letter\n_______________ // 补全条件\n    firstChar = targetFunction.getName().prefix(1) and  // Extract the first character\n    firstChar != firstChar.toLowerCase()                // Confirm it's uppercase\n  ) and\n  \n  // Ensure only the first violation per file is reported to avoid duplicates\n  not exists(Function anotherFunction |\n    anotherFunction != targetFunction and  // Must be a different function\n    anotherFunction.getLocation().getFile() = targetFunction.getLocation().getFile() and  // Same file\n    exists(string anotherFirstChar |\n      anotherFirstChar = anotherFunction.getName().prefix(1) and  // Extract the first character\n      anotherFirstChar != anotherFirstChar.toLowerCase()          // Confirm it's uppercase\n    )\n  )\nselect targetFunction, \"Function names should start with lowercase letters according to PEP8.\"  // Report the violation with remediation advice",
    "output": "exists(string firstChar |"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raises-tuple]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Raising a tuple will result in all but the first element being discarded",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Raising a tuple\n * @description Raising a tuple will result in all but the first element being discarded\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// Identify raise statements in Python 2 code where a tuple is raised\nfrom Raise raiseStatement, DataFlow::LocalSourceNode tupleSourceNode\nwhere\n  // Restrict analysis to Python 2 (Python 3 handles this as a type error)\n  major_version() = 2 and\n  // Verify the source node represents a tuple expression\n  tupleSourceNode.asExpr() instanceof Tuple and\n  // Confirm data flow path from tuple to the raised exception\n  exists(DataFlow::Node exceptionTargetNode | \n    exceptionTargetNode.asExpr() = raiseStatement.getException() and\n    tupleSourceNode.flowsTo(exceptionTargetNode)\n  )\n/* Raising a tuple is a type error in Python 3, so is handled by the IllegalRaise query. */\nselect raiseStatement,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleSourceNode, \"tuple\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-low-iteration-count]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：When deriving cryptographic keys from user-provided inputs such as password,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use iteration count at least 100k to prevent brute force attacks\n * @description When deriving cryptographic keys from user-provided inputs such as password,\n * use sufficient iteration count (at least 100k).\n *\n * This query will alert if the iteration count is less than 10000 (i.e., a constant <100000 is observed)\n * or if the source for the iteration count is not known statically.\n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import Python standard library\nimport python\n// Import experimental cryptography concepts\nimport experimental.cryptography.Concepts\n// Private import of experimental cryptography utilities, aliased as Utils\nprivate import experimental.cryptography.utils.Utils as Utils\n\n// Select key derivation operations, alert messages, and iteration configuration sources\nfrom KeyDerivationOperation keyDerivationOp, string alertMessage, DataFlow::Node iterationSource\nwhere\n  // Filter for operations that require iteration\n  keyDerivationOp.requiresIteration() and\n  // Get the source of the iteration size configuration\n  iterationSource = keyDerivationOp.getIterationSizeSrc() and\n  (\n    // Case 1: Check if iteration count is a literal integer and below threshold\n    exists(int iterationCount | \n      iterationCount = iterationSource.asExpr().(IntegerLiteral).getValue() and\n      iterationCount < 10000\n    ) and\n    alertMessage = \"Iteration count is too low. \"\n    // Case 2: Check if iteration count is not a statically verifiable literal\n    or\n    not exists(iterationSource.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Iteration count is not a statically verifiable size. \"\n  )\nselect \n  // Output the key derivation operation, alert message, and iteration configuration details\n  keyDerivationOp, alertMessage + \"Iteration count must be a minimum of 10000. Iteration Config: $@\",\n  iterationSource.asExpr(), iterationSource.asExpr().toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-padding]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Detects asymmetric encryption padding mechanisms that are either",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Detects asymmetric encryption padding mechanisms that are either\n * cryptographically insecure or not explicitly endorsed by security standards.\n * This query identifies potentially vulnerable padding configurations\n * by excluding only the most robust padding methods (OAEP, KEM, PSS) and flagging\n * all other padding schemes as possible security threats.\n * \n * The analysis targets padding implementations that could be susceptible to\n * cryptographic attacks when utilized in asymmetric encryption scenarios.\n * \n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricPadding paddingImpl, string algorithmName\nwhere\n  // Retrieve the algorithm name from the padding implementation\n  algorithmName = paddingImpl.getPaddingName()\n  // Filter out implementations employing approved secure padding schemes\n  and not algorithmName = [\"OAEP\", \"KEM\", \"PSS\"]\nselect paddingImpl, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + algorithmName"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/summarized-callable-call-sites]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies call sites associated with summarized callables",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Summarized callable call sites\n * @description Identifies call sites associated with summarized callables\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/summarized-callable-call-sites\n * @tags meta\n * @precision very-low\n */\n\n// Import Python language core library\nimport python\n// Import data flow analysis modules\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\n// Import meta metrics analysis module\nimport meta.MetaMetrics\n\n// Define analysis variables: invocation point, target callable, and call type\nfrom DataFlow::Node invocationPoint, SummarizedCallable targetCallable, string callType\nwhere\n  // Direct invocation scenario: invocation point matches callable's call site\n  (invocationPoint = targetCallable.getACall() and callType = \"Call\")\n  or\n  // Callback invocation scenario: invocation point matches callable's callback site\n  (invocationPoint = targetCallable.getACallback() and callType = \"Callback\")\n  and\n  // Exclude invocation points located in ignored files\n  not invocationPoint.getLocation().getFile() instanceof IgnoredFile\n// Output invocation point with formatted call type and target callable information\nselect invocationPoint, callType + \" to \" + targetCallable"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/iter-returns-non-iterator]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes returned by `__iter__` methods that violate iterator protocol,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__iter__` method returns non-iterator type\n * @description Identifies classes returned by `__iter__` methods that violate iterator protocol,\n *              which would trigger TypeError in iteration contexts (e.g., for-loops).\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iter-returns-non-iterator\n */\n\nimport python\n\nfrom ClassValue sourceClass, FunctionValue iterMethod, ClassValue returnedClass\nwhere\n  // Locate classes defining __iter__ method\n  iterMethod = sourceClass.lookup(\"__iter__\") and\n  // Extract the return type from __iter__ method\n  returnedClass = iterMethod.getAnInferredReturnType() and\n  // Validate return type lacks iterator implementation\n  not returnedClass.isIterator()\nselect \n  returnedClass,\n  \"Class \" + returnedClass.getName() + \n    \" returned as iterator (by $@) but fails iterator protocol compliance.\",\n  iterMethod, iterMethod.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Wrong name for an argument in a class instantiation\n * @description Identifies class instantiations using keyword arguments \n *              that don't match any parameter in the class's __init__ method.\n *              Such mismatches cause runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n_______________ // 补全条件\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstantiation, ClassValue targetClass, string invalidArgName, FunctionValue initializerMethod\nwhere\n  // Identify invalid keyword arguments in class instantiation\n  illegally_named_parameter(classInstantiation, targetClass, invalidArgName) and\n  // Retrieve the class's initializer method\n  initializerMethod = get_function_or_initializer(targetClass)\nselect classInstantiation, \n       \"Keyword argument '\" + invalidArgName + \"' is not a supported parameter name of $@.\", \n       initializerMethod,\n       initializerMethod.getQualifiedName()",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cryptographic implementations using elliptic curve algorithms that are either",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Vulnerable Elliptic Curve Implementation\n * @description Detects cryptographic implementations using elliptic curve algorithms that are either\n *              unrecognized or considered cryptographically weak, which may lead to security vulnerabilities.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm ellipticCurveOperation, string securityAlert, string curveName\nwhere\n  // Extract the curve name from the cryptographic operation\n  curveName = ellipticCurveOperation.getCurveName() and\n  (\n    // Scenario 1: Identify operations using unrecognized curve algorithms\n    curveName = unknownAlgorithm() and\n    securityAlert = \"Use of unrecognized curve algorithm.\"\n    or\n    // Scenario 2: Identify operations using recognized but weak curve algorithms\n    curveName != unknownAlgorithm() and\n    not curveName =\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    securityAlert = \"Use of weak curve algorithm \" + curveName + \".\"\n  )\nselect ellipticCurveOperation, securityAlert"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'import *' used\n * @description Detects usage of wildcard imports which can hinder static analysis\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// 导入Python分析库，提供静态代码分析所需的基础功能\nimport python\n\n// 识别所有采用通配符导入（import *）的代码节点\n// 这种导入方式会将模块中的所有公共名称引入当前作用域，可能导致命名空间污染\nfrom ImportStar namespacePollutingImport\n_______________ // 补全条件\n// 输出检测结果，提示通配符导入对命名空间的潜在污染风险\nselect namespacePollutingImport, \"Using 'from ... import *' pollutes the namespace.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insufficient KDF Derived Key Length\n * @description Identifies key derivation functions (KDF) producing keys shorter than 128 bits (16 bytes).\n_______________ // 补全条件\n *             the length defaults to the underlying hash algorithm's output size.\n * @kind problem\n * @id py/kdf-small-key-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\n// Detect key derivation operations with inadequate key sizes\nfrom KeyDerivationOperation kdfOp, string warningMsg, DataFlow::Node keySizeSpec\nwhere\n  // Obtain key size specification source, excluding None values\n  keySizeSpec = kdfOp.getDerivedKeySizeSrc() and\n  not keySizeSpec.asExpr() instanceof None and\n  (\n    // Case 1: Explicit integer value below minimum threshold\n    exists(int keySizeValue | \n        keySizeValue = keySizeSpec.asExpr().(IntegerLiteral).getValue() and\n        keySizeValue < 16 and\n        warningMsg = \"Derived key size is too small. \"\n    )\n    or\n    // Case 2: Non-integer key size specification (statically unverifiable)\n    not exists(keySizeSpec.asExpr().(IntegerLiteral).getValue()) and\n    warningMsg = \"Derived key size is not a statically verifiable size. \"\n  )\nselect kdfOp, warningMsg + \"Derived key size must be a minimum of 16 (bytes). Derived Key Size Config: $@\",\n  keySizeSpec.asExpr(), keySizeSpec.asExpr().toString()",
    "output": "* @assumption When key length is unspecified (e.g., None or omitted),"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-hashes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects the use of deprecated or cryptographically weak hash functions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insecure cryptographic hash algorithms\n * @description Detects the use of deprecated or cryptographically weak hash functions\n *              in security-sensitive contexts, which may lead to vulnerabilities.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import necessary Python language support and cryptographic analysis framework\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify weak hash algorithm implementations and generate security alerts\nfrom HashAlgorithm hashImpl, string hashAlgo, string alertMsg\nwhere\n  // Extract the algorithm name from the hash implementation\n  hashAlgo = hashImpl.getHashName() and\n  // Filter out cryptographically secure hash algorithms\n  not hashAlgo = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // Determine the appropriate security alert message based on algorithm identification\n  (\n    // Handle identified but non-compliant algorithms\n    hashAlgo != \"\" and\n    alertMsg = \"Non-compliant hash algorithm detected: \" + hashAlgo + \". This algorithm is not approved for security-sensitive operations.\"\n  )\n  or\n  (\n    // Handle cases where the algorithm cannot be identified\n    hashAlgo = \"\" and\n    alertMsg = \"Unidentified hash algorithm detected. Unable to verify cryptographic strength of this implementation.\"\n  )\nselect hashImpl, alertMsg"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'exec' used\n * @description Detects usage of the 'exec' statement or function which may lead to arbitrary code execution.\n * @kind problem\n * @tags security\n *       correctness\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec */\n\n// Import Python module for code analysis\nimport python\n\n// Helper function to generate version-specific warning message for exec usage\nstring get_exec_warning_message() {\n  // Return message for Python 2 exec statement\n  major_version() = 2 and result = \"The 'exec' statement is used.\"\n  or\n  // Return message for Python 3 exec function\n  major_version() = 3 and result = \"The 'exec' function is used.\"\n}\n\n// Helper predicate to identify calls to the exec function\npredicate is_exec_function_call(Call execFuncCallNode) {\n  // Check if call references global variable named 'exec'\n  exists(GlobalVariable execGlobalVariable | \n    execGlobalVariable = execFuncCallNode.getFunc().(Name).getVariable() and \n    execGlobalVariable.getId() = \"exec\"\n  )\n_______________ // 补全条件\n\n// Identify all exec usage nodes (function calls or statements)\nfrom AstNode execUsageNode\nwhere \n  // Check for exec function calls\n  exists(Call funcCall | \n    is_exec_function_call(funcCall) and \n    funcCall = execUsageNode\n  )\n  or\n  // Check for exec statements\n  execUsageNode instanceof Exec\n// Return problematic node and corresponding warning message\nselect execUsageNode, get_exec_warning_message()",
    "output": "}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/classic-model/block-cipher-mode]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies cryptographic operations utilizing block cipher modes",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Block cipher mode of operation\n * @description Identifies cryptographic operations utilizing block cipher modes\n *              in supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/block-cipher-mode\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport semmle.python.Concepts\n\n// Locate cryptographic operations and extract their block cipher mode information\nfrom Cryptography::CryptographicOperation encryptionOp, string cipherMode\nwhere \n  // Obtain the block cipher mode name for each identified cryptographic operation\n  cipherMode = encryptionOp.getBlockMode()\nselect \n  encryptionOp, \n  \"Cryptographic operation uses block cipher mode: \" + cipherMode"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/elliptic-curve-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Discovers all elliptic curve cryptographic algorithm implementations throughout the codebase.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Elliptic Curve Cryptography Detection\n * @description Discovers all elliptic curve cryptographic algorithm implementations throughout the codebase.\n *              This query captures curve name and key size information to help assess quantum vulnerability.\n *              Given that elliptic curve cryptography is susceptible to quantum computing threats,\n *              this identification is crucial for cryptographic asset management and transition strategies.\n * @kind problem\n * @id py/quantum-readiness/cbom/elliptic-curve-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import necessary modules for Python language analysis\nimport python\n\n// Import experimental cryptography framework components\nimport experimental.cryptography.Concepts\n\n// Locate all elliptic curve cryptographic implementations\nfrom EllipticCurveAlgorithm ellipticCurveInstance\n\n// Extract curve details for each identified instance\nselect ellipticCurveInstance,\n  // Combine algorithm name and key size into a single report string\n  \"Algorithm: \" + ellipticCurveInstance.getCurveName() + \n  \" | Key Size (bits): \" + ellipticCurveInstance.getCurveBitSize().toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-deprecated-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies imports of Python modules that have been deprecated in specific versions.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Import of deprecated module\n * @description Identifies imports of Python modules that have been deprecated in specific versions.\n * @kind problem\n * @tags maintainability\n *       external/cwe/cwe-477\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/import-deprecated-module\n */\n\nimport python\n\n/**\n * Holds if a module was deprecated in a specific Python version,\n * and provides the recommended replacement module.\n *\n * @param moduleName The name of the deprecated module.\n * @param replacementModule The recommended replacement module or \"no replacement\".\n * @param major The major version number of Python where the module was deprecated.\n * @param minor The minor version number of Python where the module was deprecated.\n */\npredicate deprecated_module(string moduleName, string replacementModule, int major, int minor) {\n  // Modules deprecated in Python 1.x\n  (moduleName = \"posixfile\" and replacementModule = \"fcntl\" and major = 1 and minor = 5\n   or\n   moduleName = \"pre\" and replacementModule = \"re\" and major = 1 and minor = 5)\n  or\n  // Modules deprecated in Python 2.0-2.2\n  (moduleName = \"whrandom\" and replacementModule = \"random\" and major = 2 and minor = 1\n   or\n   moduleName = \"statcache\" and replacementModule = \"no replacement\" and major = 2 and minor = 2\n   or\n   moduleName = \"mpz\" and replacementModule = \"a third party\" and major = 2 and minor = 2)\n  or\n  // Modules deprecated in Python 2.3-2.4\n  (moduleName = \"rfc822\" and replacementModule = \"email\" and major = 2 and minor = 3\n   or\n   moduleName = \"mimetools\" and replacementModule = \"email\" and major = 2 and minor = 3\n   or\n   moduleName = \"MimeWriter\" and replacementModule = \"email\" and major = 2 and minor = 3\n   or\n   moduleName = \"mimify\" and replacementModule = \"email\" and major = 2 and minor = 3\n   or\n   moduleName = \"xreadlines\" and replacementModule = \"no replacement\" and major = 2 and minor = 3\n   or\n   moduleName = \"rotor\" and replacementModule = \"no replacement\" and major = 2 and minor = 4)\n  or\n  // Modules deprecated in Python 2.5-2.6\n  (moduleName = \"gopherlib\" and replacementModule = \"no replacement\" and major = 2 and minor = 5\n   or\n   moduleName = \"rgbimgmodule\" and replacementModule = \"no replacement\" and major = 2 and minor = 5\n   or\n   moduleName = \"multifile\" and replacementModule = \"email\" and major = 2 and minor = 5\n   or\n   moduleName = \"sets\" and replacementModule = \"builtins\" and major = 2 and minor = 6)\n  or\n  // Other deprecated modules\n  (moduleName = \"buildtools\" and replacementModule = \"no replacement\" and major = 2 and minor = 3\n   or\n   moduleName = \"cfmfile\" and replacementModule = \"no replacement\" and major = 2 and minor = 4\n   or\n   moduleName = \"macfs\" and replacementModule = \"no replacement\" and major = 2 and minor = 3\n   or\n   moduleName = \"md5\" and replacementModule = \"hashlib\" and major = 2 and minor = 5\n   or\n   moduleName = \"sha\" and replacementModule = \"hashlib\" and major = 2 and minor = 5)\n}\n\n/**\n * Gets a deprecation warning message for a module.\n *\n * @param modName The name of the deprecated module.\n * @return A string describing when the module was deprecated.\n */\nstring deprecation_message(string modName) {\n  exists(int majorVer, int minorVer | \n    deprecated_module(modName, _, majorVer, minorVer)\n  |\n    result = \"The \" + modName + \" module was deprecated in version \" + \n             majorVer.toString() + \".\" + minorVer.toString() + \".\"\n  )\n}\n\n/**\n * Gets a replacement suggestion message for a deprecated module.\n *\n * @param modName The name of the deprecated module.\n * @return A string with replacement suggestion or empty string if no replacement.\n */\nstring replacement_message(string modName) {\n  exists(string replMod | \n    deprecated_module(modName, replMod, _, _)\n  |\n    (result = \" Use \" + replMod + \" module instead.\" and replMod != \"no replacement\")\n    or\n    (result = \"\" and replMod = \"no replacement\")\n  )\n}\n\n// Main query: find imports of deprecated modules without proper exception handling.\nfrom ImportExpr importNode, string modName, string replMod\nwhere\n  modName = importNode.getName() and\n  deprecated_module(modName, replMod, _, _) and\n  // Exclude imports that are properly handled with ImportError exception handling.\n  not exists(Try tryBlock, ExceptStmt exceptHandler | \n    exceptHandler = tryBlock.getAHandler() and\n    exceptHandler.getType().pointsTo(ClassValue::importError()) and\n    exceptHandler.containsInScope(importNode)\n  )\nselect importNode, deprecation_message(modName) + replacement_message(modName)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a module imports itself, which is typically a sign of redundant or unnecessary code",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description Detects when a module imports itself, which is typically a sign of redundant or unnecessary code\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n// Helper predicate to identify modules that import themselves\npredicate isSelfImportingModule(ImportingStmt importDeclaration, ModuleValue importedModule) {\n  // Check if the importing module's scope matches the imported module's scope\n  importDeclaration.getEnclosingModule() = importedModule.getScope() and\n  // Find the actual module being imported, selecting the shortest matching name\n  importedModule =\n    max(string moduleName, ModuleValue resolvedModule |\n      moduleName = importDeclaration.getAnImportedModuleName() and\n      resolvedModule.importedAs(moduleName)\n    |\n      resolvedModule order by moduleName.length()\n    )\n}\n\n// Main query to find all instances of modules importing themselves\nfrom ImportingStmt importDeclaration, ModuleValue importedModule\nwhere isSelfImportingModule(importDeclaration, importedModule)\nselect importDeclaration, \"Module '\" + importedModule.getName() + \"' is importing itself.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using '\\b' to escape the backspace character in a regular expression is confusing",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Backspace escape in regular expression\n * @description Using '\\b' to escape the backspace character in a regular expression is confusing\n *              since it could be mistaken for a word boundary assertion.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regex, int offset\nwhere\n  // Check for escape character at current position\n  regex.escapingChar(offset) and\n  // Verify 'b' character immediately follows the escape\n  regex.getChar(offset + 1) = \"b\" and\n  // Confirm the escape sequence occurs within a character set context\n  exists(int charSetBegin, int charSetEnd |\n    charSetBegin < offset and charSetEnd > offset and\n    regex.charSet(charSetBegin, charSetEnd)\n  )\nselect regex, \"Backspace escape in regular expression at offset \" + offset + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Constant in conditional expression or statement\n * @description The conditional is always true or always false\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/constant-conditional-expression\n */\n\nimport python\n\n// 判断表达式是否在条件上下文中使用\npredicate usedAsCondition(Expr conditionalExpression) {\n  // 检查表达式是否作为if语句的测试条件\n  exists(If ifStatement | ifStatement.getTest() = conditionalExpression) or\n  // 检查表达式是否作为条件表达式的测试部分\n  exists(IfExp ifExp | ifExp.getTest() = conditionalExpression)\n}\n\n/* Consider specific unmodified built-in names as constants */\n// 识别未被修改的内置常量名称\npredicate effective_constant(Name nameIdentifier) {\n  // 查找未被重新定义的全局内置变量\n  exists(GlobalVariable globalVariable | \n    globalVariable = nameIdentifier.getVariable() and \n    not exists(NameNode definingNode | definingNode.defines(globalVariable)) |\n    globalVariable.getId() = \"True\" or \n    globalVariable.getId() = \"False\" or \n    globalVariable.getId() = \"NotImplemented\"\n  )\n}\n\n// 检测导致代码不可达的条件表达式\npredicate createsUnreachableCode(Expr conditionalExpression) {\n  // 检查if语句中导致分支不可达的条件\n  exists(If ifStatement | \n    ifStatement.getTest() = conditionalExpression and \n    (ifStatement.getStmt(0).isUnreachable() or \n     ifStatement.getOrelse(0).isUnreachable())\n  )\n  or\n  // 检查while循环中导致循环体不可达的条件\n  exists(While whileStatement | \n    whileStatement.getTest() = conditionalExpression and \n    whileStatement.getStmt(0).isUnreachable()\n  )\n}\n_______________ // 补全条件\n// 查找在条件上下文中使用的常量表达式\nfrom Expr conditionalExpression\nwhere\n  // 确保表达式在条件上下文中使用\n  usedAsCondition(conditionalExpression) and\n  // 检查表达式是否为常量或等效常量\n  (conditionalExpression.isConstant() or effective_constant(conditionalExpression)) and\n  /* Exclude conditions that make code unreachable (handled by separate query) */\n  // 排除导致不可达代码的情况（由其他查询处理）\n  not createsUnreachableCode(conditionalExpression)\n// 报告检测结果\nselect conditionalExpression, \"Testing a constant will always give the same result.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 检查指定类及其层次结构关系\n * 通过类名和文件路径定位目标类\n */\n\nimport python\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n\n// 判断类是否为目标类的谓词\npredicate isTargetClass(Class targetClass) {\n  // 匹配指定类名\n  targetClass.getName() = \"YourClassName\"\n_______________ // 补全条件\n  // and targetClass.getLocation().getFile().getAbsolutePath().matches(\"%/folder/file.py\")\n}\n\n// 查找目标类的直接父类\nquery predicate findDirectSuperClass(Class targetClass, Class superClass) {\n  isTargetClass(targetClass) and\n  superClass = getADirectSuperclass+(targetClass)\n}\n\n// 查找目标类的直接子类\nquery predicate findDirectSubClass(Class targetClass, Class subClass) {\n  isTargetClass(targetClass) and\n  subClass = getADirectSubclass+(targetClass)\n}\n\n// 输出所有匹配的目标类\nfrom Class targetClass\nwhere isTargetClass(targetClass)\nselect targetClass",
    "output": "// 可选：通过文件路径进一步限定"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：在旧式类中使用 super() 访问继承的方法是不被支持的。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description 在旧式类中使用 super() 访问继承的方法是不被支持的。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * 判断给定的 super() 调用是否发生在旧式类中。\n * 旧式类是指不继承自 object 的 Python 2.x 风格的类。\n * 在这样的类中使用 super() 会导致运行时错误。\n */\npredicate isSuperCallInOldStyleClass(Call superCall) {\n  exists(Function containerFunction, ClassObject containerClass |\n    // 验证调用发生在函数内部，且该函数定义在类中\n    superCall.getScope() = containerFunction and\n    containerFunction.getScope() = containerClass.getPyClass() and\n    \n    // 确保类信息能够被正确推断\n    not containerClass.failedInference() and\n    \n    // 检查类是否为旧式类（非新式类）\n    not containerClass.isNewStyle() and\n    \n    // 确认调用的是 super 函数\n    superCall.getFunc().(Name).getId() = \"super\"\n  )\n}\n\n// 查找所有在旧式类中使用的 super() 调用\nfrom Call problematicSuperCall\nwhere isSuperCallInOldStyleClass(problematicSuperCall)\n// 输出问题代码和错误信息\nselect problematicSuperCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commented-out-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Commented-out code makes the remaining code more difficult to read.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commented-out code\n * @description Commented-out code makes the remaining code more difficult to read.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code\n */\n\n// 导入Python语言库\nimport python\n\n// 导入Lexical模块中的CommentedOutCode类\nimport Lexical.CommentedOutCode\n\n// 从CommentedOutCodeBlock类中选择c对象\nfrom CommentedOutCodeBlock c\n// 过滤条件：c不是示例代码\nwhere not c.maybeExampleCode()\n// 选择符合条件的c对象，并附加注释信息\nselect c, \"This comment appears to contain commented-out code.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class Cohesion Deficiency (HM Method)\n * @description Evaluates the lack of cohesion within classes using Hitz and Montazeri's methodology.\n * @kind treemap\n * @id py/lack-of-cohesion-hitz-montazeri\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n */\n\nimport python  // Import Python module for code analysis capabilities\n\n// Query to analyze class cohesion metrics\n// Results are sorted in descending order of cohesion deficiency\nfrom ClassMetrics clsMetric\n\n// Select class and its cohesion metric\nselect \n    clsMetric, \n    clsMetric.getLackOfCohesionHM() as cohesionMetric \n\n_______________ // 补全条件\norder by \n    cohesionMetric desc",
    "output": "// Order by highest cohesion deficiency first"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent return patterns (explicit vs implicit)\n * @description Functions mixing explicit returns with implicit fallthrough returns\n *              create inconsistent return types since implicit returns always yield None.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mixed-returns\n */\n\nimport python\n\n/**\n * Identifies functions containing at least one explicit return statement\n * that returns a non-None value, indicating intentional data return behavior.\n */\npredicate hasExplicitNonNullReturn(Function func) {\n  // Verify existence of return statement within function scope\n  // where the returned value is not None\n  exists(Return retStmt |\n    retStmt.getScope() = func and\n    exists(Expr retVal | retVal = retStmt.getValue() | not retVal instanceof None)\n  )\n}\n\n/**\n * Detects functions with implicit return behavior through either:\n * 1. Reachable fallthrough control flow nodes\n * 2. Return statements without explicit values\n */\npredicate hasImplicitReturn(Function func) {\n  // Check for return statements lacking explicit values\n  exists(Return retStmt | \n    retStmt.getScope() = func and \n    not exists(retStmt.getValue())\n_______________ // 补全条件\n  // OR check for reachable fallthrough nodes\n  or\n  exists(ControlFlowNode fallNode |\n    fallNode = func.getFallthroughNode() and \n    not fallNode.unlikelyReachable()\n  )\n}\n\n// Core analysis: Locate functions exhibiting both explicit non-None returns\n// and implicit returns, creating inconsistent return type behavior\nfrom Function targetFunction\nwhere \n  hasExplicitNonNullReturn(targetFunction) and \n  hasImplicitReturn(targetFunction)\nselect targetFunction,\n  \"Mixing implicit and explicit returns may indicate an error as implicit returns always return None.\"",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name CORS Misconfiguration with Credentials\n * @description Disabling or weakening Same-Origin Policy (SOP) protection may expose\n *              the application to CORS attacks when credentials are allowed.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n// 检查来源配置是否包含通配符或空值\npredicate hasWildcardOrigin(DataFlow::Node originSetting) {\n  // 情况1：来源配置是列表且包含 \"*\" 或 \"null\" 元素\n  originSetting.asExpr() instanceof List and\n  exists(StringLiteral literal |\n    literal = originSetting.asExpr().getASubExpression() and\n    literal.getText() in [\"*\", \"null\"]\n  )\n  // 情况2：来源配置直接是 \"*\" 或 \"null\" 字符串\n  or\n  exists(StringLiteral literal |\n    literal = originSetting.asExpr() and\n    literal.getText() in [\"*\", \"null\"]\n_______________ // 补全条件\n}\n\n// 验证中间件是否为 CORS 类型\npredicate isCorsMiddlewareType(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n// 检查中间件是否启用了凭证支持\npredicate supportsCredentials(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getCredentialsAllowed().asExpr() instanceof True\n}\n\n// 查询存在安全风险的 CORS 中间件配置\nfrom Http::Server::CorsMiddleware corsMiddleware\nwhere\n  // 条件组合：确认中间件类型 + 启用凭证 + 使用通配符来源\n  isCorsMiddlewareType(corsMiddleware) and\n  supportsCredentials(corsMiddleware) and\n  hasWildcardOrigin(corsMiddleware.getOrigins().getALocalSource())\nselect corsMiddleware,\n  // 安全风险说明：允许任意来源的认证请求可能导致敏感数据泄露\n  \"This CORS middleware configuration allows authenticated cross-origin requests from any source, potentially exposing sensitive data\"",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Superclass attribute shadows subclass method\n * @description Detects when a subclass method is hidden by an attribute defined in its superclass.\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n_______________ // 补全条件\n *\n * Identifies cases where attributes defined in superclass initializers shadow methods\n * declared in subclasses. This occurs when a superclass __init__ method assigns an\n * attribute with the same name as a method in its subclass, effectively hiding the\n * subclass method. Excludes intentional overrides where the superclass also defines\n * a method with the same name.\n */\n\nimport python\n\n// Determines if a subclass method is shadowed by an attribute in its superclass\npredicate isMethodShadowedBySuperAttribute(\n  ClassObject subClass, ClassObject superClass, Assign attrAssignment, FunctionObject shadowedMethod\n) {\n  // Establish inheritance relationship between classes\n  subClass.getASuperType() = superClass and\n  // Verify the subclass declares the method being shadowed\n  subClass.declaredAttribute(_) = shadowedMethod and\n  // Find matching attribute assignment in superclass initializer\n  exists(FunctionObject superInit, Attribute assignedAttr |\n    // Superclass must define __init__ method\n    superClass.declaredAttribute(\"__init__\") = superInit and\n    // Attribute assignment targets the assigned attribute\n    assignedAttr = attrAssignment.getATarget() and\n    // Assignment is to 'self' instance\n    assignedAttr.getObject().(Name).getId() = \"self\" and\n    // Attribute name matches the shadowed method name\n    assignedAttr.getName() = shadowedMethod.getName() and\n    // Assignment occurs within superclass initializer scope\n    attrAssignment.getScope() = superInit.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  // Exclude cases where superclass intentionally defines同名 method\n  not superClass.hasAttribute(shadowedMethod.getName())\n}\n\nfrom ClassObject subClass, ClassObject superClass, Assign attrAssignment, FunctionObject shadowedMethod\nwhere isMethodShadowedBySuperAttribute(subClass, superClass, attrAssignment, shadowedMethod)\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superClass.getName() +\n    \"'.\", attrAssignment, \"attribute\"",
    "output": "* @id py/attribute-shadows-method"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insufficient KDF Salt Size\n * @description Key Derivation Function (KDF) salts must be at least 128 bits (16 bytes) in length.\n *\n * This rule identifies security vulnerabilities where the salt size used in key derivation\n * functions is less than the required 128 bits, or when the salt size cannot be statically\n * determined during code analysis. Insufficient salt size can weaken cryptographic security\n * by making the derived keys more susceptible to brute-force attacks.\n * @kind problem\n * @id py/kdf-small-salt-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// 检测密钥派生函数中盐值大小不足的安全漏洞\nfrom \n  KeyDerivationOperation keyDerivFunc,  // 密钥派生函数操作\n  DataFlow::Node saltSizeNode,         // 盐值大小参数节点\n  API::CallNode urandomFuncCall,       // os.urandom函数调用\n  string securityAlert                 // 安全警报消息\nwhere\n  // 基本条件：确保密钥派生操作需要盐值\n  keyDerivFunc.requiresSalt() and\n  \n  // 验证盐值来源：确认盐值配置是通过os.urandom函数生成的\n  urandomFuncCall = keyDerivFunc.getSaltConfigSrc() and\n  urandomFuncCall = API::moduleImport(\"os\").getMember(\"urandom\").getACall() and\n  \n  // 参数追踪：获取盐值大小参数的最终数据源\n_______________ // 补全条件\n  \n  // 安全评估：检查盐值大小是否满足最低要求或是否可静态确定\n  (\n    // 情况1：盐值大小无法静态验证（运行时动态确定）\n    not exists(saltSizeNode.asExpr().(IntegerLiteral).getValue()) and\n    securityAlert = \"Salt size cannot be statically verified. \"\n    or\n    // 情况2：盐值大小不足（低于16字节安全阈值）\n    saltSizeNode.asExpr().(IntegerLiteral).getValue() < 16 and\n    securityAlert = \"Salt size is below the minimum required. \"\n  )\nselect \n  keyDerivFunc,  // 选择存在安全问题的密钥派生操作\n  securityAlert + \"Salt size must be a minimum of 16 (bytes). os.urandom Config: $@, Size Config: $@\",  // 构建安全警报消息\n  urandomFuncCall, urandomFuncCall.toString(),  // 显示urandom调用及其字符串表示\n  saltSizeNode, saltSizeNode.toString()  // 显示盐值大小参数及其字符串表示",
    "output": "saltSizeNode = CryptoUtils::getUltimateSrcFromApiNode(urandomFuncCall.getParameter(0, \"size\")) and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python代码总行数统计\n * @description 计算数据库中所有Python文件的总代码行数，包括外部库和自动生成的文件。\n *   此指标用于评估代码库规模，仅统计实际代码行，不包含空白行和注释。\n * @kind metric\n_______________ // 补全条件\n *       telemetry\n * @id py/summary/lines-of-code\n */\n\nimport python // 导入Python分析模块，提供Python代码分析的核心功能\n\nfrom Module pyModule\nselect sum(pyModule.getMetrics().getNumberOfLinesOfCode())\n// 说明：\n// - `Module` 类表示一个Python代码模块\n// - 变量 `pyModule` 遍历所有Python模块实例\n// - `pyModule.getMetrics().getNumberOfLinesOfCode()` 获取模块的代码行数\n// - `sum(...)` 聚合函数计算所有模块代码行数的总和",
    "output": "* @tags summary"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Wrong name for an argument in a call\n * @description Identifies function/method calls using keyword arguments that don't match\n *              any parameter names of the called function. Such mismatches cause runtime TypeErrors.\n * @kind problem\n_______________ // 补全条件\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-argument\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Identify function calls with invalid keyword argument names\nfrom Call callNode, FunctionObject targetFunction, string invalidArgName\nwhere\n  // Check if the call uses an undefined keyword argument\n  illegally_named_parameter_objectapi(callNode, targetFunction, invalidArgName)\n  and \n  // Exclude abstract methods as their parameters may be defined in implementations\n  not targetFunction.isAbstract()\n  and \n  // Exclude cases where the argument exists in overridden parent methods\n  not exists(FunctionObject parentMethod |\n    targetFunction.overrides(parentMethod) and\n    parentMethod.getFunction().getAnArg().(Name).getId() = invalidArgName\n  )\n// Report the invalid call with contextual information\nselect callNode, \n  \"Keyword argument '\" + invalidArgName + \"' is not a supported parameter name of $@.\", \n  targetFunction, \n  targetFunction.descriptiveString()",
    "output": "* @tags reliability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Modification of dictionary returned by locals()\n * @description Detects attempts to modify the dictionary returned by locals() which do not affect the actual local variables.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/modification-of-locals\n */\n\nimport python\n\n// 判断控制流节点是否引用了 locals() 函数的调用结果\n_______________ // 补全条件\n    cfNode.pointsTo(_, _, Value::named(\"locals\").getACall()) \n}\n\n// 检查是否存在对 locals() 返回字典的字典操作（下标赋值或删除）\npredicate isDictionaryModification(ControlFlowNode modNode) {\n    exists(SubscriptNode subscriptNode |\n        subscriptNode = modNode and\n        referencesLocalsCall(subscriptNode.getObject()) and\n        (subscriptNode.isStore() or subscriptNode.isDelete())\n    )\n}\n\n// 检查是否存在对 locals() 返回字典的方法调用（会修改字典内容的方法）\npredicate isMethodCallModification(ControlFlowNode modNode) {\n    exists(CallNode callNode, AttrNode attributeNode, string methodName |\n        callNode = modNode and\n        attributeNode = callNode.getFunction() and\n        referencesLocalsCall(attributeNode.getObject(methodName)) and\n        methodName in [\"pop\", \"popitem\", \"update\", \"clear\"]\n    )\n}\n\n// 判断是否存在对 locals() 返回字典的任何修改操作\npredicate modifiesLocalsDictionary(ControlFlowNode modNode) {\n    isDictionaryModification(modNode) or\n    isMethodCallModification(modNode)\n}\n\nfrom AstNode astNode, ControlFlowNode modNode\nwhere\n    // 查找修改 locals() 返回字典的操作\n    modifiesLocalsDictionary(modNode) and\n    // 获取与控制流节点对应的 AST 节点\n    astNode = modNode.getNode() and\n    // 排除模块级别作用域，因为在模块级别 locals() 等同于 globals()\n    not astNode.getScope() instanceof ModuleScope\n// 输出结果并附带警告信息\nselect astNode, \"Modification of the locals() dictionary will have no effect on the local variables.\"",
    "output": "predicate referencesLocalsCall(ControlFlowNode cfNode) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable 'except' block\n * @description Handling general exceptions before specific exceptions means that the specific\n *              handlers are never executed.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n/**\n * 获取异常处理块对应的异常类型。\n * @param exceptStmt - 异常处理块\n * @return - 异常类型\n */\n_______________ // 补全条件\n  exceptStmt.getType().pointsTo(result) \n}\n\n/**\n * 判断两个异常处理块的顺序是否会导致后面的块不可达。\n * 当一个处理一般异常的块位于处理特定异常的块之前时，后面的块将永远不会被执行。\n * @param earlierExcept - 先执行的异常处理块\n * @param generalExceptClass - 先执行的异常处理块处理的异常类型\n * @param laterExcept - 后执行的异常处理块\n * @param specificExceptClass - 后执行的异常处理块处理的异常类型\n */\npredicate hasUnreachableExceptBlock(ExceptStmt earlierExcept, ClassValue generalExceptClass, \n                                   ExceptStmt laterExcept, ClassValue specificExceptClass) {\n  exists(int earlierIndex, int laterIndex, Try tryStmt |\n    // earlierExcept 是 tryStmt 的第 earlierIndex 个异常处理块\n    earlierExcept = tryStmt.getHandler(earlierIndex) and\n    // laterExcept 是 tryStmt 的第 laterIndex 个异常处理块\n    laterExcept = tryStmt.getHandler(laterIndex) and\n    // 确保 earlierExcept 在 laterExcept 之前\n    earlierIndex < laterIndex and\n    // 获取 earlierExcept 的异常类型\n    generalExceptClass = getExceptionClass(earlierExcept) and\n    // 获取 laterExcept 的异常类型\n    specificExceptClass = getExceptionClass(laterExcept) and\n    // 检查 generalExceptClass 是 specificExceptClass 的父类或接口\n    generalExceptClass = specificExceptClass.getASuperType()\n  )\n}\n\n// 从所有异常处理块中筛选出存在不可达情况的组合\nfrom ExceptStmt earlierExcept, ClassValue generalExceptClass, \n     ExceptStmt laterExcept, ClassValue specificExceptClass\n// 条件是这些数据满足 hasUnreachableExceptBlock 谓词\nwhere hasUnreachableExceptBlock(earlierExcept, generalExceptClass, laterExcept, specificExceptClass)\n// 选择 laterExcept 作为结果，并生成一条警告信息\nselect laterExcept,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  specificExceptClass, specificExceptClass.getName(), earlierExcept, \"except block\", \n  generalExceptClass, generalExceptClass.getName()",
    "output": "ClassValue getExceptionClass(ExceptStmt exceptStmt) {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/string-concatenation-in-loop]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects inefficient string concatenation inside loops that causes quadratic performance.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name String concatenation in loop\n * @description Detects inefficient string concatenation inside loops that causes quadratic performance.\n * @kind problem\n * @tags efficiency\n *       maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision low\n * @id py/string-concatenation-in-loop\n */\n\nimport python\n\n/**\n * Identifies string concatenation operations within loops.\n * This predicate matches binary expressions where:\n * - Operation is string addition (+)\n * - Occurs inside a loop construct\n * - Involves string variables that get repeatedly updated\n */\npredicate string_concat_in_loop(BinaryExpr concatExpr) {\n  // Step 1: Verify addition operation\n  concatExpr.getOp() instanceof Add and\n  // Step 2: Analyze variable relationships\n  exists(SsaVariable originalVar, SsaVariable updatedVar, BinaryExprNode exprNode |\n    // Link expression node to binary operation\n    exprNode.getNode() = concatExpr and \n    // Establish variable definition chain\n    originalVar = updatedVar.getAnUltimateDefinition() and\n    // Verify string variable definition\n    originalVar.getDefinition().(DefinitionNode).getValue() = exprNode and\n    // Confirm variable usage in concatenation\n    updatedVar.getAUse() = exprNode.getAnOperand() and\n    // Validate string type operand\n    exprNode.getAnOperand().pointsTo().getClass() = ClassValue::str()\n  )\n}\n\n// Detect problematic string concatenation in loops\nfrom BinaryExpr concatExpr, Stmt loopStmt\nwhere \n  // Match inefficient concatenation pattern\n  string_concat_in_loop(concatExpr) and\n  // Locate enclosing loop statement\n  loopStmt.getASubExpression() = concatExpr\n// Report with performance warning\nselect loopStmt, \"String concatenation in a loop is quadratic in the number of iterations.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies functions with uppercase-initial names that violate Python naming conventions.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed function\n * @description Identifies functions with uppercase-initial names that violate Python naming conventions.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python  // Import Python library for analyzing Python source code\n\n// Predicate to determine if a function name begins with an uppercase letter\npredicate hasUppercaseInitial(Function functionObj) {\n  exists(string firstChar |\n    firstChar = functionObj.getName().prefix(1) and  // Extract the initial character of function name\n    firstChar.toUpperCase() = firstChar  // Confirm the character is uppercase\n  )\n}\n\n// Query to locate functions that violate Python naming conventions\nfrom Function functionObj\nwhere\n  // Verify the function is defined in source code\n  functionObj.inSource() and\n  \n  // Check if function name starts with uppercase letter\n  hasUppercaseInitial(functionObj) and\n  \n  // Filter out functions that share the same file with other uppercase-named functions\n  // This reduces reporting noise by focusing on isolated violations\n  not exists(Function otherFunctionObj |\n    otherFunctionObj != functionObj and  // Ensure it's a different function\n    otherFunctionObj.getLocation().getFile() = functionObj.getLocation().getFile() and  // Same file location\n    hasUppercaseInitial(otherFunctionObj)  // Also violates naming convention\n  )\nselect functionObj, \"Function names should start in lowercase.\"  // Report violation with suggested fix"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/ineffectual-statement]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A statement has no effect",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Statement has no effect\n * @description A statement has no effect\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/ineffectual-statement\n */\n\nimport python\n\n// Determines if an attribute access is well-understood by analyzing its type information\npredicate is_understood_attribute(Attribute attrNode, ClassValue sourceCls, ClassValue attrCls) {\n  exists(string attrName | attrNode.getName() = attrName |\n    attrNode.getObject().pointsTo().getClass() = sourceCls and\n    sourceCls.attr(attrName).getClass() = attrCls\n  )\n}\n\n/* Conservative check for side effects in attribute access */\npredicate is_side_effecting_attribute(Attribute attrNode) {\n  exists(ClassValue attrCls |\n    is_understood_attribute(attrNode, _, attrCls) and\n    is_side_effecting_descriptor_type(attrCls)\n  )\n}\n\n// Identifies attributes that may have side effects\npredicate is_maybe_side_effecting_attribute(Attribute attrNode) {\n  not is_understood_attribute(attrNode, _, _) and not attrNode.pointsTo(_)\n  or\n  is_side_effecting_attribute(attrNode)\n}\n\n// Determines if a descriptor type has side effects\npredicate is_side_effecting_descriptor_type(ClassValue descriptorCls) {\n  descriptorCls.isDescriptorType() and\n  // While all descriptor accesses technically have side effects, \n  // some represent missing calls and should be treated as effectless\n  not descriptorCls = ClassValue::functionType() and\n  not descriptorCls = ClassValue::staticmethod() and\n  not descriptorCls = ClassValue::classmethod()\n}\n\n// Helper to get special method names for operators\nprivate string get_special_method_name() {\n  result = any(Cmpop c).getSpecialMethodName()\n  or\n  result = any(BinaryExpr b).getOp().getSpecialMethodName()\n}\n\npragma[nomagic]\nprivate predicate is_binary_operator_special_method(\n  BinaryExpr binaryExpr, Expr subExpr, ClassValue sourceCls, string methodName\n) {\n  methodName = get_special_method_name() and\n  subExpr = binaryExpr.getLeft() and\n  methodName = binaryExpr.getOp().getSpecialMethodName() and\n  subExpr.pointsTo().getClass() = sourceCls\n}\n\npragma[nomagic]\nprivate predicate is_comparison_special_method(Compare comparisonExpr, Expr subExpr, ClassValue sourceCls, string methodName) {\n  exists(Cmpop op |\n    comparisonExpr.compares(subExpr, op, _) and\n    methodName = op.getSpecialMethodName()\n  ) and\n  subExpr.pointsTo().getClass() = sourceCls\n}\n\n/**\n * Binary operators rarely have side effects, so we assume they don't\n * unless we have evidence to the contrary\n */\npredicate is_side_effecting_binary(Expr binaryExpr) {\n  exists(Expr subExpr, ClassValue sourceCls, string methodName |\n    is_binary_operator_special_method(binaryExpr, subExpr, sourceCls, methodName)\n    or\n    is_comparison_special_method(binaryExpr, subExpr, sourceCls, methodName)\n  |\n    methodName = get_special_method_name() and\n    sourceCls.hasAttribute(methodName) and\n    not exists(ClassValue declaring |\n      declaring.declaresAttribute(methodName) and\n      declaring = sourceCls.getASuperType() and\n      declaring.isBuiltin() and\n      not declaring = ClassValue::object()\n    )\n  )\n}\n\n// Checks if a file is a Jupyter/IPython notebook\npredicate is_notebook_file(File file) {\n  exists(Comment comment | comment.getLocation().getFile() = file |\n    comment.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\n/** Identifies expressions within Jupyter/IPython notebooks */\npredicate is_in_notebook(Expr expression) { \n  is_notebook_file(expression.getScope().(Module).getFile()) \n}\n\n// Retrieves the unittest.TestCase.assertRaises method\nFunctionValue get_unittest_assert_raises() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\n/** Checks if an expression is within a test for exception raising */\npredicate is_in_raises_test(Expr expression) {\n  exists(With withStmt |\n    withStmt.contains(expression) and\n    withStmt.getContextExpr() = get_unittest_assert_raises().getACall().getNode()\n  )\n}\n\n/** Identifies Python 2 print statements with redirection */\npredicate is_python2_print(Expr expression) {\n  expression.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n  expression.(BinaryExpr).getOp() instanceof RShift\n  or\n  is_python2_print(expression.(Tuple).getElt(0))\n}\n\n// Determines if an expression has no effect\npredicate is_no_effect_expression(Expr expression) {\n  // Strings can serve as documentation\n  (not expression instanceof StringLiteral and not expression.hasSideEffects()) and\n  // Verify all sub-expressions are side-effect free\n  forall(Expr subExpr | subExpr = expression.getASubExpression*() |\n    (not is_side_effecting_binary(subExpr) and not is_maybe_side_effecting_attribute(subExpr))\n  ) and\n  // Exclude special contexts where effectless expressions are allowed\n  (not is_in_notebook(expression) and not is_in_raises_test(expression) and not is_python2_print(expression))\n}\n\n// Select expression statements with no effect and report issues\nfrom ExprStmt statement\nwhere is_no_effect_expression(statement.getValue())\nselect statement, \"This statement has no effect.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Symmetric Encryption Padding Schemes Detection\n * @description Detects symmetric encryption algorithms that employ padding schemes,\n_______________ // 补全条件\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricPadding symmetricEncWithPadding\nselect symmetricEncWithPadding, \"Identified symmetric encryption with padding: \" + symmetricEncWithPadding.getPaddingName()",
    "output": "*              which could be susceptible to specific cryptographic attacks."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name points-to fails for expression.\n * @description Identifies Python expressions that do not point-to any object,\n *              which can prevent proper type inference and static analysis.\n * @kind problem\n * @id py/points-to-failure\n_______________ // 补全条件\n * @tags debug\n * @deprecated\n */\n\n// Import Python module for CodeQL analysis\nimport python\n\n// Find expressions that fail to point-to any object in the codebase\nfrom Expr problematicExpr\nwhere \n    // Check if there's a control flow node associated with this expression\n    exists(ControlFlowNode flowNode | \n        flowNode = problematicExpr.getAFlowNode()\n        // Verify that this flow node doesn't reference any object\n        and not flowNode.refersTo(_)\n    )\n// Report the problematic expression with an informative message\nselect problematicExpr, \"Expression does not 'point-to' any object.\"",
    "output": "* @problem.severity info"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/file-classifier]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and categorizes source files by detecting",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Source File Type Identification\n * @description Identifies and categorizes source files by detecting\n *              auto-generated code and test files using path patterns\n *              and contextual analysis. This classification enables\n *              targeted security assessments by differentiating between\n *              various file types in the codebase.\n * @kind file-classifier\n * @id py/file-classifier\n */\n\n// Import core Python analysis module\nimport python\n// Import module for detecting auto-generated source files\nimport semmle.python.filters.GeneratedCode\n// Import module for identifying test-related files and directories\nimport semmle.python.filters.Tests\n\n// Query that identifies and categorizes files based on their properties\nfrom File sourceFile, string classification\nwhere \n  // First condition: Identify auto-generated files\n  sourceFile instanceof GeneratedFile and classification = \"generated\"\n  // Second condition: Identify test files\n  or\n  (\n    exists(TestScope testContext | \n      testContext.getLocation().getFile() = sourceFile\n    ) \n    and classification = \"test\"\n  )\nselect sourceFile, classification"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-randomness]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies security-sensitive operations that rely on cryptographically weak",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insecure randomness\n * @description Identifies security-sensitive operations that rely on cryptographically weak \n *              pseudo-random number generators, enabling attackers to predict generated \n *              values and compromise system security.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// Core Python analysis infrastructure\nimport python\n\n// Security analysis module specialized for detecting weak random number generation\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Data flow tracking and propagation utilities\nimport semmle.python.dataflow.new.DataFlow\n\n// Visualization framework for data flow paths\nimport InsecureRandomness::Flow::PathGraph\n\n// Query to detect and report insecure random value flows\nfrom \n  InsecureRandomness::Flow::PathNode insecureRandomOrigin,  // Starting point of insecure random value\n  InsecureRandomness::Flow::PathNode sensitiveUsagePoint     // Security-critical destination of the value\nwhere \n  // Verify data flow connection between insecure random source and sensitive sink\n  InsecureRandomness::Flow::flowPath(insecureRandomOrigin, sensitiveUsagePoint)\nselect \n  // Location where insecure value is used (primary result)\n  sensitiveUsagePoint.getNode(),\n  // Path visualization: source node\n  insecureRandomOrigin,\n  // Path visualization: sink node\n  sensitiveUsagePoint,\n  // Security alert message with reference to vulnerable element\n  \"Cryptographically insecure $@ used in security context.\",\n  // Reference node for alert context\n  insecureRandomOrigin.getNode(),\n  // Description of the security issue\n  \"random value generation\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unguarded next in generator\n * @description Detects generator functions where next() is called without proper exhaustion checks.\n * @kind problem\n * @tags maintainability\n *       portability\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unguarded-next-in-generator\n */\n\nimport python\nprivate import semmle.python.ApiGraphs\n\n// API nodes for built-in functions and exceptions\nAPI::Node iterBuiltin() { result = API::builtin(\"iter\") }\nAPI::Node nextBuiltin() { result = API::builtin(\"next\") }\nAPI::Node stopIterationBuiltin() { result = API::builtin(\"StopIteration\") }\n\n// Identifies iter() calls with specific sequence source\npredicate iterCallWithSequenceSource(CallNode iterCall, EssaVariable originalSequence) {\n  iterCall = iterBuiltin().getACall().asCfgNode() and\n  iterCall.getArg(0) = originalSequence.getAUse()\n}\n\n// Identifies next() calls targeting specific iterator\npredicate nextCallOnIteratorVar(CallNode nextCallNode, ControlFlowNode iteratorVar) {\n  nextCallNode = nextBuiltin().getACall().asCfgNode() and\n  nextCallNode.getArg(0) = iteratorVar\n}\n\n// Checks if next() call includes default value parameter\npredicate nextCallWithDefault(CallNode nextCallNode) {\n  exists(nextCallNode.getArg(1)) or exists(nextCallNode.getArgByName(\"default\"))\n}\n\n// Determines if sequence has emptiness protection\npredicate sequenceIsGuarded(EssaVariable seqVar) {\n  seqVar.getDefinition() instanceof EssaEdgeRefinement\n}\n\n/**\n * Holds when iterator is verified non-exhausted.\n * \n * Detects patterns like next(iter(x)) where x is confirmed non-empty.\n */\npredicate iteratorIsNonExhausted(EssaVariable iterVar) {\n  exists(EssaVariable originalSequence |\n    iterCallWithSequenceSource(iterVar.getDefinition().(AssignmentDefinition).getValue(), originalSequence) and\n    sequenceIsGuarded(originalSequence)\n  )\n}\n\n// Verifies StopIteration exception handling in current scope\npredicate stopIterationIsHandled(CallNode nextCallNode) {\n  exists(Try tryStmt |\n_______________ // 补全条件\n    tryStmt.getAHandler().getType() = stopIterationBuiltin().getAValueReachableFromSource().asExpr()\n  )\n}\n\n// Main query detecting unguarded next() calls in generators\nfrom CallNode nextCall\nwhere\n  // Validate next() function call\n  nextCallOnIteratorVar(nextCall, _) and\n  // Ensure no default value protection\n  not nextCallWithDefault(nextCall) and\n  // Confirm iterator might be exhausted\n  not exists(EssaVariable iterVar |\n    nextCallOnIteratorVar(nextCall, iterVar.getAUse()) and\n    iteratorIsNonExhausted(iterVar)\n  ) and\n  // Restrict to generator functions\n  nextCall.getNode().getScope().(Function).isGenerator() and\n  // Exclude comprehensions\n  not exists(Comp comprehension | comprehension.contains(nextCall.getNode())) and\n  // Verify no StopIteration handling\n  not stopIterationIsHandled(nextCall) and\n  // PEP 479 resolved this issue in Python 3.7+\n  // Flag only for Python 2 (minor version not detectable)\n  major_version() = 2\nselect nextCall, \"Call to 'next()' in a generator.\"",
    "output": "tryStmt.containsInScope(nextCallNode.getNode()) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-permissive-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly permissive file permissions\n * @description Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.\n * @kind problem\n * @id py/overly-permissive-file\n * @problem.severity warning\n * @security-severity 7.8\n * @sub-severity high\n * @precision medium\n * @tags external/cwe/cwe-732\n *       security\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Helper function to extract world-readable/writable permission bits\nbindingset[permissionValue]\nint get_world_permission(int permissionValue) { \n  result = permissionValue % 8 \n}\n\n// Helper function to extract group-readable/writable permission bits\nbindingset[permissionValue]\nint get_group_permission(int permissionValue) { \n  result = (permissionValue / 8) % 8 \n}\n\n// Helper function to convert permission bits to descriptive string\nbindingset[permissionValue]\nstring get_permission_description(int permissionValue) {\n  permissionValue % 4 >= 2 and result = \"writable\"  // Writable if last two bits >= 2\n  or\n  permissionValue % 4 < 2 and permissionValue != 0 and result = \"readable\"  // Readable if non-zero but < 2\n}\n\n// Helper function to identify overly permissive permission configurations\nbindingset[permissionValue]\nstring get_permissive_permission_type(int permissionValue) {\n  result = \"world \" + get_permission_description(get_world_permission(permissionValue))  // Check world permissions first\n  or\n  get_world_permission(permissionValue) = 0 and result = \"group \" + get_permission_description(get_group_permission(permissionValue))  // Fall back to group if world is 0\n}\n\n// Predicate to identify os.chmod calls with explicit permission modes\npredicate is_chmod_call(API::CallNode callNode, string functionName, int permissionMode) {\n  callNode = API::moduleImport(\"os\").getMember(\"chmod\").getACall() and\n  permissionMode = callNode.getParameter(1, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue() and\n  functionName = \"chmod\"\n}\n\n// Predicate to identify os.open calls with explicit permission modes\npredicate is_open_call(API::CallNode callNode, string functionName, int permissionMode) {\n  callNode = API::moduleImport(\"os\").getMember(\"open\").getACall() and\n  permissionMode = callNode.getParameter(2, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue() and\n  functionName = \"open\"\n}\n\n// Main query: Identify file permission operations with overly permissive settings\nfrom API::CallNode callNode, string functionName, int permissionMode, string permissionDescription\nwhere\n  (is_chmod_call(callNode, functionName, permissionMode) or is_open_call(callNode, functionName, permissionMode)) and\n  permissionDescription = get_permissive_permission_type(permissionMode)\nselect callNode, \"Overly permissive mask in \" + functionName + \" sets file to \" + permissionDescription + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/key-exchange]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects all key exchange algorithm implementations in supported cryptographic libraries.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Key Exchange Algorithms\n * @description Detects all key exchange algorithm implementations in supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/key-exchange\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import the Python analysis framework\nimport python\n\n// Import the experimental cryptographic concepts module\nimport experimental.cryptography.Concepts\n\n// Data source: key exchange algorithm implementations\nfrom KeyExchangeAlgorithm algorithm\n\n// Output: algorithm identification and alert message\nselect algorithm, \"Use of algorithm \" + algorithm.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unreachable-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers that are unreachable due to handler ordering,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unreachable 'except' block\n * @description Identifies exception handlers that are unreachable due to handler ordering,\n *              where a broader exception handler earlier in the try-except block\n *              intercepts all exceptions before narrower handlers can execute.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Extracts the exception class handled by an except clause\nClassValue extractHandledExceptionType(ExceptStmt handler) { \n  handler.getType().pointsTo(result) \n}\n\n// Determines if an exception handler is unreachable due to preceding broader handler\npredicate isHandlerUnreachable(ExceptStmt precedingHandler, ClassValue generalException, \n                              ExceptStmt subsequentHandler, ClassValue specificException) {\n  exists(int precedingIdx, int subsequentIdx, Try tryBlock |\n    // Both handlers belong to the same try statement\n    precedingHandler = tryBlock.getHandler(precedingIdx) and\n    subsequentHandler = tryBlock.getHandler(subsequentIdx) and\n    // Preceding handler appears before subsequent handler in source\n    precedingIdx < subsequentIdx and\n    // Extract exception types for both handlers\n    generalException = extractHandledExceptionType(precedingHandler) and\n    specificException = extractHandledExceptionType(subsequentHandler) and\n    // Preceding handler catches a superclass of subsequent handler's exception\n    generalException = specificException.getASuperType()\n  )\n}\n\n// Identifies all unreachable exception handlers\nfrom ExceptStmt precedingHandler, ClassValue generalException, \n     ExceptStmt subsequentHandler, ClassValue specificException\nwhere isHandlerUnreachable(precedingHandler, generalException, subsequentHandler, specificException)\nselect subsequentHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  specificException, specificException.getName(), precedingHandler, \"except block\", generalException, generalException.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unreachable-statement]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code that can never be executed",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unreachable code\n * @description Identifies code that can never be executed\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-statement\n */\n\nimport python\n\n// Determines if an import statement is used solely for type hints\npredicate is_typing_import(ImportingStmt importDecl) {\n  exists(Module mod |\n    importDecl.getScope() = mod and // Check if import is at module level\n    exists(TypeHintComment typeHint | typeHint.getLocation().getFile() = mod.getFile()) // Verify type hints exist in module\n  )\n}\n\n// Checks if a statement contains the only yield expression in its function scope\npredicate has_unique_yield(Stmt targetStmt) {\n  exists(Yield yieldExpr | targetStmt.contains(yieldExpr)) and // Statement contains a yield\n  exists(Function enclosingFunc |\n    enclosingFunc = targetStmt.getScope() and // Get containing function\n    strictcount(Yield y | enclosingFunc.containsInScope(y)) = 1 // Function has exactly one yield\n  )\n}\n\n// Detects if contextlib.suppress is used in the same scope as the statement\npredicate has_suppression_in_scope(Stmt targetStmt) {\n  exists(With withBlock |\n    withBlock.getContextExpr().(Call).getFunc().pointsTo(Value::named(\"contextlib.suppress\")) and // Context manager is suppress\n    withBlock.getScope() = targetStmt.getScope() // Same scope as target statement\n  )\n}\n\n// Identifies statements that mark impossible else branches (always-raising)\npredicate is_impossible_else_branch(Stmt targetStmt) {\n  exists(If ifBlock | ifBlock.getOrelse().getItem(0) = targetStmt |\n    targetStmt.(Assert).getTest() instanceof False // Always-false assertion\n    or\n    targetStmt instanceof Raise // Always-raising exception\n  )\n}\n\n// Determines if a statement qualifies as reportable unreachable code\npredicate is_reportable_unreachable(Stmt targetStmt) {\n  targetStmt.isUnreachable() and // Statement is fundamentally unreachable\n  not is_typing_import(targetStmt) and // Exclude type-hint imports\n  not has_suppression_in_scope(targetStmt) and // Exclude suppressed contexts\n  not exists(Stmt otherUnreachable | otherUnreachable.isUnreachable() |\n    otherUnreachable.contains(targetStmt) // Exclude nested unreachable statements\n    or\n    exists(StmtList containerList, int earlierIdx, int laterIdx | \n      containerList.getItem(earlierIdx) = otherUnreachable and \n      containerList.getItem(laterIdx) = targetStmt and \n      earlierIdx < laterIdx // Exclude statements following other unreachable code\n    )\n  ) and\n  not has_unique_yield(targetStmt) and // Exclude generator functions with single yield\n  not is_impossible_else_branch(targetStmt) // Exclude intentional impossible branches\n}\n\n// Main query: Find and report unreachable code\nfrom Stmt targetStmt\nwhere is_reportable_unreachable(targetStmt)\nselect targetStmt, \"This statement is unreachable.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/property-in-old-style-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects property descriptors used in old-style classes, which are not supported from Python 2.1 onward.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Property in old-style class\n * @description Detects property descriptors used in old-style classes, which are not supported from Python 2.1 onward.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/property-in-old-style-class\n */\n\nimport python\n\n// Identify property objects defined within old-style classes\nfrom PropertyObject propertyObj, ClassObject targetClass\n// Check conditions where:\n// 1. The class declares the property\n// 2. The class inference is successful\n// 3. The class is an old-style class (not new-style)\nwhere \n  targetClass.declaredAttribute(_) = propertyObj and\n  not targetClass.failedInference() and\n  not targetClass.isNewStyle()\n// Select the property object and generate appropriate warning message\nselect propertyObj,\n  \"Property \" + propertyObj.getName() + \" will not work properly, as class \" + targetClass.getName() +\n    \" is an old-style class.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cyclomatic-complexity-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the cyclomatic complexity of Python functions by calculating the number of",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Function cyclomatic complexity analysis\n * @description Measures the cyclomatic complexity of Python functions by calculating the number of\n *              independent paths through source code. Higher values indicate more branching logic,\n *              requiring increased testing effort and potentially reducing maintainability.\n * @kind treemap\n * @id py/cyclomatic-complexity-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max sum\n * @tags testability\n *       complexity\n *       maintainability\n */\n\nimport python\n\n// Identify all Python functions and compute their cyclomatic complexity metrics\nfrom Function analyzedFunction, int complexityScore\n// Calculate complexity score for each function using its metrics\nwhere complexityScore = analyzedFunction.getMetrics().getCyclomaticComplexity()\n// Output results showing functions with corresponding complexity scores, sorted by highest complexity first\nselect analyzedFunction, complexityScore order by complexityScore desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type metrics\n * @description Analyzes and quantifies different categories of type annotations in Python code,\n *              including parameter annotations, return types, and annotated assignments.\n *              This query provides metrics on built-in types, forward declarations,\n *              simple types, complex types, and optional types.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents Python built-in types (e.g., int, str, bool)\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TypeAnnotatableElement =\n  TTypeAnnotatableFunctionElement(FunctionExpr func) { exists(func.getReturns()) } or\n  TTypeAnnotatableParameterElement(Parameter param) { exists(param.getAnnotation()) } or\n  TTypeAnnotatableAssignmentElement(AnnAssign assign) { exists(assign.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class TypeAnnotationElement extends TypeAnnotatableElement {\n  string toString() { result = \"TypeAnnotationElement\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass FunctionTypeAnnotationElement extends TTypeAnnotatableFunctionElement, TypeAnnotationElement {\n  FunctionExpr functionExpr;\n\n  FunctionTypeAnnotationElement() { this = TTypeAnnotatableFunctionElement(functionExpr) }\n  override Expr getAnnotation() { result = functionExpr.getReturns() }\n}\n\n// Parameters with type annotations\nclass ParameterTypeAnnotationElement extends TTypeAnnotatableParameterElement, TypeAnnotationElement {\n  Parameter parameter;\n\n  ParameterTypeAnnotationElement() { this = TTypeAnnotatableParameterElement(parameter) }\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AssignmentTypeAnnotationElement extends TTypeAnnotatableAssignmentElement, TypeAnnotationElement {\n  AnnAssign assignment;\n\n  AssignmentTypeAnnotationElement() { this = TTypeAnnotatableAssignmentElement(assignment) }\n  override Expr getAnnotation() { result = assignment.getAnnotation() }\n}\n\n/** Holds if `annotationExpr` is a forward-declared type (string literal). */\npredicate is_forward_declaration(Expr annotationExpr) { annotationExpr instanceof StringLiteral }\n\n/** Holds if `annotationExpr` is a complex type that may be difficult to analyze. */\npredicate is_complex_type(Expr annotationExpr) {\n  (annotationExpr instanceof Subscript and not is_optional_type(annotationExpr)) or\n  annotationExpr instanceof Tuple or\n  annotationExpr instanceof List\n}\n\n/** Holds if `annotationExpr` is an Optional type (e.g., Optional[...]). */\npredicate is_optional_type(Subscript annotationExpr) { annotationExpr.getObject().(Name).getId() = \"Optional\" }\n\n/** Holds if `annotationExpr` is a simple type (non-built-in identifier or attribute chain). */\npredicate is_simple_type(Expr annotationExpr) {\n  (annotationExpr instanceof Name and not annotationExpr instanceof BuiltinType) or\n  is_simple_type(annotationExpr.(Attribute).getObject())\n}\n\n/** Holds if `annotationExpr` is a built-in type. */\npredicate is_builtin_type(Expr annotationExpr) { annotationExpr instanceof BuiltinType }\n\n// Computes metrics for parameter type annotations\npredicate parameter_annotation_metrics(\n  int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  totalCount = count(ParameterTypeAnnotationElement annotatedParam) and\n  builtinCount = count(ParameterTypeAnnotationElement annotatedParam | is_builtin_type(annotatedParam.getAnnotation())) and\n  forwardDeclCount = count(ParameterTypeAnnotationElement annotatedParam | is_forward_declaration(annotatedParam.getAnnotation())) and\n  simpleTypeCount = count(ParameterTypeAnnotationElement annotatedParam | is_simple_type(annotatedParam.getAnnotation())) and\n  complexTypeCount = count(ParameterTypeAnnotationElement annotatedParam | is_complex_type(annotatedParam.getAnnotation())) and\n  optionalTypeCount = count(ParameterTypeAnnotationElement annotatedParam | is_optional_type(annotatedParam.getAnnotation()))\n}\n\n// Computes metrics for return type annotations\npredicate return_type_annotation_metrics(\n  int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  totalCount = count(FunctionTypeAnnotationElement annotatedFunc) and\n  builtinCount = count(FunctionTypeAnnotationElement annotatedFunc | is_builtin_type(annotatedFunc.getAnnotation())) and\n  forwardDeclCount = count(FunctionTypeAnnotationElement annotatedFunc | is_forward_declaration(annotatedFunc.getAnnotation())) and\n  simpleTypeCount = count(FunctionTypeAnnotationElement annotatedFunc | is_simple_type(annotatedFunc.getAnnotation())) and\n  complexTypeCount = count(FunctionTypeAnnotationElement annotatedFunc | is_complex_type(annotatedFunc.getAnnotation())) and\n  optionalTypeCount = count(FunctionTypeAnnotationElement annotatedFunc | is_optional_type(annotatedFunc.getAnnotation()))\n}\n\n// Computes metrics for annotated assignments\npredicate assignment_annotation_metrics(\n  int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  totalCount = count(AssignmentTypeAnnotationElement annotatedAssign) and\n  builtinCount = count(AssignmentTypeAnnotationElement annotatedAssign | is_builtin_type(annotatedAssign.getAnnotation())) and\n  forwardDeclCount = count(AssignmentTypeAnnotationElement annotatedAssign | is_forward_declaration(annotatedAssign.getAnnotation())) and\n  simpleTypeCount = count(AssignmentTypeAnnotationElement annotatedAssign | is_simple_type(annotatedAssign.getAnnotation())) and\n  complexTypeCount = count(AssignmentTypeAnnotationElement annotatedAssign | is_complex_type(annotatedAssign.getAnnotation())) and\n  optionalTypeCount = count(AssignmentTypeAnnotationElement annotatedAssign | is_optional_type(annotatedAssign.getAnnotation()))\n}\n\n// Combines metrics for all categories of type annotations\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n_______________ // 补全条件\n    category = \"Parameter annotation\" and\n    parameter_annotation_metrics(totalCount, builtinCount, forwardDeclCount, \n                              simpleTypeCount, complexTypeCount, optionalTypeCount)\n  )\n  or\n  // Return type annotation metrics\n  (\n    category = \"Return type annotation\" and\n    return_type_annotation_metrics(totalCount, builtinCount, forwardDeclCount, \n                              simpleTypeCount, complexTypeCount, optionalTypeCount)\n  )\n  or\n  // Annotated assignment metrics\n  (\n    category = \"Annotated assignment\" and\n    assignment_annotation_metrics(totalCount, builtinCount, forwardDeclCount, \n                               simpleTypeCount, complexTypeCount, optionalTypeCount)\n  )\n}\n\n// Query execution and results output\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                       simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount",
    "output": "("
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 未知密钥生成密钥大小\n * @description 检测非对称密钥生成操作中使用了无法静态验证的密钥大小的情况\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n_______________ // 补全条件\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找非对称密钥生成操作，其中密钥大小无法静态验证\nfrom AsymmetricKeyGen keyGen, DataFlow::Node configSrc, string algoName\nwhere\n  // 确保密钥生成操作没有静态验证的密钥大小\n  not keyGen.hasKeySize(configSrc) and\n  // 获取密钥配置源和算法名称\n  configSrc = keyGen.getKeyConfigSrc() and\n  algoName = keyGen.getAlgorithm().getName()\nselect keyGen,\n  // 报告问题，指出算法和配置源信息\n  \"用于算法 \" + algoName.toString() + \" 的密钥生成使用了无法静态验证的密钥大小，在配置源 $@\", configSrc, configSrc.toString()",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Encoding error\n * @description Identifies Python encoding violations that may lead to runtime failures\n *              and impede static analysis effectiveness.\n * @kind problem\n * @id py/encoding-error\n * @tags reliability\n *       correctness\n * @problem.severity error\n_______________ // 补全条件\n * @precision high\n */\n\nimport python\n\n// Identify all encoding violations in the codebase\nfrom EncodingError encodingViolation\n\n// Retrieve each violation's diagnostic message and present it alongside the violation instance\nselect encodingViolation, encodingViolation.getMessage()",
    "output": "* @sub-severity low"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Hardcoded SECRET_KEY in Web Applications\n * @description Detects static assignment of SECRET_KEY in Flask/Django apps,\n *              which may enable authentication bypass attacks\n * @kind path-problem\n * @id py/webapp-hardcoded-secret\n * @problem.severity error\n * @security-severity 8.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.filters.Tests\n\n// Framework types for web application classification\nnewtype WebFrameworkType =\n  FlaskFramework() or\n  DjangoFramework()\n\n_______________ // 补全条件\nprivate module SecretKeyTaintConfig implements DataFlow::StateConfigSig {\n  // State representation for web frameworks\n  class FlowState = WebFrameworkType;\n\n  // Identifies hardcoded string sources as potential secrets\n  predicate isSource(DataFlow::Node sourceNode, FlowState framework) {\n    exists(string secretLiteral |\n      secretLiteral = sourceNode.asExpr().(StringLiteral).getText() and\n      secretLiteral.length() > 0 and\n      // Exclude common placeholder values\n      not secretLiteral.matches([\"\", \"changeme\", \"secret\", \"password\", \"default\"]) and\n      (framework = FlaskFramework() or framework = DjangoFramework())\n    )\n  }\n\n  // Identifies secret key assignment targets\n  predicate isSink(DataFlow::Node sinkNode, FlowState framework) {\n    exists(DataFlow::Node secretKeyAttr |\n      secretKeyAttr.asExpr().(Attribute).getName() = \"SECRET_KEY\" and\n      sinkNode.asExpr() = secretKeyAttr.asExpr().(Attribute).getObject() and\n      (framework = FlaskFramework() or framework = DjangoFramework())\n    )\n  }\n\n  // Defines sanitization barriers for taint analysis\n  predicate isBarrier(DataFlow::Node node) {\n    // Exclude standard library components\n    node.getLocation().getFile().inStdlib()\n    or\n    // Exclude test/demo files except specific test cases\n    exists(string relativePath |\n      relativePath = node.getLocation().getFile().getRelativePath() and\n      relativePath.matches([\"%test%\", \"%demo%\", \"%example%\", \"%sample%\"]) and\n      not relativePath.matches(\"%query-tests/Security/CWE-287%\")\n    )\n    or\n    // Filter obvious non-secret values\n    exists(string nonSecretLiteral |\n      nonSecretLiteral = node.asExpr().(StringLiteral).getText() and\n      nonSecretLiteral in [\"\", \"changeme\", \"secret\", \"password\", \"default\"]\n    )\n  }\n\n  // Enable differential analysis for incremental mode\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global taint tracking with framework state support\nmodule SecretKeyFlowAnalysis = TaintTracking::GlobalWithState<SecretKeyTaintConfig>;\n\n// Import path graph for vulnerability visualization\nimport SecretKeyFlowAnalysis::PathGraph\n\n// Query to detect hardcoded secret key assignments\nfrom SecretKeyFlowAnalysis::PathNode sourceNode, SecretKeyFlowAnalysis::PathNode sinkNode\nwhere SecretKeyFlowAnalysis::flowPath(sourceNode, sinkNode)\nselect sinkNode, sourceNode, sinkNode, \"SECRET_KEY assigned from $@.\", sourceNode,\n  \" hardcoded value\"",
    "output": "// Configuration module for secret key taint analysis with framework tracking"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name CSRF protection weakened or disabled\n * @description Detects applications that are susceptible to Cross-Site Request Forgery (CSRF) attacks\n *              because their CSRF protection mechanisms have been turned off or are not properly implemented.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/csrf-protection-disabled\n * @tags security\n *       external/cwe/cwe-352\n */\n\nimport python\nimport semmle.python.Concepts\n\n// Predicate to identify CSRF configurations in production environments (excluding test files)\npredicate isProductionCsrfConfig(Http::Server::CsrfProtectionSetting csrfConfig) {\n  not csrfConfig.getLocation().getFile().getAbsolutePath().matches(\"%test%\")\n}\n\n// Predicate to identify CSRF configurations that lack proper protection mechanisms\npredicate hasInsufficientCsrfProtection(Http::Server::CsrfProtectionSetting csrfConfig) {\n  csrfConfig.getVerificationSetting() = false and\n  not exists(Http::Server::CsrfLocalProtectionSetting localProtection | \n             localProtection.csrfEnabled())\n}\n\n// Main query to locate CSRF vulnerabilities in production environments\n_______________ // 补全条件\nfrom Http::Server::CsrfProtectionSetting csrfConfig\nwhere\n  isProductionCsrfConfig(csrfConfig) and\n  hasInsufficientCsrfProtection(csrfConfig) and\n  // Confirm that all production CSRF settings have the same vulnerable state\n  forall(Http::Server::CsrfProtectionSetting otherCsrfConfig | \n         isProductionCsrfConfig(otherCsrfConfig) | \n         hasInsufficientCsrfProtection(otherCsrfConfig))\nselect csrfConfig, \"Potential CSRF vulnerability due to forgery protection being disabled or weakened.\"",
    "output": "// This ensures that all production CSRF configurations are consistently checked for vulnerabilities"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * 分析指向关系数据结构的压缩性能：通过测量不同上下文深度下的\n * 去重事实数量与总关系规模的比例，评估压缩算法的效率。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义查询输出变量：去重事实计数、关系总规模、上下文深度和压缩比率\nfrom int distinctFactsCount, int totalRelationsSize, int contextDepth, float compressionRatio\nwhere\n  // 计算去重事实数量：统计唯一的(控制流节点, 目标对象, 对象类)三元组\n  distinctFactsCount =\n    strictcount(ControlFlowNode controlFlowNode, Object targetObject, ClassObject objectClass |\n      exists(PointsToContext pointsToContext |\n        // 检查在给定上下文中，控制流节点是否指向特定对象，且该对象属于特定类\n        PointsTo::points_to(controlFlowNode, pointsToContext, targetObject, objectClass, _) and\n        contextDepth = pointsToContext.getDepth()\n      )\n    ) and\n  // 计算关系总规模：统计所有(控制流节点, 目标对象, 对象类, 上下文, 源节点)五元组\n  totalRelationsSize =\n    strictcount(ControlFlowNode controlFlowNode, Object targetObject, ClassObject objectClass, \n      PointsToContext pointsToContext, ControlFlowNode sourceNode |\n      // 验证完整的指向关系，包括源节点信息\n      PointsTo::points_to(controlFlowNode, pointsToContext, targetObject, objectClass, sourceNode) and\n      contextDepth = pointsToContext.getDepth()\n    ) and\n  // 计算压缩比率：去重事实数量占关系总规模的百分比\n  compressionRatio = 100.0 * distinctFactsCount / totalRelationsSize\n// 输出结果：上下文深度、去重事实数量、关系总规模和压缩比率\nselect contextDepth, distinctFactsCount, totalRelationsSize, compressionRatio"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Symmetric Encryption Padding Schemes Detection\n * @description Identifies cryptographic padding schemes used with symmetric encryption algorithms,\n *              which may impact cryptographic security and compliance.\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n_______________ // 补全条件\nselect paddingScheme, \n       \"Algorithm in use: \" + paddingScheme.getPaddingName()",
    "output": "from SymmetricPadding paddingScheme"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies incorrect usage of super() in traditional class definitions that lack modern inheritance support.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description Identifies incorrect usage of super() in traditional class definitions that lack modern inheritance support.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * Identifies super() function calls within methods of old-style classes.\n * \n * These calls are problematic because old-style classes do not support the inheritance\n * mechanisms required by super(), leading to runtime errors.\n */\npredicate superCallInOldClass(Call superCall) {\n  exists(Function methodInClass, ClassObject oldStyleClass |\n    // Verify the call targets the built-in super function\n    superCall.getFunc().(Name).getId() = \"super\" and\n    // Ensure the call occurs within a method's scope\n    superCall.getScope() = methodInClass and\n    // Confirm the method is defined within a class\n    methodInClass.getScope() = oldStyleClass.getPyClass() and\n    // Validate successful class type inference\n    not oldStyleClass.failedInference() and\n    // Identify old-style classes (non-new-style)\n    not oldStyleClass.isNewStyle()\n  )\n}\n\n// Query all call expressions\nfrom Call superCall\n// Filter for super() calls specifically within old-style classes\nwhere superCallInOldClass(superCall)\n// Report the identified issue with an appropriate message\nselect superCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python functions that begin with uppercase letters, violating the standard naming convention.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed function\n * @description Detects Python functions that begin with uppercase letters, violating the standard naming convention.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python  // Import Python library for analyzing Python source code\n\n// Helper predicate to identify functions with uppercase-initial names\npredicate hasUppercaseInitial(Function fn) {\n  exists(string firstChar |\n    firstChar = fn.getName().prefix(1) and  // Extract the initial character of function name\n    firstChar != firstChar.toLowerCase()   // Confirm the character is uppercase\n  )\n}\n\n// Query to find functions that violate Python naming conventions\nfrom Function targetFn\nwhere\n  // Ensure function is defined in source code\n  targetFn.inSource() and  \n  // Check for uppercase-initial naming pattern\n  hasUppercaseInitial(targetFn) and  \n  // Filter out files with multiple uppercase-initial functions\n  not exists(Function otherFn |\n    otherFn != targetFn and  // Exclude the current function\n    otherFn.getLocation().getFile() = targetFn.getLocation().getFile() and  // Same file check\n    hasUppercaseInitial(otherFn)  // Also has uppercase-initial naming\n  )\nselect targetFn, \"Function names should start in lowercase.\"  // Report violation with recommendation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称密钥生成源识别\n * @description 检测代码中使用受支持库生成的所有非对称密钥，并追踪其配置来源。\n *              此查询分析非对称密钥生成操作及其配置数据流，帮助识别潜在的\n *              密钥管理问题和安全风险。\n * @kind problem\n * @id py/quantum-readiness/cbom/asymmetric-key-generation\n * @problem.severity error\n_______________ // 补全条件\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找所有非对称密钥生成操作及其关联的配置源\n// 通过匹配密钥生成操作的配置源与数据流节点，识别密钥生成模式\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node keyConfigSource\nwhere keyGenOperation.getKeyConfigSrc() = keyConfigSource\nselect keyGenOperation,\n  \"检测到非对称密钥生成，使用算法: \" + keyGenOperation.getAlgorithm().getName() +\n    \"，密钥配置源: $@\", keyConfigSource, keyConfigSource.toString()",
    "output": "* @tags cbom"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/useless-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handling blocks that reference non-exception types,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-exception in 'except' clause\n * @description Identifies exception handling blocks that reference non-exception types,\n *              rendering them ineffective as they cannot catch actual exceptions at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Core variables for analyzing exception handling constructs\nfrom ExceptFlowNode exceptionBlock, Value caughtType, ClassValue exceptionClass, \n     ControlFlowNode exceptionOrigin, string typeInfo\nwhere\n  // Establish connection between exception handler and its source\n  exceptionBlock.handledException(caughtType, exceptionClass, exceptionOrigin)\n  and\n  (\n    // Case 1: Handler uses a class that is not a valid exception type\n    exists(ClassValue invalidException | \n      invalidException = caughtType and\n      not invalidException.isLegalExceptionType() and\n      not invalidException.failedInference(_) and\n      typeInfo = \"class '\" + invalidException.getName() + \"'\"\n    )\n    or\n    // Case 2: Handler uses a non-class value (instance instead of class)\n    not caughtType instanceof ClassValue and\n    typeInfo = \"instance of '\" + exceptionClass.getName() + \"'\"\n  )\nselect exceptionBlock.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  exceptionOrigin, typeInfo"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name 外部依赖关系\n * @description 计算一个Python源文件对外部包的依赖数量。\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType externalDependency\n * @id py/external-dependencies\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 分析Python源文件与外部包之间的依赖关系，量化每个文件对外部包的依赖程度。\n * \n * 查询核心要素：\n * - 源代码文件路径（依赖关系主体）\n * - 外部包对象（PyPI或类似外部源提供的包）\n * - 包版本信息（如果可用）\n * - 源文件对该包的依赖数量统计\n * \n * 输出格式：\n * - 第一列：依赖实体标识符（文件路径和外部包的组合）\n * - 第二列：依赖计数\n * \n * 注意：文件路径前添加'/'前缀，以与仪表板数据库中的相对文件路径格式保持一致。\n */\n\n// 定义查询变量：源文件、依赖计数、依赖实体和外部包\nfrom File sourceFile, int depCount, string depEntity, ExternalPackage externalPackage\nwhere\n_______________ // 补全条件\n  depCount =\n    strictcount(AstNode astNode |\n      // 检查AST节点是否依赖于指定的外部包\n      dependency(astNode, externalPackage) and\n      // 确保AST节点位于指定的源文件中\n      astNode.getLocation().getFile() = sourceFile\n    ) and\n  // 将源文件和外部包信息合并为单个实体标识符\n  depEntity = munge(sourceFile, externalPackage)\n// 输出结果：依赖实体和依赖计数，按依赖数量降序排列\nselect depEntity, depCount order by depCount desc",
    "output": "// 计算特定源文件对特定外部包的依赖数量"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes and displays the total line count for each Python file module.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File Line Count Analysis\n * @description Computes and displays the total line count for each Python file module.\n *              This analysis helps identify large files that might benefit from refactoring.\n * @kind treemap\n * @id py/lines-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python // Import Python module for code analysis capabilities\n\n// Define source variables representing Python modules and their corresponding line counts\nfrom Module pythonModule, int totalLines\n// Calculate the total number of lines for each Python module\nwhere totalLines = pythonModule.getMetrics().getNumberOfLines()\n// Output the module and its line count, sorted by line count in descending order\nselect pythonModule, totalLines order by totalLines desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Call graph\n * @description Identifies edges in the call graph, representing function/method invocations.\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/call-graph\n * @tags meta\n * @precision very-low\n */\n\n_______________ // 补全条件\nimport python\n// Import internal data flow analysis utilities for call graph construction\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n// Import meta metrics for additional analysis capabilities\nimport meta.MetaMetrics\n\n// Define the source of our analysis: function/method invocations and their callable targets\nfrom DataFlowCall invocation, DataFlowCallable callableTarget\nwhere\n  // Ensure the target is a viable callable for the given invocation\n  callableTarget = viableCallable(invocation)\n  and\n  // Exclude invocations located in ignored files\n  not invocation.getLocation().getFile() instanceof IgnoredFile\n  and\n  // Exclude callable targets whose scope is in ignored files\n  not callableTarget.getScope().getLocation().getFile() instanceof IgnoredFile\nselect invocation, \"Call to $@\", callableTarget.getScope(), callableTarget.toString()",
    "output": "// Import standard Python language analysis library"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Identical code block detection\n * @description Identifies blocks of code that appear multiple times in the codebase. Refactoring shared code into a single location is recommended when feasible. Note that not all duplicates can be automatically resolved; specialized checks for duplicate functions or classes provide more targeted results with higher confidence.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @deprecated\n * @precision medium\n * @id py/duplicate-block\n */\n\nimport python\n\n// Query for identifying duplicate code blocks\n_______________ // 补全条件\nwhere none()\n// Generate alert message for each detected duplicate block\nselect duplicateBlock, \"Duplicate code: \" + \"-1\" + \" lines are duplicated at \" + \"<file>\" + \":\" + \"-1\"",
    "output": "from BasicBlock duplicateBlock"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Small KDF derived key length.\n * @description Detects key derivation functions (KDF) generating keys smaller than 128 bits (16 bytes).\n * @assumption When key length isn't explicitly specified (e.g., None or omitted), \n *             the length is assumed to match the underlying hash algorithm's output length.\n * @kind problem\n * @id py/kdf-small-key-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\n// Identify key derivation operations with insufficient key sizes\nfrom KeyDerivationOperation keyDerivationOp, string alertMessage, DataFlow::Node keySizeNode\nwhere\n_______________ // 补全条件\n  keySizeNode = keyDerivationOp.getDerivedKeySizeSrc() and\n  not keySizeNode.asExpr() instanceof None and\n  (\n    // Case 1: Explicitly defined integer value below minimum threshold\n    exists(int keySizeValue | \n        keySizeValue = keySizeNode.asExpr().(IntegerLiteral).getValue() and\n        keySizeValue < 16 and\n        alertMessage = \"Derived key size is too small. \"\n    )\n    or\n    // Case 2: Non-integer key size specification (statically unverifiable)\n    not exists(keySizeNode.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Derived key size is not a statically verifiable size. \"\n  )\nselect keyDerivationOp, alertMessage + \"Derived key size must be a minimum of 16 (bytes). Derived Key Size Config: $@\",\n  keySizeNode.asExpr(), keySizeNode.asExpr().toString()",
    "output": "// Retrieve key size specification source, excluding None values"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/modification-of-default-value]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects modifications of parameters that have default values, which can cause unexpected behavior since default values are shared across function calls.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Parameter with default value modification\n * @description Detects modifications of parameters that have default values, which can cause unexpected behavior since default values are shared across function calls.\n * @kind path-problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/modification-of-default-value\n */\n\nimport python\nimport semmle.python.functions.ModificationOfParameterWithDefault\nimport ModificationOfParameterWithDefault::Flow::PathGraph\n\nfrom\n  ModificationOfParameterWithDefault::Flow::PathNode startNode,\n  ModificationOfParameterWithDefault::Flow::PathNode endNode\nwhere \n  ModificationOfParameterWithDefault::Flow::flowPath(startNode, endNode)\nselect \n  endNode.getNode(), \n  startNode, \n  endNode, \n  \"This expression mutates a $@.\", \n  startNode.getNode(),\n  \"default value\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name File Similarity Analysis\n * @description Placeholder query for evaluating similarity metrics between files.\n *              This implementation selects Python files and assigns arbitrary similarity scores.\n *              Note: The actual similarity calculation algorithm is not implemented.\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags testability\n * @id py/similar-lines-in-files\n */\n\nimport python // Python module for code analysis and query operations\n_______________ // 补全条件\n// Part 1: Define variables for file analysis and similarity scoring\nfrom File analyzedFile, int similarityScore\n\n// Part 2: Apply filtering conditions (none in this placeholder implementation)\nwhere \n  none()\n\n// Part 3: Output results with ordering\nselect analyzedFile, similarityScore order by similarityScore desc",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Function returning tuples of inconsistent lengths\n * @description Detects functions that return tuples with varying lengths, which can lead to errors\n *              when consumers of these functions expect a consistent tuple structure.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       quality\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mixed-tuple-returns\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// 定义谓词函数，判断函数是否返回特定大小的元组\npredicate returns_tuple_of_size(Function targetFunction, int tupleSize, Tuple returnedTuple) {\n  // 检查函数的返回语句和相关的数据流\n  exists(Return returnStmt, DataFlow::Node returnValueNode |\n    // 返回值的数据流节点与返回语句的值对应\n    returnValueNode.asExpr() = returnStmt.getValue() and\n    // 确保返回语句属于目标函数\n    returnStmt.getScope() = targetFunction and\n    // 检查从元组到返回值的数据流\n    any(DataFlow::LocalSourceNode sourceNode | sourceNode.asExpr() = returnedTuple).flowsTo(returnValueNode)\n  |\n    // 计算元组中元素的数量\n    tupleSize = count(int idx | exists(returnedTuple.getElt(idx)))\n  )\n}\n\n// 查找返回不同大小元组的函数\nfrom Function targetFunction, int smallerSize, int largerSize, AstNode smallerTuple, AstNode largerTuple\nwhere\n  // 函数返回较小大小的元组\n  returns_tuple_of_size(targetFunction, smallerSize, smallerTuple) and\n  // 函数返回较大大小的元组\n  returns_tuple_of_size(targetFunction, largerSize, largerTuple) and\n  // 确保两个元组大小不同\n  smallerSize < largerSize and\n  // 排除有返回类型注解的函数\n_______________ // 补全条件\n// 选择结果，包括函数、函数名和两个不同大小的元组信息\nselect targetFunction, targetFunction.getQualifiedName() + \" returns $@ and $@.\", smallerTuple, \n  \"tuple of size \" + smallerSize, largerTuple, \"tuple of size \" + largerSize",
    "output": "not exists(targetFunction.getDefinition().(FunctionExpr).getReturns())"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python source file comment density analysis\n * @description This analysis calculates the percentage of comment lines relative to the total lines\n *              in Python source files. Note that docstrings are excluded from this calculation\n *              as they are considered separately from standard comments.\n * @kind treemap\n * @id py/comment-density-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n_______________ // 补全条件\n */\n\nimport python\n\nfrom Module pyFile\nwhere \n  // Only consider files that have at least one line of code\n  pyFile.getMetrics().getNumberOfLines() > 0\nselect \n  pyFile,\n  // Calculate comment density as a percentage\n  (100.0 * pyFile.getMetrics().getNumberOfLinesOfComments()) / pyFile.getMetrics().getNumberOfLines() as commentRatio\norder by \n  commentRatio desc",
    "output": "*       documentation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of commits\n * @description Counts the number of commits in the repository, excluding artificial changes\n * @kind treemap\n * @id py/historical-number-of-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\n// Import required modules for Python and version control analysis\nimport python\nimport external.VCS\n\n// Process repository commit entries, filtering out artificial changes\nfrom Commit commitEntry\n_______________ // 补全条件\n  // Exclude commits marked as artificial changes to count only genuine commits\n  not artificialChange(commitEntry)\nselect \n  // Retrieve the revision identifier for each valid commit\n  commitEntry.getRevisionName(), \n  // Assign a count value of 1 to each commit for metric aggregation\n  1",
    "output": "where"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unencrypted logging of confidential data\n * @description Detects when sensitive information is written to logs without proper encryption,\n *              potentially exposing confidential data to unauthorized access.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/clear-text-logging-sensitive-data\n * @tags security\n *       external/cwe/cwe-312\n *       external/cwe/cwe-359\n *       external/cwe/cwe-532\n */\n\n// Import Python language support\nimport python\n// Import data flow tracking functionality\nprivate import semmle.python.dataflow.new.DataFlow\n// Import path visualization components\nimport CleartextLoggingFlow::PathGraph\n// Import specialized cleartext logging analysis\nimport semmle.python.security.dataflow.CleartextLoggingQuery\n_______________ // 补全条件\n// Declare variables for tracking data flow path components\nfrom\n  CleartextLoggingFlow::PathNode confidentialDataSource, \n  CleartextLoggingFlow::PathNode logDestination, \n  string infoCategory\nwhere\n  // Establish data flow path between source and sink\n  CleartextLoggingFlow::flowPath(confidentialDataSource, logDestination)\n  and\n  // Extract data classification from source\n  exists(Source src |\n    src = confidentialDataSource.getNode() and\n    infoCategory = src.getClassification()\n  )\nselect \n  // Generate results with sink location, source node, sink node, message, and data classification\n  logDestination.getNode(), \n  confidentialDataSource, \n  logDestination, \n  \"This expression logs $@ as clear text.\", \n  confidentialDataSource.getNode(),\n  \"sensitive data (\" + infoCategory + \")\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Misnamed function\n * @description Detects functions that begin with an uppercase letter, \n *              which contradicts Python naming standards and affects code clarity.\n *              The query limits reporting to a single function per file when multiple\n *              violations exist to prevent redundant alerts within the same file.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n_______________ // 补全条件\n */\n\nimport python\n\nfrom Function funcToCheck\nwhere\n  // Confirm the function is defined in user source code (excluding library files)\n  funcToCheck.inSource() and\n  \n  // Validate that the function name starts with an uppercase character\n  exists(string initialChar |\n    initialChar = funcToCheck.getName().prefix(1) and\n    initialChar.toUpperCase() = initialChar\n  ) and\n  \n  // Restrict reporting to only one such function per source file\n  not exists(Function anotherFunc |\n    anotherFunc != funcToCheck and\n    anotherFunc.getLocation().getFile() = funcToCheck.getLocation().getFile() and\n    exists(string initialChar |\n      initialChar = anotherFunc.getName().prefix(1) and\n      initialChar.toUpperCase() = initialChar\n    )\n  )\nselect funcToCheck, \"Function names should start in lowercase.\"",
    "output": "* @tags maintainability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-commented-out-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Counts the number of lines containing commented-out code in each file",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lines of commented-out code in files\n * @description Counts the number of lines containing commented-out code in each file\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// Import necessary modules for Python language analysis and commented code detection\nimport python\nimport Lexical.CommentedOutCode\n\n// Define variables for code files and their commented code line counts\nfrom File codeFile, int commentedOutCodeLines\n// Calculate the count of commented lines, excluding potential example code\nwhere commentedOutCodeLines = count(CommentedOutCodeLine commentedCodeLine | \n        not commentedCodeLine.maybeExampleCode() and \n        commentedCodeLine.getLocation().getFile() = codeFile)\n// Return files and their commented code line counts, ordered by count in descending order\nselect codeFile, commentedOutCodeLines order by commentedOutCodeLines desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Statement nesting depth\n * @description Calculates and presents the maximum nesting depth of statements within each function.\n *              Deep nesting often indicates increased complexity and reduced code readability.\n * @kind treemap\n * @id py/statement-nesting-depth-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags maintainability\n *       complexity\n */\n\nimport python\n\n_______________ // 补全条件\nfrom FunctionMetrics funcWithMetrics\n// Compute and display the maximum nesting depth, prioritizing functions with higher complexity\nselect funcWithMetrics, funcWithMetrics.getStatementNestingDepth() as maxNestingDepth order by maxNestingDepth desc",
    "output": "// Identify functions for complexity analysis based on statement nesting"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Raising a tuple\n * @description In Python 2, raising a tuple results in only the first element being raised\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// Identify Python 2 raise statements where a tuple is raised\nfrom Raise raiseStmt, DataFlow::LocalSourceNode tupleNode\nwhere\n  // Verify the source node represents a tuple expression\n  tupleNode.asExpr() instanceof Tuple and\n  // Target only Python 2 (Python 3 handles this as a type error)\n  major_version() = 2 and\n  // Confirm data flow path from tuple to the raised exception\n  exists(DataFlow::Node flowTarget | \n    flowTarget.asExpr() = raiseStmt.getException() and\n    tupleNode.flowsTo(flowTarget)\n  )\n/* Note: Python 3 treats tuple raising as a type error, handled by IllegalRaise query */\nselect raiseStmt,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleNode, \"tuple\"",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raises-tuple]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code that raises a tuple in Python 2, which causes all elements except the first to be discarded",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Raising a tuple\n * @description Detects code that raises a tuple in Python 2, which causes all elements except the first to be discarded\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// Identify raise statements in Python 2 code where a tuple is being raised\nfrom Raise raiseStatement, DataFlow::LocalSourceNode tupleExprNode\nwhere\n  // Restrict analysis to Python 2 environments, as this behavior differs in Python 3\n  major_version() = 2 and\n  // Confirm that the data flow source represents a tuple expression\n  tupleExprNode.asExpr() instanceof Tuple and\n  // Establish data flow path from the tuple expression to the exception part of the raise statement\n  exists(DataFlow::Node exceptionTargetNode | \n    exceptionTargetNode.asExpr() = raiseStatement.getException() and\n    tupleExprNode.flowsTo(exceptionTargetNode)\n  )\n/* Note: In Python 3, raising a tuple results in a TypeError, which is handled by the IllegalRaise query. */\nselect raiseStatement,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleExprNode, \"tuple\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 错误的类实例化参数数量\n * @description 检测类实例化调用中传递的参数数量与类构造函数(__init__)定义不匹配的情况，\n *              这种不匹配会导致程序在运行时抛出TypeError异常。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n_______________ // 补全条件\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classCreationCall, ClassValue targetClass, string errorDescription, string constraintPrefix, int requiredArgCount, FunctionValue classConstructor\nwhere\n  // 获取目标类的构造函数（即__init__方法）\n  classConstructor = get_function_or_initializer(targetClass)\n  and (\n    // 处理参数数量超过构造函数定义上限的情况\n    too_many_args(classCreationCall, targetClass, requiredArgCount)\n    and errorDescription = \"too many arguments\"\n    and constraintPrefix = \"no more than \"\n    or\n    // 处理参数数量低于构造函数定义下限的情况\n    too_few_args(classCreationCall, targetClass, requiredArgCount)\n    and errorDescription = \"too few arguments\"\n    and constraintPrefix = \"no fewer than \"\n  )\nselect classCreationCall, \n  \"Call to $@ with \" + errorDescription + \"; should be \" + constraintPrefix + requiredArgCount.toString() + \".\", \n  classConstructor,\n  // 输出调用点、错误消息及构造函数的完全限定名\n  classConstructor.getQualifiedName()",
    "output": "* @sub-severity low"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name XML external entity expansion vulnerability\n * @description Identifies security risks where user-provided data flows into XML parsers\n *              lacking safeguards against external entity expansion attacks.\n * @kind path-problem\n * @problem.severity error\n_______________ // 补全条件\n * @precision high\n * @id py/xxe\n * @tags security\n *       external/cwe/cwe-611\n *       external/cwe/cwe-827\n */\n\n// Import core Python analysis framework\nimport python\n\n// Import specialized XXE vulnerability detection modules\nimport semmle.python.security.dataflow.XxeQuery\n\n// Import path graph utilities for data flow visualization\nimport XxeFlow::PathGraph\n\n// Trace unsafe data flows from input sources to XML processing sinks\nfrom XxeFlow::PathNode taintedInput, XxeFlow::PathNode vulnerableSink\nwhere \n  // Establish propagation path from untrusted input to XML parser\n  XxeFlow::flowPath(taintedInput, vulnerableSink)\n\n// Report vulnerable XML parsing lacking XXE protection mechanisms\nselect vulnerableSink.getNode(), taintedInput, vulnerableSink,\n  \"XML parser consumes $@ without external entity expansion protection.\",\n  taintedInput.getNode(), \"untrusted user input\"",
    "output": "* @security-severity 9.1"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-small-salt-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Cryptographic key derivation requires salt values of at least 128 bits (16 bytes) to ensure security.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inadequate KDF Salt Length\n * @description Cryptographic key derivation requires salt values of at least 128 bits (16 bytes) to ensure security.\n *\n * This query detects vulnerabilities where the salt size in key derivation functions is below the\n * recommended 128 bits minimum, or when the salt size cannot be determined through static analysis.\n * Using insufficient salt sizes weakens cryptographic protection by increasing vulnerability to\n * brute-force attacks against derived keys.\n * @kind problem\n * @id py/kdf-small-salt-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Query definition: Identifies key derivation functions with inadequate salt size\nfrom KeyDerivationOperation keyDerivationFunc, DataFlow::Node saltSizeArg, API::CallNode urandomCall, string alertMessage\nwhere\n  // Essential condition: The key derivation function requires a salt\n  keyDerivationFunc.requiresSalt() and\n  \n  // Salt source verification: Confirms os.urandom is used as the salt source\n  urandomCall = keyDerivationFunc.getSaltConfigSrc() and\n  urandomCall = API::moduleImport(\"os\").getMember(\"urandom\").getACall() and\n  \n  // Parameter tracking: Identifies the ultimate source of the salt size parameter\n  saltSizeArg = CryptoUtils::getUltimateSrcFromApiNode(urandomCall.getParameter(0, \"size\")) and\n  \n  // Security assessment: Evaluates salt size for potential vulnerabilities\n  (\n    // Vulnerability case 1: Salt size is not statically determinable\n    not exists(saltSizeArg.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Salt configuration uses a non-static size value. \"\n    or\n    // Vulnerability case 2: Salt size is below the security minimum\n    saltSizeArg.asExpr().(IntegerLiteral).getValue() < 16 and\n    alertMessage = \"Salt configuration size is below security threshold. \"\n  )\nselect keyDerivationFunc,  // Target: The vulnerable key derivation operation\n  alertMessage + \"Minimum salt size requirement is 16 bytes. os.urandom Configuration: $@, Size Parameter: $@\",  // Alert construction\n  urandomCall, urandomCall.toString(),  // Reference: urandom invocation details\n  saltSizeArg, saltSizeArg.toString()  // Reference: Salt size parameter details"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/catch-base-exception]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers that catch BaseException without re-raising,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Exception block catches 'BaseException'\n * @description Identifies exception handlers that catch BaseException without re-raising,\n *              potentially causing improper handling of system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Determine if an exception handler fails to re-raise the caught exception\npredicate doesNotReraise(ExceptStmt exceptionHandler) { \n  // Check if control flow from the handler reaches program exit\n  exceptionHandler.getAFlowNode().getBasicBlock().reachesExit() \n}\n\n// Detect handlers that catch BaseException or use bare except clauses\npredicate catchesBaseException(ExceptStmt exceptionHandler) {\n  // Verify explicit BaseException handling\n  exceptionHandler.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  // Identify bare except clauses (catching all exceptions)\n  not exists(exceptionHandler.getType())\n}\n\n// Primary query: Locate handlers that catch BaseException without re-raising\nfrom ExceptStmt exceptionHandler\nwhere\n  catchesBaseException(exceptionHandler) and // Condition: Catches BaseException\n  doesNotReraise(exceptionHandler)          // Condition: Doesn't re-raise\nselect exceptionHandler, \"Except block directly handles BaseException.\" // Output with description"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Denial of Service using Unicode Characters\n * @description A remote user-controlled data can reach a costly Unicode normalization with either form NFKC or NFKD. On Windows OS, with an attack such as the One Million Unicode Characters, this could lead to a denial of service. And, with the use of special Unicode characters, like U+2100 (℀) or U+2105 (℅), the payload size could be tripled.\n * @kind path-problem\n * @id py/unicode-dos\n * @precision high\n * @problem.severity error\n * @tags security\n *       experimental\n *       external/cwe/cwe-770\n */\n\nimport python\nimport semmle.python.ApiGraphs\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n// 定义一个类，用于表示Unicode兼容性规范化调用。这些调用来自unicodedata、unidecode、pyunormalize和textnorm模块。\n// argIdx用于约束被规范化的参数。\nclass UnicodeCompatibilityNormalize extends API::CallNode {\n  int argIdx; // 参数索引\n\n  UnicodeCompatibilityNormalize() {\n    (\n      this = API::moduleImport(\"unicodedata\").getMember(\"normalize\").getACall() and\n      this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember(\"normalize\").getACall() and\n      this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n    ) and\n    argIdx = 1 // 如果匹配到上述情况，则设置argIdx为1\n    or\n    (\n      this = API::moduleImport(\"textnorm\").getMember(\"normalize_unicode\").getACall() and\n      this.getParameter(1).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"unidecode\").getMember(\"unidecode\").getACall()\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember([\"NFKC\", \"NFKD\"]).getACall()\n    ) and\n    argIdx = 0 // 如果匹配到上述情况，则设置argIdx为0\n  }\n\n  DataFlow::Node getPathArg() { result = this.getArg(argIdx) } // 获取路径参数节点\n}\n\n// 定义一个谓词，用于检查在特定条件下是否满足值限制条件。\npredicate underAValue(DataFlow::GuardNode g, ControlFlowNode node, boolean branch) {\n  exists(CompareNode cn | cn = g |\n    exists(API::CallNode lenCall, Cmpop op, Node n |\n      lenCall = n.getALocalSource() and\n      (\n        // arg <= LIMIT OR arg < LIMIT\n        (op instanceof LtE or op instanceof Lt) and\n        branch = true and\n        cn.operands(n.asCfgNode(), op, _)\n        or\n        // LIMIT >= arg OR LIMIT > arg\n        (op instanceof GtE or op instanceof Gt) and\n        branch = true and\n        cn.operands(_, op, n.asCfgNode())\n        or\n        // not arg >= LIMIT OR not arg > LIMIT\n        (op instanceof GtE or op instanceof Gt) and\n        branch = false and\n        cn.operands(n.asCfgNode(), op, _)\n        or\n        // not LIMIT <= arg OR not LIMIT < arg\n        (op instanceof LtE or op instanceof Lt) and\n        branch = false and\n        cn.operands(_, op, n.asCfgNode())\n_______________ // 补全条件\n    |\n      lenCall = API::builtin(\"len\").getACall() and\n      node = lenCall.getArg(0).asCfgNode() // 确保是内置函数len的调用，并获取其第一个参数节点\n    ) //and\n    //not cn.getLocation().getFile().inStdlib() // 注释掉的标准库检查\n  )\n}\n\n// 定义一个私有模块，配置数据流分析的相关规则。\nprivate module UnicodeDoSConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource } // 定义源节点为远程流源\n\n  predicate isBarrier(DataFlow::Node sanitizer) {\n    // underAValue是一个检查，确保用户提供的值的长度限制在一定范围内。\n    sanitizer = DataFlow::BarrierGuard<underAValue/3>::getABarrierNode() // 定义屏障节点为underAValue检查节点\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    // 任何对Unicode兼容性规范化的调用都是一个高成本操作。\n    sink = any(UnicodeCompatibilityNormalize ucn).getPathArg()\n    or\n    // pallets/werkzeug中的secure_filename()调用在底层使用Unicode兼容性规范化。\n    sink = API::moduleImport(\"werkzeug\").getMember(\"secure_filename\").getACall().getArg(_)\n    or\n    sink =\n      API::moduleImport(\"werkzeug\")\n          .getMember(\"utils\")\n          .getMember(\"secure_filename\")\n          .getACall()\n          .getArg(_) // 定义接收节点为Unicode兼容性规范化调用或secure_filename调用的参数节点\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() } // 增量模式观察差异的谓词，这里不做具体实现\n}\n\n// 定义全局数据流分析模块，使用UnicodeDoSConfig配置。\nmodule UnicodeDoSFlow = TaintTracking::Global<UnicodeDoSConfig>;\n\nimport UnicodeDoSFlow::PathGraph // 导入路径图模块\n\nfrom UnicodeDoSFlow::PathNode source, UnicodeDoSFlow::PathNode sink // 从源节点和接收节点中选择路径\nwhere UnicodeDoSFlow::flowPath(source, sink) // 条件：存在从源节点到接收节点的数据流路径\nselect sink.getNode(), source, sink, \"This $@ can reach a $@.\", source.getNode(),\n  \"user-provided value\", sink.getNode(), \"costly Unicode normalization operation\" // 选择结果并生成报告信息",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of the return value of a procedure\n * @description Detects usage of return values from procedures (functions that return None). \n *              Such usage is misleading since the returned value (None) typically has no meaningful purpose.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/procedure-return-value-used\n */\n\nimport python\nimport Testing.Mox\n\n/**\n * Determines if a call expression's result is utilized in the code.\n * A call is considered used if it is part of another expression or statement\n * that expects a value, excluding certain common patterns like standalone returns.\n */\npredicate is_used(Call funcCall) {\n  // Case 1: The call is nested within another value-requiring expression\n  exists(Expr parentExpr | \n    parentExpr != funcCall and \n    parentExpr.containsInScope(funcCall) and\n    (parentExpr instanceof Call or \n     parentExpr instanceof Attribute or \n     parentExpr instanceof Subscript)\n  )\n  // Case 2: The call is a sub-expression in non-expression statements\n  or\n  exists(Stmt stmtParent |\n    funcCall = stmtParent.getASubExpression() and\n    not stmtParent instanceof ExprStmt and\n    /* Exclude single return statements (common pattern like 'def f(): return g()').\n       Also covers implicit returns in lambda functions. */\n    not (stmtParent instanceof Return and \n         strictcount(Return r | r.getScope() = stmtParent.getScope()) = 1)\n  )\n}\n\nfrom Call funcCall, FunctionValue calledFunction\nwhere\n  /* The call result is used, but the callee is a procedure */\n  is_used(funcCall) and\n  funcCall.getFunc().pointsTo(calledFunction) and\n  calledFunction.getScope().isProcedure() and\n  /* Ensure all possible callees are procedures */\n  forall(FunctionValue possibleCallee | \n    funcCall.getFunc().pointsTo(possibleCallee) | \n    possibleCallee.getScope().isProcedure()\n  ) and\n_______________ // 补全条件\n  not useOfMoxInModule(funcCall.getEnclosingModule())\nselect funcCall, \"The result of $@ is used even though it is always None.\", calledFunction, calledFunction.getQualifiedName()",
    "output": "/* Exclude Mox mock objects with `AndReturn` method */"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Framework-mode endpoint catalog for model editor\n * @description Identifies accessible endpoints (methods and attributes) available in the model editor's framework mode. \n *              Excludes test and generated code artifacts from results.\n * @kind table\n * @id py/utils/modeleditor/framework-mode-endpoints\n * @tags modeleditor endpoints framework-mode\n */\n\n// Import ModelEditor capabilities for endpoint analysis\nimport modeling.ModelEditor\n\n// Retrieve framework-mode endpoint metadata with enhanced variable naming\nfrom Endpoint frameworkEndpoint\nselect \n  // Core endpoint reference\n  frameworkEndpoint,\n  // Namespace containing the endpoint\n  frameworkEndpoint.getNamespace(),\n  // Parent class defining the endpoint\n  frameworkEndpoint.getClass(),\n_______________ // 补全条件\n  frameworkEndpoint.getFunctionName(),\n  // Parameter signature of the endpoint\n  frameworkEndpoint.getParameters(),\n  // Supported HTTP status codes\n  frameworkEndpoint.getSupportedStatus(),\n  // Source file containing endpoint definition\n  frameworkEndpoint.getFileName(),\n  // Supported data types for the endpoint\n  frameworkEndpoint.getSupportedType(),\n  // Endpoint classification (method/attribute)\n  frameworkEndpoint.getKind()",
    "output": "// Method/function name of the endpoint"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Exception block catches 'BaseException'\n * @description Capturing 'BaseException' can lead to improper handling of system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n_______________ // 补全条件\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// 检查异常处理块是否不会重新抛出捕获的异常\n// 通过分析控制流，确定异常处理块的基本块是否能够到达程序退出点\npredicate doesNotReraise(ExceptStmt exceptionHandler) { \n  exceptionHandler.getAFlowNode().getBasicBlock().reachesExit() \n}\n\n// 确定异常处理块是否捕获了BaseException或其子类\n// 包括两种情况：显式捕获BaseException，或者使用裸except子句（未指定异常类型）\npredicate catchesBaseException(ExceptStmt exceptionHandler) {\n  // 检查异常类型是否为BaseException\n  exceptionHandler.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  // 检查是否为裸except子句（未指定异常类型）\n  not exists(exceptionHandler.getType())\n}\n\n// 主查询：识别潜在问题模式\n// 查找同时满足以下两个条件的异常处理块：\n// 1. 捕获了BaseException（包括裸except子句）\n// 2. 不会重新抛出异常\nfrom ExceptStmt exceptionHandler\nwhere\n  catchesBaseException(exceptionHandler) and \n  doesNotReraise(exceptionHandler)\nselect exceptionHandler, \"Except block directly handles BaseException.\"",
    "output": "*       readability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/afferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes and presents the number of classes that depend on each particular class.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Analysis of incoming class dependencies\n * @description Computes and presents the number of classes that depend on each particular class.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// Extract the target class from class metrics and obtain its afferent coupling value\nfrom ClassMetrics targetClass, int afferentCoupling\nwhere afferentCoupling = targetClass.getAfferentCoupling() and exists(afferentCoupling)\nselect targetClass, \n       afferentCoupling as dependencyCount \norder by dependencyCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Identifies descriptor classes containing mutation operations\n// Mutations must occur in non-initializer functions called via descriptor protocol methods\npredicate containsDescriptorMutation(ClassObject descriptorClass, SelfAttributeStore mutationOperation) {\n  // Verify the class implements descriptor protocol\n  descriptorClass.isDescriptorType() and\n  // Find descriptor protocol methods (__get__/__set__/__delete__)\n  exists(PyFunctionObject descriptorMethod, string protocolMethodName |\n    descriptorClass.lookupAttribute(protocolMethodName) = descriptorMethod and\n    (protocolMethodName = \"__get__\" or protocolMethodName = \"__set__\" or protocolMethodName = \"__delete__\") and\n    // Locate functions invoked by descriptor methods\n_______________ // 补全条件\n      // Called function must be a class member method\n      descriptorClass.lookupAttribute(_) = calledFunction and\n      // Descriptor method directly/indirectly invokes the function\n      descriptorMethod.getACallee*() = calledFunction and\n      // Exclude initialization methods\n      not calledFunction.getName() = \"__init__\" and\n      // Mutation occurs within the called function's scope\n      mutationOperation.getScope() = calledFunction.getFunction()\n    )\n  )\n}\n\n// Find all classes with descriptor mutations and associated operations\nfrom ClassObject descriptorClass, SelfAttributeStore mutationOperation\nwhere containsDescriptorMutation(descriptorClass, mutationOperation)\n// Output mutation location, warning message, related class and its name\nselect mutationOperation,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorClass, descriptorClass.getName()",
    "output": "exists(PyFunctionObject calledFunction |"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/iteration-string-and-sequence]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies loops that iterate over both string and sequence types,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Iterable can be either a string or a sequence\n * @description Identifies loops that iterate over both string and sequence types,\n * which may cause runtime errors due to inconsistent iteration behavior\n * @kind problem\n * @tags reliability\n *       maintainability\n *       non-local\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iteration-string-and-sequence\n */\n\nimport python\nimport semmle.python.filters.Tests\n\n// Determines if a value represents a string type (str or Python 2 unicode)\npredicate has_string_type(Value value) {\n  value.getClass() = ClassValue::str() \n  or \n  value.getClass() = ClassValue::unicode() and major_version() = 2\n}\n\nfrom \n  For loopStmt, \n  ControlFlowNode iterNode, \n  Value strValue, \n  Value seqValue, \n  ControlFlowNode seqOrigin,\n  ControlFlowNode strOrigin\nwhere \n  // Extract iterator node from loop structure\n  loopStmt.getIter().getAFlowNode() = iterNode and\n  \n  // Verify iterator points to both string and sequence values\n  iterNode.pointsTo(strValue, strOrigin) and\n  iterNode.pointsTo(seqValue, seqOrigin) and\n  \n  // Validate type compatibility: string + non-string iterable\n  has_string_type(strValue) and\n  seqValue.getClass().isIterable() and\n  not has_string_type(seqValue) and\n  \n  // Exclude test code scenarios from analysis\n  not strOrigin.getScope().getScope*() instanceof TestScope and\n  not seqOrigin.getScope().getScope*() instanceof TestScope\nselect loopStmt,\n  \"Iteration over $@, of class \" + seqValue.getClass().getName() + \n  \", may also iterate over $@.\",\n  seqOrigin, \"sequence\", strOrigin, \"string\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class Cohesion Deficiency (HM Method)\n * @description Measures the lack of cohesion in classes based on Hitz and Montazeri's methodology.\n * @kind treemap\n * @id py/lack-of-cohesion-hitz-montazeri\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n */\n\nimport python  // Import Python module for code analysis capabilities\n\n// Detect classes with cohesion problems using Hitz-Montazeri (HM) methodology\n// This metric quantifies the relationship between methods and instance variables\n_______________ // 补全条件\n\n// Extract class details and compute the cohesion deficiency score\n// Elevated scores indicate more significant cohesion issues within the class\nselect \n    clsMetrics, \n    clsMetrics.getLackOfCohesionHM() as lhmScore \n\n// Arrange results to emphasize classes with the most critical cohesion deficiencies\norder by \n    lhmScore desc",
    "output": "from ClassMetrics clsMetrics"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/redundant-comparison]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies comparisons whose results are determined by preceding conditions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Redundant comparison\n * @description Identifies comparisons whose results are determined by preceding conditions\n * @kind problem\n * @tags useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/redundant-comparison\n */\n\nimport python\nimport semmle.python.Comparisons\n\n/**\n * Checks if an expression has complex comparison structures including:\n * - Chained comparisons (e.g., a < b < c)\n * - Nested unary operations (e.g., not (x > y))\n */\nprivate predicate hasComplexStructure(Expr expr) {\n  // Detect chained comparisons with multiple operators\n  exists(expr.(Compare).getOp(1))\n  or\n  // Recursively analyze unary expression operands\n  hasComplexStructure(expr.(UnaryExpr).getOperand())\n}\n\n/**\n * Determines if a comparison is redundant by checking if its result\n * is implied by a controlling condition block. Excludes complex\n * comparison structures due to flow analysis limitations.\n */\nprivate predicate isRedundantComparison(Comparison compNode, ComparisonControlBlock ctrlBlock, boolean resultValue) {\n  // Verify control block implies comparison result\n  ctrlBlock.impliesThat(compNode.getBasicBlock(), compNode, resultValue) and\n  // Exclude complex comparison patterns\n  not hasComplexStructure(ctrlBlock.getTest().getNode())\n}\n\n/**\n * Establishes relationship between redundant test expressions\n * and their corresponding controlling conditions in the AST.\n */\nprivate predicate hasRedundantComparisonInAST(AstNode testNode, AstNode relatedCondNode, boolean resultValue) {\n  forex(Comparison compNode, ConditionBlock condBlock |\n    // Map test node to comparison node\n    compNode.getNode() = testNode and\n    // Map condition to last node in control block\n    condBlock.getLastNode().getNode() = relatedCondNode\n  |\n    // Verify redundancy relationship\n    isRedundantComparison(compNode, condBlock, resultValue)\n  )\n}\n\nfrom Expr testExpr, Expr relatedCond, boolean resultValue\nwhere\n  // Identify redundant tests excluding child nodes\n  hasRedundantComparisonInAST(testExpr, relatedCond, resultValue) and \n  not hasRedundantComparisonInAST(testExpr.getAChildNode+(), relatedCond, _)\nselect testExpr, \"Test is always \" + resultValue + \", because of $@.\", relatedCond, \"this condition\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/hash-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all potential usage of cryptographic hash algorithms",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cryptographic Hash Algorithms Detection\n * @description Identifies all potential usage of cryptographic hash algorithms\n *              across supported cryptographic libraries in Python code.\n *              This detection helps identify cryptographic implementations\n *              that may require quantum-resistant alternatives.\n * @kind problem\n * @id py/quantum-readiness/cbom/hash-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python language support for code analysis and AST parsing\nimport python\n\n// Import experimental cryptography concepts module for algorithm detection\nimport experimental.cryptography.Concepts\n\n// Define source: all cryptographic hash algorithm instances in the codebase\nfrom HashAlgorithm hashAlgorithmInstance\n\n// Generate results: select each identified hash algorithm with descriptive message\nselect hashAlgorithmInstance, \n       \"Use of algorithm \" + hashAlgorithmInstance.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Encoding error\n * @description 检测Python代码中可能导致运行时失败并阻碍静态分析的编码问题\n * @kind problem\n * @id py/encoding-error\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n_______________ // 补全条件\n\nimport python\n\n// 定位所有编码错误实例\nfrom EncodingError encodingProblem\n\n// 输出编码错误及其详细描述信息\nselect encodingProblem, encodingProblem.getMessage()",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-global]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies instances where 'global' statements are used, potentially indicating suboptimal modular design patterns.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Detection of 'global' keyword usage.\n * @description Identifies instances where 'global' statements are used, potentially indicating suboptimal modular design patterns.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/use-of-global\n */\n\nimport python\n\n// Identify global statements that are not at module level.\n// Using global variables outside of module initialization can make code harder to understand and maintain.\nfrom Global globalStatement\nwhere \n  // Exclude global statements that are at module level, as these are generally acceptable\n  not globalStatement.getScope() instanceof Module\nselect globalStatement, \"Modifying global variables outside of module initialization is not recommended.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Potentially unsafe exit() or quit() usage\n * @description Identifies calls to exit() or quit() functions that are defined in the site module.\n_______________ // 补全条件\n *              the site module where these functions are defined. Consider using sys.exit() instead.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/use-of-exit-or-quit\n */\n\nimport python\n\nfrom CallNode problematicExitCall, string exitFuncName\nwhere \n  // Identify function calls that reference site.Quitter objects (exit/quit)\n  problematicExitCall.getFunction().pointsTo(Value::siteQuitter(exitFuncName))\nselect \n  problematicExitCall,\n  \"Usage of '\" + exitFuncName + \n  \"' depends on site module availability and may fail when Python runs with '-S' flag.\"",
    "output": "*              These calls may fail when Python runs with the '-S' flag, which prevents loading"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Misleading super() first parameter\n * @description Identifies instances where super() is invoked with an initial argument\n *              that differs from the containing class name, potentially causing\n *              incorrect initialization behavior in inheritance hierarchies.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-687\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/super-not-enclosing-class\n */\n\nimport python  // 导入Python库，用于分析Python代码\nimport semmle.python.dataflow.new.DataFlow  // 导入数据流分析模块\nimport semmle.python.ApiGraphs  // 导入API图模块\n\n// 定义查询的输入变量：super()调用节点和封闭类的名称\nfrom DataFlow::CallCfgNode superCall, string enclosingClassName\nwhere\n  // 验证节点确实是对super内置函数的调用\n  superCall = API::builtin(\"super\").getACall() and\n  // 获取当前类作用域的名称作为封闭类名\n  enclosingClassName = superCall.getScope().getScope().(Class).getName() and\n_______________ // 补全条件\n  exists(DataFlow::Node firstArg |\n    firstArg = superCall.getArg(0) and\n    // 比较第一个参数的标识符与封闭类名\n    firstArg.getALocalSource().asExpr().(Name).getId() != enclosingClassName\n  )\n// 选择问题节点并生成报告消息\nselect superCall.getNode(), \"First argument to super() should be \" + enclosingClassName + \".\"",
    "output": "// 检查是否存在第一个参数且与封闭类名不匹配"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/function-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：该查询用于识别Python代码中的函数定义，并建立每个函数与其源代码文件之间的关联关系",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python函数定义源码位置映射\n * @description 该查询用于识别Python代码中的函数定义，并建立每个函数与其源代码文件之间的关联关系\n * @kind source-link\n * @id py/function-source-links\n * @metricType callable\n */\n\nimport python\n\n// 查询所有Python函数定义，并获取它们在源代码中的位置信息\nfrom Function funcDef, Location sourceLocation\nwhere sourceLocation = funcDef.getLocation()\nselect funcDef, sourceLocation.getFile()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/xxe]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies vulnerabilities where user-supplied input is processed",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name XML external entity expansion\n * @description Identifies vulnerabilities where user-supplied input is processed\n *              by an XML parser without proper security controls against external entity expansion.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision high\n * @id py/xxe\n * @tags security\n *       external/cwe/cwe-611\n *       external/cwe/cwe-827\n */\n\n// Import Python analysis framework for code parsing and evaluation\nimport python\n\n// Import specialized XXE vulnerability detection modules\nimport semmle.python.security.dataflow.XxeQuery\n\n// Import path graph utilities for visualizing data flow trajectories\nimport XxeFlow::PathGraph\n\n// Identify potential XXE vulnerability entry points and dangerous XML parsing locations\nfrom XxeFlow::PathNode userInputOrigin, XxeFlow::PathNode xmlParsingLocation\n// Verify data flow exists between user input and insecure XML processing\nwhere XxeFlow::flowPath(userInputOrigin, xmlParsingLocation)\n\n// Generate security alert with complete data flow path information\nselect xmlParsingLocation.getNode(), userInputOrigin, xmlParsingLocation,\n  \"XML document parsing utilizes a $@ without implementing safeguards against external entity expansion.\", // Security alert: Unprotected XML processing\n  userInputOrigin.getNode(), \"user-controlled input\" // Input source identification and labeling"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * Generate a comprehensive summary of the analyzed Python snapshot\n * by collecting various metadata and metrics into key-value pairs.\n */\n\nimport python\n\n// Retrieve snapshot information as key-value pairs\nfrom string infoKey, string infoValue\nwhere\n  // Extractor version information\n  infoKey = \"Extractor version\" and py_flags_versioned(\"extractor.version\", infoValue, _)\n  or\n  // Snapshot build timestamp\n  infoKey = \"Snapshot build time\" and\n  exists(date buildDate | snapshotDate(buildDate) and infoValue = buildDate.toString())\n  or\n  // Python interpreter version in major.minor format\n  infoKey = \"Interpreter version\" and\n  exists(string majorVersion, string minorVersion |\n    py_flags_versioned(\"extractor_python_version.major\", majorVersion, _) and\n    py_flags_versioned(\"extractor_python_version.minor\", minorVersion, _) and\n    infoValue = majorVersion + \".\" + minorVersion\n  )\n  or\n  // Build platform with user-friendly names\n  infoKey = \"Build platform\" and\n  exists(string platformRaw | py_flags_versioned(\"sys.platform\", platformRaw, _) |\n    if platformRaw = \"win32\"\n    then infoValue = \"Windows\"\n    else\n      if platformRaw = \"linux2\"\n      then infoValue = \"Linux\"\n      else\n        if platformRaw = \"darwin\"\n        then infoValue = \"OSX\"\n        else infoValue = platformRaw\n  )\n  or\n  // Source code location prefix\n  infoKey = \"Source location\" and sourceLocationPrefix(infoValue)\n  or\n  // Total lines of source code (only counting files with relative paths)\n  infoKey = \"Lines of code (source)\" and\n  infoValue =\n    sum(ModuleMetrics moduleMetric | exists(moduleMetric.getFile().getRelativePath()) | \n        moduleMetric.getNumberOfLinesOfCode()).toString()\n  or\n  // Total lines of code including all files\n  infoKey = \"Lines of code (total)\" and\n  infoValue = sum(ModuleMetrics moduleMetric | any() | moduleMetric.getNumberOfLinesOfCode()).toString()\nselect infoKey, infoValue"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/percent-format/wrong-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies string formatting using % operator where conversion specifier",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Mismatched argument count in percent formatting\n * @description Identifies string formatting using % operator where conversion specifier \n *              count in format string doesn't match provided argument count. \n *              This mismatch causes runtime TypeError.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/percent-format/wrong-arguments\n */\n\nimport python\nimport semmle.python.strings\n\n/**\n * Detects percent-style string formatting operations.\n * @param fmtExpr - Binary expression representing formatting operation\n * @param fmtStrLiteral - Format string literal used in operation\n * @param argValues - Values intended for formatting\n * @param argSrc - AST node representing argument source\n */\npredicate isPercentFormatOperation(BinaryExpr fmtExpr, StringLiteral fmtStrLiteral, Value argValues, AstNode argSrc) {\n  // Verify modulo operator usage\n  fmtExpr.getOp() instanceof Mod and\n  exists(Context context |\n    // Resolve left operand to format string literal\n    fmtExpr.getLeft().pointsTo(context, _, fmtStrLiteral) and\n    // Resolve right operand to argument values\n    fmtExpr.getRight().pointsTo(context, argValues, argSrc)\n  )\n}\n\n/**\n * Computes actual argument count in sequence.\n * @param argValues - Value representing argument sequence\n * @return Number of arguments present\n */\nint getArgumentCount(Value argValues) {\n  // Handle tuple arguments (excluding starred expressions)\n  exists(Tuple tuple | tuple.pointsTo(argValues, _) |\n    result = strictcount(tuple.getAnElt()) and\n    not tuple.getAnElt() instanceof Starred\n  )\n  or\n  // Handle single literal arguments\n  exists(ImmutableLiteral literal | literal.getLiteralValue() = argValues | result = 1)\n}\n\nfrom\n  BinaryExpr formatExpr, StringLiteral fmtStr, Value argValues, \n  int argCount, int specCount, AstNode argSrcNode, string msgSuffix\nwhere\n  // Identify percent-style formatting operations\n  isPercentFormatOperation(formatExpr, fmtStr, argValues, argSrcNode) and\n  // Calculate provided argument count\n  argCount = getArgumentCount(argValues) and\n  // Count format specifiers in the string\n  specCount = format_items(fmtStr) and\n  // Detect mismatch between arguments and format specifiers\n  argCount != specCount and\n  // Generate context-aware message suffix\n  (if argCount = 1 then msgSuffix = \" is provided.\" else msgSuffix = \" are provided.\")\nselect formatExpr,\n  \"Incorrect number of $@ for string formatting. Format $@ expects \" + \n    specCount.toString() + \" values, but \" + argCount.toString() + msgSuffix, \n  argSrcNode, \"arguments\", fmtStr, fmtStr.getText()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Missing docstring\n * @description The absence of documentation strings in public classes, functions, \n *              or methods hinders code maintainability, as it makes it challenging \n *              for other developers to comprehend the code's intent and usage.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/missing-docstring\n */\n\n/*\n * Note: This query has medium precision because determining the need for a docstring \n * is inherently subjective. The requirement often varies based on the code's context \n * and its intended audience.\n */\n\nimport python\n\n_______________ // 补全条件\npredicate requires_documentation(Scope scope) {\n  scope.isPublic() and\n  (\n    not scope instanceof Function\n    or\n    function_needs_documentation(scope)\n  )\n}\n\n// Determines if a function requires documentation\npredicate function_needs_documentation(Function func) {\n  // Exclude lambda functions\n  func.getName() != \"lambda\" and\n  // Calculate actual code lines (excluding decorators)\n  (func.getMetrics().getNumberOfLinesOfCode() - count(func.getADecorator())) > 2 and\n  // Ensure it's not a property getter/setter\n  not exists(PythonPropertyObject property |\n    property.getGetter().getFunction() = func or\n    property.getSetter().getFunction() = func\n  ) and\n  // Validate override documentation requirements\n  not exists(FunctionValue overridingFunc, FunctionValue baseFunc | \n    overridingFunc.overrides(baseFunc) and overridingFunc.getScope() = func |\n    not function_needs_documentation(baseFunc.getScope())\n  )\n}\n\n// Returns the type name of a scope (Module, Class, or Function)\nstring get_scope_type_name(Scope scope) {\n  // Handle non-package modules\n  result = \"Module\" and scope instanceof Module and not scope.(Module).isPackage()\n  or\n  // Handle classes\n  result = \"Class\" and scope instanceof Class\n  or\n  // Handle functions\n  result = \"Function\" and scope instanceof Function\n}\n\n// Identifies scopes requiring documentation but missing it\nfrom Scope scope\nwhere requires_documentation(scope) and not exists(scope.getDocString())\nselect scope, get_scope_type_name(scope) + \" \" + scope.getName() + \" does not have a docstring.\"",
    "output": "// Determines if a scope requires documentation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/old-style-octal-literal]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects octal literals that use the old-style notation (leading 0),",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Confusing octal literal\n * @description Detects octal literals that use the old-style notation (leading 0),\n *              which can be confusing as they appear similar to decimal numbers\n *              but have different values.\n * @kind problem\n * @tags readability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/old-style-octal-literal\n */\n\nimport python\n\n/**\n * Identifies integer literals that use the legacy octal notation (starting with 0\n * but without the 0o prefix). This notation is confusing because it looks like a\n * decimal number but represents a different value. The predicate excludes the\n * special case \"00\" and common file permission representations (with lengths 4, 5, or 7).\n */\npredicate uses_legacy_octal_notation(IntegerLiteral octalLiteral) {\n  exists(string literalValue | \n    literalValue = octalLiteral.getText() and\n    // Basic check: starts with '0' and has at least one more digit\n    literalValue.charAt(0) = \"0\" and\n    literalValue.length() > 1 and\n    exists(literalValue.charAt(1).toInt()) and\n    // Exclusions: not \"00\" and not common file permission patterns\n    not literalValue = \"00\" and\n    not literalValue.length() in [4, 5, 7]\n  )\n}\n\n// Query to find all integer literals that use the confusing legacy octal format\nfrom IntegerLiteral octalLiteral\nwhere uses_legacy_octal_notation(octalLiteral)\nselect octalLiteral, \"Confusing octal literal, use 0o\" + octalLiteral.getText().suffix(1) + \" instead.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-comments-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the total comment lines per file (including docstrings,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File Comment Line Count\n * @kind treemap\n * @description Calculates the total comment lines per file (including docstrings,\n *              excluding pure code lines and blank lines).\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg sum max\n * @id py/lines-of-comments-in-files\n */\n\nimport python // 导入Python分析模块，提供Python代码结构分析功能\n\n// 遍历所有Python模块，计算每个模块中的注释总行数\n// 注释包括常规注释行和文档字符串行\nfrom Module pythonModule, int totalCommentLines\nwhere\n  // 计算总注释行数：常规注释行数加上文档字符串行数\n  totalCommentLines = \n    pythonModule.getMetrics().getNumberOfLinesOfComments() + \n    pythonModule.getMetrics().getNumberOfLinesOfDocStrings()\nselect pythonModule, totalCommentLines order by totalCommentLines desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Identical Value Comparison\n * @description Detects comparisons where a value is compared against itself,\n *              which usually represents a logical mistake or ambiguous code intention.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n_______________ // 补全条件\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\nimport python  // Core Python library for code analysis\nimport Expressions.RedundantComparison  // Module for detecting redundant comparison expressions\n\n// Define the main query to find identical value comparisons\nfrom RedundantComparison identicalComparison\n\n// Apply filters to reduce false positives\nwhere \n  // Filter out constant comparisons which could be intentional\n  not identicalComparison.isConstant() and \n  // Filter out cases where 'self' might be missing to avoid false alarms\n  not identicalComparison.maybeMissingSelf()\n\n// Output the results with an appropriate warning message\nselect identicalComparison, \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\"",
    "output": "* @problem.severity warning"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-input]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of the built-in 'input' function in Python 2, which can execute arbitrary code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'input' function used in Python 2\n * @description Detects usage of the built-in 'input' function in Python 2, which can execute arbitrary code.\n * @kind problem\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/use-of-input\n */\n\nimport python  // 导入Python库，用于分析Python代码\nimport semmle.python.dataflow.new.DataFlow  // 导入数据流分析库\nimport semmle.python.ApiGraphs  // 导入API图分析库\n\n// 查找Python 2中对不安全的'input'函数的调用\nfrom DataFlow::CallCfgNode unsafeInputCall\nwhere\n  // 确保代码运行在Python 2环境中\n  major_version() = 2 and\n  // 查找对内置'input'函数的调用\n  unsafeInputCall = API::builtin(\"input\").getACall() and\n  // 排除对'raw_input'函数的调用，因为它是安全的\n  unsafeInputCall != API::builtin(\"raw_input\").getACall()\nselect unsafeInputCall, \"The unsafe built-in function 'input' is used in Python 2.\"  // 报告不安全的'input'函数调用"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Imprecise assert\n * @description Using 'assertTrue' or 'assertFalse' rather than a more specific assertion can give uninformative failure messages.\n * @kind problem\n * @tags maintainability\n *       testability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/imprecise-assert\n */\n\nimport python\n\n/* Helper predicate identifying comparison-based assertion calls */\npredicate isComparisonBasedAssert(Call assertionCall, string methodName, Cmpop comparisonOperator) {\n  // Verify the call targets assertTrue/assertFalse methods\n  assertionCall.getFunc().(Attribute).getName() = methodName and\n  (methodName = \"assertTrue\" or methodName = \"assertFalse\") and\n  exists(Compare comparisonExpr |\n    // Ensure first argument is a comparison operation\n    comparisonExpr = assertionCall.getArg(0) and\n    /* Exclude chained comparisons like: a < b < c */\n    // Reject complex multi-operator comparisons\n    not exists(comparisonExpr.getOp(1)) and\n    comparisonOperator = comparisonExpr.getOp(0)\n  )\n}\n\nclass CallToAssertOnComparison extends Call {\n  // Constructor matches comparison-based assertions\n  CallToAssertOnComparison() { isComparisonBasedAssert(this, _, _) }\n\n  // Retrieve the comparison operator used\n  Cmpop getOperator() { isComparisonBasedAssert(this, _, result) }\n\n  // Get the name of the assertion method\n  string getMethodName() { isComparisonBasedAssert(this, result, _) }\n\n  // Determine the recommended specific assertion method\n  string getBetterName() {\n    exists(Cmpop operator |\n      // Handle assertTrue cases\n      isComparisonBasedAssert(this, \"assertTrue\", operator) and\n      (\n        operator instanceof Eq and result = \"assertEqual\"\n        or\n        operator instanceof NotEq and result = \"assertNotEqual\"\n        or\n        operator instanceof Lt and result = \"assertLess\"\n        or\n        operator instanceof LtE and result = \"assertLessEqual\"\n        or\n        operator instanceof Gt and result = \"assertGreater\"\n        or\n        operator instanceof GtE and result = \"assertGreaterEqual\"\n        or\n        operator instanceof In and result = \"assertIn\"\n        or\n        operator instanceof NotIn and result = \"assertNotIn\"\n        or\n        operator instanceof Is and result = \"assertIs\"\n        or\n        operator instanceof IsNot and result = \"assertIsNot\"\n      )\n      or\n      // Handle assertFalse cases\n      isComparisonBasedAssert(this, \"assertFalse\", operator) and\n      (\n        operator instanceof NotEq and result = \"assertEqual\"\n        or\n_______________ // 补全条件\n        or\n        operator instanceof GtE and result = \"assertLess\"\n        or\n        operator instanceof Gt and result = \"assertLessEqual\"\n        or\n        operator instanceof LtE and result = \"assertGreater\"\n        or\n        operator instanceof Lt and result = \"assertGreaterEqual\"\n        or\n        operator instanceof NotIn and result = \"assertIn\"\n        or\n        operator instanceof In and result = \"assertNotIn\"\n        or\n        operator instanceof IsNot and result = \"assertIs\"\n        or\n        operator instanceof Is and result = \"assertIsNot\"\n      )\n    )\n  }\n}\n\nfrom CallToAssertOnComparison assertionCall\nwhere\n  /* Exclude assertions with explicit failure messages */\n  // Filter out cases where custom message is provided\n  not exists(assertionCall.getArg(1))\nselect assertionCall,\n  // Generate recommendation message with specific assertion alternatives\n  assertionCall.getMethodName() + \"(a \" + assertionCall.getOperator().getSymbol() + \" b) \" +\n    \"cannot provide an informative message. Using \" + assertionCall.getBetterName() +\n    \"(a, b) instead will give more informative messages.\"",
    "output": "operator instanceof Eq and result = \"assertNotEqual\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-be-context-manager]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes that use __del__ for resource management",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class should be a context manager\n * @description Identifies classes that use __del__ for resource management\n *              but lack context manager protocol support. Such classes would\n *              benefit from implementing the context manager pattern to improve\n *              resource handling and code readability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision medium\n * @id py/should-be-context-manager\n */\n\nimport python\n\nfrom ClassValue resourceClass\nwhere\n  // Focus on user-defined classes, excluding built-in ones\n  not resourceClass.isBuiltin()\n  and\n  // Check for presence of __del__ method, typically used for resource cleanup\n  exists(resourceClass.declaredAttribute(\"__del__\"))\n  and\n  // Verify the class does not implement the context manager protocol\n  not resourceClass.isContextManager()\nselect resourceClass,\n  \"Class \" + resourceClass.getName() +\n    \" implements __del__ (presumably to release some resource). Consider making it a context manager.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inconsistent-mro]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python classes with inheritance hierarchies causing MRO conflicts,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent method resolution order\n * @description Detects Python classes with inheritance hierarchies causing MRO conflicts,\n *              which may lead to runtime type errors during class construction\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n/**\n * Identifies classes that cannot be constructed due to inheritance conflicts.\n * The query detects when a class inherits from two classes where one is an\n * improper superclass of the other, creating an invalid method resolution order.\n */\nfrom ClassObject targetCls, ClassObject baseA, ClassObject baseB\nwhere \n  // Ensure new-style class semantics\n  targetCls.isNewStyle() and\n  // Check consecutive base classes for improper inheritance relationships\n  exists(int position | \n    position > 0 and \n    baseB = targetCls.getBaseType(position) and \n    baseA = targetCls.getBaseType(position - 1) and\n    baseA = baseB.getAnImproperSuperType()\n  )\nselect targetCls,\n  \"Construction of class \" + targetCls.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", baseA,\n  baseA.getName(), baseB, baseB.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of parameters without defaults\n * @description This analysis identifies Python functions with parameters lacking default values.\n *              Functions with many non-default parameters tend to be more complex and harder to test,\n *              as they require more arguments to be explicitly provided during invocation.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // Import Python module for static code analysis capabilities\n\n// Define the analysis scope: examine all Python functions to evaluate their parameter complexity\nfrom FunctionMetrics targetFunction\n_______________ // 补全条件\nwhere exists(targetFunction.getNumberOfParametersWithoutDefault())\n// Select the target function and its count of non-default parameters for complexity assessment\nselect targetFunction, \n       targetFunction.getNumberOfParametersWithoutDefault() as nonDefaultParamCount \n// Order results by non-default parameter count in descending order to highlight most complex functions first\norder by nonDefaultParamCount desc",
    "output": "// Calculate the count of parameters without default values for each function"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 不完整的URL子串消毒\n * @description 对未解析URL的子串进行安全检查存在绕过风险，\n *              因为这些检查未考虑完整的URL结构\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// 定义用于URL验证的常见顶级域名正则表达式模式\nprivate string getTopLevelDomainPattern() { result = \"com|org|edu|gov|uk|net|io\" }\n\n// 判断字符串字面量是否包含URL特征模式\npredicate hasUrlCharacteristics(StringLiteral urlLiteral) {\n_______________ // 补全条件\n    literalContent.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + getTopLevelDomainPattern() + \")(:[0-9]+)?/?\")\n    or\n    literalContent.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// 检测直接字符串比较操作\npredicate isDirectStringComparison(Expr sanitizationOp, StringLiteral urlLiteral) {\n  exists(Compare comparisonOp | \n    comparisonOp.compares(urlLiteral, any(In i), _) and\n    sanitizationOp = comparisonOp\n  )\n}\n\n// 检测不安全的startswith使用\npredicate isUnsafeStartsWithUsage(Expr sanitizationOp, StringLiteral urlLiteral) {\n  exists(Call methodCall | \n    methodCall.getFunc().(Attribute).getName() = \"startswith\" and\n    methodCall.getArg(0) = urlLiteral and\n    not urlLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\") and\n    sanitizationOp = methodCall\n  )\n}\n\n// 检测不安全的endswith使用\npredicate isUnsafeEndsWithUsage(Expr sanitizationOp, StringLiteral urlLiteral) {\n  exists(Call methodCall | \n    methodCall.getFunc().(Attribute).getName() = \"endswith\" and\n    methodCall.getArg(0) = urlLiteral and\n    not urlLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\") and\n    sanitizationOp = methodCall\n  )\n}\n\n// 识别执行不完整URL子串消毒的表达式\npredicate exhibitsIncompleteSanitization(Expr sanitizationOp, StringLiteral urlLiteral) {\n  hasUrlCharacteristics(urlLiteral) and\n  (\n    isDirectStringComparison(sanitizationOp, urlLiteral) or\n    isUnsafeStartsWithUsage(sanitizationOp, urlLiteral) or\n    isUnsafeEndsWithUsage(sanitizationOp, urlLiteral)\n  )\n}\n\n// 查找所有存在不完整URL子串消毒模式的表达式\nfrom Expr sanitizationOp, StringLiteral urlLiteral\nwhere exhibitsIncompleteSanitization(sanitizationOp, urlLiteral)\nselect sanitizationOp, \"字符串 $@ 可能位于被消毒URL的任意位置。\", urlLiteral,\n  urlLiteral.getText()",
    "output": "exists(string literalContent | literalContent = urlLiteral.getText() |"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Duplicate function\n * @description Detects functions with identical implementations. Consider refactoring by extracting shared code into common modules or base classes.\n * @kind problem\n * @tags testability\n *       useless-code\n *       maintainability\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n_______________ // 补全条件\n * @id py/duplicate-function\n */\n\nimport python\n\n// Analysis variables for duplicate function detection\nfrom Function originalFn, Function duplicateFn, string diagnosticMessage\n// Placeholder condition - disabled pending future implementation\nwhere \n  none()\n// Output format: original function, diagnostic message, duplicate function, and its name\nselect \n  originalFn, \n  diagnosticMessage, \n  duplicateFn, \n  duplicateFn.getName()",
    "output": "* @precision high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Module imports itself\n * @description Detects modules that import themselves directly\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n/**\n * Identifies modules that directly import themselves\n * \n * This predicate detects Python modules that import themselves, which is typically\n * an unnecessary code pattern that can lead to circular dependencies and maintenance issues.\n * \n_______________ // 补全条件\n * - importStmt: The import statement being analyzed\n * - importedModule: The module being imported\n */\npredicate isSelfImport(ImportingStmt importStmt, ModuleValue importedModule) {\n  // Check if the importing module's scope matches the imported module's scope\n  importStmt.getEnclosingModule() = importedModule.getScope() and\n  // Find the most specific module match using longest-name priority\n  importedModule = \n    max(string importedName, ModuleValue moduleCandidate |\n      // Get the module name referenced in the import statement\n      importedName = importStmt.getAnImportedModuleName() and\n      // Verify the candidate module is imported under this name\n      moduleCandidate.importedAs(importedName)\n    |\n      // Prioritize longest matching names for correct relative import handling\n      moduleCandidate order by importedName.length() desc\n    )\n}\n\n// Main query: Identify all self-importing module instances\n// \n// This query scans all import statements and uses the isSelfImport predicate\n// to filter statements where a module imports itself, generating warnings.\nfrom ImportingStmt importStmt, ModuleValue importedModule\nwhere isSelfImport(importStmt, importedModule)\nselect importStmt, \"The module '\" + importedModule.getName() + \"' imports itself.\"",
    "output": "* Parameters:"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/encoding-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别Python代码中可能引起运行时异常并妨碍静态分析的编码缺陷。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Encoding error\n * @description 识别Python代码中可能引起运行时异常并妨碍静态分析的编码缺陷。\n *              此类问题通常源于文件编码声明与实际内容不符，或字符串编码操作不当，\n *              可能引发UnicodeDecodeError等运行时错误。\n * @kind problem\n * @id py/encoding-error\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n */\n\nimport python\n\n// 识别Python代码中存在的所有编码问题\n// 这些问题涵盖编码声明不匹配、文件编码与实际内容不符等多种情况\nfrom EncodingError encodingProblem\n\n// 输出检测到的编码问题及其相关描述信息\n// 描述信息将详细说明问题性质，协助开发人员定位和解决编码问题\nselect encodingProblem, encodingProblem.getMessage()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/ineffectual-statement]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies statements that have no effect on the program's behavior",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Statement has no effect\n * @description Identifies statements that have no effect on the program's behavior\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/ineffectual-statement\n */\n\nimport python\n\n// Determines if an attribute access is understood by the analysis\npredicate is_attribute_understood(Attribute attributeAccess, ClassValue sourceClass, ClassValue attributeClass) {\n  exists(string attributeName | attributeAccess.getName() = attributeName |\n    attributeAccess.getObject().pointsTo().getClass() = sourceClass and\n    sourceClass.attr(attributeName).getClass() = attributeClass\n  )\n}\n\n/* Conservatively estimates if attribute access might have side effects */\npredicate has_side_effecting_attribute(Attribute attributeAccess) {\n  exists(ClassValue attributeClass |\n    is_attribute_understood(attributeAccess, _, attributeClass) and\n    is_descriptor_type_side_effecting(attributeClass)\n  )\n}\n\n// Determines if an attribute access might potentially have side effects\npredicate might_have_side_effect_attribute(Attribute attributeAccess) {\n  not is_attribute_understood(attributeAccess, _, _) and not attributeAccess.pointsTo(_)\n  or\n  has_side_effecting_attribute(attributeAccess)\n}\n\n// Checks if a descriptor type is known to have side effects\npredicate is_descriptor_type_side_effecting(ClassValue descriptor) {\n  descriptor.isDescriptorType() and\n  // Technically all descriptor accesses have side effects, but some represent missing calls\n  // which we want to treat as having no effect.\n  not descriptor = ClassValue::functionType() and\n  not descriptor = ClassValue::staticmethod() and\n  not descriptor = ClassValue::classmethod()\n}\n\n/**\n * Binary operators with side effects are rare, so we assume they have no side effects\n * unless we know otherwise.\n */\npredicate has_side_effecting_binary(Expr binaryExpr) {\n  exists(Expr subExpr, ClassValue exprClass, string methodName |\n    is_binary_operator_special_method(binaryExpr, subExpr, exprClass, methodName)\n    or\n    is_comparison_special_method(binaryExpr, subExpr, exprClass, methodName)\n  |\n    methodName = get_special_method_name() and\n    exprClass.hasAttribute(methodName) and\n    not exists(ClassValue declaringClass |\n      declaringClass.declaresAttribute(methodName) and\n      declaringClass = exprClass.getASuperType() and\n      declaringClass.isBuiltin() and\n      not declaringClass = ClassValue::object()\n    )\n  )\n}\n\npragma[nomagic]\nprivate predicate is_binary_operator_special_method(\n  BinaryExpr binaryExpr, Expr subExpr, ClassValue exprClass, string methodName\n) {\n  methodName = get_special_method_name() and\n  subExpr = binaryExpr.getLeft() and\n  methodName = binaryExpr.getOp().getSpecialMethodName() and\n  subExpr.pointsTo().getClass() = exprClass\n}\n\npragma[nomagic]\nprivate predicate is_comparison_special_method(Compare comparisonExpr, Expr subExpr, ClassValue exprClass, string methodName) {\n  exists(Cmpop op |\n    comparisonExpr.compares(subExpr, op, _) and\n    methodName = op.getSpecialMethodName()\n  ) and\n  subExpr.pointsTo().getClass() = exprClass\n}\n\nprivate string get_special_method_name() {\n  result = any(Cmpop c).getSpecialMethodName()\n  or\n  result = any(BinaryExpr b).getOp().getSpecialMethodName()\n}\n\n// Determines if a file is a Jupyter/IPython notebook\npredicate is_jupyter_notebook(File sourceFile) {\n  exists(Comment comment | comment.getLocation().getFile() = sourceFile |\n    comment.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\n/** Expressions (statements) within Jupyter/IPython notebooks */\npredicate is_in_notebook(Expr expr) { is_jupyter_notebook(expr.getScope().(Module).getFile()) }\n\n// Retrieves the FunctionValue object for the assertRaises method in unittest.TestCase\nFunctionValue get_unittest_assert_raises() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\n/** Holds if expression `expr` is within a `with` block that tests for exception raising. */\npredicate is_in_exception_test(Expr expr) {\n  exists(With withBlock |\n    withBlock.contains(expr) and\n    withBlock.getContextExpr() = get_unittest_assert_raises().getACall().getNode()\n  )\n}\n\n/** Holds if expression `expr` has the form of a Python 2 `print >> out, ...` statement */\npredicate is_python2_print(Expr expr) {\n  expr.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n  expr.(BinaryExpr).getOp() instanceof RShift\n  or\n  is_python2_print(expr.(Tuple).getElt(0))\n}\n\n// Determines if an expression has no effect\npredicate has_no_effect(Expr expr) {\n  // Strings can be used as comments\n  not expr instanceof StringLiteral and\n  not expr.hasSideEffects() and\n  forall(Expr subExpr | subExpr = expr.getASubExpression*() |\n    not has_side_effecting_binary(subExpr) and\n    not might_have_side_effect_attribute(subExpr)\n  ) and\n  not is_in_notebook(expr) and\n  not is_in_exception_test(expr) and\n  not is_python2_print(expr)\n}\n\n// Selects expression statements that have no effect and report them as issues\nfrom ExprStmt statement\nwhere has_no_effect(statement.getValue())\nselect statement, \"This statement has no effect.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/functions-and-methods-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides a count of functions and methods contained within each file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Functions and methods per file\n * @description Provides a count of functions and methods contained within each file.\n * @kind treemap\n * @id py/functions-and-methods-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python // 引入Python分析模块，支持代码结构解析\n\nfrom Module sourceModule, int funcQuantity\n// 定义计算条件：统计每个源模块中排除lambda函数后的函数总数\nwhere funcQuantity = count(Function funcItem | \n       funcItem.getEnclosingModule() = sourceModule and \n       funcItem.getName() != \"lambda\")\n// 输出结果：模块对象及其函数计数，按函数数量从高到低排序\nselect sourceModule, funcQuantity order by funcQuantity desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incoming class dependencies\n * @description Count of classes that have dependencies on a given class.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// 查询每个类的传入耦合度（即依赖于该类的其他类数量），\n// 并按照耦合度从高到低排序\n_______________ // 补全条件\nselect classMetric, classMetric.getAfferentCoupling() as couplingCount order by couplingCount desc",
    "output": "from ClassMetrics classMetric"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-hashes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Finds uses of cryptography algorithms that are unapproved or otherwise weak.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak hashes\n * @description Finds uses of cryptography algorithms that are unapproved or otherwise weak.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// 导入Python库和实验性加密概念库\nimport python\nimport experimental.cryptography.Concepts\n\n// 从HashAlgorithm操作符、字符串名称和消息中选择数据\nfrom HashAlgorithm op, string name, string msg\nwhere\n  // 获取哈希算法的名称并赋值给变量name\n  name = op.getHashName() and\n  // 过滤掉SHA256, SHA384, SHA512这些被认可的强哈希算法\n  not name = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // 如果哈希算法名称未知，则设置消息为“使用未识别的哈希算法”\n  if name = unknownAlgorithm()\n  then msg = \"Use of unrecognized hash algorithm.\"\n  // 否则，设置消息为“使用未经批准的哈希算法或API”并附加算法名称\n  else msg = \"Use of unapproved hash algorithm or API \" + name + \".\"\nselect op, msg"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/diagnostics/successfully-extracted-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：此查询用于识别并列出源代码树中所有成功提取的Python源文件。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 提取的Python文件\n * @description 此查询用于识别并列出源代码树中所有成功提取的Python源文件。\n *              通过验证文件是否具有有效的相对路径，我们可以确认文件是否被正确提取。\n *              这是代码分析过程中的重要步骤，确保后续分析基于完整的源代码。\n * @kind diagnostic\n * @id py/diagnostics/successfully-extracted-files\n * @tags successfully-extracted-files\n */\n\nimport python\n\n// 查询所有Python文件，并筛选出具有有效相对路径的文件\n// 这些文件表示已成功从源代码树中提取的Python模块\nfrom File extractedPyFile\nwhere exists(extractedPyFile.getRelativePath())\n// 输出文件对象和空字符串（保持格式一致性）\nselect extractedPyFile, \"\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-protocol]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects configurations using deprecated SSL/TLS protocol versions vulnerable to attacks",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of insecure SSL/TLS version\n * @description Detects configurations using deprecated SSL/TLS protocol versions vulnerable to attacks\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n/* Represents protocol configuration nodes using insecure SSL/TLS versions */\nclass InsecureProtocolConfig extends DataFlow::Node {\n  InsecureProtocolConfig() {\n    /* Case 1: Insecure connection with context */\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    /* Case 2: Insecure connection without context */\n    unsafe_connection_creation_without_context(this, _)\n    or\n    /* Case 3: Insecure context creation */\n    unsafe_context_creation(this, _)\n  }\n\n  /* Retrieves the function node associated with this configuration */\n  DataFlow::Node getFunctionNode() { result = this.(DataFlow::CallCfgNode).getFunction() }\n}\n\n/* Represents nodes that can be qualified (function calls or attribute references) */\nclass QualifiedNode extends DataFlow::Node {\n  QualifiedNode() {\n    /* Case 1: Node from protocol configuration function */\n    this = any(InsecureProtocolConfig cfg).getFunctionNode()\n    or\n    /* Case 2: Attribute reference of another qualified node */\n    this = any(QualifiedNode base).(DataFlow::AttrRef).getObject()\n  }\n}\n\n/* Builds qualified name for nodes with hierarchical naming */\nstring getQualifiedName(QualifiedNode n) {\n  /* Case 1: Direct function name */\n  result = n.asExpr().(Name).getId()\n  or\n  /* Case 2: Attribute access chain */\n  exists(DataFlow::AttrRef attr | attr = n |\n    result = getQualifiedName(attr.getObject()) + \".\" + attr.getAttributeName()\n  )\n}\n\n/* Generates descriptive label for protocol configuration */\nstring getConfigLabel(InsecureProtocolConfig cfg) {\n  /* Case 1: Function call configuration */\n  exists(DataFlow::CallCfgNode call | call = cfg |\n    result = \"call to \" + getQualifiedName(call.getFunction())\n  )\n  or\n  /* Case 2: Non-call context modification */\n  not cfg instanceof DataFlow::CallCfgNode and\n  not cfg instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n/* Determines appropriate verb based on specificity flag */\nstring getVerb(boolean specificFlag) {\n  specificFlag = true and result = \"specified\"\n  or\n  specificFlag = false and result = \"allowed\"\n}\n\n/* Main query detecting insecure SSL/TLS version usage */\nfrom\n  DataFlow::Node connNode, string version, \n  InsecureProtocolConfig cfgNode, boolean specificFlag\nwhere\n  /* Case 1: Insecure connection with context */\n  unsafe_connection_creation_with_context(connNode, version, cfgNode, specificFlag)\n  or\n  /* Case 2: Insecure connection without context */\n  unsafe_connection_creation_without_context(connNode, version) and\n  cfgNode = connNode and\n  specificFlag = true\n  or\n  /* Case 3: Insecure context creation */\n  unsafe_context_creation(cfgNode, version) and\n  connNode = cfgNode and\n  specificFlag = true\nselect connNode,\n  \"Insecure SSL/TLS protocol version \" + version + \" \" + getVerb(specificFlag) + \" by $@.\",\n  cfgNode, getConfigLabel(cfgNode)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Snapshot Metadata Overview\n * @description Generates a detailed summary of snapshot metadata, encompassing\n *              extractor information, build details, Python interpreter version,\n *              platform specifics, source location, and code statistics.\n */\n\nimport python\n\n// Define key-value pairs for snapshot metadata\n_______________ // 补全条件\nwhere\n  // Extractor version identification\n  metadataKey = \"Extractor version\" and \n  py_flags_versioned(\"extractor.version\", metadataValue, _)\n  or\n  // Snapshot build timestamp\n  metadataKey = \"Snapshot build time\" and\n  exists(date snapshotDate | snapshotDate(snapshotDate) and metadataValue = snapshotDate.toString())\n  or\n  // Python interpreter version in major.minor format\n  metadataKey = \"Interpreter version\" and\n  exists(string majorVersion, string minorVersion |\n    py_flags_versioned(\"extractor_python_version.major\", majorVersion, _) and\n    py_flags_versioned(\"extractor_python_version.minor\", minorVersion, _) and\n    metadataValue = majorVersion + \".\" + minorVersion\n  )\n  or\n  // Build platform with user-friendly naming\n  metadataKey = \"Build platform\" and\n  exists(string rawPlatform | py_flags_versioned(\"sys.platform\", rawPlatform, _) |\n    if rawPlatform = \"win32\"\n    then metadataValue = \"Windows\"\n    else\n      if rawPlatform = \"linux2\"\n      then metadataValue = \"Linux\"\n      else\n        if rawPlatform = \"darwin\"\n        then metadataValue = \"OSX\"\n        else metadataValue = rawPlatform\n  )\n  or\n  // Source code location prefix path\n  metadataKey = \"Source location\" and sourceLocationPrefix(metadataValue)\n  or\n  // Total lines of source code (excluding generated code)\n  metadataKey = \"Lines of code (source)\" and\n  metadataValue =\n    sum(ModuleMetrics moduleMetrics | exists(moduleMetrics.getFile().getRelativePath()) | \n        moduleMetrics.getNumberOfLinesOfCode()).toString()\n  or\n  // Total lines of code (including all generated code)\n  metadataKey = \"Lines of code (total)\" and\n  metadataValue = sum(ModuleMetrics moduleMetrics | any() | moduleMetrics.getNumberOfLinesOfCode()).toString()\nselect metadataKey, metadataValue",
    "output": "from string metadataKey, string metadataValue"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/nested-loops-with-same-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects nested loops where both outer and inner loops utilize identical variables",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Nested loops reusing iteration variable\n * @description Detects nested loops where both outer and inner loops utilize identical variables\n *              as their iteration target. This practice may cause the inner loop to overwrite\n *              the outer loop's variable, resulting in unexpected behavior and diminished code clarity.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\n// Check if a loop variable is used as the iteration target in a for loop\npredicate loopUsesVariableAsTarget(For loopStatement, Variable loopVariable) { \n  loopStatement.getTarget().defines(loopVariable) \n}\n\n// Find nested loops that share the same iteration variable,\n// and where the variable is referenced outside the inner loop's scope\npredicate hasConflictingNestedLoop(For innerLoop, For outerLoop, Variable sharedVariable) {\n  // The inner loop must be directly contained within the outer loop's body\n  outerLoop.getBody().contains(innerLoop) and\n  // Both loops must use the same variable as their iteration target\n  loopUsesVariableAsTarget(innerLoop, sharedVariable) and\n  loopUsesVariableAsTarget(outerLoop, sharedVariable) and\n  // The shared variable must be referenced in the outer loop but outside the inner loop\n  exists(Name variableReference | \n    variableReference.uses(sharedVariable) and \n    outerLoop.contains(variableReference) and \n    not innerLoop.contains(variableReference)\n  )\n}\n\n// Query to identify and report nested loops with problematic shared iteration variables\nfrom For innerForLoop, For outerForLoop, Variable iterationVariable\nwhere hasConflictingNestedLoop(innerForLoop, outerForLoop, iterationVariable)\nselect innerForLoop, \n  \"Nested for loop reuses iteration variable '\" + iterationVariable.getId() + \n  \"' from enclosing $@.\", \n  outerForLoop, \n  \"outer for loop\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Signature mismatch in overriding method\n * @description Detects when a method overrides another method but has a different signature,\n *              which can lead to runtime errors due to parameter count or type mismatches.\n_______________ // 补全条件\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python  // 导入Python库，用于分析Python代码\nimport Expressions.CallArgs  // 导入表达式调用参数模块\n\n// 定义查询，用于检测方法重写时的签名不匹配问题\nfrom FunctionValue baseFunction, PythonFunctionValue derivedFunction  // 从基类函数和派生类函数中选择数据\nwhere\n  // 确保基类函数没有被直接调用\n  not exists(baseFunction.getACall()) and\n  \n  // 确保没有其他派生类函数重写了基类函数并且被调用\n  not exists(FunctionValue otherDerived |\n    otherDerived.overrides(baseFunction) and\n    exists(otherDerived.getACall())\n  ) and\n  \n  // 排除特殊方法和构造函数\n  not derivedFunction.getScope().isSpecialMethod() and\n  derivedFunction.getName() != \"__init__\" and\n  \n  // 确保派生类函数是普通方法\n  derivedFunction.isNormalMethod() and\n  \n  // 检查派生类函数是否重写了基类函数，并且参数数量不匹配\n  derivedFunction.overrides(baseFunction) and\n  (\n    // 派生类函数的最小参数数量大于基类函数的最大参数数量\n    derivedFunction.minParameters() > baseFunction.maxParameters()\n    or\n    // 派生类函数的最大参数数量小于基类函数的最小参数数量\n    derivedFunction.maxParameters() < baseFunction.minParameters()\n  )\n\n// 选择派生类函数并生成警告信息，同时标记基类函数为被重写的方法\nselect derivedFunction, \n  \"Overriding method '\" + derivedFunction.getName() + \"' has signature mismatch with $@.\",\n  baseFunction, \"overridden method\"",
    "output": "* @kind problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-cookie-source]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Constructing HTTP cookies with untrusted user input enables cookie poisoning attacks",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted Input to Cookie Construction Vulnerability\n * @description Constructing HTTP cookies with untrusted user input enables cookie poisoning attacks \n *              where an attacker can manipulate session tokens or other sensitive data.\n * @kind path-problem\n * @problem.severity warning\n * @precision medium\n * @security-severity 6.0\n * @id py/untrusted-cookie-source\n * @tags security\n *        external/cwe/cwe-20\n *        external/cwe/cwe-79\n */\n\n// Import core Python analysis libraries\nimport python\n\n// Import specialized cookie injection analysis components\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Import data flow tracking framework for path analysis\nimport CookieInjectionFlow::PathGraph\n\n// Identify untrusted input sources flowing into cookie construction points\nfrom CookieInjectionFlow::PathNode userInputSource, CookieInjectionFlow::PathNode cookieCreationPoint\nwhere CookieInjectionFlow::flowPath(userInputSource, cookieCreationPoint)\n\n// Generate vulnerability report with flow path details\nselect cookieCreationPoint.getNode(), \n       userInputSource, \n       cookieCreationPoint, \n       \"Cookie is constructed from a $@\", \n       userInputSource.getNode(), \n       \"user-supplied input\",\n       \"This pattern allows attackers to inject malicious content into HTTP cookies,\"\n       + \" potentially compromising session integrity and user privacy.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-number-class-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测类实例化调用时参数数量不匹配的情况，可能导致运行时 TypeError 异常。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 错误的类实例化参数数量\n * @description 检测类实例化调用时参数数量不匹配的情况，可能导致运行时 TypeError 异常。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call callNode, ClassValue targetClass, string issueType, string requirementPrefix, int requiredArgCount, FunctionValue initMethod\nwhere\n  // 获取目标类的初始化方法\n  initMethod = get_function_or_initializer(targetClass) and\n  (\n    // 处理参数过多的情况\n    too_many_args(callNode, targetClass, requiredArgCount) and\n    issueType = \"too many arguments\" and\n    requirementPrefix = \"no more than \"\n    or\n    // 处理参数过少的情况\n    too_few_args(callNode, targetClass, requiredArgCount) and\n    issueType = \"too few arguments\" and\n    requirementPrefix = \"no fewer than \"\n  )\nselect callNode, \"Call to $@ with \" + issueType + \"; should be \" + requirementPrefix + requiredArgCount.toString() + \".\", initMethod,\n  // 输出调用点、错误描述及初始化方法的完全限定名\n  initMethod.getQualifiedName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Commented-out code detection\n * @description Identifies code segments that have been commented out, which can reduce code readability and maintainability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code */\n_______________ // 补全条件\n// Import core Python analysis capabilities for static code inspection\nimport python\n\n// Import lexical analysis module specifically for detecting commented code patterns\nimport Lexical.CommentedOutCode\n\n// Main query to identify commented-out code blocks while filtering example code\nfrom CommentedOutCodeBlock commentedOutCodeBlock\nwhere \n  // Exclude blocks that represent example code to minimize false positives\n  not commentedOutCodeBlock.maybeExampleCode()\n// Report identified blocks with standardized diagnostic message\nselect commentedOutCodeBlock, \"This comment appears to contain commented-out code.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Except block handles 'BaseException'\n * @description Detects except blocks that catch BaseException or use bare except clauses without re-raising exceptions.\n *              Such handling may cause mis-handling of system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Identifies exception handlers that catch BaseException or use bare except clauses\npredicate catchesGenericBaseException(ExceptStmt exceptBlock) {\n  exceptBlock.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  not exists(exceptBlock.getType())\n}\n\n_______________ // 补全条件\npredicate handlerExitsNormally(ExceptStmt exceptBlock) { \n  exceptBlock.getAFlowNode().getBasicBlock().reachesExit() \n}\n\n// Combines detection logic for problematic exception handling patterns\npredicate isProblematicExceptionHandler(ExceptStmt exceptBlock) {\n  catchesGenericBaseException(exceptBlock) and \n  handlerExitsNormally(exceptBlock)\n}\n\nfrom ExceptStmt problematicExceptBlock\nwhere isProblematicExceptionHandler(problematicExceptBlock)\nselect problematicExceptBlock, \"Except block directly handles BaseException.\"",
    "output": "// Determines if an exception handler fails to re-raise caught exceptions"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Denial of Service via Unicode Character Processing\n * @description Detects remote user input processed by expensive Unicode normalization (NFKC/NFKD).\n *              These operations can cause DoS via attacks like \"One Million Unicode Characters\".\n *              Special chars (e.g., U+2100 ℀ or U+2105 ℅) may triple payload size during normalization.\n * @kind path-problem\n * @id py/unicode-dos\n * @precision high\n * @problem.severity error\n * @tags security\n *       experimental\n *       external/cwe/cwe-770\n */\n\nimport python\nimport semmle.python.ApiGraphs\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n// Represents calls to Unicode normalization functions from unicodedata, unidecode, \n// pyunormalize, and textnorm modules. normalizedArgIndex identifies which argument \n// contains the string to be normalized.\nclass UnicodeNormalizationCall extends API::CallNode {\n  int normalizedArgIndex; // Index of argument being normalized\n\n  UnicodeNormalizationCall() {\n    // Case 1: normalize() calls with NFKC/NFKD form (2nd argument normalized)\n    (\n      this = API::moduleImport(\"unicodedata\").getMember(\"normalize\").getACall() and\n      this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember(\"normalize\").getACall() and\n      this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n    ) and\n    normalizedArgIndex = 1\n    or\n    // Case 2: Other normalization calls where 1st argument is normalized\n    (\n      this = API::moduleImport(\"textnorm\").getMember(\"normalize_unicode\").getACall() and\n      this.getParameter(1).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"unidecode\").getMember(\"unidecode\").getACall()\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember([\"NFKC\", \"NFKD\"]).getACall()\n    ) and\n    normalizedArgIndex = 0\n  }\n\n  DataFlow::Node getNormalizedArgument() { \n    result = this.getArg(normalizedArgIndex) \n  }\n}\n\n// Identifies guard conditions enforcing size limits on input values\npredicate hasSizeLimitGuard(DataFlow::GuardNode guard, ControlFlowNode controlledNode, boolean branchValue) {\n  exists(CompareNode comparisonNode | comparisonNode = guard |\n    exists(API::CallNode lengthCall, Cmpop operator, Node lengthNode |\n      lengthCall = lengthNode.getALocalSource() and\n      (\n        // Patterns: input <= LIMIT or input < LIMIT (branch true)\n        (operator instanceof LtE or operator instanceof Lt) and\n        branchValue = true and\n        comparisonNode.operands(lengthNode.asCfgNode(), operator, _)\n        or\n        // Patterns: LIMIT >= input or LIMIT > input (branch true)\n        (operator instanceof GtE or operator instanceof Gt) and\n        branchValue = true and\n        comparisonNode.operands(_, operator, lengthNode.asCfgNode())\n        or\n        // Patterns: not input >= LIMIT or not input > LIMIT (branch false)\n        (operator instanceof GtE or operator instanceof Gt) and\n        branchValue = false and\n        comparisonNode.operands(lengthNode.asCfgNode(), operator, _)\n        or\n        // Patterns: not LIMIT <= input or not LIMIT < input (branch false)\n        (operator instanceof LtE or operator instanceof Lt) and\n        branchValue = false and\n        comparisonNode.operands(_, operator, lengthNode.asCfgNode())\n      )\n_______________ // 补全条件\n      lengthCall = API::builtin(\"len\").getACall() and\n      controlledNode = lengthCall.getArg(0).asCfgNode()\n    )\n  )\n}\n\n// Taint tracking configuration for Unicode DoS vulnerability analysis\nprivate module UnicodeDoSAnalysisConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node sourceNode) { \n    sourceNode instanceof RemoteFlowSource \n  }\n\n  predicate isBarrier(DataFlow::Node guardBarrier) {\n    // Size limit checks prevent uncontrolled input growth\n    guardBarrier = DataFlow::BarrierGuard<hasSizeLimitGuard/3>::getABarrierNode()\n  }\n\n  predicate isSink(DataFlow::Node sinkNode) {\n    // Direct Unicode normalization calls\n    sinkNode = any(UnicodeNormalizationCall unicodeNormCall).getNormalizedArgument()\n    or\n    // werkzeug's secure_filename() uses Unicode normalization internally\n    exists(API::CallNode werkzeugCall |\n      werkzeugCall = API::moduleImport(\"werkzeug\").getMember(\"secure_filename\").getACall()\n      or\n      werkzeugCall = API::moduleImport(\"werkzeug\")\n                          .getMember(\"utils\")\n                          .getMember(\"secure_filename\")\n                          .getACall()\n    |\n      sinkNode = werkzeugCall.getArg(_)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global taint tracking using Unicode DoS configuration\nmodule UnicodeDoSFlow = TaintTracking::Global<UnicodeDoSAnalysisConfig>;\n\nimport UnicodeDoSFlow::PathGraph\n\nfrom UnicodeDoSFlow::PathNode sourceNode, UnicodeDoSFlow::PathNode sinkNode\nwhere UnicodeDoSFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode, \"This $@ can reach a $@.\", sourceNode.getNode(),\n  \"user-provided value\", sinkNode.getNode(), \"costly Unicode normalization operation\"",
    "output": "|"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/old-style-octal-literal]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Octal literal with a leading 0 is easily misread as a decimal value",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Confusing octal literal\n * @description Octal literal with a leading 0 is easily misread as a decimal value\n * @kind problem\n * @tags readability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/old-style-octal-literal\n */\n\nimport python\n\n/**\n * 判断整数字面量是否为旧式八进制表示法（以0开头但非0o前缀）\n * 这种表示法容易与十进制混淆，建议使用明确的0o前缀表示法\n */\npredicate is_old_style_octal_literal(IntegerLiteral intLiteral) {\n  exists(string literalText | literalText = intLiteral.getText() |\n    // 必须以'0'开头，但排除\"00\"特殊情况\n    literalText.charAt(0) = \"0\" and\n    not literalText = \"00\" and\n    // 确保第二个字符是数字（0-7）\n    exists(literalText.charAt(1).toInt()) and\n    /* 排除文件权限掩码，它们通常具有特定长度 */\n    exists(int textLength | textLength = literalText.length() |\n      textLength != 4 and  // 如 0755\n      textLength != 5 and  // 如 00755\n      textLength != 7     // 如 0000755\n    )\n  )\n}\n\n// 查找所有使用旧式八进制表示的整数字面量\nfrom IntegerLiteral octalLiteral\nwhere is_old_style_octal_literal(octalLiteral)\nselect octalLiteral, \n  \"Confusing octal literal, use 0o\" + octalLiteral.getText().suffix(1) + \" instead.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak elliptic curve\n * @description Identifies the use of unapproved or weak elliptic curve cryptography algorithms.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n/**\n * Retrieves a list of cryptographically secure elliptic curve algorithms\n_______________ // 补全条件\n */\nstring getApprovedEllipticCurves() {\n  result =\n    [\n      \"SECP256R1\", \"PRIME256V1\",  // NIST P-256 curves\n      \"SECP384R1\",               // NIST P-384 curve\n      \"SECP521R1\",               // NIST P-521 curve\n      \"ED25519\",                 // EdDSA Ed25519 curve\n      \"X25519\"                   // ECDH X25519 curve\n    ]\n}\n\n/**\n * Detects weak or unrecognized elliptic curve algorithms in cryptographic operations.\n */\nfrom EllipticCurveAlgorithm curveAlgorithm, string securityAlert, string ellipticCurveName\nwhere\n  // Extract the curve name from the algorithm instance\n  ellipticCurveName = curveAlgorithm.getCurveName() and\n  (\n    // Case 1: Check for unrecognized curve algorithms\n    ellipticCurveName = unknownAlgorithm() and\n    securityAlert = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: Check for weak curve algorithms not in the approved list\n    ellipticCurveName != unknownAlgorithm() and\n    not ellipticCurveName = getApprovedEllipticCurves() and\n    securityAlert = \"Use of weak curve algorithm \" + ellipticCurveName + \".\"\n  )\nselect curveAlgorithm, securityAlert",
    "output": "* that are approved for use in secure systems."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-misconfiguration-with-credentials]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Disabling or weakening Same-Origin Policy (SOP) protection may expose",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name CORS Misconfiguration with Credentials\n * @description Disabling or weakening Same-Origin Policy (SOP) protection may expose\n *              the application to CORS attacks when credentials are allowed.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n// 检查CORS来源配置是否包含不安全的通配符或空值\npredicate containsInsecureOrigin(DataFlow::Node originSetting) {\n  // 情况1：来源配置为列表且包含 \"*\" 或 \"null\" 元素\n  exists(List listExpr | listExpr = originSetting.asExpr() |\n    exists(StringLiteral strLit |\n      strLit = listExpr.getASubExpression() and\n      strLit.getText() in [\"*\", \"null\"]\n    )\n  )\n  // 情况2：来源配置直接为 \"*\" 或 \"null\" 字符串\n  or\n  exists(StringLiteral strLit |\n    strLit = originSetting.asExpr() and\n    strLit.getText() in [\"*\", \"null\"]\n  )\n}\n\n// 验证中间件是否为CORS类型中间件\npredicate isCorsTypeMiddleware(Http::Server::CorsMiddleware corsMid) {\n  corsMid.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n// 检查中间件是否配置为支持凭证\npredicate allowsCredentials(Http::Server::CorsMiddleware corsMid) {\n  corsMid.getCredentialsAllowed().asExpr() instanceof True\n}\n\n// 查询存在安全风险的CORS中间件配置组合\nfrom Http::Server::CorsMiddleware corsMid\nwhere\n  // 安全风险条件组合：凭证支持 + 不安全来源配置 + CORS中间件验证\n  allowsCredentials(corsMid) and\n  containsInsecureOrigin(corsMid.getOrigins().getALocalSource()) and\n  isCorsTypeMiddleware(corsMid)\nselect corsMid,\n  // 安全风险说明：允许任意来源的认证请求可能导致敏感数据泄露\n  \"This CORS middleware configuration allows authenticated cross-origin requests from any source, potentially exposing sensitive data\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__init__` method calls overridden method\n * @description Detects when an `__init__` method calls a method that is overridden by a subclass.\n *              This can lead to a partially initialized instance being observed by the subclass method,\n *              potentially causing unexpected behavior or errors.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/init-calls-subclass\n */\n\nimport python\n\n// Identify calls in parent class initializers to methods overridden by subclasses\nfrom\n  ClassObject parentClass, string methodName, Call callInInit,\n  FunctionObject subclassMethod, FunctionObject parentMethod\nwhere\n  // Verify existence of parent class initializer containing a self-method call\n  exists(FunctionObject initializer, SelfAttribute selfAttr |\n    // Locate parent class __init__ method\n    parentClass.declaredAttribute(\"__init__\") = initializer and\n_______________ // 补全条件\n    callInInit.getScope() = initializer.getFunction() and\n    // Confirm call targets self attribute\n    callInInit.getFunc() = selfAttr and\n    // Match attribute name to target method\n    selfAttr.getName() = methodName and\n    // Retrieve parent class method definition\n    parentMethod = parentClass.declaredAttribute(methodName) and\n    // Detect overriding implementation in subclass\n    subclassMethod.overrides(parentMethod)\n  )\n// Report problematic call with contextual method details\nselect callInInit, \"Call to self.$@ in __init__ method, which is overridden by $@.\", parentMethod, methodName,\n  subclassMethod, subclassMethod.descriptiveString()",
    "output": "// Ensure call occurs within initializer scope"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies all instances where signing algorithms are utilized within the supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/signing-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python language analysis support library\nimport python\n\n// Import experimental cryptography concepts module for identifying cryptographic operations and algorithms\nimport experimental.cryptography.Concepts\n\n// Define variable to represent instances of signing algorithms in the codebase\nfrom SigningAlgorithm signingAlgoInstance\n\n// Output results: each signing algorithm instance along with its descriptive message\nselect signingAlgoInstance, \"Use of algorithm \" + signingAlgoInstance.getName()",
    "output": "* @name Signing Algorithms"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class dependency impact analysis\n * @description This analysis measures the afferent coupling of classes,\n *              which represents the count of external classes that depend on a specific class.\n *              Classes with higher afferent coupling values are considered more\n *              architecturally significant and changes to them may have broader impact.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// Define the main analysis query for class coupling\nfrom ClassMetrics targetClass, int couplingCount\nwhere \n  // Calculate the afferent coupling for each class\n  couplingCount = targetClass.getAfferentCoupling() and\n  // Ensure the coupling count exists and is measurable\n  exists(couplingCount)\nselect \n  targetClass, \n  couplingCount \n_______________ // 补全条件\n  couplingCount desc",
    "output": "order by"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Binding a socket to all network interfaces\n * @description Binding a socket to all interfaces exposes it to traffic from any IPv4/IPv6 address,\n *              creating significant security risks.\n * @kind problem\n * @tags security\n *       external/cwe/cwe-200\n * @problem.severity error\n * @security-severity 6.5\n * @sub-severity low\n * @precision high\n * @id py/bind-socket-all-network-interfaces\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n/** Returns hostnames that bind to all network interfaces (IPv4/IPv6) */\nprivate string allInterfacesHostname() {\n  result in [\n      // IPv4 wildcards\n      \"0.0.0.0\", \"\",\n      // IPv6 wildcards\n_______________ // 补全条件\n    ]\n}\n\n/** Tracks references to hostnames that bind to all interfaces */\nprivate DataFlow::TypeTrackingNode trackHostnameRef(DataFlow::TypeTracker tracker, string hostname) {\n  exists(StringLiteral interfaceLiteral |\n    hostname = allInterfacesHostname() and\n    interfaceLiteral.getText() = hostname and\n    tracker.start() and\n    result.asExpr() = interfaceLiteral\n  )\n  or\n  exists(DataFlow::TypeTracker prevTracker | \n    result = trackHostnameRef(prevTracker, hostname).track(prevTracker, tracker)\n  )\n}\n\n/** Returns data flow nodes containing references to all-interfaces hostnames */\nDataFlow::Node allInterfacesHostnameRef(string hostname) {\n  trackHostnameRef(DataFlow::TypeTracker::end(), hostname).flowsTo(result)\n}\n\n/** Tracks tuples containing all-interfaces hostnames as first element */\nprivate DataFlow::TypeTrackingNode trackAddressTuple(DataFlow::TypeTracker tracker, string hostname) {\n  exists(Tuple interfaceTuple | \n    interfaceTuple.getElt(0) = allInterfacesHostnameRef(hostname).asExpr() and\n    tracker.start() and\n    result.asExpr() = interfaceTuple\n  )\n  or\n  exists(DataFlow::TypeTracker prevTracker | \n    result = trackAddressTuple(prevTracker, hostname).track(prevTracker, tracker)\n  )\n}\n\n/** Returns data flow nodes containing tuples with all-interfaces hostnames */\nDataFlow::Node allInterfacesAddressTuple(string hostname) {\n  trackAddressTuple(DataFlow::TypeTracker::end(), hostname).flowsTo(result)\n}\n\n/**\n * Gets socket instances created with specific address families.\n * Reference: https://docs.python.org/3/library/socket.html\n */\nAPI::Node socketInstance() { \n  result = API::moduleImport(\"socket\").getMember(\"socket\").getReturn() \n}\n\nfrom DataFlow::CallCfgNode bindCall, DataFlow::Node addressArg, string hostname\nwhere\n  bindCall = socketInstance().getMember(\"bind\").getACall() and\n  addressArg = bindCall.getArg(0) and\n  addressArg = allInterfacesAddressTuple(hostname)\nselect bindCall.asExpr(), \"Socket binds to all interfaces using '\" + hostname + \"'\"",
    "output": "\"::\", \"::0\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides comprehensive details about alert suppression mechanisms in Python code,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Provides comprehensive details about alert suppression mechanisms in Python code,\n *              specifically focusing on the handling of suppression comments like 'noqa'.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression utilities for managing suppression logic\nprivate import codeql.util.suppression.AlertSuppression as SuppressionUtils\n// Import Python comment processing utilities for comment analysis\nprivate import semmle.python.Comment as PythonComment\n\n// Represents AST nodes with enhanced location tracking capabilities, providing methods for location and string representation\nclass AstNode instanceof PythonComment::AstNode {\n  // Generate string representation of the AST node\n  string toString() { result = super.toString() }\n\n  // Verify if the node's location matches specified coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n}\n\n// Represents single-line comments with precise location tracking, including methods to retrieve comment text and location\nclass SingleLineComment instanceof PythonComment::Comment {\n  // Generate string representation of the comment\n  string toString() { result = super.toString() }\n\n  // Retrieve the textual content of the comment\n  string getText() { result = super.getContents() }\n\n  // Verify if the comment's location matches specified coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n}\n\n// Import the AlertSuppression template to generate suppression relationships using the defined AstNode and SingleLineComment\nimport SuppressionUtils::Make<AstNode, SingleLineComment>\n\n/**\n * Represents a suppression comment that follows the 'noqa' standard, which is recognized by both pylint and pyflakes,\n * and therefore should be respected by lgtm.\n */\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Constructor identifying noqa comment patterns\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Provides the suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Defines the code coverage range for this suppression annotation\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Ensure the comment's location matches and starts at line beginning\n    this.hasLocationInfo(filePath, startLine, _, endLine, endCol) and\n    startCol = 1\n  }\n}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/signature-mismatch]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects methods that override parent class methods but have incompatible",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Signature mismatch in overriding method\n * @description Detects methods that override parent class methods but have incompatible\n *              parameter signatures, which can lead to runtime errors when the methods are called.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python  // 导入Python分析库，提供Python代码分析的基础功能\nimport Expressions.CallArgs  // 导入表达式调用参数处理模块，用于分析函数调用参数\n\n// 查询定义：识别子类重写父类方法时签名不匹配的情况\nfrom FunctionValue parentMethod, PythonFunctionValue childMethod  // 从父类方法和子类方法中选取数据源\nwhere\n  // 确保父类方法未被调用，避免误报已使用的方法\n  not exists(parentMethod.getACall()) and\n  \n  // 检查是否有其他子类方法重写了同一个父类方法且被调用\n  not exists(FunctionValue anotherDerivedMethod |\n    anotherDerivedMethod.overrides(parentMethod) and  // 确认重写关系\n    exists(anotherDerivedMethod.getACall())  // 确认被调用\n  ) and\n  \n  // 排除特殊方法和构造函数，专注于普通业务方法\n  not childMethod.getScope().isSpecialMethod() and  // 不是特殊方法\n  childMethod.getName() != \"__init__\" and  // 不是构造函数\n  childMethod.isNormalMethod() and  // 确保是普通方法\n  \n  // 确认重写关系并检查参数数量不匹配的情况\n  childMethod.overrides(parentMethod) and\n  (\n    // 情况1：子类方法所需的最小参数多于父类方法能接受的最大参数\n    childMethod.minParameters() > parentMethod.maxParameters()\n    or\n    // 情况2：子类方法能接受的最大参数少于父类方法所需的最小参数\n    childMethod.maxParameters() < parentMethod.minParameters()\n  )\n\n// 输出结果：子类方法及其相关的警告信息\nselect childMethod, \"Overriding method '\" + childMethod.getName() + \"' has signature mismatch with $@.\",  // 选择子类方法并生成警告消息\n  parentMethod, \"overridden method\"  // 选择父类方法并标记为被重写的方法"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides comprehensive details about alert suppressions in the codebase, focusing on 'noqa' directive usage.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert Suppression Information\n * @description Provides comprehensive details about alert suppressions in the codebase, focusing on 'noqa' directive usage.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import CodeQL's alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment handling module\nprivate import semmle.python.Comment as P\n\n// Represents AST nodes equipped with location tracking capabilities\nclass AstNode instanceof P::AstNode {\n  // Determine if the node's location matches the provided coordinates\n  predicate hasLocationInfo(\n    string filePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    super.getLocation().hasLocationInfo(filePath, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Provide a string representation of the AST node\n  string toString() { result = super.toString() }\n}\n\n// Represents single-line comments that include location information\nclass SingleLineComment instanceof P::Comment {\n  // Verify if the comment's location matches the given coordinates\n  predicate hasLocationInfo(\n    string filePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    super.getLocation().hasLocationInfo(filePath, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Obtain the text content of the comment\n  string getText() { result = super.getContents() }\n\n  // Return a string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships using AS template with custom node types\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * Represents a suppression comment using the 'noqa' directive. This directive is recognized by both pylint and pyflakes, and thus should be respected by LGTM as well.\n */\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Constructor: identify comments that match the noqa pattern\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Provide the suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Specify the code coverage scope for this suppression\n  override predicate covers(\n    string filePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Retrieve the location details of the comment\n    exists(int commentStartLine, int commentEndLine, int commentEndColumn |\n      this.hasLocationInfo(filePath, commentStartLine, _, commentEndLine, commentEndColumn) and\n      // Set the coverage to the entire line where the comment appears\n      beginLine = commentStartLine and\n      finishLine = commentEndLine and\n      beginColumn = 1 and\n      finishColumn = commentEndColumn\n    )\n  }\n}"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects sensitive data being logged without encryption,\n *              exposing confidential information to unauthorized access.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/clear-text-logging-sensitive-data\n * @tags security\n *       external/cwe/cwe-312\n *       external/cwe/cwe-359\n *       external/cwe/cwe-532\n */\n\n// Import Python analysis libraries\nimport python\n// Import data flow analysis framework\nprivate import semmle.python.dataflow.new.DataFlow\n// Import path graph generation utilities\nimport CleartextLoggingFlow::PathGraph\n// Import cleartext logging detection query\nimport semmle.python.security.dataflow.CleartextLoggingQuery\n\n// Define query variables: origin point, destination point, and data classification\nfrom\n  CleartextLoggingFlow::PathNode originPoint, \n  CleartextLoggingFlow::PathNode destinationPoint, \n  string dataClassification\nwhere\n  // Validate data flow path exists between origin and destination\n  CleartextLoggingFlow::flowPath(originPoint, destinationPoint)\n  and\n  // Extract sensitivity classification from origin point\n  dataClassification = originPoint.getNode().(Source).getClassification()\nselect \n  // Output destination node, origin point, destination point, warning message, origin node and its classification\n  destinationPoint.getNode(), \n  originPoint, \n  destinationPoint, \n  \"This expression logs $@ as clear text.\", \n  originPoint.getNode(),\n  \"sensitive data (\" + dataClassification + \")\"",
    "output": "* @name Clear-text logging of sensitive information"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Identifies asymmetric encryption padding schemes that are either cryptographically\n * weak or not recognized as secure by established security standards. The query\n * exclusively permits robust padding methods (OAEP, KEM, PSS) and flags all others\n * as potential security vulnerabilities.\n * \n * Focuses on padding implementations vulnerable to cryptographic attacks in\n * asymmetric encryption contexts.\n * \n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n_______________ // 补全条件\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricPadding insecurePadding, string paddingName\nwhere\n  // Extract the padding algorithm identifier from the implementation\n  paddingName = insecurePadding.getPaddingName()\n  // Identify padding schemes that are not in the approved secure list\n  and not paddingName = [\"OAEP\", \"KEM\", \"PSS\"]\nselect insecurePadding, \"Detected unapproved, weak, or unknown asymmetric padding algorithm: \" + paddingName",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-input]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects calls to Python 2's built-in 'input' function which evaluates",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Potentially unsafe 'input' function usage in Python 2\n * @description Detects calls to Python 2's built-in 'input' function which evaluates\n *              user input as executable code, creating a critical code injection risk.\n *              This contrasts with 'raw_input()' which safely returns input as a string.\n * @kind problem\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/use-of-input\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Identify dangerous input() calls in Python 2 environments\nfrom DataFlow::CallCfgNode unsafeInputCall\nwhere\n  // Target Python 2 where input() is inherently unsafe\n  major_version() = 2\n  and\n  // Match calls to the vulnerable built-in input function\n  unsafeInputCall = API::builtin(\"input\").getACall()\n  and\n  // Exclude safe raw_input() calls from results\n  unsafeInputCall != API::builtin(\"raw_input\").getACall()\nselect unsafeInputCall, \"Use of unsafe built-in 'input' in Python 2 enables code injection.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Cookie Injection via Untrusted Data Sources\n * @description Identifies potential cookie poisoning vulnerabilities by monitoring data flows\n *              from untrusted sources to cookie construction operations. Detects instances\n *              where unsanitized user input is utilized in HTTP cookie creation.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n_______________ // 补全条件\n/** \n * Main vulnerability detection mechanism:\n * - Monitors data propagation from untrusted origins (e.g., user inputs)\n * - Pinpoints cookie creation operations as potential vulnerability points\n * - Highlights paths where untrusted data flows into cookie construction\n */\nfrom \n  CookieInjectionFlow::PathNode untrustedOrigin,\n  CookieInjectionFlow::PathNode cookieGenerationSink\nwhere \n  // Establish data flow connection between untrusted source and cookie sink\n  CookieInjectionFlow::flowPath(untrustedOrigin, cookieGenerationSink)\n\n// Report findings with enhanced variable naming while preserving output format:\nselect \n  cookieGenerationSink.getNode(),\n  untrustedOrigin,\n  cookieGenerationSink,\n  \"Cookie is constructed using $@.\",\n  untrustedOrigin.getNode(),\n  \"untrusted user input\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/polluting-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects star imports that introduce namespace pollution when the",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' may pollute namespace\n * @description Detects star imports that introduce namespace pollution when the \n *              imported module lacks '__all__' definition to control exports\n * @kind problem\n * @tags maintainability\n *       modularity\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/polluting-import\n */\n\n// Import Python analysis library for code examination\nimport python\n\n// Query to identify namespace-polluting star imports\nfrom ImportStar problematicImport, ModuleValue sourceModule\nwhere \n  // Verify module existence and name consistency\n  sourceModule.importedAs(problematicImport.getImportedModuleName()) and\n  not sourceModule.isAbsent() and\n  \n  // Exclude built-in modules as they are inherently safe\n  not sourceModule.isBuiltin() and\n  \n  // Check for absence of '__all__' definition in relevant scopes\n  not (\n    // Check module's main execution scope\n    sourceModule.getScope().(ImportTimeScope).definesName(\"__all__\") or\n    // Check module's initialization scope (for packages)\n    sourceModule.getScope().getInitModule().(ImportTimeScope).definesName(\"__all__\")\n  )\nselect problematicImport,\n  \"Import pollutes the enclosing namespace, as the imported module $@ does not define '__all__'.\",\n  sourceModule, sourceModule.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n_______________ // 补全条件\n * @description Detects modules containing significant amounts of duplicated code. Refactoring these modules improves code maintainability and reduces technical debt. This query is intentionally disabled.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-file\n */\n\nimport python\n\nfrom \n  Module originalModule,\n  Module clonedModule,\n  string warningMessage\nwhere \n  // Query intentionally disabled\n  none()\nselect \n  originalModule,\n  warningMessage,\n  clonedModule,\n  clonedModule.getName()",
    "output": "* @name Substantial code duplication identifier"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Property in old-style class\n * @description Detects property descriptors within old-style Python classes, which are not properly supported since Python 2.1.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/property-in-old-style-class\n */\n\nimport python\n\n/**\n * This query identifies property objects defined within old-style classes.\n * Old-style classes in Python (pre-2.1) have limitations with property descriptors,\n * which can lead to unexpected behavior or runtime errors.\n */\nfrom PropertyObject propertyDescriptor, ClassObject targetClass\nwhere\n  // Condition 1: The property is directly declared as an attribute of the class\n  targetClass.declaredAttribute(_) = propertyDescriptor and\n  // Condition 2: The class type inference was successful (no analysis failures)\n_______________ // 补全条件\n  // Condition 3: The class uses old-style inheritance (not inheriting from 'object')\n  not targetClass.isNewStyle()\n// Report the problematic property with a contextual warning message\nselect propertyDescriptor,\n  \"Property '\" + propertyDescriptor.getName() + \"' will not function correctly, as class '\" + \n  targetClass.getName() + \"' uses old-style inheritance (not inheriting from 'object').\"",
    "output": "not targetClass.failedInference() and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Pythagorean calculation with sub-optimal numerics\n * @description Detects potentially problematic hypotenuse calculations using the standard formula (a²+b²) that may cause numeric overflow\n * @kind problem\n * @tags accuracy\n * @problem.severity warning\n * @sub-severity low\n * @precision medium\n * @id py/pythagorean\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n_______________ // 补全条件\n/**\n * Identifies expressions that compute the square of a value.\n * This includes both exponentiation with power 2 (x**2) and\n * self-multiplication (x*x).\n */\nDataFlow::ExprNode squareOperation() {\n  exists(BinaryExpr expr | expr = result.asExpr() |\n    // Check for exponentiation with power of 2\n    (expr.getOp() instanceof Pow and expr.getRight().(IntegerLiteral).getN() = \"2\")\n    or\n    // Check for self-multiplication pattern\n    (expr.getOp() instanceof Mult and \n     expr.getRight().(Name).getId() = expr.getLeft().(Name).getId())\n  )\n}\n\n/**\n * Main query to detect problematic Pythagorean calculations.\n * Finds math.sqrt() calls that compute the hypotenuse using the\n * standard formula, which may lead to numeric overflow issues.\n */\nfrom \n  DataFlow::CallCfgNode sqrtCallNode,     // The math.sqrt() function call\n  BinaryExpr additionExpr,                // Addition expression inside the sqrt\n  DataFlow::ExprNode leftOperand,         // First term in the addition\n  DataFlow::ExprNode rightOperand         // Second term in the addition\nwhere\n  // Verify we're looking at a math.sqrt call\n  sqrtCallNode = API::moduleImport(\"math\").getMember(\"sqrt\").getACall() and\n  \n  // Ensure the argument to sqrt is an addition operation\n  sqrtCallNode.getArg(0).asExpr() = additionExpr and\n  additionExpr.getOp() instanceof Add and\n  \n  // Extract the left and right operands of the addition\n  leftOperand.asExpr() = additionExpr.getLeft() and\n  rightOperand.asExpr() = additionExpr.getRight() and\n  \n  // Confirm both operands are square operations\n  leftOperand.getALocalSource() = squareOperation() and\n  rightOperand.getALocalSource() = squareOperation()\nselect sqrtCallNode, \"Pythagorean calculation with sub-optimal numerics.\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-block-mode]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects symmetric encryption block modes that are considered weak, deprecated, or non-compliant with security standards.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak block mode\n * @description Detects symmetric encryption block modes that are considered weak, deprecated, or non-compliant with security standards.\n * @id py/weak-block-mode\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Select cryptographic operations and their corresponding security alert messages\nfrom CryptographicArtifact cryptoArtifact, string securityAlert\nwhere\n  // Filter out false positives from cryptography/hazmat paths\n  // This specifically addresses cases where ECB is used internally within keywrap operations\n  not cryptoArtifact.asExpr()\n      .getLocation()\n      .getFile()\n      .getAbsolutePath()\n      .toString()\n      .matches(\"%cryptography/hazmat/%\") and\n  (\n    // Analyze BlockMode instances for potentially weak configurations\n    cryptoArtifact instanceof BlockMode and\n    // ECB mode is only permitted for KeyWrapOperations\n    (cryptoArtifact.(BlockMode).getBlockModeName() = \"ECB\" implies not cryptoArtifact instanceof KeyWrapOperation) and\n    exists(string blockModeName | \n      blockModeName = cryptoArtifact.(BlockMode).getBlockModeName() and\n      // Only allow CBC, CTS, and XTS modes according to security requirements\n      // Reference: https://liquid.microsoft.com/Web/Object/Read/MS.Security/Requirements/Microsoft.Security.Cryptography.10002\n      not blockModeName = [\"CBC\", \"CTS\", \"XTS\"] and\n      (\n        // Case 1: Unrecognized algorithm\n        blockModeName = unknownAlgorithm() and\n        securityAlert = \"Use of unrecognized block mode algorithm.\"\n        or\n        // Case 2: Algorithms requiring special approval\n        blockModeName in [\"GCM\", \"CCM\"] and\n        securityAlert = \"Use of block mode algorithm \" + blockModeName + \" requires special crypto board approval/review.\"\n        or\n        // Case 3: Other unapproved algorithms\n        not blockModeName in [\"GCM\", \"CCM\"] and\n        not blockModeName = unknownAlgorithm() and\n        securityAlert = \"Use of unapproved block mode algorithm or API \" + blockModeName + \".\"\n      )\n    )\n    or\n    // Detect SymmetricCipher instances without a specified block mode\n    cryptoArtifact instanceof SymmetricCipher and\n    not cryptoArtifact.(SymmetricCipher).hasBlockMode() and\n    securityAlert = \"Cipher has unspecified block mode algorithm.\"\n  )\nselect cryptoArtifact, securityAlert"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__slots__` in old-style class\n * @description In Python, old-style classes (classes not inheriting from object) lack proper support\n *              for the `__slots__` attribute. When used in such classes, `__slots__` fails to override\n *              the class dictionary as intended, instead creating a regular class attribute named\n *              `__slots__`. This behavior leads to unexpected results and inefficient memory usage.\n * @kind problem\n * @problem.severity error\n * @tags portability\n *       correctness\n * @sub-severity low\n * @precision very-high\n * @id py/slots-in-old-style-class\n */\n\nimport python\n\nfrom ClassObject cls\n_______________ // 补全条件\n  not cls.isNewStyle() \n  and cls.declaresAttribute(\"__slots__\") \n  and not cls.failedInference()\nselect cls,\n  \"Using '__slots__' in an old style class just creates a class attribute called '__slots__'.\"",
    "output": "where"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable code\n * @description Code is unreachable\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-statement\n */\n\nimport python\n\n// 检查导入语句是否用于类型提示\npredicate is_typing_import(ImportingStmt importDecl) {\n  exists(Module mod |\n    importDecl.getScope() = mod and\n    exists(TypeHintComment hint | hint.getLocation().getFile() = mod.getFile())\n  )\n}\n\n// 检查语句是否包含函数作用域内唯一的yield表达式\npredicate has_unique_yield(Stmt targetStmt) {\n  exists(Yield yieldExpr | targetStmt.contains(yieldExpr)) and\n  exists(Function func |\n    func = targetStmt.getScope() and\n    strictcount(Yield y | func.containsInScope(y)) = 1\n  )\n}\n\n// 检查语句是否与contextlib.suppress在同一作用域中使用\npredicate uses_suppression_context(Stmt targetStmt) {\n  exists(With withBlock |\n    withBlock.getContextExpr().(Call).getFunc().pointsTo(Value::named(\"contextlib.suppress\")) and\n    withBlock.getScope() = targetStmt.getScope()\n  )\n}\n\n// 检查语句是否在if-elif-else链末尾触发异常\npredicate terminates_impossible_branch(Stmt targetStmt) {\n  exists(If ifBlock | ifBlock.getOrelse().getItem(0) = targetStmt |\n    targetStmt.(Assert).getTest() instanceof False or\n    targetStmt instanceof Raise\n  )\n}\n\n// 判断语句是否为可报告的不可达代码\npredicate is_reportable_unreachable(Stmt targetStmt) {\n  targetStmt.isUnreachable() and\n  not is_typing_import(targetStmt) and\n  not uses_suppression_context(targetStmt) and\n  not exists(Stmt otherUnreachable | otherUnreachable.isUnreachable() |\n    otherUnreachable.contains(targetStmt) or\n    exists(StmtList stmtList, int idx1, int idx2 | \n      stmtList.getItem(idx1) = otherUnreachable and \n      stmtList.getItem(idx2) = targetStmt and \n      idx1 < idx2\n    )\n_______________ // 补全条件\n  not has_unique_yield(targetStmt) and\n  not terminates_impossible_branch(targetStmt)\n}\n\n// 查询不可达代码并选择相应的语句和描述信息\nfrom Stmt targetStmt\nwhere is_reportable_unreachable(targetStmt)\nselect targetStmt, \"This statement is unreachable.\"",
    "output": ") and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/unmatchable-caret]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies regular expressions containing a caret symbol '^'",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Invalid caret placement in regex pattern\n * @description Identifies regular expressions containing a caret symbol '^' \n *              placed in positions other than the start, making the pattern unmatchable.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/regex/unmatchable-caret\n */\n\nimport python\nimport semmle.python.regex\n\n// Define variables for regex pattern and caret position analysis\nfrom RegExp pattern, int caretIndex\n// Check for problematic caret placement scenarios\nwhere \n  // Filter out regex modes where caret has special line-start semantics\n  not pattern.getAMode() = \"MULTILINE\" and\n  not pattern.getAMode() = \"VERBOSE\" and\n  // Locate caret symbol at specific position within pattern\n  pattern.specialCharacter(caretIndex, caretIndex + 1, \"^\") and\n  // Confirm caret is not positioned at the beginning of pattern\n  not pattern.firstItem(caretIndex, caretIndex + 1)\n// Generate alert with regex pattern and diagnostic information\nselect pattern,\n  \"Unmatchable caret found at offset \" + caretIndex.toString() + \" in this regular expression.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 跨域资源共享（CORS）策略配置缺陷\n * @description 使用不安全的字符串前缀比较（如 'startswith'）验证用户提供的 Origin 头部，\n *              可能导致 CORS 安全机制被绕过，引发跨域攻击风险。\n * @kind path-problem\n * @problem.severity warning\n * @id py/cors-bypass\n * @tags security\n *       externa/cwe/CWE-346\n */\n\nimport python\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.Flow\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n/**\n * 判断输入字符串是否包含 CORS 相关标识符\n */\nbindingset[inputStr]\npredicate containsCorsKeywords(string inputStr) { \n  inputStr.matches([\"%origin%\", \"%cors%\"]) \n}\n\n/**\n * 表示不安全的字符串前缀比较调用\n */\nprivate class WeakStringPrefixCheck extends ControlFlowNode {\n  WeakStringPrefixCheck() { \n    this.(CallNode).getFunction().(AttrNode).getName() = \"startswith\" \n  }\n}\n\n/**\n * 识别与 CORS 处理相关的代码节点\n * \n * 通过以下启发式规则检测 CORS 验证逻辑：\n * 1. 检查调用对象是否包含 CORS 关键字（作为汇点）\n * 2. 检查方法参数是否包含 CORS 关键字（作为汇点）\n * 3. 检查变量赋值是否涉及 CORS 关键字（作为源点）\n */\nprivate predicate isCorsRelated(ControlFlowNode node) {\n  // 场景1：调用对象包含 CORS 关键字（汇点）\n  exists(string corsKeyword | \n    containsCorsKeywords(corsKeyword) and \n    node.(CallNode).getFunction().(AttrNode).getObject().(NameNode).getId() = corsKeyword\n  )\n  or\n  // 场景2：方法参数包含 CORS 关键字（汇点）\n  exists(string corsKeyword | \n    containsCorsKeywords(corsKeyword) and \n    node.(CallNode).getArg(0).(NameNode).getId() = corsKeyword\n  )\n  or\n  // 场景3：变量赋值包含 CORS 关键字（源点）\n  exists(Variable corsVar | \n    containsCorsKeywords(corsVar.getId()) and \n    node.getASuccessor*().getNode() = corsVar.getAStore()\n  )\n}\n\n/**\n * 表示 CherryPy 框架的请求对象成员\n * 作为远程输入源被识别\n */\nclass CherryPyRequestMember extends RemoteFlowSource::Range {\n  CherryPyRequestMember() {\n    this =\n      API::moduleImport(\"cherrypy\")\n          .getMember(\"request\")\n          .getMember([\n              \"charset\", \"content_type\", \"filename\", \"fp\", \"name\", \n              \"params\", \"headers\", \"length\"\n            ])\n          .asSource()\n  }\n\n  override string getSourceType() { \n    result = \"cherrypy.request\" \n  }\n}\n\n/**\n * CORS 安全策略绕过分析配置\n */\nmodule CorsBypassConfig implements DataFlow::ConfigSig {\n  /**\n   * 定义数据流源：所有远程输入源\n   */\n  predicate isSource(DataFlow::Node node) { \n    node instanceof RemoteFlowSource \n  }\n\n  /**\n   * 定义数据流汇：startswith 方法的参数或调用对象\n   */\n  predicate isSink(DataFlow::Node node) {\n    exists(WeakStringPrefixCheck prefixCheck |\n      node.asCfgNode() = prefixCheck.(CallNode).getArg(0) or\n      node.asCfgNode() = prefixCheck.(CallNode).getFunction().(AttrNode).getObject()\n_______________ // 补全条件\n  }\n\n  /**\n   * 定义额外流步骤：处理 cherrypy.request.headers.get() 调用链\n   */\n  predicate isAdditionalFlowStep(DataFlow::Node sourceNode, DataFlow::Node targetNode) {\n    exists(API::CallNode headersCall, API::Node requestHeaders |\n      requestHeaders = API::moduleImport(\"cherrypy\")\n                          .getMember(\"request\")\n                          .getMember(\"headers\") and\n      headersCall = requestHeaders.getMember(\"get\").getACall()\n    |\n      headersCall.getReturn().asSource() = targetNode and \n      requestHeaders.asSource() = sourceNode\n    )\n  }\n\n  // 启用增量模式差异观察\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// 全局污点跟踪模块\nmodule CorsBypassFlow = TaintTracking::Global<CorsBypassConfig>;\n\nimport CorsBypassFlow::PathGraph\n\n/**\n * 查询潜在的 CORS 策略绕过漏洞\n */\nfrom CorsBypassFlow::PathNode sourceNode, CorsBypassFlow::PathNode sinkNode\nwhere\n  CorsBypassFlow::flowPath(sourceNode, sinkNode) and\n  (\n    isCorsRelated(sourceNode.getNode().asCfgNode())\n    or\n    isCorsRelated(sinkNode.getNode().asCfgNode())\n  )\nselect sinkNode, sourceNode, sinkNode,\n  \"使用弱字符串比较验证 Origin 头部，可能导致 CORS 安全策略被绕过。\"",
    "output": ")"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Discovers all instances of cryptographic algorithm utilization",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comprehensive Cryptographic Algorithm Detection\n * @description Discovers all instances of cryptographic algorithm utilization \n *              across supported libraries, capturing both algorithm identifiers \n *              and block cipher operational modes.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport semmle.python.Concepts\n\nfrom Cryptography::CryptographicOperation cryptographicOperation, string algorithmIdentifier\nwhere \n  // Capture either the algorithm name or block cipher mode from the cryptographic operation\n  algorithmIdentifier = cryptographicOperation.getAlgorithm().getName() \n  or \n  algorithmIdentifier = cryptographicOperation.getBlockMode()\nselect cryptographicOperation, \"Use of algorithm \" + algorithmIdentifier"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/nosql-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Building a NoSQL query from user-controlled sources is vulnerable to insertion of",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name NoSQL Injection\n * @description Building a NoSQL query from user-controlled sources is vulnerable to insertion of\n *              malicious NoSQL code by the user.\n * @kind path-problem\n * @precision high\n * @problem.severity error\n * @security-severity 8.8\n * @id py/nosql-injection\n * @tags security\n *       external/cwe/cwe-943\n */\n\n// Import Python libraries for code analysis\nimport python\n// Import NoSQL injection detection module\nimport semmle.python.security.dataflow.NoSqlInjectionQuery\n// Import path graph representation for data flow tracking\nimport NoSqlInjectionFlow::PathGraph\n\n// Define path nodes representing data flow sources and sinks\nfrom NoSqlInjectionFlow::PathNode origin, NoSqlInjectionFlow::PathNode destination\n// Ensure data flows from user-controlled source to NoSQL query sink\nwhere NoSqlInjectionFlow::flowPath(origin, destination)\n// Report results with vulnerability details and flow path\nselect destination.getNode(), \n       origin, \n       destination, \n       \"This NoSQL query contains an unsanitized $@.\", \n       origin, \n       \"user-provided value\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Key points-to fails for expression.\n * @description Expression does not \"point-to\" an object which prevents further points-to analysis.\n * @kind problem\n * @problem.severity info\n * @id py/key-points-to-failure\n * @deprecated\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n * Determines if an expression has points-to analysis failure.\n * Holds when the expression's control flow node has no points-to relations.\n */\npredicate points_to_failure(Expr expr) {\n  exists(ControlFlowNode controlFlowNode | \n    controlFlowNode = expr.getAFlowNode() and \n    not PointsTo::pointsTo(controlFlowNode, _, _, _)\n  )\n}\n\n/**\n * Identifies critical points-to failures where:\n * 1. The expression itself has points-to failure\n * 2. None of its sub-expressions have points-to failure\n * 3. No SSA variable using this expression has a failing definition\n * 4. The expression is not the target of an assignment\n */\npredicate key_points_to_failure(Expr expr) {\n  // Condition 1: Expression has points-to failure\n  points_to_failure(expr) and\n  \n  // Condition 2: No sub-expressions have points-to failure\n  not points_to_failure(expr.getASubExpression()) and\n  \n  // Condition 3: No SSA variable with failing definition uses this expression\n  not exists(SsaVariable ssaVariable | \n    ssaVariable.getAUse() = expr.getAFlowNode() and\n    points_to_failure(ssaVariable.getAnUltimateDefinition().getDefinition().getNode())\n  ) and\n  \n  // Condition 4: Expression is not an assignment target\n  not exists(Assign assignment | assignment.getATarget() = expr)\n}\n\n_______________ // 补全条件\n// that are not part of a call expression\nfrom Attribute expression\nwhere \n  key_points_to_failure(expression) and \n  not exists(Call call | call.getFunc() = expression)\nselect expression, \"Expression does not 'point-to' any object, but all its sources do.\"",
    "output": "// Query: Find attribute expressions with critical points-to failures"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/zipslip]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects unsafe archive extraction where malicious file paths containing '..'",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file access during archive extraction (\"Zip Slip\")\n * @description Detects unsafe archive extraction where malicious file paths containing '..' \n *              can bypass destination directory restrictions, enabling unauthorized \n *              file system access.\n * @kind path-problem\n * @id py/zipslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.semmle.python.security.ZipSlip\nimport ZipSlipFlow::PathGraph\n\n// Identify vulnerable data flow paths from archive entry to file operation\nfrom ZipSlipFlow::PathNode archiveEntryNode, ZipSlipFlow::PathNode fileOperationNode\nwhere ZipSlipFlow::flowPath(archiveEntryNode, fileOperationNode)\n\n// Generate vulnerability report with complete path context\nselect archiveEntryNode.getNode(), archiveEntryNode, fileOperationNode,\n  \"This unsanitized archive entry (potentially containing '..') flows to a $@.\", fileOperationNode.getNode(),\n  \"file system operation\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/truncated-division]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The arguments to a division statement may be integers, which",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Result of integer division may be truncated\n * @description The arguments to a division statement may be integers, which\n *              may cause the result to be truncated in Python 2.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// 定义一个查询，用于查找可能导致结果被截断的整数除法操作\nfrom BinaryExpr div, ControlFlowNode left, ControlFlowNode right\nwhere\n  // 仅在Python 2中相关，因为后续版本实现了真除法\n  major_version() = 2 and\n  exists(BinaryExprNode bin, Value lval, Value rval |\n    bin = div.getAFlowNode() and // 获取除法表达式节点\n    bin.getNode().getOp() instanceof Div and // 确保操作符是除法\n    bin.getLeft().pointsTo(lval, left) and // 获取左操作数的值和控制流节点\n    lval.getClass() = ClassValue::int_() and // 确保左操作数是整数类型\n    bin.getRight().pointsTo(rval, right) and // 获取右操作数的值和控制流节点\n    rval.getClass() = ClassValue::int_() and // 确保右操作数是整数类型\n    // 忽略整除没有余数的情况\n    not lval.(NumericValue).getIntValue() % rval.(NumericValue).getIntValue() = 0 and\n    // 忽略包含`from future`导入的模块\n    not bin.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    // 过滤掉用`int(...)`包装的结果\n    not exists(CallNode c |\n      c = ClassValue::int_().getACall() and // 检查是否存在将结果转换为整数的调用\n      c.getAnArg() = bin // 确保转换的是当前除法表达式的结果\n    )\n  )\nselect div, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  left, \"left\", right, \"right\" // 选择并报告可能被截断的除法操作及其左右操作数"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-permissive-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly permissive file permissions\n * @description Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.\n * @kind problem\n * @id py/overly-permissive-file\n * @problem.severity warning\n * @security-severity 7.8\n * @sub-severity high\n * @precision medium\n * @tags external/cwe/cwe-732\n *       security\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n/**\n * Extracts the world permission bits (least significant 3 bits) from a file permission value.\n * @param permissionValue The full permission value (e.g., 0o777)\n * @return The world permission component (0-7)\n */\nbindingset[permissionValue]\nint extractWorldPermission(int permissionValue) { \n  result = permissionValue % 8 \n}\n\n/**\n * Extracts the group permission bits (middle 3 bits) from a file permission value.\n * @param permissionValue The full permission value (e.g., 0o777)\n * @return The group permission component (0-7)\n */\nbindingset[permissionValue]\nint extractGroupPermission(int permissionValue) { \n  result = (permissionValue / 8) % 8 \n}\n\n/**\n * Generates a human-readable description of permission bits.\n * @param permissionBits The permission component to describe (0-7)\n * @return \"writable\" if write permission is set, \"readable\" if only read permission is set\n */\nbindingset[permissionBits]\nstring describePermission(int permissionBits) {\n  permissionBits % 4 >= 2 and result = \"writable\"\n  or\n  permissionBits % 4 < 2 and permissionBits != 0 and result = \"readable\"\n}\n\n/**\n * Identifies overly permissive permission components in a file permission value.\n * @param permissionValue The full permission value to analyze\n * @return Description of the permissive component (e.g., \"world writable\")\n */\nbindingset[permissionValue]\nstring identifyPermissiveComponent(int permissionValue) {\n  result = \"world \" + describePermission(extractWorldPermission(permissionValue))\n  or\n  extractWorldPermission(permissionValue) = 0 and \n  result = \"group \" + describePermission(extractGroupPermission(permissionValue))\n}\n\n/**\n * Matches os.chmod calls and extracts the permission mode parameter.\n * @param call The API call node\n * @param funcName Always \"chmod\" for this predicate\n * @param mode The permission mode value\n */\npredicate isChmodCall(API::CallNode call, string funcName, int mode) {\n  call = API::moduleImport(\"os\").getMember(\"chmod\").getACall() and\n  mode = call.getParameter(1, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue() and\n  funcName = \"chmod\"\n}\n\n/**\n * Matches os.open calls and extracts the permission mode parameter.\n * @param call The API call node\n * @param funcName Always \"open\" for this predicate\n * @param mode The permission mode value\n */\npredicate isOpenCall(API::CallNode call, string funcName, int mode) {\n  call = API::moduleImport(\"os\").getMember(\"open\").getACall() and\n  mode = call.getParameter(2, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue() and\n  funcName = \"open\"\n}\n\n// Find file permission API calls with overly permissive modes\nfrom API::CallNode call, string funcName, int mode, string permissionDescription\nwhere\n  (isChmodCall(call, funcName, mode) or isOpenCall(call, funcName, mode)) and\n  permissionDescription = identifyPermissiveComponent(mode)\nselect call, \"Overly permissive mask in \" + funcName + \" sets file to \" + permissionDescription + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/utils/modeleditor/framework-mode-endpoints]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Discovers and lists all accessible API endpoints (methods/attributes) available to library consumers,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Model Editor Framework Mode API Endpoints\n * @description Discovers and lists all accessible API endpoints (methods/attributes) available to library consumers, \n *              filtering out test code and auto-generated implementations. This query helps developers understand\n *              the public API surface of the Model Editor framework in framework mode.\n * @kind table\n * @id py/utils/modeleditor/framework-mode-endpoints\n * @tags modeleditor endpoints framework-mode\n */\n\nimport modeling.ModelEditor\n\nfrom Endpoint apiEndpoint\nselect \n  // Core API endpoint reference - the primary object representing the endpoint\n  apiEndpoint,\n  // Namespace context for the endpoint - helps identify the module/package the endpoint belongs to\n  apiEndpoint.getNamespace(),\n  // Parent class containing the endpoint - provides class hierarchy context\n  apiEndpoint.getClass(),\n  // Function/method name identifier - the actual name of the endpoint as exposed to consumers\n  apiEndpoint.getFunctionName(),\n  // Parameter signature list - defines the input parameters the endpoint accepts\n  apiEndpoint.getParameters(),\n  // Supported HTTP status codes - indicates the possible response status codes\n  apiEndpoint.getSupportedStatus(),\n  // Source file location - helps with code navigation and debugging\n  apiEndpoint.getFileName(),\n  // Supported data types - specifies the data types the endpoint can work with\n  apiEndpoint.getSupportedType(),\n  // Endpoint classification type - categorizes the endpoint (e.g., method, attribute, etc.)\n  apiEndpoint.getKind()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Syntax error\n * @description Syntax errors cause failures at runtime and prevent analysis of the code.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n_______________ // 补全条件\nimport python\n\n// 查找所有Python语法错误实例，这些错误会导致代码无法正常解析和执行\nfrom SyntaxError syntaxFailure\n// 过滤条件：排除编码错误(EncodingError)，因为编码错误属于文件解析阶段的问题，\n// 而非语法结构问题，需要单独处理\nwhere not syntaxFailure instanceof EncodingError\n// 输出结果：语法错误对象及其详细信息，附加当前Python主版本信息以便于问题定位\nselect syntaxFailure, syntaxFailure.getMessage() + \" (in Python \" + major_version() + \").\"",
    "output": "// 导入Python语言分析模块，提供Python代码的语法树构建、解析和错误检测功能"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jwt-missing-verification]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects JWT decoding operations that lack verification using a cryptographic secret or public key.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name JWT missing secret or public key verification\n * @description Detects JWT decoding operations that lack verification using a cryptographic secret or public key.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-missing-verification\n * @tags security\n *       experimental\n *       external/cwe/cwe-347\n */\n\n// Import required modules for Python AST analysis and security concept detection\nimport python\nimport experimental.semmle.python.Concepts\n\n// Locate instances of JWT decoding without proper cryptographic verification\nfrom JwtDecoding insecureJwtOperation\nwhere \n  // Exclude JWT operations that perform signature verification with cryptographic keys\n  not insecureJwtOperation.verifiesSignature()\n// Report the JWT payload location with security advisory message\nselect insecureJwtOperation.getPayload(), \"is not verified with a cryptographic secret or public key.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Implicit string concatenation in a list\n * @description Detects implicit string concatenation in lists which may indicate missing commas\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-665\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/implicit-string-concatenation-in-list\n */\n\nimport python\n\n/**\n * Determines whether an expression represents a string constant.\n * This includes both direct string literals and implicitly concatenated strings.\n * @param expr The expression to evaluate\n */\npredicate isStringConstant(Expr expr) {\n  // Base case: direct string literal\n  expr instanceof StringLiteral\n  // Recursive case: binary operation where both operands are string constants\n  or \n  (\n    isStringConstant(expr.(BinaryExpr).getLeft()) and \n    isStringConstant(expr.(BinaryExpr).getRight())\n  )\n}\n\n/**\n * Identifies string literals with implicit concatenation within lists.\n * This pattern commonly indicates a missing comma between list elements.\n */\nfrom StringLiteral strLit\nwhere\n  // Condition 1: The string literal contains implicit concatenation\n  exists(strLit.getAnImplicitlyConcatenatedPart()) and\n  // Condition 2: The string literal isn't parenthesized (which would make concatenation explicit)\n  not strLit.isParenthesized() and\n  // Condition 3: The string literal appears in a list containing another string constant\n  exists(List containerList, Expr adjacentString |\n    // The string literal is an element in the list\n    containerList.getAnElt() = strLit and\n    // The list contains another distinct string element\n    containerList.getAnElt() = adjacentString and\n    not strLit = adjacentString and\n    // The adjacent element is also a string constant (literal or concatenated)\n_______________ // 补全条件\n  )\nselect strLit, \"Implicit string concatenation. Maybe missing a comma?\"",
    "output": "isStringConstant(adjacentString)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Detects cryptographic implementations utilizing elliptic curve algorithms\n *              that are either unrecognized or classified as cryptographically weak,\n *              which may introduce security vulnerabilities in the application.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm curveImplementation, string securityWarning, string ellipticCurveIdentifier\nwhere\n  // Define the set of cryptographically approved elliptic curves\n  exists(string approvedCurve |\n    approvedCurve = [\n      \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n      \"SECP384R1\",              // P-384 curve\n      \"SECP521R1\",              // P-521 curve\n      \"ED25519\",                // Ed25519 curve\n_______________ // 补全条件\n    ]\n  |\n    // Retrieve the curve identifier from the implementation\n    ellipticCurveIdentifier = curveImplementation.getCurveName() and\n    (\n      // First scenario: Detection of an unrecognized curve algorithm\n      ellipticCurveIdentifier = unknownAlgorithm() and\n      securityWarning = \"Use of unrecognized curve algorithm.\"\n      or\n      // Second scenario: Detection of a recognized but cryptographically weak curve algorithm\n      ellipticCurveIdentifier != unknownAlgorithm() and\n      not ellipticCurveIdentifier = approvedCurve and\n      securityWarning = \"Use of weak curve algorithm \" + ellipticCurveIdentifier + \".\"\n    )\n  )\nselect curveImplementation, securityWarning",
    "output": "\"X25519\"                  // X25519 curve"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Flask app is run in debug mode\n * @description Running a Flask app in debug mode may allow an attacker to run arbitrary code through the Werkzeug debugger.\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/flask-debug\n * @tags security\n *       external/cwe/cwe-215\n *       external/cwe/cwe-489\n */\n\nimport python  // 导入python库，用于分析Python代码\nimport semmle.python.dataflow.new.DataFlow  // 导入数据流分析库\nimport semmle.python.ApiGraphs  // 导入API图分析库\nimport semmle.python.frameworks.Flask  // 导入Flask框架分析库\n_______________ // 补全条件\n// 从API调用节点中选择调用\nfrom API::CallNode call\nwhere\n  // 检查是否为Flask应用实例的run方法调用，并且第二个参数（debug）为true\n  call = Flask::FlaskApp::instance().getMember(\"run\").getACall() and\n  call.getParameter(2, \"debug\").getAValueReachingSink().asExpr().(ImmutableLiteral).booleanValue() = true\nselect call,\n  // 选择符合条件的调用并输出警告信息\n  \"A Flask app appears to be run in debug mode. This may allow an attacker to run arbitrary code through the debugger.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of a broken or weak cryptographic algorithm\n * @description Employing broken or weak cryptographic algorithms can lead to security vulnerabilities.\n * @kind problem\n_______________ // 补全条件\n * @security-severity 7.5\n * @precision high\n * @id py/weak-cryptographic-algorithm\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.Concepts\n\n// Locate cryptographic operations that utilize weak algorithms or block modes\nfrom Cryptography::CryptographicOperation secureOp, string alertPrefix\nwhere\n  (\n    // Check for weak encryption algorithm\n    exists(Cryptography::EncryptionAlgorithm weakAlgo | \n      weakAlgo = secureOp.getAlgorithm() and\n      weakAlgo.isWeak() and\n      alertPrefix = \"The cryptographic algorithm \" + weakAlgo.getName()\n    )\n    // Check for weak block mode\n    or\n    secureOp.getBlockMode().isWeak() and \n    alertPrefix = \"The block mode \" + secureOp.getBlockMode()\n  )\nselect secureOp, \"$@ is broken or weak, and should not be used.\", secureOp.getInitialization(),\n  alertPrefix",
    "output": "* @problem.severity warning"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/return-or-yield-outside-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using 'return' or 'yield' outside a function causes a 'SyntaxError' at runtime.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of 'return' or 'yield' outside a function\n * @description Using 'return' or 'yield' outside a function causes a 'SyntaxError' at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/return-or-yield-outside-function\n */\n\nimport python\n\n// 查询目标：检测在函数体外使用控制流语句的情况\nfrom AstNode problematicStmt, string statementType\nwhere \n  // 确认语句不在任何函数定义的作用域内\n  not exists(Function enclosingFunc | problematicStmt.getScope() = enclosingFunc.getScope())\n  and\n  (\n    // 检测 return 语句\n    (problematicStmt instanceof Return and statementType = \"return\")\n    or\n    // 检测 yield 语句\n    (problematicStmt instanceof Yield and statementType = \"yield\")\n    or\n    // 检测 yield from 语句\n    (problematicStmt instanceof YieldFrom and statementType = \"yield from\")\n  )\n// 返回违规语句及相应的错误描述\nselect problematicStmt, \"'\" + statementType + \"' is used outside a function.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Superclass attribute shadows subclass method\n * @description Detects when an attribute set in a superclass's __init__ method \n *              unintentionally hides a method defined in a subclass, potentially causing runtime errors.\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n_______________ // 补全条件\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * This query identifies subclass methods that become inaccessible due to \n * attribute assignments in superclass initializers, which may lead to \n * unexpected behavior when method resolution order is affected.\n */\n\nimport python\n\n// Predicate detecting subclass methods hidden by superclass attributes\npredicate method_hidden_by_super_attr(\n  ClassObject subCls, ClassObject superCls, Assign attrAssign, FunctionObject hiddenMethod\n) {\n  // Establish inheritance relationship\n  subCls.getASuperType() = superCls and\n  // Verify subclass contains the hidden method\n  subCls.declaredAttribute(_) = hiddenMethod and\n  // Find superclass __init__ containing the shadowing attribute\n  exists(FunctionObject superInit |\n    superCls.declaredAttribute(\"__init__\") = superInit and\n    // Identify attribute assignment that causes shadowing\n    exists(Attribute assignedAttr |\n      assignedAttr = attrAssign.getATarget() and\n      // Confirm assignment targets 'self' instance\n      assignedAttr.getObject().(Name).getId() = \"self\" and\n      // Match attribute name with hidden method name\n      assignedAttr.getName() = hiddenMethod.getName() and\n      // Ensure assignment occurs within __init__ scope\n      attrAssign.getScope() = superInit.getOrigin().(FunctionExpr).getInnerScope()\n    )\n  ) and\n  // Exclude cases where superclass defines the same method\n  not superCls.hasAttribute(hiddenMethod.getName())\n}\n\n// Query to identify shadowed methods and their source attributes\nfrom ClassObject subCls, ClassObject superCls, Assign attrAssign, FunctionObject hiddenMethod\nwhere method_hidden_by_super_attr(subCls, superCls, attrAssign, hiddenMethod)\n// Output: hidden method location, detailed message, attribute assignment location\nselect hiddenMethod.getOrigin(),\n  \"Method \" + hiddenMethod.getName() + \" is shadowed by $@ in superclass '\" + superCls.getName() +\n    \"'.\", attrAssign, \"attribute\"",
    "output": "* @sub-severity low"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of 'global' at module level\n * @description Use of the 'global' statement at module level\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n_______________ // 补全条件\n * @id py/redundant-global-declaration\n */\n\n// Import Python language module for code analysis and AST traversal\nimport python\n\n// Identify global variable declarations that occur at module scope\nfrom Global redundantGlobalDecl\nwhere \n  // Restrict analysis to global declarations in module context only\n  redundantGlobalDecl.getScope() instanceof Module\nselect \n  redundantGlobalDecl, \n  // Construct warning message highlighting the redundant global usage\n  \"Declaring '\" + redundantGlobalDecl.getAName() + \"' as global at module-level is redundant.\"",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Assert statement tests the truth value of a literal constant\n * @description Detects assert statements that evaluate literal constants, which may behave\n *              differently under compiler optimizations and indicate potential dead code.\n * @kind problem\n * @tags reliability\n_______________ // 补全条件\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/assert-literal-constant\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom Assert assertStmt, string literalValue\nwhere\n  // Skip assertions within test frameworks to reduce false positives\n  not assertStmt.getScope().getScope*() instanceof TestScope and\n  // Extract literal constant value from assertion test expression\n  exists(Expr testExpr | \n    testExpr = assertStmt.getTest() and (\n      // Process integer literals (e.g., assert 5)\n      literalValue = testExpr.(IntegerLiteral).getN() or\n      // Process string literals with escaped quotes (e.g., assert \"foo\")\n      literalValue = \"\\\"\" + testExpr.(StringLiteral).getS() + \"\\\"\" or\n      // Process named constants (e.g., assert True)\n      literalValue = testExpr.(NameConstant).toString()\n    )\n  ) and\n  // Filter out assertions at the end of elif chains (common debug placeholders)\n  not exists(If ifStmt | \n    ifStmt.getElif().getAnOrelse() = assertStmt\n  )\nselect assertStmt, \"Assert of literal constant \" + literalValue + \".\"",
    "output": "*       correctness"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unknown-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别在非对称加密密钥生成过程中，密钥大小参数无法通过静态分析验证的代码实例",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 未知密钥生成密钥大小\n * @description 识别在非对称加密密钥生成过程中，密钥大小参数无法通过静态分析验证的代码实例\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查询非对称密钥生成操作及其配置源\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node configSource\nwhere\n  // 获取密钥配置源\n  configSource = keyGenOperation.getKeyConfigSrc() and\n  // 验证操作是否缺少静态可验证的密钥大小\n  not keyGenOperation.hasKeySize(configSource)\nselect keyGenOperation,\n  // 获取算法名称并输出包含算法名称和配置源的诊断信息\n  \"算法 \" + keyGenOperation.getAlgorithm().getName() + \" 的密钥生成使用了无法静态验证的密钥大小，配置源位于 $@\", configSource, configSource.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/nested-loops-with-same-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies nested for loops that reuse identical iteration variables,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Nested loops with same variable\n * @description Identifies nested for loops that reuse identical iteration variables,\n *              which may introduce logical errors and reduce code clarity.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\n// Checks whether a for loop uses the specified variable as its iteration target\npredicate loopUsesTargetVar(For loopStmt, Variable var) { \n  loopStmt.getTarget().defines(var) \n}\n\n// Query: Find nested loops sharing iteration variables with external references\nfrom For nestedLoop, For enclosingLoop, Variable sharedVar\nwhere \n  // Ensure inner loop is directly nested within outer loop's body (excluding else branches)\n  enclosingLoop.getBody().contains(nestedLoop) and\n  // Verify both loops utilize the same iteration variable\n  loopUsesTargetVar(nestedLoop, sharedVar) and\n  loopUsesTargetVar(enclosingLoop, sharedVar) and\n  // Confirm variable is referenced in outer scope beyond inner loop boundaries\n  exists(Name varUsage | \n    varUsage.uses(sharedVar) and \n    enclosingLoop.contains(varUsage) and \n    not nestedLoop.contains(varUsage)\n  )\nselect nestedLoop, \n  \"Nested for loop reuses iteration variable '\" + sharedVar.getId() + \n  \"' from enclosing $@.\", \n  enclosingLoop, \n  \"outer for loop\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/implicit-string-concatenation-in-list]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects string literals that are implicitly concatenated within a list,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Implicit string concatenation in a list\n * @description Detects string literals that are implicitly concatenated within a list,\n *              which may indicate a missing comma and reduce code clarity.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-665\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/implicit-string-concatenation-in-list\n */\n\nimport python\n\n/**\n * Identifies string constants including implicitly concatenated strings.\n * Handles both direct literals and recursive binary operations between strings.\n */\npredicate isStringConstant(Expr expr) {\n  // Base case: Direct string literal\n  expr instanceof StringLiteral\n  // Recursive case: Binary operation between string constants\n  or \n  exists(BinaryExpr binOp | \n    binOp = expr and \n    isStringConstant(binOp.getLeft()) and \n    isStringConstant(binOp.getRight())\n  )\n}\n\nfrom StringLiteral targetStr\nwhere\n  // Condition 1: Verify implicit concatenation exists and isn't parenthesized\n  exists(targetStr.getAnImplicitlyConcatenatedPart()) and\n  not targetStr.isParenthesized() and\n  \n  // Condition 2: Check if string exists in a list with other string constants\n  exists(List containerList |\n    // Confirm target string is in list\n    containerList.getAnElt() = targetStr and\n    \n    // Find another string constant in same list\n    exists(Expr otherStr |\n      otherStr != targetStr and\n      containerList.getAnElt() = otherStr and\n      isStringConstant(otherStr)\n    )\n  )\nselect targetStr, \"Implicit string concatenation. Maybe missing a comma?\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-complex-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies `__del__` methods with high cyclomatic complexity. The `__del__` special method in Python",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly complex `__del__` method\n * @description Identifies `__del__` methods with high cyclomatic complexity. The `__del__` special method in Python \n *              is invoked during object destruction, which occurs at unpredictable times or might not happen at all. \n *              Complex logic within these methods can cause performance issues and unpredictable behavior during \n *              garbage collection cycles.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python\n\nfrom FunctionValue delMethod\nwhere \n  // Identify classes that define a __del__ method\n  exists(ClassValue definingClass | \n    definingClass.declaredAttribute(\"__del__\") = delMethod\n  )\n  // Evaluate if the __del__ method has excessive complexity\n  and \n  delMethod.getScope().getMetrics().getCyclomaticComplexity() > 3\nselect delMethod, \"Overly complex '__del__' method.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Code injection\n * @description Execution of unsanitized user-provided input as code enables attackers to perform\n *              arbitrary code execution.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.3\n * @sub-severity high\n * @precision high\n * @id py/code-injection\n * @tags security\n *       external/cwe/cwe-094\n *       external/cwe/cwe-095\n *       external/cwe/cwe-116\n */\n\n// Import Python language analysis library\nimport python\n\n// Import CodeQL security dataflow module for code injection analysis\nimport semmle.python.security.dataflow.CodeInjectionQuery\n\n// Import PathGraph class representing vulnerability propagation paths\nimport CodeInjectionFlow::PathGraph\n\n// Define query identifying code injection vulnerability paths\nfrom CodeInjectionFlow::PathNode injectionSource, CodeInjectionFlow::PathNode injectionSink\n_______________ // 补全条件\n  // Condition: Verify data flow path exists from source to sink\n  CodeInjectionFlow::flowPath(injectionSource, injectionSink)\nselect \n  // Output sink location, source-to-sink path, and vulnerability description\n  injectionSink.getNode(), \n  injectionSource, \n  injectionSink, \n  \"This code execution depends on a $@.\", \n  injectionSource.getNode(),\n  \"user-provided value\"",
    "output": "where"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Symmetric Padding Schemes Detection\n * @description Identifies cryptographic padding schemes used with symmetric encryption algorithms.\n *              This query helps detect specific padding methods that may impact security posture,\n_______________ // 补全条件\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricPadding scheme\nselect scheme, \n       \"Use of algorithm \" + scheme.getPaddingName()",
    "output": "*              particularly in quantum readiness assessments and CBOM analysis."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-recent-authors]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Number of distinct authors that have recently made changes",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of recent authors\n * @description Number of distinct authors that have recently made changes\n * @kind treemap\n * @id py/historical-number-of-recent-authors\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python // 导入python库，用于处理Python代码\nimport external.VCS // 导入外部版本控制系统（VCS）库，用于访问版本控制信息\n\n// 从模块m中选择数据\nfrom Module m\n// 条件：模块m存在行数度量指标\nwhere exists(m.getMetrics().getNumberOfLinesOfCode())\n// 选择模块m和最近180天内有提交的作者数量\nselect m,\n  count(Author author |\n    // 条件：存在一个提交e满足以下条件\n    exists(Commit e |\n      e = author.getACommit() and // 提交e是作者author的一个提交\n      m.getFile() = e.getAnAffectedFile() and // 提交e影响了模块m的文件\n      e.daysToNow() <= 180 and // 提交e在最近180天内\n      not artificialChange(e) // 提交e不是人工变更\n    )\n  )"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/decompression-bomb]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies decompression bomb vulnerabilities where untrusted data",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Decompression Bomb Vulnerability\n * @description Identifies decompression bomb vulnerabilities where untrusted data\n *              is passed to decompression APIs without compression ratio checks\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.8\n * @precision high\n * @id py/decompression-bomb\n * @tags security\n *       experimental\n *       external/cwe/cwe-409\n */\n\n// Core Python analysis capabilities\nimport python\n// Decompression bomb detection utilities\nimport experimental.semmle.python.security.DecompressionBomb\n// Path flow visualization tools\nimport BombsFlow::PathGraph\n\n// Identify source and sink nodes for decompression attacks\nfrom BombsFlow::PathNode sourceNode, BombsFlow::PathNode sinkNode\n// Ensure complete data flow path exists between source and sink\nwhere BombsFlow::flowPath(sourceNode, sinkNode)\n// Generate security alert with complete attack path context\nselect sinkNode.getNode(), \n       sourceNode, \n       sinkNode, \n       \"This uncontrolled decompression originates from $@.\", \n       sourceNode.getNode(),\n       \"untrusted input that may trigger excessive resource consumption\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mismatch between signature and use of an overridden method\n * @description Identifies methods whose signatures differ from both their overridden methods\n_______________ // 补全条件\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/inheritance/incorrect-overridden-signature\n */\n\nimport python  // Provides core Python code analysis capabilities\nimport Expressions.CallArgs  // Enables analysis of function call arguments\n\nfrom Call invocation, FunctionValue parentMethod, FunctionValue childMethod, string problemDescription  // Define data sources for the query\nwhere\n  // Filter out constructor methods as they typically have different parameter patterns\n  not parentMethod.getName() = \"__init__\" and\n  \n  // Verify that the child method actually overrides the parent method\n  childMethod.overrides(parentMethod) and\n  \n  // Retrieve the call node where the child method is invoked\n  invocation = childMethod.getAMethodCall().getNode() and\n  \n  // Ensure the arguments are correct when called as a method\n  correct_args_if_called_as_method(invocation, childMethod) and\n  \n  // Analyze various parameter mismatch scenarios\n  (\n    // Scenario 1: Insufficient arguments provided\n    arg_count(invocation) + 1 < parentMethod.minParameters() and \n    problemDescription = \"too few arguments\"\n    \n    or\n    \n    // Scenario 2: Excessive arguments provided\n    arg_count(invocation) >= parentMethod.maxParameters() and \n    problemDescription = \"too many arguments\"\n    \n    or\n    \n    // Scenario 3: Keyword arguments accepted by child but not parent\n    exists(string parameterName |\n      // Identify keyword argument names in the invocation\n      invocation.getAKeyword().getArg() = parameterName and\n      \n      // Confirm the parameter exists in the child method's parameter list\n      childMethod.getScope().getAnArg().(Name).getId() = parameterName and\n      \n      // Verify the parameter is absent from the parent method's parameter list\n      not parentMethod.getScope().getAnArg().(Name).getId() = parameterName and\n      \n      // Construct the problem description\n      problemDescription = \"an argument named '\" + parameterName + \"'\"\n    )\n  )\nselect parentMethod,  // Select the parent method as the primary result\n  \"Overridden method signature does not match $@, where it is passed \" + problemDescription +\n    \". Overriding method $@ matches the call.\", invocation, \"call\", childMethod,  // Generate descriptive error message\n  childMethod.descriptiveString()  // Provide detailed description of the child method",
    "output": "*              and the arguments used in their calls, which may lead to runtime errors."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-module global variable usage detection.\n * @description This query finds occurrences of the 'global' keyword when used outside module scope,\n *              potentially resulting in code that's hard to maintain and comprehend.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/use-of-global\n */\n\nimport python\n\n// Source: all global variable declarations\nfrom Global nonModuleGlobalVar\n_______________ // 补全条件\nwhere \n  // Verify the global variable is not declared within module scope\n  not nonModuleGlobalVar.getScope() instanceof Module\n// Output: the global variable and a warning message\nselect nonModuleGlobalVar, \"Modifying global variables outside of module initialization is considered a bad practice.\"",
    "output": "// Condition: global variable must be outside module scope"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name An assert statement has a side-effect\n * @description Detects assert statements containing expressions with side-effects,\n *              which cause behavioral differences between normal and optimized execution.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/side-effect-in-assert\n */\n\nimport python\n_______________ // 补全条件\n// Predicate to identify expressions containing function calls with known side effects\npredicate exprContainsSideEffectFunc(Expr expr) {\n  // Check if the expression is an attribute or name reference to a side-effect function\n  exists(string funcName | \n    funcName = expr.(Attribute).getName() or funcName = expr.(Name).getId() |\n    funcName in [\n        \"print\", \"write\", \"append\", \"pop\", \"remove\", \"discard\", \"delete\", \"close\", \"open\", \"exit\"\n      ]\n  )\n}\n\n// Predicate to identify subprocess module calls which inherently have side effects\npredicate isSubprocessCall(Call callExpr) {\n  // Match calls to subprocess module functions that execute external commands\n  callExpr.getAFlowNode() = Value::named(\"subprocess.call\").getACall()\n  or\n  callExpr.getAFlowNode() = Value::named(\"subprocess.check_call\").getACall()\n  or\n  callExpr.getAFlowNode() = Value::named(\"subprocess.check_output\").getACall()\n}\n\n// Predicate to determine if an expression may produce side effects\npredicate hasPotentialSideEffect(Expr expr) {\n  // Case 1: Yield expressions (excluding those in comprehensions)\n  expr instanceof Yield and not exists(Comp c | c.contains(expr))\n  or\n  // Case 2: YieldFrom expressions\n  expr instanceof YieldFrom\n  or\n  // Case 3: Function calls with side effects\n  expr instanceof Call and exprContainsSideEffectFunc(expr.(Call).getFunc())\n  or\n  // Case 4: Subprocess calls\n  expr instanceof Call and isSubprocessCall(expr)\n}\n\n// Main query to find assert statements containing expressions with side effects\nfrom Assert assertStmt, Expr exprWithSideEffect\nwhere hasPotentialSideEffect(exprWithSideEffect) and assertStmt.contains(exprWithSideEffect)\nselect assertStmt, \"This 'assert' statement contains an $@ which may have side effects.\", exprWithSideEffect, \"expression\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称加密算法\n * @description 查找所有使用受支持库的潜在非对称密钥进行加密或密钥交换的用法。\n * @kind 问题\n * @id py/quantum-readiness/cbom/all-asymmetric-encryption-algorithms\n * @problem.severity 错误\n * @tags cbom\n *       密码学\n */\n_______________ // 补全条件\nimport python\nimport experimental.cryptography.Concepts\n\n// 从 AsymmetricEncryptionAlgorithm 类中选择算法实例 alg\nfrom AsymmetricEncryptionAlgorithm alg\n// 选择 alg 和 \"Use of algorithm \" + alg.getEncryptionName() 作为查询结果\nselect alg, \"Use of algorithm \" + alg.getEncryptionName()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Untrusted Input Injection via Cookies\n * @description Identifies instances where untrusted user inputs are directly used to construct cookie values,\n *              creating potential for injection attacks that could compromise session integrity and confidentiality.\n *              This pattern aligns with CWE-20 (Improper Input Validation) and may lead to cookie tampering vulnerabilities.\n * @id py/untrusted-cookie-injection\n * @kind path-problem\n * @precision medium\n * @problem.severity high\n * @security-severity 8.7\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\n_______________ // 补全条件\n  CookieInjectionFlow::PathNode untrustedInputSource, \n  CookieInjectionFlow::PathNode cookieAssignmentSink, \n  int configId\nwhere \n  configId = 1\n  and CookieInjectionFlow::flowPath(untrustedInputSource, cookieAssignmentSink)\nselect \n  cookieAssignmentSink.getNode(), \n  untrustedInputSource, \n  cookieAssignmentSink, \n  \"Cookie value constructed from $@.\", \n  untrustedInputSource.getNode(), \n  \"untrusted user input\"",
    "output": "from"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-parameters-without-default-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The number of parameters of a function that do not have default values defined.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of parameters without defaults\n * @description The number of parameters of a function that do not have default values defined.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // 导入Python库，用于处理Python代码的查询\n\n// 从FunctionMetrics类中选择函数和没有默认值的参数数量\nfrom FunctionMetrics func\nselect func, func.getNumberOfParametersWithoutDefault() as n order by n desc\n// 选择函数func和其没有默认值的参数数量n，并按n降序排列"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cryptographic implementations utilizing elliptic curve algorithms",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Detects cryptographic implementations utilizing elliptic curve algorithms \n *              that are either unapproved or considered cryptographically weak, which may \n *              introduce security vulnerabilities.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm cryptoOperation, string alertMessage, string curveIdentifier\nwhere\n  // Define the set of cryptographically approved elliptic curves\n  exists(string approvedCurve |\n    approvedCurve = [\n      \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n      \"SECP384R1\",              // P-384 curve\n      \"SECP521R1\",              // P-521 curve\n      \"ED25519\",                // Ed25519 curve\n      \"X25519\"                  // X25519 curve\n    ]\n  |\n    // Extract the curve identifier from the cryptographic operation\n    curveIdentifier = cryptoOperation.getCurveName() and\n    (\n      // Scenario 1: Detection of an unrecognized curve algorithm\n      curveIdentifier = unknownAlgorithm() and\n      alertMessage = \"Use of unrecognized curve algorithm.\"\n      or\n      // Scenario 2: Detection of a recognized but cryptographically weak curve algorithm\n      curveIdentifier != unknownAlgorithm() and\n      not curveIdentifier = approvedCurve and\n      alertMessage = \"Use of weak curve algorithm \" + curveIdentifier + \".\"\n    )\n  )\nselect cryptoOperation, alertMessage"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Property in old-style class\n * @description Identifies property descriptors used in old-style classes, which lack proper support since Python 2.1.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n_______________ // 补全条件\n * @precision very-high\n * @id py/property-in-old-style-class\n */\n\nimport python\n\n// Find property objects defined within old-style classes\nfrom PropertyObject prop, ClassObject cls\n// Verify the following conditions:\n// 1. Property is directly declared in the class\n// 2. Class type inference was successful\n// 3. Class uses old-style inheritance (not new-style)\nwhere \n  cls.declaredAttribute(_) = prop and\n  not cls.failedInference() and\n  not cls.isNewStyle()\n// Report the property with contextual warning message\nselect prop,\n  \"Property \" + prop.getName() + \" will not work properly, as class \" + cls.getName() +\n    \" is an old-style class.\"",
    "output": "* @sub-severity low"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-recent-authors]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query calculates the number of distinct contributors who have made",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Recent contributors count per module\n * @description This query calculates the number of distinct contributors who have made \n *              changes to each Python module within the last 180 days. It helps identify\n *              modules with high contributor activity, which may indicate areas of frequent\n *              updates or potential maintenance burden.\n * @kind treemap\n * @id py/historical-number-of-recent-authors\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Select each module that has lines of code metrics\nfrom Module targetModule\nwhere exists(targetModule.getMetrics().getNumberOfLinesOfCode())\nselect targetModule,\n  count(Author codeAuthor |\n    // Check if the author has made valid commits to the module in the last 180 days\n    exists(Commit versionCommit |\n      versionCommit = codeAuthor.getACommit() and\n      targetModule.getFile() = versionCommit.getAnAffectedFile() and\n      versionCommit.daysToNow() <= 180 and\n      not artificialChange(versionCommit)\n    )\n  )"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-hostname-regexp]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects security vulnerabilities in regular expressions used for hostname or URL validation,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Vulnerable hostname regular expression patterns\n * @description Detects security vulnerabilities in regular expressions used for hostname or URL validation, \n *              specifically focusing on patterns where dots are not properly escaped, leading to overly \n *              permissive hostname matching that could bypass security restrictions.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-hostname-regexp\n * @tags correctness\n *       security\n *       external/cwe/cwe-020\n */\n\n// Import the specialized analysis module designed for examining security aspects of hostname regular expressions\nprivate import semmle.python.security.regexp.HostnameRegex as HostnameRegexSecurityModule\n\n// Define the primary query predicate to detect security vulnerabilities in hostname regular expressions\n// This predicate identifies patterns where hostname validation regex patterns are insufficient,\n// potentially allowing attackers to bypass security restrictions through malformed hostnames\n// The predicate leverages the security module to analyze regex patterns for incomplete hostname validation\nquery predicate insecureHostnamePatterns = \n  HostnameRegexSecurityModule::incompleteHostnameRegExp/4;"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name JWT encoding with empty key or algorithm\n * @description Identifies JWT token encoding operations that utilize empty cryptographic keys or algorithms,\n *              potentially causing security weaknesses in token validation mechanisms.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-empty-secret-or-algorithm\n * @tags security\n *       experimental\n */\n\n// Import Python analysis core libraries\nimport python\nimport experimental.semmle.python.Concepts\nimport experimental.semmle.python.frameworks.JWT\n\n// Detect JWT encoding operations with vulnerable parameters\nfrom JwtEncoding encodingOp, string paramName\nwhere\n  // Check for empty algorithm parameter\n  (\n    paramName = \"algorithm\" and\n    isEmptyOrNone(encodingOp.getAlgorithm())\n  )\n  or\n_______________ // 补全条件\n  (\n    paramName = \"key\" and\n    isEmptyOrNone(encodingOp.getKey())\n  )\nselect encodingOp, \"This JWT encoding uses an empty \" + paramName + \" parameter.\"",
    "output": "// Check for empty key parameter"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Detection of Asymmetric Encryption Padding Techniques\n * @description Identifies all instances where padding schemes are employed in asymmetric cryptographic algorithms.\n_______________ // 补全条件\n * @id py/quantum-readiness/cbom/asymmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python  // 导入Python库，用于分析Python代码\nimport experimental.cryptography.Concepts  // 导入实验性加密概念库，用于处理加密相关的概念\n\n// 查询所有非对称加密填充方案\nfrom AsymmetricPadding paddingScheme\n\n// 输出填充方案对象及其描述信息\nselect paddingScheme, \"Detected asymmetric padding scheme: \" + paddingScheme.getPaddingName()",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name 外部依赖关系\n * @description 计算一个Python源文件对外部包的依赖数量。\n * @kind treemap\n_______________ // 补全条件\n * @metricType externalDependency\n * @id py/external-dependencies\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 分析Python源文件与外部包的依赖关系，量化每个文件对各个外部包的依赖程度。\n * \n * 核心逻辑要素：\n * 1. 源代码文件路径（依赖主体）\n * 2. 外部包对象（PyPI等外部源提供的包）\n * 3. 包版本信息（可用时）\n * 4. 源文件对包的依赖计数\n * \n * 输出格式说明：\n * - 第一列：依赖实体标识符（文件路径+包信息组合）\n * - 第二列：依赖计数（降序排列）\n * - 文件路径添加'/'前缀以匹配仪表板数据库格式\n */\n\n// 定义查询变量：源文件、依赖计数、依赖实体、外部包\nfrom File sourceFile, int depCount, string depEntity, ExternalPackage extPkg\nwhere\n  // 计算源文件对特定外部包的依赖数量\n  depCount = strictcount(AstNode node |\n    dependency(node, extPkg) and // 检查AST节点是否依赖指定外部包\n    node.getLocation().getFile() = sourceFile // 确保节点位于目标源文件中\n  ) and\n  // 构建依赖实体标识符（合并文件路径和包信息）\n  depEntity = munge(sourceFile, extPkg)\n// 输出结果：依赖实体和依赖计数，按依赖数量降序排列\nselect depEntity, depCount order by depCount desc",
    "output": "* @treemap.warnOn highValues"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/missing-docstring]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Public classes, functions, or methods without documentation strings",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Missing docstring\n * @description Public classes, functions, or methods without documentation strings\n *              hinder code maintainability for other developers.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/missing-docstring\n */\n\n/*\n * NOTE: The 'medium' precision is due to the subjective nature of docstring requirements.\n * Whether a function requires a docstring often depends on its intended audience.\n */\n\nimport python\n\n/**\n * Determines whether a scope requires a docstring.\n * A scope needs a docstring if it's public and either:\n * 1. It's not a function, or\n * 2. It's a function that meets the criteria for needing a docstring.\n */\npredicate requires_docstring(Scope scope) {\n  scope.isPublic() and\n  (\n    not scope instanceof Function\n    or\n    function_requires_docstring(scope)\n  )\n}\n\n/**\n * Checks if a function requires a docstring based on specific criteria:\n * - It's not overriding a function that doesn't need a docstring\n * - It's not a lambda function\n * - It has more than 2 lines of code (excluding decorators)\n * - It's not a property getter or setter\n */\npredicate function_requires_docstring(Function func) {\n  // Ensure the function isn't overriding a base function that doesn't need a docstring\n  not exists(FunctionValue overriding, FunctionValue base | \n    overriding.overrides(base) and overriding.getScope() = func |\n    not function_requires_docstring(base.getScope())\n  ) and\n  // Exclude lambda functions\n  func.getName() != \"lambda\" and\n  // Check if the function has substantial code (more than 2 lines excluding decorators)\n  (func.getMetrics().getNumberOfLinesOfCode() - count(func.getADecorator())) > 2 and\n  // Exclude property getters and setters\n  not exists(PythonPropertyObject prop |\n    prop.getGetter().getFunction() = func or\n    prop.getSetter().getFunction() = func\n  )\n}\n\n/**\n * Returns the type of a scope as a string.\n * Possible values: \"Module\", \"Class\", or \"Function\".\n */\nstring get_scope_type(Scope scope) {\n  // Check if it's a module (but not a package)\n  result = \"Module\" and scope instanceof Module and not scope.(Module).isPackage()\n  // Check if it's a class\n  or\n  result = \"Class\" and scope instanceof Class\n  // Check if it's a function\n  or\n  result = \"Function\" and scope instanceof Function\n}\n\n// Find all scopes that require a docstring but don't have one\nfrom Scope scope\nwhere requires_docstring(scope) and not exists(scope.getDocString())\nselect scope, get_scope_type(scope) + \" \" + scope.getName() + \" does not have a docstring.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Redundant module-level global declarations\n * @description Identifies redundant 'global' keyword usage at module scope in Python code\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-global-declaration\n */\n\n// Import Python analysis framework\nimport python\n\n// Identify global declarations that are redundant at module level\nfrom Global redundantGlobalStmt\nwhere \n    // Verify the global statement is at module scope\n_______________ // 补全条件\nselect \n    redundantGlobalStmt, \n    // Construct warning message for the redundant global declaration\n    \"Redundant global declaration of '\" + redundantGlobalStmt.getAName() + \"' at module level.\"",
    "output": "redundantGlobalStmt.getScope() instanceof Module"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use iteration count at least 100k to prevent brute force attacks\n * @description Identifies key derivation functions with insecure iteration configurations.\n * Cryptographic key generation from user inputs (e.g., passwords) requires high iteration counts\n * (minimum 100,000) to effectively resist brute force attacks.\n * \n * Detects two security issues:\n * 1. Iteration counts explicitly set below security threshold\n * 2. Iteration counts that cannot be statically analyzed\n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\nfrom KeyDerivationOperation keyDerivFunc, string alertMsg, DataFlow::Node iterCountSource\nwhere\n  // Focus on key derivation functions requiring iteration parameter configuration\n  keyDerivFunc.requiresIteration() and\n  // Identify the source node providing iteration count value\n  iterCountSource = keyDerivFunc.getIterationSizeSrc() and\n  // Evaluate iteration count security conditions\n  (\n    // Case 1: Explicitly configured iteration count below threshold\n_______________ // 补全条件\n    iterCountSource.asExpr().(IntegerLiteral).getValue() < 10000 and\n    alertMsg = \"Insufficient iteration count configured. \"\n    or\n    // Case 2: Iteration count cannot be statically determined\n    not exists(iterCountSource.asExpr().(IntegerLiteral).getValue()) and\n    alertMsg = \"Cannot statically validate iteration count. \"\n  )\nselect \n  keyDerivFunc, alertMsg + \"Minimum secure iteration count is 10000. Configuration source: $@\",\n  iterCountSource.asExpr(), iterCountSource.asExpr().toString()",
    "output": "exists(iterCountSource.asExpr().(IntegerLiteral).getValue()) and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Symmetric Encryption Padding Schemes Detection\n * @description Identifies symmetric encryption algorithms that utilize padding schemes,\n *              which may be vulnerable to certain cryptographic attacks.\n_______________ // 补全条件\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricPadding symmetricEncryptionWithPadding\nselect symmetricEncryptionWithPadding, \"Identified symmetric encryption with padding: \" + symmetricEncryptionWithPadding.getPaddingName()",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Suspicious unused loop iteration variable\n * @description A loop iteration variable is unused, which suggests an error.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/unused-loop-variable\n */\n\nimport python\nimport Definition\n\n// 判断语句是否为递增操作，例如 x += n 或 x = x + n\npredicate is_increment(Stmt s) {\n  /* x += n */\n  s.(AugAssign).getValue() instanceof IntegerLiteral\n  or\n  /* x = x + n */\n  exists(Name t, BinaryExpr add |\n    t = s.(AssignStmt).getTarget(0) and\n    add = s.(AssignStmt).getValue() and\n    add.getLeft().(Name).getVariable() = t.getVariable() and\n    add.getRight() instanceof IntegerLiteral\n  )\n}\n\n// 判断 for 循环是否为计数循环，即每次迭代变量递增\npredicate counting_loop(For f) { is_increment(f.getAStmt()) }\n\n// 判断 for 循环是否为空循环，即循环体只有一个 Pass 语句\npredicate empty_loop(For f) { not exists(f.getStmt(1)) and f.getStmt(0) instanceof Pass }\n\n// 判断 for 循环是否只包含一个返回或中断语句\npredicate one_item_only(For f) {\n  not exists(Continue c | f.contains(c)) and\n  exists(Stmt s | s = f.getBody().getLastItem() |\n    s instanceof Return\n    or\n    s instanceof Break\n  )\n}\n\n// 判断控制流节点是否指向对 range 或 xrange 的调用\npredicate points_to_call_to_range(ControlFlowNode f) {\n  /* (x)range is a function in Py2 and a class in Py3, so we must treat it as a plain object */\n  exists(Value range |\n    range = Value::named(\"range\") or\n    range = Value::named(\"xrange\")\n  |\n    f = range.getACall()\n  )\n  or\n  /* In case points-to fails due to 'from six.moves import range' or similar. */\n  exists(string range | f.getNode().(Call).getFunc().(Name).getId() = range |\n    range = \"range\" or range = \"xrange\"\n  )\n  or\n  /* Handle list(range(...)) and list(list(range(...))) */\n  f.(CallNode).pointsTo().getClass() = ClassValue::list() and\n  points_to_call_to_range(f.(CallNode).getArg(0))\n}\n\n/** Whether n is a use of a variable that is a not effectively a constant. */\n// 判断名称 n 是否使用了非常量的变量\npredicate use_of_non_constant(Name n) {\n  exists(Variable var |\n    n.uses(var) and\n    /* use is local */\n    not n.getScope() instanceof Module and\n    /* variable is not global */\n    not var.getScope() instanceof Module\n  |\n    /* Defined more than once (dynamically) */\n    strictcount(Name def | def.defines(var)) > 1\n    or\n    exists(For f, Name def | f.contains(def) and def.defines(var))\n    or\n    exists(While w, Name def | w.contains(def) and def.defines(var))\n  )\n}\n\n/**\n * Whether loop body is implicitly repeating something N times.\n * E.g. queue.add(None)\n */\n// 判断循环体是否隐式地重复了某些操作，例如 queue.add(None)\npredicate implicit_repeat(For f) {\n  not exists(f.getStmt(1)) and\n  exists(ImmutableLiteral imm | f.getStmt(0).contains(imm)) and\n  not exists(Name n | f.getBody().contains(n) and use_of_non_constant(n))\n}\n\n/**\n * Get the CFG node for the iterable relating to the for-statement `f` in a comprehension.\n * The for-statement `f` is the artificial for-statement in a comprehension\n * and the result is the iterable in that comprehension.\n * E.g. gets `x` from `{ y for y in x }`.\n */\n// 获取与理解中的 for 语句相关的可迭代对象的控制流图节点\nControlFlowNode get_comp_iterable(For f) {\n  exists(Comp c | c.getFunction().getStmt(0) = f | c.getAFlowNode().getAPredecessor() = result)\n}\n\n// 查询未使用的循环迭代变量，并生成相应的警告信息\nfrom For f, Variable v, string msg\nwhere\n  f.getTarget() = v.getAnAccess() and // 循环目标变量是 v\n  not f.getAStmt().contains(v.getAnAccess()) and // 循环增量语句中不包含 v\n  not points_to_call_to_range(f.getIter().getAFlowNode()) and // 循环迭代器不是对 range 或 xrange 的调用\n  not points_to_call_to_range(get_comp_iterable(f)) and // 理解中的迭代器也不是对 range 或 xrange 的调用\n  not name_acceptable_for_unused_variable(v) and // v 的名称不适合作为未使用变量\n  not f.getScope().getName() = \"genexpr\" and // 不在生成器表达式中\n  not empty_loop(f) and // 不是空循环\n  not one_item_only(f) and // 不只包含一个返回或中断语句\n  not counting_loop(f) and // 不是计数循环\n  not implicit_repeat(f) and // 不是隐式重复操作\n  if exists(Name del | del.deletes(v) and f.getAStmt().contains(del)) // 如果 v 在循环体内被删除\n_______________ // 补全条件\n  else msg = \"' is not used in the loop body.\" // 否则设置消息为“在循环体内未使用”\nselect f, \"For loop variable '\" + v.getId() + msg // 选择循环和相应的警告信息",
    "output": "then msg = \"' is deleted, but not used, in the loop body.\" // 设置消息为“在循环体内被删除但未使用”"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Loop variable capture\n * @description 检测循环变量在闭包或推导式中被捕获的情况。\n *              这可能导致意外行为，因为闭包创建后，循环变量的值可能会改变。\n * @kind problem\n * @tags correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/loop-variable-capture\n */\n\nimport python\n\n// 获取循环迭代变量所属的作用域\nScope getLoopIterationVariableScope(AstNode loopNode) {\n  result = loopNode.(For).getScope()  // For循环的直接作用域\n  or\n  result = loopNode.(Comp).getFunction()  // 推导式所属的函数作用域\n}\n\n// 判断表达式是否捕获了循环变量\npredicate isCapturingLoopVariable(CallableExpr capturedExpr, AstNode loopNode, Variable loopVar) {\n  // 确保变量属于循环迭代作用域\n  loopVar.getScope() = getLoopIterationVariableScope(loopNode) and\n  // 变量访问发生在捕获表达式的内部作用域\n  loopVar.getAnAccess().getScope() = capturedExpr.getInnerScope() and\n  // 捕获表达式是循环节点的后代\n  capturedExpr.getParentNode+() = loopNode and\n  (\n    // For循环：目标变量是当前变量\n    loopNode.(For).getTarget() = loopVar.getAnAccess()\n    or\n    // 推导式：迭代变量是当前变量\n    loopVar = loopNode.(Comp).getAnIterationVariable()\n  )\n}\n\n// 判断捕获的循环变量是否逃逸了原始作用域\n_______________ // 补全条件\n  isCapturingLoopVariable(capturedExpr, loopNode, loopVar) and\n  (\n    // For循环中的逃逸情况：存在循环外部的引用\n    loopNode instanceof For and\n    exists(Expr refExpr | \n      refExpr.pointsTo(_, _, capturedExpr) and\n      not loopNode.contains(refExpr)\n    )\n    or\n    // 推导式中的逃逸情况：捕获表达式作为元素或元素的一部分\n    loopNode.(Comp).getElt() = capturedExpr\n    or\n    loopNode.(Comp).getElt().(Tuple).getAnElt() = capturedExpr\n  )\n}\n\n// 查询所有捕获并逃逸的循环变量\nfrom CallableExpr capturedExpr, AstNode loopNode, Variable loopVar\nwhere isEscapingCapturedLoopVariable(capturedExpr, loopNode, loopVar)\nselect capturedExpr, \"Capture of loop variable $@.\", loopNode, loopVar.getId()",
    "output": "predicate isEscapingCapturedLoopVariable(CallableExpr capturedExpr, AstNode loopNode, Variable loopVar) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Generator in `__init__` method\n * @description Detects class initializers containing generator expressions (yield/yield from).\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n_______________ // 补全条件\n */\n\nimport python\n\nfrom Function initMethod\nwhere\n  // Confirm target is a class initialization method\n  initMethod.isInitMethod() and\n  (\n    // Check for yield statements within method body\n    exists(Yield yieldStmt | yieldStmt.getScope() = initMethod) or\n    // Check for yield from statements within method body\n    exists(YieldFrom yieldFromStmt | yieldFromStmt.getScope() = initMethod)\n  )\nselect initMethod, \"__init__ method is a generator.\"",
    "output": "* @id py/init-method-is-generator"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable 'except' block\n * @description Identifies exception handlers that are never executed because a more general\n *              exception handler precedes them in the same try-except structure, catching\n *              all exceptions before the more specific handler is reached.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Retrieves the exception class that is handled by a given except clause\nClassValue extractExceptionClass(ExceptStmt handler) { \n_______________ // 补全条件\n}\n\n// Determines if an exception handler is unreachable due to the ordering of handlers\npredicate isHandlerUnreachable(ExceptStmt precedingHandler, ClassValue generalExceptionType, \n                              ExceptStmt subsequentHandler, ClassValue specificExceptionType) {\n  exists(int precedingIndex, int subsequentIndex, Try tryStatement |\n    // Both handlers are associated with the same try statement\n    precedingHandler = tryStatement.getHandler(precedingIndex) and\n    subsequentHandler = tryStatement.getHandler(subsequentIndex) and\n    // The preceding handler appears before the subsequent handler in the source code\n    precedingIndex < subsequentIndex and\n    // Extract the exception types for both handlers\n    generalExceptionType = extractExceptionClass(precedingHandler) and\n    specificExceptionType = extractExceptionClass(subsequentHandler) and\n    // The preceding handler catches a superclass of the subsequent handler's exception\n    generalExceptionType = specificExceptionType.getASuperType()\n  )\n}\n\n// Locates all unreachable exception handlers in the codebase\nfrom ExceptStmt precedingHandler, ClassValue generalExceptionType, \n     ExceptStmt subsequentHandler, ClassValue specificExceptionType\nwhere isHandlerUnreachable(precedingHandler, generalExceptionType, subsequentHandler, specificExceptionType)\nselect subsequentHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  specificExceptionType, specificExceptionType.getName(), precedingHandler, \"except block\", generalExceptionType, generalExceptionType.getName()",
    "output": "handler.getType().pointsTo(result)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/failed-inheritance-inference]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes where the analysis engine was unable to determine their inheritance relationships,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inheritance hierarchy cannot be inferred for class\n * @description Identifies classes where the analysis engine was unable to determine their inheritance relationships,\n *              potentially leading to incomplete or inaccurate analysis results.\n * @id py/failed-inheritance-inference\n * @kind problem\n * @problem.severity info\n * @tags debug\n */\n\nimport python\n\n// Identify classes where the inheritance hierarchy inference process encountered errors\n// and retrieve the corresponding error message explaining the failure\nfrom Class classWithFailedInference, string failureMessage\nwhere \n  // Verify that there exists a class instance (ClassObject) associated with our target class\n  // which has experienced a failure during inheritance inference analysis\n  exists(ClassObject classInstance | \n    classInstance.getPyClass() = classWithFailedInference and \n    classInstance.failedInference(failureMessage)\n  )\nselect classWithFailedInference, \"Inference of class hierarchy failed for class '\" + classWithFailedInference.getName() + \"': \" + failureMessage + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class Efferent Coupling Analysis\n * @description Measures and quantifies the number of distinct external classes that each class depends on.\n *              Efferent coupling represents how many different types a particular class relies upon,\n *              which is a key indicator of class responsibility and modularity.\n * @kind treemap\n * @id py/efferent-coupling-per-class\n_______________ // 补全条件\n * @metricType reftype\n * @metricAggregate avg max\n * @tags testability\n *       modularity\n */\n\nimport python\n\n// Analyze each class in the codebase to determine its efferent coupling\n// Efferent coupling is calculated as the count of distinct external dependencies\nfrom ClassMetrics analyzedClass\n// Calculate the efferent coupling metric for the analyzed class\nselect analyzedClass, \n       analyzedClass.getEfferentCoupling() as efferentCouplingCount \n// Order results by the efferent coupling count in descending order\n// This highlights classes with the highest number of external dependencies first\norder by efferentCouplingCount desc",
    "output": "* @treemap.warnOn highValues"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/clear-text-storage-sensitive-data]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测应用程序中敏感数据未经加密或哈希处理直接存储的安全漏洞",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 明文存储敏感信息\n * @description 检测应用程序中敏感数据未经加密或哈希处理直接存储的安全漏洞\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/clear-text-storage-sensitive-data\n * @tags security\n *       external/cwe/cwe-312\n *       external/cwe/cwe-315\n *       external/cwe/cwe-359\n */\n\nimport python\nprivate import semmle.python.dataflow.new.DataFlow\nimport CleartextStorageFlow::PathGraph\nimport semmle.python.security.dataflow.CleartextStorageQuery\n\nfrom \n  CleartextStorageFlow::PathNode sourcePathNode, \n  CleartextStorageFlow::PathNode sinkPathNode, \n  string dataClassification\nwhere \n  CleartextStorageFlow::flowPath(sourcePathNode, sinkPathNode) and\n  dataClassification = sourcePathNode.getNode().(Source).getClassification()\nselect \n  sinkPathNode.getNode(), \n  sourcePathNode, \n  sinkPathNode, \n  \"This expression stores $@ as clear text.\", \n  sourcePathNode.getNode(), \n  \"sensitive data (\" + dataClassification + \")\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Exception block catches 'BaseException'\n * @description Detects exception handling blocks that catch BaseException or utilize bare except clauses\n *              without re-raising the exception. This pattern can hide system-exiting events such as\n *              SystemExit or KeyboardInterrupt, potentially causing improper program termination.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Predicate to identify handlers that catch BaseException or use bare except clauses\npredicate catchesBaseException(ExceptStmt exceptBlock) {\n  // Check for explicit BaseException handling in the except clause\n  exceptBlock.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  // Check for bare except clauses (catches all exceptions including BaseException)\n  not exists(exceptBlock.getType())\n}\n\n// Predicate to determine if an exception block does not re-raise the caught exception\npredicate lacksReraise(ExceptStmt exceptBlock) { \n_______________ // 补全条件\n  exceptBlock.getAFlowNode().getBasicBlock().reachesExit() \n}\n\n// Main query: Find exception handlers that catch BaseException without re-raising\nfrom ExceptStmt exceptBlock\nwhere\n  catchesBaseException(exceptBlock) and\n  lacksReraise(exceptBlock)\nselect exceptBlock, \"Except block directly handles BaseException without re-raising.\"",
    "output": "// Verify that control flow from the exception block reaches program exit"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Weak asymmetric key generation with insufficient key size (< 2048 bits)\n * @description\n * Detects cryptographic operations that generate asymmetric keys with sizes below the recommended\n * security threshold of 2048 bits, which are susceptible to brute-force attacks.\n * @id py/weak-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// This query identifies asymmetric key generation operations with insufficient key strength\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node keyConfigurationNode, int keySizeBits, string algorithmName\nwhere\n  // Extract cryptographic key configuration details\n  (\n    keySizeBits = keyGenOperation.getKeySizeInBits(keyConfigurationNode) and\n    algorithmName = keyGenOperation.getAlgorithm().getName()\n  ) and\n  // Apply security threshold filters\n  (\n    keySizeBits < 2048 and\n    not isEllipticCurveAlgorithm(algorithmName, _)\n  )\n// Generate alert with details about the weak key configuration\nselect keyGenOperation,\n  \"Weak asymmetric key size (\" + keySizeBits.toString() + \" bits) for algorithm \" +\n    algorithmName + \" configured at $@\", keyConfigurationNode, keyConfigurationNode.toString()",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/duplicate-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identical function implementation detected. Refactor by extracting shared code to common modules or base classes.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Duplicate function\n * @description Identical function implementation detected. Refactor by extracting shared code to common modules or base classes.\n * @kind problem\n * @tags testability\n *       useless-code\n *       maintainability\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/duplicate-function\n */\n\nimport python\n\n// Define analysis variables for duplicate function detection\nfrom Function originalFunction, Function duplicateFunc, string message\n// Placeholder condition - currently disabled for future implementation\nwhere \n  none()\n// Format output: original function, diagnostic message, duplicate function, and its name\nselect \n  originalFunction, \n  message, \n  duplicateFunc, \n  duplicateFunc.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Backspace escape in regular expression\n * @description Detects usage of '\\b' to represent backspace character within regex character sets,\n *              which can be confused with word boundary assertions.\n * @kind problem\n * @tags maintainability\n_______________ // 补全条件\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp pattern, int escPos\nwhere\n  // First, locate all escape characters in the regex pattern\n  pattern.escapingChar(escPos) and\n  \n  // Then, verify that 'b' follows the escape character, forming '\\b' sequence\n  pattern.getChar(escPos + 1) = \"b\" and\n  \n  // Finally, ensure this escape sequence is contained within a character set definition\n  exists(int setStart, int setEnd |\n    // Character set must properly enclose the escape position\n    setStart < escPos and \n    setEnd > escPos and\n    // Validate that these positions actually define a character set\n    pattern.charSet(setStart, setEnd)\n  )\nselect pattern, \"Backspace escape in regular expression at offset \" + escPos + \".\"",
    "output": "* @problem.severity recommendation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-block-mode-iv-or-nonce]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects initialization vectors or nonces used in block modes that are weak, obsolete, or unaccepted.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak block mode IV or nonce\n * @description Detects initialization vectors or nonces used in block modes that are weak, obsolete, or unaccepted.\n *              Specifically identifies IVs/nonces not generated by cryptographically secure random number generators.\n * \n *              NOTE: For simplicity, any IV/nonce not explicitly generated by os.urandom is flagged.\n *                    Special cases like GCM nonce requirements or Fernet's internal urandom usage are handled as follows:\n *                    - GCM is assumed to be flagged by a separate query (crypto board review required)\n *                    - Fernet is explicitly excluded since it internally uses os.urandom\n *                    - Functions inferring mode/IV may be flagged (user suppression required)\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom BlockMode blockModeOperation, string message, DataFlow::Node configurationNode\nwhere\n  // Exclude Fernet encryption instances (handled internally)\n  not blockModeOperation instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet and\n  \n  // Check for missing IV/nonce or non-urandom generated IV/nonce\n  (\n    not blockModeOperation.hasIVorNonce() or\n    not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = blockModeOperation.getIVorNonce()\n  ) and\n  \n  // Determine configuration node based on IV/nonce presence\n  (\n    if not blockModeOperation.hasIVorNonce()\n    then configurationNode = blockModeOperation  // Operation itself when missing\n    else configurationNode = blockModeOperation.getIVorNonce()  // Actual IV/nonce node\n  ) and\n  \n  // Standardized warning message\n  message = \"Block mode is not using an accepted IV/Nonce initialization: $@\"\nselect blockModeOperation, message, configurationNode, configurationNode.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Constructing cookies from user input may allow an attacker to perform a Cookie Poisoning attack.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Construction of a cookie using user-supplied input\n * @description Constructing cookies from user input may allow an attacker to perform a Cookie Poisoning attack.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// 导入Python库，用于分析Python代码\nimport python\n\n// 导入与Cookie注入相关的查询模块\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// 导入路径图类，用于表示数据流路径\nimport CookieInjectionFlow::PathGraph\n\n// 定义不可信输入源节点和Cookie构造汇节点\nfrom \n  CookieInjectionFlow::PathNode untrustedInputSource,  // 表示用户提供的不可信输入源\n  CookieInjectionFlow::PathNode cookieConstructionSink // 表示Cookie构造点\n// 验证数据流路径是否存在\nwhere CookieInjectionFlow::flowPath(untrustedInputSource, cookieConstructionSink)\n// 输出结果：汇节点、源节点、路径信息、描述信息\nselect \n  cookieConstructionSink.getNode(), \n  untrustedInputSource, \n  cookieConstructionSink, \n  \"Cookie is constructed from a $@.\", \n  untrustedInputSource.getNode(),\n  \"user-supplied input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-use-with]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies try-finally blocks exclusively used for resource cleanup,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Should use a 'with' statement\n * @description Identifies try-finally blocks exclusively used for resource cleanup,\n *              which harms code readability. The 'with' statement provides a cleaner\n *              approach for resource management in Python.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/should-use-with\n */\n\nimport python\n\n// Determines if a call invokes a 'close' method\npredicate isCloseMethodCall(Call resourceCleanupCall) { \n    resourceCleanupCall.getFunc().(Attribute).getName() = \"close\"\n}\n\n// Checks if a try block's finally clause contains exclusively a close call\npredicate finallyContainsOnlyCloseCall(Try resourceTryBlock, Call cleanupCall) {\n    exists(ExprStmt finalStatement |\n        finalStatement = resourceTryBlock.getAFinalstmt() and \n        finalStatement.getValue() = cleanupCall and \n        strictcount(resourceTryBlock.getAFinalstmt()) = 1\n    )\n}\n\n// Verifies if a control flow node references a context manager instance\npredicate isContextManagerReference(ControlFlowNode resourceFlowNode, ClassValue managerClass) {\n    exists(Value resourceValue | \n        resourceFlowNode.pointsTo(resourceValue) and \n        resourceValue.getClass() = managerClass and\n        managerClass.isContextManager()\n    )\n}\n\n// Identifies try-finally blocks that exclusively close context managers\nfrom Call cleanupCall, Try resourceTryBlock, ClassValue managerClass\nwhere\n    finallyContainsOnlyCloseCall(resourceTryBlock, cleanupCall) and\n    isCloseMethodCall(cleanupCall) and\n    exists(ControlFlowNode resourceFlowNode | \n        resourceFlowNode = cleanupCall.getFunc().getAFlowNode().(AttrNode).getObject() and\n        isContextManagerReference(resourceFlowNode, managerClass)\n    )\nselect cleanupCall,\n    \"Instance of context-manager class $@ is closed in a finally block. Consider using 'with' statement.\",\n    managerClass, managerClass.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/summarized-callable-call-sites]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies call sites that are covered by flow summaries.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Summarized Callable Call Sites\n * @description Identifies call sites that are covered by flow summaries.\n *              This includes both direct calls and callback invocations.\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/summarized-callable-call-sites\n * @tags meta\n * @precision very-low\n */\n\n// Import Python language core library\nimport python\n// Import data flow analysis modules\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\n// Import meta metrics analysis module\nimport meta.MetaMetrics\n\n// Define analysis variables: invocation node, target summarized callable, and invocation type\nfrom DataFlow::Node invocationNode, SummarizedCallable summarizedTarget, string invocationType\nwhere\n  // Check if the invocation node is a direct call to the summarized target\n  (invocationNode = summarizedTarget.getACall() and invocationType = \"Call\")\n  or\n  // Check if the invocation node is a callback to the summarized target\n  (invocationNode = summarizedTarget.getACallback() and invocationType = \"Callback\")\n  and\n  // Ensure the invocation node is not in an ignored file\n  not invocationNode.getLocation().getFile() instanceof IgnoredFile\n// Format the result message and select the invocation node with the message\nselect invocationNode, invocationType + \" to \" + summarizedTarget"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lack-of-cohesion-chidamber-kemerer]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：此查询实现Chidamber和Kemerer提出的类内聚性缺乏度量。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lack of Cohesion in Methods (CK)\n * @description 此查询实现Chidamber和Kemerer提出的类内聚性缺乏度量。\n *              该指标量化类中方法间的关联程度，数值越高表示内聚性越低，\n *              可能表明类承担了过多职责。\n * @kind treemap\n * @id py/lack-of-cohesion-chidamber-kemerer\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n */\n\nimport python\n\n// 获取所有已进行指标分析的类并计算其LCM值\n// LCM值反映方法间缺乏相关性的程度，高值表示低内聚性\n// 结果按LCM值降序排列，便于识别最需要重构的类\nfrom ClassMetrics measuredClass\nselect measuredClass, measuredClass.getLackOfCohesionCK() as cohesionValue order by cohesionValue desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name All Cryptographic Algorithms\n * @description Identifies all cryptographic algorithm usages across supported libraries\n *              by detecting both algorithm names and block cipher modes.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms\n_______________ // 补全条件\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport semmle.python.Concepts\n\nfrom Cryptography::CryptographicOperation cryptoOperation, string algorithmName\nwhere \n  algorithmName = cryptoOperation.getAlgorithm().getName()\n  or\n  algorithmName = cryptoOperation.getBlockMode()\nselect cryptoOperation, \"Use of algorithm \" + algorithmName",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unresolved import\n * @description An unresolved import may result in reduced coverage and accuracy of analysis.\n * @kind problem\n * @problem.severity info\n * @id py/import-failure\n */\n\n// 导入Python分析库\nimport python\n\n/**\n * 查找可能作为替代方案的导入表达式\n * 当两个导入表达式位于条件分支的不同路径中时，它们可能互为替代方案\n */\nImportExpr findAlternativeImport(ImportExpr importExpr) {\n  // 检查是否存在别名映射，使得当前导入表达式或其成员模块与结果表达式相关联\n  exists(Alias currentAlias, Alias alternativeAlias |\n    (currentAlias.getValue() = importExpr or currentAlias.getValue().(ImportMember).getModule() = importExpr) and\n    (alternativeAlias.getValue() = result or alternativeAlias.getValue().(ImportMember).getModule() = result) and\n    (\n      // 检查if语句的两个分支是否分别包含当前导入表达式和结果表达式\n      exists(If ifStmt | ifStmt.getBody().contains(importExpr) and ifStmt.getOrelse().contains(result))\n      or\n      exists(If ifStmt | ifStmt.getBody().contains(result) and ifStmt.getOrelse().contains(importExpr))\n      or\n      // 检查try语句的主体和异常处理块是否分别包含当前导入表达式和结果表达式\n      exists(Try tryStmt | tryStmt.getBody().contains(importExpr) and tryStmt.getAHandler().contains(result))\n      or\n      exists(Try tryStmt | tryStmt.getBody().contains(result) and tryStmt.getAHandler().contains(importExpr))\n    )\n  )\n}\n\n/**\n * 判断导入表达式是否与特定操作系统相关\n * 返回对应的操作系统名称，如果不匹配任何已知模式则返回空字符串\n */\nstring getOSSpecificImport(ImportExpr importExpr) {\n  exists(string moduleName | moduleName = importExpr.getImportedModuleName() |\n    // Java平台相关的模块\n    (moduleName.matches(\"org.python.%\") or moduleName.matches(\"java.%\")) and result = \"java\"\n    or\n_______________ // 补全条件\n    moduleName.matches(\"Carbon.%\") and result = \"darwin\"\n    or\n    // Windows平台相关的模块\n    result = \"win32\" and\n    (\n      moduleName = \"_winapi\" or\n      moduleName = \"_win32api\" or\n      moduleName = \"_winreg\" or\n      moduleName = \"nt\" or\n      moduleName.matches(\"win32%\") or\n      moduleName = \"ntpath\"\n    )\n    or\n    // Linux平台相关的模块\n    result = \"linux2\" and\n    (moduleName = \"posix\" or moduleName = \"posixpath\")\n    or\n    // 不支持的平台相关的模块\n    result = \"unsupported\" and\n    (moduleName = \"__pypy__\" or moduleName = \"ce\" or moduleName.matches(\"riscos%\"))\n  )\n}\n\n/**\n * 获取当前运行的操作系统平台信息\n * 通过检查sys.platform的值来确定当前操作系统\n */\nstring getCurrentOS() { \n  py_flags_versioned(\"sys.platform\", result, major_version().toString()) \n}\n\n/**\n * 判断导入表达式是否被允许失败\n * 如果存在替代导入方案，或者导入表达式是针对特定操作系统但与当前系统不匹配，则允许失败\n */\npredicate isImportAllowedToFail(ImportExpr importExpr) {\n  // 存在可用的替代导入表达式\n  findAlternativeImport(importExpr).refersTo(_)\n  or\n  // 导入表达式是特定操作系统相关的，但与当前操作系统不匹配\n  getOSSpecificImport(importExpr) != getCurrentOS()\n}\n\n/**\n * 表示Python版本测试节点的类\n * 这些节点通常用于检查Python解释器的版本信息\n */\nclass PythonVersionTest extends ControlFlowNode {\n  PythonVersionTest() {\n    // 检查节点是否引用了sys模块的版本相关属性\n    exists(string attributeName |\n      attributeName.matches(\"%version%\") and\n      this.(CompareNode).getAChild+().pointsTo(Module::named(\"sys\").attr(attributeName))\n    )\n  }\n\n  override string toString() { result = \"VersionTest\" }\n}\n\n/**\n * 表示Python版本保护块的类\n * 这些代码块根据Python版本条件控制代码执行路径\n */\nclass PythonVersionGuard extends ConditionBlock {\n  PythonVersionGuard() { \n    // 检查条件块的最后一个节点是否是版本测试节点\n    this.getLastNode() instanceof PythonVersionTest \n  }\n}\n\n// 主查询：查找无法解析且不应失败的导入表达式\nfrom ImportExpr importExpr\nwhere\n  // 导入表达式无法解析为任何模块\n  not importExpr.refersTo(_) and \n  // 导入表达式存在于有效的分析上下文中\n  exists(Context context | context.appliesTo(importExpr.getAFlowNode())) and \n  // 导入表达式不被允许失败\n  not isImportAllowedToFail(importExpr) and \n  // 导入表达式不受版本保护块的控制\n  not exists(PythonVersionGuard versionGuard | versionGuard.controls(importExpr.getAFlowNode().getBasicBlock(), _))\n// 选择符合条件的导入表达式并生成问题描述\nselect importExpr, \"Unable to resolve import of '\" + importExpr.getImportedModuleName() + \"'.\"",
    "output": "// macOS (Darwin)平台相关的模块"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-star-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of wildcard imports which can lead to namespace pollution",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' used\n * @description Detects usage of wildcard imports which can lead to namespace pollution\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// Import the Python analysis module to enable static analysis of Python code\nimport python\n\n// Define the source of wildcard import statements we want to detect\nfrom ImportStar wildcardImport\n\n// Report all instances of wildcard imports with a warning message\n// This helps maintain code clarity by avoiding namespace pollution\nselect wildcardImport, \"Using 'from ... import *' pollutes the namespace.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Generates information about alert suppressions in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression utilities with alias SuppressionUtils\nprivate import codeql.util.suppression.AlertSuppression as SuppressionUtils\n// Import Python comment handling utilities with alias CommentHandler\nprivate import semmle.python.Comment as CommentHandler\n\n// Define AST node representation extending Python's AST node\nclass SourceNode instanceof CommentHandler::AstNode {\n  /**\n   * Retrieves location information for the AST node\n   * @param sourceFile - Path to source file\n   * @param beginLine - Starting line number\n   * @param beginCol - Starting column number\n   * @param endLine - Ending line number\n   * @param endCol - Ending column number\n   */\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    // Delegate location resolution to parent class\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginCol, endLine, endCol)\n  }\n\n  // Provide string representation of the AST node\n  string toString() { result = super.toString() }\n}\n\n// Define single-line comment representation extending Python's comment class\nclass LineComment instanceof CommentHandler::Comment {\n  /**\n   * Retrieves location information for the comment\n   * @param sourceFile - Path to source file\n   * @param beginLine - Starting line number\n   * @param beginCol - Starting column number\n   * @param endLine - Ending line number\n   * @param endCol - Ending column number\n   */\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    // Delegate location resolution to parent class\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginCol, endLine, endCol)\n  }\n\n  // Extract text content from the comment\n  string getText() { result = super.getContents() }\n\n  // Provide string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Establish alert suppression relationships using CodeQL's Make template\nimport SuppressionUtils::Make<SourceNode, LineComment>\n\n/**\n * Represents a noqa suppression comment. Both pylint and pyflakes respect this annotation,\n * so LGTM analysis should also honor it.\n */\nclass NoqaSuppression extends SuppressionComment instanceof LineComment {\n  // Initialize with comments matching noqa pattern (case-insensitive)\n  NoqaSuppression() {\n    LineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Return the annotation identifier for LGTM\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Determine code coverage of this suppression comment\n  override predicate covers(\n    string sourceFile, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    // Verify comment location and ensure it starts at column 1 (line beginning)\n    this.hasLocationInfo(sourceFile, beginLine, _, endLine, endCol) and\n    beginCol = 1\n  }\n}"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Conflicting attributes in base classes\n * @description Identifies classes inheriting from multiple base classes where identical attributes are defined in more than one parent. Such attribute collisions can cause unpredictable behavior due to ambiguous resolution order.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n/**\n * Determines if a Python function implementation is functionally empty.\n * A function qualifies as empty when its body exclusively contains pass statements or docstring expressions.\n */\npredicate is_empty_implementation(PyFunctionObject func) {\n  // Validate that function body contains only pass statements or docstring expressions\n  not exists(Stmt bodyStmt | bodyStmt.getScope() = func.getFunction() |\n    not bodyStmt instanceof Pass and \n    not bodyStmt.(ExprStmt).getValue() = func.getFunction().getDocString()\n  )\n}\n\n/**\n * Identifies functions that explicitly utilize super() for method resolution.\n * This pattern indicates intentional handling of multiple inheritance scenarios\n * through proper parent class method invocation.\n */\npredicate invokes_super(FunctionObject func) {\n  // Detect super() method invocation pattern within function body\n  exists(Call superCall, Call methodCall, Attribute attrRef, GlobalVariable superVar |\n    methodCall.getScope() = func.getFunction() and\n    methodCall.getFunc() = attrRef and\n    attrRef.getObject() = superCall and\n    attrRef.getName() = func.getName() and\n    superCall.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/**\n * Defines attribute names excluded from conflict detection.\n * These attributes follow established multiple inheritance patterns\n * where conflicts are intentionally managed and non-problematic.\n */\npredicate is_exempt_attribute(string attrName) {\n  /*\n   * Exemption for process_request per Python's socketserver documentation:\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   * This attribute follows expected override patterns in multiple inheritance\n   * and does not indicate a problematic conflict scenario.\n   */\n  attrName = \"process_request\"\n}\n\nfrom\n  ClassObject derivedClass, \n  ClassObject baseClassA, \n  ClassObject baseClassB, \n  string attributeName, \n  int inheritanceOrderA, \n  int inheritanceOrderB, \n  Object attributeInA, \n  Object attributeInB\nwhere\n  // Establish inheritance hierarchy with distinct parent classes\n  derivedClass.getBaseType(inheritanceOrderA) = baseClassA and\n  derivedClass.getBaseType(inheritanceOrderB) = baseClassB and\n  inheritanceOrderA < inheritanceOrderB and\n  \n  // Detect attribute conflicts between parent classes\n  attributeInA = baseClassA.lookupAttribute(attributeName) and\n  attributeInB = baseClassB.lookupAttribute(attributeName) and\n  attributeInA != attributeInB and\n  \n  // Exclude non-problematic conflict scenarios\n  not attributeName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and                 // Filter out special methods\n  not is_exempt_attribute(attributeName) and                      // Skip exempted attributes\n  not derivedClass.declaresAttribute(attributeName) and           // Child doesn't override\n  not attributeInA.overrides(attributeInB) and                    // No override relationship\n  not attributeInB.overrides(attributeInA) and\n  not invokes_super(attributeInA) and                             // First parent handles resolution\n_______________ // 补全条件\nselect derivedClass, \n  \"Base classes contain conflicting definitions for attribute '\" + attributeName + \"': $@ and $@.\", \n  attributeInA, attributeInA.toString(), \n  attributeInB, attributeInB.toString()",
    "output": "not is_empty_implementation(attributeInB)                       // Second parent has non-trivial implementation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lack-of-cohesion-chidamber-kemerer]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：计算类方法的缺乏内聚性指标，该指标由Chidamber和Kemerer提出。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lack of Cohesion in Methods (CK)\n * @description 计算类方法的缺乏内聚性指标，该指标由Chidamber和Kemerer提出。\n *              该指标衡量类中方法之间缺乏相关性的程度，值越高表示内聚性越低。\n * @kind treemap\n * @id py/lack-of-cohesion-chidamber-kemerer\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n */\n\nimport python\n\n// 确定分析目标：获取所有已进行指标度量的类\nfrom ClassMetrics evaluatedClass\n\n// 评估每个类的LCM（Lack of Cohesion in Methods）值\n// LCM值反映了类中方法之间的关联程度，数值越大表明内聚性越差\n// 结果按LCM值降序排列，便于优先关注内聚性最弱的类\nselect evaluatedClass, evaluatedClass.getLackOfCohesionCK() as lcmMetric order by lcmMetric desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description 在解压tar存档时，若未验证目标文件路径是否在目标目录内，可能导致目录遍历攻击（TarSlip），使攻击者能够覆盖目标目录外的任意文件。\n * @kind path-problem\n * @id py/tarslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\n_______________ // 补全条件\nfrom TarSlipFlow::PathNode maliciousSource, TarSlipFlow::PathNode vulnerableExtraction\nwhere TarSlipFlow::flowPath(maliciousSource, vulnerableExtraction)\n// 报告存在目录遍历风险的文件提取操作\nselect vulnerableExtraction.getNode(), maliciousSource, vulnerableExtraction, \n  \"This file extraction depends on a $@.\", maliciousSource.getNode(),\n  \"potentially untrusted source\" // 该文件提取依赖于一个潜在的不受信任的源",
    "output": "// 检测从不受信任源到文件提取操作的数据流路径"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称密钥生成中使用未知密钥大小\n * @description 检测非对称密钥生成过程中使用了无法静态验证的密钥大小的情况\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找所有非对称密钥生成操作，其中密钥大小无法静态验证\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node configSourceNode, string cryptographicAlgo\nwhere\n  // 获取密钥配置的来源节点\n  configSourceNode = keyGenOperation.getKeyConfigSrc() and\n  // 获取使用的加密算法名称\n  cryptographicAlgo = keyGenOperation.getAlgorithm().getName() and\n  // 验证密钥生成操作没有静态验证的密钥大小\n  not keyGenOperation.hasKeySize(configSourceNode)\nselect keyGenOperation,\n  // 构建警告信息，指出哪个算法的密钥生成使用了无法静态验证的密钥大小\n_______________ // 补全条件\n  configSourceNode,\n  configSourceNode.toString()",
    "output": "\"算法 \" + cryptographicAlgo + \" 的密钥生成使用了无法静态验证的密钥大小，配置源位于 $@\","
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-default-protocol]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Unspecified SSL/TLS version can lead to usage of insecure",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Default version of SSL/TLS may be insecure\n * @description Unspecified SSL/TLS version can lead to usage of insecure\n *              default protocols.\n * @id py/insecure-default-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\n// Typically, connections are established using a context that defines the acceptable\n// protocol range. This query identifies the deprecated method of creating connections\n// without a context reference (via `ssl.wrap_socket`). When this approach is used\n// without explicitly specifying acceptable protocols, connections will default to\n// insecure settings.\n//\n// The detection of connections created with an improperly configured context is\n// addressed by the data-flow query py/insecure-protocol.\nimport python\nimport semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode socketCall\nwhere\n  // Identify calls to ssl.wrap_socket\n  socketCall = API::moduleImport(\"ssl\").getMember(\"wrap_socket\").getACall()\n  // Verify absence of ssl_version parameter\n  and not exists(socketCall.getArgByName(\"ssl_version\"))\nselect socketCall,\n  \"Call to deprecated method ssl.wrap_socket does not specify a protocol, which may result in an insecure default being used.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-parameters-without-default-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects and quantifies function parameters that are not assigned default values.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of parameters without defaults\n * @description Detects and quantifies function parameters that are not assigned default values.\n *              Functions containing multiple parameters without defaults tend to be more difficult\n *              to test and maintain, potentially impacting code quality.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // Essential module for performing static analysis on Python source code\n\n// Extract function metrics from the analyzed Python codebase\nfrom FunctionMetrics funcMetrics\n// Compute the quantity of parameters lacking default values for each function\n// This measurement serves as an indicator of function complexity and maintainability\nselect funcMetrics, \n       funcMetrics.getNumberOfParametersWithoutDefault() as paramWithoutDefaultCount \n// Sort the results in descending order based on the count of parameters without defaults\n// This arrangement prioritizes functions that may require refactoring due to high complexity\norder by paramWithoutDefaultCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Reflected server-side cross-site scripting\n * @description Identifies security vulnerabilities where untrusted user input is directly\n *              rendered in web pages without proper sanitization, enabling attackers to\n *              execute malicious scripts through reflected data flows.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @sub-severity high\n * @precision high\n * @id py/reflective-xss\n * @tags security\n *       external/cwe/cwe-079\n *       external/cwe/cwe-116\n */\n\n// Import core Python analysis framework\nimport python\n// Import specialized module for detecting reflected cross-site scripting vulnerabilities\nimport semmle.python.security.dataflow.ReflectedXssQuery\n// Import path graph module for visualizing complete data flow trajectories\nimport ReflectedXssFlow::PathGraph\n\n_______________ // 补全条件\nfrom ReflectedXssFlow::PathNode taintedSource, ReflectedXssFlow::PathNode vulnerableSink\n// Validate complete data flow propagation exists between source and sink\nwhere ReflectedXssFlow::flowPath(taintedSource, vulnerableSink)\n// Report security vulnerability with source/sink context and detailed description\nselect vulnerableSink.getNode(), taintedSource, vulnerableSink, \n       \"Cross-site scripting vulnerability originating from $@.\", \n       taintedSource.getNode(), \"untrusted user input\"",
    "output": "// Define data flow analysis tracking untrusted input to dangerous web outputs"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression analysis\n * @description Identifies and analyzes alert suppression mechanisms in Python code,\n *              concentrating on 'noqa' style suppression comments which are commonly used\n *              to disable linter warnings.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression utilities for analyzing suppression mechanisms\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing utilities to extract and process code comments\nprivate import semmle.python.Comment as PythonComment\n\n/**\n * Represents a single-line Python comment with enhanced location tracking capabilities.\n * This class extends the base Comment class to provide more detailed location information.\n */\nclass SingleLineComment instanceof PythonComment::Comment {\n  /**\n   * Retrieves detailed location information for the comment.\n   * @param sourceFile - The path to the file containing the comment\n   * @param beginLine - The starting line number of the comment\n   * @param beginColumn - The starting column number of the comment\n   * @param endLine - The ending line number of the comment\n   * @param endColumn - The ending column number of the comment\n   */\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginColumn, int endLine, int endColumn\n  ) {\n    // Inherit location details from parent class\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginColumn, endLine, endColumn)\n  }\n\n  /**\n   * Extracts the text content of the comment, excluding the comment marker.\n   * @returns The textual content of the comment\n   */\n  string getText() { result = super.getContents() }\n\n  /**\n   * Provides a string representation of the comment.\n   * @returns A string representation of the comment\n   */\n  string toString() { result = super.toString() }\n}\n\n/**\n * Represents a Python AST node with detailed location tracking capabilities.\n * This class extends the base AstNode class to provide comprehensive location information.\n */\nclass AstNode instanceof PythonComment::AstNode {\n  /**\n   * Retrieves detailed location information for the AST node.\n   * @param sourceFile - The path to the file containing the node\n   * @param beginLine - The starting line number of the node\n   * @param beginColumn - The starting column number of the node\n   * @param endLine - The ending line number of the node\n   * @param endColumn - The ending column number of the node\n   */\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginColumn, int endLine, int endColumn\n  ) {\n    // Inherit location details from parent class\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginColumn, endLine, endColumn)\n  }\n\n  /**\n   * Provides a string representation of the AST node.\n   * @returns A string representation of the node\n   */\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships between AST nodes and comments using the AlertSuppression framework\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * Represents a 'noqa' suppression comment, which is a widely recognized mechanism\n * for disabling linter warnings in Python code. Both pylint and pyflakes respect\n * this convention, making it a standard for suppression in the Python ecosystem.\n */\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  /**\n   * Constructs a NoqaSuppressionComment by identifying comments that match the noqa pattern.\n   * The pattern is case-insensitive and allows for optional suffixes after the noqa keyword.\n   */\n  NoqaSuppressionComment() {\n    // Match case-insensitive noqa with optional suffix (without colon)\n    super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  /**\n   * Retrieves the annotation identifier for this suppression comment.\n   * @returns The string \"lgtm\" as the annotation identifier\n   */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /**\n   * Defines the code range covered by this suppression comment.\n   * A noqa comment typically covers the entire line where it appears.\n   * @param sourceFile - The path to the file containing the suppression\n   * @param beginLine - The starting line number of the covered range\n   * @param beginColumn - The starting column number of the covered range\n   * @param endLine - The ending line number of the covered range\n   * @param endColumn - The ending column number of the covered range\n   */\n  override predicate covers(\n    string sourceFile, int beginLine, int beginColumn, int endLine, int endColumn\n  ) {\n    // Get comment location and verify it starts at column 1 (beginning of line)\n_______________ // 补全条件\n    beginColumn = 1\n  }\n}",
    "output": "this.hasLocationInfo(sourceFile, beginLine, _, endLine, endColumn) and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-exception in 'except' clause\n * @description Detects exception handlers that reference non-exception types,\n *              which are ineffective at runtime since they never match actual exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n_______________ // 补全条件\n * @id py/useless-except\n */\n\nimport python\n\n// Variables for analyzing exception handling constructs\nfrom ExceptFlowNode exceptNode, Value caughtType, ClassValue exceptionType, \n     ControlFlowNode sourceNode, string typeInfo\nwhere\n  // Establish relationship between exception handler and its source\n  exceptNode.handledException(caughtType, exceptionType, sourceNode) and\n  (\n    // Case 1: Type is a class but not a valid exception\n    exists(ClassValue nonExceptionClass | \n      nonExceptionClass = caughtType and\n      not nonExceptionClass.isLegalExceptionType() and\n      not nonExceptionClass.failedInference(_) and\n      typeInfo = \"class '\" + nonExceptionClass.getName() + \"'\"\n    )\n    or\n    // Case 2: Type is not a class value\n    not caughtType instanceof ClassValue and\n    typeInfo = \"instance of '\" + exceptionType.getName() + \"'\"\n  )\nselect exceptNode.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  sourceNode, typeInfo",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks on substrings of unparsed URLs are vulnerable to bypass\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n_______________ // 补全条件\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Generates regex pattern for common top-level domains used in URL validation\nprivate string getCommonTldPattern() { result = \"com|org|edu|gov|uk|net|io\" }\n\n// Determines if string literal matches URL structure patterns\npredicate resemblesUrl(StringLiteral urlLiteral) {\n  exists(string literalContent | literalContent = urlLiteral.getText() |\n    literalContent.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + getCommonTldPattern() +\n        \")(:[0-9]+)?/?\")\n    or\n    literalContent.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Identifies unsafe startswith checks for URL validation\npredicate hasUnsafeStartswithCheck(Call methodCall, StringLiteral urlLiteral) {\n  methodCall.getFunc().(Attribute).getName() = \"startswith\" and\n  methodCall.getArg(0) = urlLiteral and\n  not urlLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n}\n\n// Identifies unsafe endswith checks for URL validation\npredicate hasUnsafeEndswithCheck(Call methodCall, StringLiteral urlLiteral) {\n  methodCall.getFunc().(Attribute).getName() = \"endswith\" and\n  methodCall.getArg(0) = urlLiteral and\n  not urlLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n}\n\n// Detects incomplete sanitization operations on URL substrings\npredicate hasIncompleteUrlSanitization(Expr sanitizationExpr, StringLiteral urlLiteral) {\n  resemblesUrl(urlLiteral) and\n  (\n    sanitizationExpr.(Compare).compares(urlLiteral, any(In i), _)\n    or\n    hasUnsafeStartswithCheck(sanitizationExpr, urlLiteral)\n    or\n    hasUnsafeEndswithCheck(sanitizationExpr, urlLiteral)\n  )\n}\n\n// Main query: Locate expressions with incomplete URL substring sanitization\nfrom Expr sanitizationExpr, StringLiteral urlLiteral\nwhere hasIncompleteUrlSanitization(sanitizationExpr, urlLiteral)\nselect sanitizationExpr, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlLiteral,\n  urlLiteral.getText()",
    "output": "* @id py/incomplete-url-substring-sanitization"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 检测子类中定义的方法是否被父类中的属性所遮蔽\n * 这种情况会导致方法调用被属性覆盖，可能引发意外行为\n */\n\n/* 聚焦于在父类构造函数中定义的属性 */\nimport python\n\n// 判断子类方法是否被父类属性遮蔽\npredicate isMethodShadowedBySuperAttribute(\n  ClassObject subClass, ClassObject superClass, Assign attrAssignment, FunctionObject shadowedMethod\n) {\n  // 确认继承关系：subClass 继承自 superClass\n  subClass.getASuperType() = superClass and\n  // 子类声明了 shadowedMethod 作为其属性\n  subClass.declaredAttribute(_) = shadowedMethod and\n  // 检查父类构造函数中是否存在同名属性赋值\n  exists(FunctionObject initMethod, Attribute assignedAttr |\n    // 父类定义了 __init__ 方法\n    superClass.declaredAttribute(\"__init__\") = initMethod and\n    // 属性赋值的目标是 assignedAttr\n    assignedAttr = attrAssignment.getATarget() and\n    // 属性赋值对象是 self\n    assignedAttr.getObject().(Name).getId() = \"self\" and\n    // 属性名称与子类方法名称相同\n    assignedAttr.getName() = shadowedMethod.getName() and\n    // 赋值操作发生在父类的构造函数中\n    attrAssignment.getScope() = initMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  /*\n   * 排除父类中也定义了同名方法的情况\n   * 这种情况下，我们认为是有意为之的设计\n   */\n  // 确保父类没有定义同名属性\n  not superClass.hasAttribute(shadowedMethod.getName())\n}\n\n// 从子类、父类、属性赋值和被遮蔽的方法中查询\nfrom ClassObject subClass, ClassObject superClass, Assign attrAssignment, FunctionObject shadowedMethod\n// 应用谓词进行筛选\nwhere isMethodShadowedBySuperAttribute(subClass, superClass, attrAssignment, shadowedMethod)\n// 选择被遮蔽方法的位置、错误信息、属性赋值位置和属性类型\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superClass.getName() +\n    \"'.\", attrAssignment, \"attribute\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-number-class-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测类实例化时参数数量不匹配的问题。当调用类的构造函数时，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 类实例化参数数量错误\n * @description 检测类实例化时参数数量不匹配的问题。当调用类的构造函数时，\n *              如果传入的参数数量与定义不符，会导致运行时 TypeError 异常。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstantiationCall, ClassValue targetClass, string errorType, string paramRequirement, int expectedArgCount, FunctionValue classConstructor\nwhere\n  (\n    // 检测参数过多的情况\n    too_many_args(classInstantiationCall, targetClass, expectedArgCount) and\n    errorType = \"too many arguments\" and\n    paramRequirement = \"no more than \"\n    or\n    // 检测参数过少的情况\n    too_few_args(classInstantiationCall, targetClass, expectedArgCount) and\n    errorType = \"too few arguments\" and\n    paramRequirement = \"no fewer than \"\n  ) and\n  // 获取目标类的构造函数或初始化方法\n  classConstructor = get_function_or_initializer(targetClass)\nselect classInstantiationCall, \"Call to $@ with \" + errorType + \"; should be \" + paramRequirement + expectedArgCount.toString() + \".\", classConstructor,\n  classConstructor.getQualifiedName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Untrusted data passed to external API\n * @description Detects untrusted data from remote sources being passed to external APIs\n_______________ // 补全条件\n * @id py/untrusted-data-to-external-api\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 7.8\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport ExternalAPIs\nimport UntrustedDataToExternalApiFlow::PathGraph\n\nfrom\n  UntrustedDataToExternalApiFlow::PathNode untrustedSourceNode,  // Entry point of tainted data flow\n  UntrustedDataToExternalApiFlow::PathNode vulnerableSinkNode,   // API invocation consuming tainted data\n  ExternalApiUsedWithUntrustedData taintedApiCall                // External API handling untrusted input\nwhere\n  // Validate sink node corresponds to the API's tainted parameter\n  vulnerableSinkNode.getNode() = taintedApiCall.getUntrustedDataNode()\n  and\n  // Verify data propagation path exists from source to sink\n  UntrustedDataToExternalApiFlow::flowPath(untrustedSourceNode, vulnerableSinkNode)\nselect\n  // Maintain original output structure with renamed variables\n  vulnerableSinkNode.getNode(), untrustedSourceNode, vulnerableSinkNode,\n  \"Call to \" + taintedApiCall.toString() + \" with untrusted data from $@.\", untrustedSourceNode.getNode(),\n  untrustedSourceNode.toString()",
    "output": "*              without sanitization, potentially leading to security vulnerabilities."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-padding]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Identifies the use of asymmetric encryption padding schemes that are",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Identifies the use of asymmetric encryption padding schemes that are\n * either cryptographically weak or not explicitly recognized as secure.\n * The query specifically filters out approved padding methods (OAEP, KEM, PSS)\n * and highlights any other padding schemes as potential security risks.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Step 1: Identify all asymmetric padding implementations and their algorithm names\nfrom AsymmetricPadding cryptoPadding, string paddingAlgorithm\nwhere\n  // Step 2: Extract the padding algorithm name from the implementation\n  paddingAlgorithm = cryptoPadding.getPaddingName()\n  // Step 3: Exclude known secure padding algorithms (OAEP, KEM, PSS)\n  and not paddingAlgorithm = [\"OAEP\", \"KEM\", \"PSS\"]\nselect cryptoPadding, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + paddingAlgorithm"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__init__` method calls overridden method\n * @description Calling a method from `__init__` that is overridden by a subclass may result in a partially\n *              initialized instance being observed.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/init-calls-subclass\n */\n\nimport python\n\n// 查找基类__init__方法中调用被子类重写方法的情况\nfrom\n  ClassObject baseClass, string calledMethodName, Call initMethodCall, \n  FunctionObject overridingMethod, FunctionObject overriddenMethod\nwhere\n  // 条件1: 确保调用发生在基类的__init__方法中，且通过self属性访问\n  exists(FunctionObject initMethod, SelfAttribute selfAttr |\n    baseClass.declaredAttribute(\"__init__\") = initMethod and\n    initMethodCall.getScope() = initMethod.getFunction() and\n    initMethodCall.getFunc() = selfAttr and\n    selfAttr.getName() = calledMethodName\n  ) and\n  // 条件2: 获取基类中声明的方法定义\n  overriddenMethod = baseClass.declaredAttribute(calledMethodName) and\n  // 条件3: 确认子类方法重写了基类方法\n  overridingMethod.overrides(overriddenMethod)\n// 输出调用位置及警告信息\nselect initMethodCall, \"Call to self.$@ in __init__ method, which is overridden by $@.\", overriddenMethod, calledMethodName,\n_______________ // 补全条件",
    "output": "overridingMethod, overridingMethod.descriptiveString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-churn]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Number of churned lines per file, across the revision history in the database.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Churned lines per file\n * @description Number of churned lines per file, across the revision history in the database.\n * @kind treemap\n * @id py/historical-churn\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\n// 导入python模块\nimport python\n// 导入外部版本控制系统（VCS）模块\nimport external.VCS\n\n// 从Module m和整数n中选择数据\nfrom Module m, int n\nwhere\n  // 计算每个文件的变更行数，并存储在变量n中\n  n =\n    sum(Commit entry, int churn |\n      // 获取最近一次提交中文件的变更行数，并且过滤掉人工更改的提交\n      churn = entry.getRecentChurnForFile(m.getFile()) and not artificialChange(entry)\n    |\n      // 累加变更行数\n      churn\n    ) and\n  // 确保模块有代码行数的度量指标\n  exists(m.getMetrics().getNumberOfLinesOfCode())\nselect m, n order by n desc\n// 选择模块和变更行数，并按变更行数降序排列"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-data-to-external-api]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Data provided remotely is used in this external API without sanitization, which could be a security risk.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted data passed to external API\n * @description Data provided remotely is used in this external API without sanitization, which could be a security risk.\n * @id py/untrusted-data-to-external-api\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 7.8\n * @tags security external/cwe/cwe-20\n */\n\n// Import Python analysis libraries for code parsing and processing\nimport python\n// Import external API identification utilities\nimport ExternalAPIs\n// Import data flow path tracking framework\nimport UntrustedDataToExternalApiFlow::PathGraph\n\n// Identify vulnerable data flows from untrusted sources to external APIs\nfrom\n  UntrustedDataToExternalApiFlow::PathNode untrustedSource, // Origin point of untrusted data\n  UntrustedDataToExternalApiFlow::PathNode apiSink,         // Destination point at external API\n  ExternalApiUsedWithUntrustedData riskyExternalApi         // External API consuming untrusted data\nwhere\n  // Ensure sink node corresponds to the untrusted data used in the external API call\n  apiSink.getNode() = riskyExternalApi.getUntrustedDataNode() and\n  // Verify complete data flow path exists from source to sink\n  UntrustedDataToExternalApiFlow::flowPath(untrustedSource, apiSink)\nselect\n  // Report findings with path details and contextual information\n  apiSink.getNode(), untrustedSource, apiSink,\n  \"Call to \" + riskyExternalApi.toString() + \" with untrusted data from $@.\", untrustedSource.getNode(),\n  untrustedSource.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/tarslip]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：解压tar存档时，若未验证目标路径是否位于预期目录内，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description 解压tar存档时，若未验证目标路径是否位于预期目录内，\n *              可能引发目录遍历攻击，导致目标目录外任意文件被覆盖。\n * @kind path-problem\n * @id py/tarslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\n// 定义污染源节点和文件提取汇点节点\nfrom TarSlipFlow::PathNode taintedSource, TarSlipFlow::PathNode fileExtractionSink\n// 检查是否存在从污染源到文件提取汇点的数据流传播路径\nwhere TarSlipFlow::flowPath(taintedSource, fileExtractionSink)\n// 输出结果：提取操作位置、污染源节点、完整路径及安全警告\nselect fileExtractionSink.getNode(), taintedSource, fileExtractionSink, \n  \"This file extraction depends on a $@.\", taintedSource.getNode(),\n  \"potentially untrusted source\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 跨域资源共享（CORS）策略配置缺陷\n * @description 检测使用不安全的字符串前缀比较（如 'startswith'）验证用户提供的 Origin 头部，\n *              这种实现方式可能导致 CORS 安全机制被绕过，从而引发跨域攻击风险。\n * @kind path-problem\n * @problem.severity warning\n * @id py/cors-bypass\n * @tags security\n *       externa/cwe/CWE-346\n */\n\nimport python\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.Flow\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n// ======== 辅助谓词和类定义 ========\n\n/**\n * 判断输入字符串是否包含 CORS 相关标识符\n * 用于识别与 CORS 处理相关的代码节点\n */\nbindingset[inputStr]\npredicate containsCorsKeywords(string inputStr) { \n  inputStr.matches([\"%origin%\", \"%cors%\"]) \n}\n\n/**\n * 表示不安全的字符串前缀比较调用\n * 这类调用通常用于验证 Origin 头部，但存在安全风险\n */\nprivate class UnsafeStringPrefixComparison extends ControlFlowNode {\n  UnsafeStringPrefixComparison() { \n    this.(CallNode).getFunction().(AttrNode).getName() = \"startswith\" \n  }\n}\n\n/**\n * 表示 CherryPy 框架的请求对象成员\n * 这些成员被视为远程输入源，可能包含用户提供的 Origin 头部\n */\nclass CherryPyRequestMember extends RemoteFlowSource::Range {\n  CherryPyRequestMember() {\n    this =\n      API::moduleImport(\"cherrypy\")\n          .getMember(\"request\")\n          .getMember([\n              \"charset\", \"content_type\", \"filename\", \"fp\", \"name\", \n              \"params\", \"headers\", \"length\"\n            ])\n_______________ // 补全条件\n  }\n\n  override string getSourceType() { \n    result = \"cherrypy.request\" \n  }\n}\n\n// ======== CORS 相关节点识别 ========\n\n/**\n * 识别与 CORS 处理相关的代码节点\n * \n * 通过以下启发式规则检测 CORS 验证逻辑：\n * 1. 检查调用对象是否包含 CORS 关键字（作为汇点）\n * 2. 检查方法参数是否包含 CORS 关键字（作为汇点）\n * 3. 检查变量赋值是否涉及 CORS 关键字（作为源点）\n */\nprivate predicate isCorsRelated(ControlFlowNode codeNode) {\n  // 场景1：调用对象包含 CORS 关键字（汇点）\n  exists(string corsIdentifier | \n    containsCorsKeywords(corsIdentifier) and \n    codeNode.(CallNode).getFunction().(AttrNode).getObject().(NameNode).getId() = corsIdentifier\n  )\n  or\n  // 场景2：方法参数包含 CORS 关键字（汇点）\n  exists(string corsIdentifier | \n    containsCorsKeywords(corsIdentifier) and \n    codeNode.(CallNode).getArg(0).(NameNode).getId() = corsIdentifier\n  )\n  or\n  // 场景3：变量赋值包含 CORS 关键字（源点）\n  exists(Variable corsVariable | \n    containsCorsKeywords(corsVariable.getId()) and \n    codeNode.getASuccessor*().getNode() = corsVariable.getAStore()\n  )\n}\n\n// ======== 数据流配置 ========\n\n/**\n * CORS 安全策略绕过分析配置\n * 定义数据流源、汇和额外流步骤\n */\nmodule CorsBypassConfig implements DataFlow::ConfigSig {\n  /**\n   * 定义数据流源：所有远程输入源\n   * 包括 CherryPy 请求对象和其他远程输入源\n   */\n  predicate isSource(DataFlow::Node flowSource) { \n    flowSource instanceof RemoteFlowSource \n  }\n\n  /**\n   * 定义数据流汇：startswith 方法的参数或调用对象\n   * 这些位置通常用于验证 Origin 头部\n   */\n  predicate isSink(DataFlow::Node flowSink) {\n    exists(UnsafeStringPrefixComparison prefixComparison |\n      flowSink.asCfgNode() = prefixComparison.(CallNode).getArg(0) or\n      flowSink.asCfgNode() = prefixComparison.(CallNode).getFunction().(AttrNode).getObject()\n    )\n  }\n\n  /**\n   * 定义额外流步骤：处理 cherrypy.request.headers.get() 调用链\n   * 确保数据流能够正确跟踪从请求头到验证逻辑的路径\n   */\n  predicate isAdditionalFlowStep(DataFlow::Node sourceNode, DataFlow::Node targetNode) {\n    exists(API::CallNode headersGetMethod, API::Node requestHeaders |\n      requestHeaders = API::moduleImport(\"cherrypy\")\n                          .getMember(\"request\")\n                          .getMember(\"headers\") and\n      headersGetMethod = requestHeaders.getMember(\"get\").getACall()\n    |\n      headersGetMethod.getReturn().asSource() = targetNode and \n      requestHeaders.asSource() = sourceNode\n    )\n  }\n\n  // 启用增量模式差异观察\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// ======== 污点跟踪模块 ========\n\n// 全局污点跟踪模块\nmodule CorsBypassFlow = TaintTracking::Global<CorsBypassConfig>;\n\nimport CorsBypassFlow::PathGraph\n\n// ======== 主查询 ========\n\n/**\n * 查询潜在的 CORS 策略绕过漏洞\n * 检测从远程输入源到不安全字符串前缀比较的数据流路径\n */\nfrom CorsBypassFlow::PathNode sourcePathNode, CorsBypassFlow::PathNode sinkPathNode\nwhere\n  CorsBypassFlow::flowPath(sourcePathNode, sinkPathNode) and\n  (\n    isCorsRelated(sourcePathNode.getNode().asCfgNode())\n    or\n    isCorsRelated(sinkPathNode.getNode().asCfgNode())\n  )\nselect sinkPathNode, sourcePathNode, sinkPathNode,\n  \"使用弱字符串比较验证 Origin 头部，可能导致 CORS 安全策略被绕过。\"",
    "output": ".asSource()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/all-asymmetric-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all potential asymmetric cryptographic algorithm implementations (RSA & ECC)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name All Asymmetric Algorithms\n * @description Identifies all potential asymmetric cryptographic algorithm implementations (RSA & ECC) \n *              across supported cryptographic libraries in the codebase.\n * @kind problem\n * @id py/quantum-readiness/cbom/all-asymmetric-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python language support for code analysis\nimport python\n\n// Import experimental cryptographic concepts library for algorithm detection\nimport experimental.cryptography.Concepts\n\n// Define variable for asymmetric algorithm instances\nfrom AsymmetricAlgorithm asymmetricCryptoAlgorithm\n\n// Output algorithm instances with descriptive messages\nselect asymmetricCryptoAlgorithm, \"Detected asymmetric algorithm: \" + asymmetricCryptoAlgorithm.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python函数源代码位置映射\n * @description 识别并提供Python函数与其源代码文件路径之间的映射关系\n * @kind source-link\n * @id py/function-source-links\n * @metricType callable\n */\n\nimport python\n\n_______________ // 补全条件\nfrom Function pythonFunction, Location sourceLocation\nwhere sourceLocation = pythonFunction.getLocation()\nselect pythonFunction, sourceLocation.getFile()",
    "output": "// 直接获取每个Python函数及其源文件位置"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Detects cryptographic operations that generate asymmetric keys with sizes below the recommended",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak asymmetric key generation with insufficient key size (< 2048 bits)\n * @description\n * Detects cryptographic operations that generate asymmetric keys with sizes below the recommended\n * security threshold of 2048 bits, which are susceptible to brute-force attacks.\n * @id py/weak-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// This query identifies asymmetric key generation operations with insufficient key strength\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node keyConfigurationNode, int keySizeBits, string algorithmName\nwhere\n  // Extract cryptographic key configuration details\n  (\n    keySizeBits = keyGenOperation.getKeySizeInBits(keyConfigurationNode) and\n    algorithmName = keyGenOperation.getAlgorithm().getName()\n  ) and\n  // Apply security threshold filters\n  (\n    keySizeBits < 2048 and\n    not isEllipticCurveAlgorithm(algorithmName, _)\n  )\n// Generate alert with details about the weak key configuration\nselect keyGenOperation,\n  \"Weak asymmetric key size (\" + keySizeBits.toString() + \" bits) for algorithm \" +\n    algorithmName + \" configured at $@\", keyConfigurationNode, keyConfigurationNode.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 指向关系深度分布特征分析：\n * 此查询用于评估代码库中指向关系的深度分布模式，重点分析：\n * - 边际关系数：在最浅深度层级上出现的唯一指向关系数量\n * - 关系总数：在特定深度层级上的所有指向关系实例数\n * - 效率比率：边际关系数占总关系数的百分比，反映该深度层级的效率\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n_______________ // 补全条件\n// 确定控制流节点在给定目标对象和类实例下的上下文深度\nint determineContextDepth(ControlFlowNode cfNode, Object targetObj, ClassObject classInstance) {\n  // 当存在指向上下文使节点在该上下文中指向目标对象并关联类实例时，返回上下文深度\n  exists(PointsToContext ptContext |\n    PointsTo::points_to(cfNode, ptContext, targetObj, classInstance, _) and\n    result = ptContext.getDepth()\n  )\n}\n\n// 获取控制流节点在给定目标对象和类实例下的最小上下文深度\nint fetchMinimumContextDepth(ControlFlowNode cfNode, Object targetObj, ClassObject classInstance) {\n  // 返回所有可能深度的最小值\n  result = min(int depth | depth = determineContextDepth(cfNode, targetObj, classInstance))\n}\n\n// 分析不同深度层级的指向关系特征\nfrom int edgeCount, int totalRelations, int depthTier, float efficiencyRatio\nwhere\n  // 计算边际关系数：最浅深度等于当前深度层级的唯一指向关系数量\n  edgeCount = strictcount(ControlFlowNode cfNode, Object targetObj, ClassObject classInstance |\n    depthTier = fetchMinimumContextDepth(cfNode, targetObj, classInstance)\n  ) and\n  // 计算关系总数：深度等于当前深度层级的所有指向关系数量\n  totalRelations = strictcount(ControlFlowNode cfNode, Object targetObj, ClassObject classInstance, \n                              PointsToContext ptContext, ControlFlowNode originNode |\n    PointsTo::points_to(cfNode, ptContext, targetObj, classInstance, originNode) and\n    depthTier = ptContext.getDepth()\n  ) and\n  // 计算效率比率：边际关系数占总关系数的百分比\n  totalRelations > 0 and  // 避免除以零错误\n  efficiencyRatio = 100.0 * edgeCount / totalRelations\n// 输出结果：深度层级、边际关系数、关系总数和效率比率\nselect depthTier, edgeCount, totalRelations, efficiencyRatio",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak elliptic curve detection\n * @description Detects cryptographic operations employing elliptic curve algorithms that are\n *              either unidentified or categorized as weak based on recognized security benchmarks.\n *              This analysis assists in identifying possible security weaknesses in cryptographic implementations.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n_______________ // 补全条件\nfrom EllipticCurveAlgorithm curveCryptoOperation, string vulnerabilityMessage, string curveName\nwhere\n  // Retrieve the curve name from the cryptographic operation\n  curveName = curveCryptoOperation.getCurveName() and\n  \n  // Check if the curve is either unrecognized or weak\n  (\n    // Condition 1: The curve algorithm is not recognized by the system\n    // This indicates potential use of custom or non-standard curves\n    curveName = unknownAlgorithm() and\n    vulnerabilityMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Condition 2: The curve algorithm is recognized but not in the approved secure list\n    // These curves are known to have security weaknesses or are deprecated\n    curveName != unknownAlgorithm() and\n    not curveName in\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    vulnerabilityMessage = \"Use of weak curve algorithm \" + curveName + \".\"\n  )\nselect curveCryptoOperation, vulnerabilityMessage",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raise-not-implemented]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies incorrect usage of 'NotImplemented' in raise statements,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name NotImplemented is not an Exception\n * @description Identifies incorrect usage of 'NotImplemented' in raise statements,\n *              which triggers runtime type errors due to its non-exception nature.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Core Python analysis framework\nimport python\n\n// Module for handling NotImplemented-related exceptions\nimport Exceptions.NotImplemented\n\n// Identify problematic expressions where NotImplemented is raised\nfrom Expr notImplementedUsage\n// Filter expressions where NotImplemented appears in raise contexts\nwhere use_of_not_implemented_in_raise(_, notImplementedUsage)\n// Output the problematic expression with corrective guidance\nselect notImplementedUsage, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commented-out-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code segments that have been commented out by developers, which can degrade code readability and impede long-term maintenance efforts.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commented-out code\n * @description Detects code segments that have been commented out by developers, which can degrade code readability and impede long-term maintenance efforts.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code */\n\n// Import the Python language analysis module\nimport python\n\n// Import the CommentedOutCode class from Lexical module for detecting commented code\nimport Lexical.CommentedOutCode\n\n// Identify problematic commented code blocks\nfrom CommentedOutCodeBlock problematicCommentBlock\n// Exclude blocks that might represent example code or documentation\nwhere not problematicCommentBlock.maybeExampleCode()\n// Report the identified commented code blocks with an appropriate warning message\nselect problematicCommentBlock, \"This comment appears to contain commented-out code.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name NotImplemented is not an Exception\n * @description Detects raise statements that incorrectly use 'NotImplemented' \n *              instead of 'NotImplementedError', causing type errors since \n *              NotImplemented is not an exception class.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n_______________ // 补全条件\n *       maintainability\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom Expr misusedNotImplementedExpr\nwhere \n  // Identify raise statements containing incorrect NotImplemented usage\n  use_of_not_implemented_in_raise(_, misusedNotImplementedExpr)\nselect \n  misusedNotImplementedExpr, \n  \"NotImplemented is not an Exception. Did you mean NotImplementedError?\"",
    "output": "* @tags reliability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/symmetric-encryption-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Locates symmetric encryption algorithm implementations in Python projects,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Detection of Symmetric Encryption Algorithms\n * @description Locates symmetric encryption algorithm implementations in Python projects,\n *              with emphasis on established cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-encryption-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricEncryptionAlgorithm symmetricAlgo\nselect symmetricAlgo, \n       \"Algorithm usage detected: \" + symmetricAlgo.getEncryptionName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/paramiko-command-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects user-controlled inputs that lead to command execution on external systems,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Command execution on a secondary remote server\n * @description Detects user-controlled inputs that lead to command execution on external systems,\n *              potentially compromising other users or administrative infrastructure\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.3\n * @precision high\n * @id py/paramiko-command-injection\n * @tags security\n *       experimental\n *       external/cwe/cwe-074\n */\n\n// Core Python language support for security analysis\nimport python\n// Experimental utilities for identifying remote command execution vulnerabilities\nimport experimental.semmle.python.security.RemoteCommandExecution\n// Path graph components for tracking data flow propagation\nimport RemoteCommandExecutionFlow::PathGraph\n\n// Identify vulnerable paths where untrusted input reaches remote command execution points\nfrom RemoteCommandExecutionFlow::PathNode untrustedSource, RemoteCommandExecutionFlow::PathNode commandExecutionSink\n// Verify complete data flow propagation from untrusted source to command execution sink\nwhere RemoteCommandExecutionFlow::flowPath(untrustedSource, commandExecutionSink)\n// Generate vulnerability report with detailed propagation path information\nselect commandExecutionSink.getNode(), untrustedSource, commandExecutionSink, \n       \"This command execution originates from a $@.\", untrustedSource.getNode(),\n       \"user-controlled input source\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/all-asymmetric-encryption-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：查找所有使用受支持库的潜在非对称密钥进行加密或密钥交换的用法。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 非对称加密算法\n * @description 查找所有使用受支持库的潜在非对称密钥进行加密或密钥交换的用法。\n * @kind 问题\n * @id py/quantum-readiness/cbom/all-asymmetric-encryption-algorithms\n * @problem.severity 错误\n * @tags cbom\n *       密码学\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找所有非对称加密算法实例\nfrom AsymmetricEncryptionAlgorithm cryptoAlgorithm\n// 生成警告消息，标识检测到的非对称加密算法\nselect cryptoAlgorithm, \"Use of algorithm \" + cryptoAlgorithm.getEncryptionName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type metrics\n * @description Quantifies different categories of type annotations in Python code\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Core Python built-in types for type annotation analysis\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements supporting type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr funcExpr) { exists(funcExpr.getReturns()) } or \n  TAnnotatedParameter(Parameter param) { exists(param.getAnnotation()) } or \n  TAnnotatedAssignment(AnnAssign annotAssign) { exists(annotAssign.getAnnotation()) }\n\n// Base class for elements that can have type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Represents functions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr funcExpr;\n  AnnotatedFunction() { this = TAnnotatedFunction(funcExpr) }\n  override Expr getAnnotation() { result = funcExpr.getReturns() }\n}\n\n// Represents parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter param;\n  AnnotatedParameter() { this = TAnnotatedParameter(param) }\n  override Expr getAnnotation() { result = param.getAnnotation() }\n}\n\n// Represents assignments with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign annotAssign;\n  AnnotatedAssignment() { this = TAnnotatedAssignment(annotAssign) }\n  override Expr getAnnotation() { result = annotAssign.getAnnotation() }\n}\n\n// Type classification predicates\n/** Identifies forward-declared types (string literals) */\npredicate is_forward_declaration(Expr annotationExpr) { \n  annotationExpr instanceof StringLiteral \n}\n\n/** Identifies complex type structures */\npredicate is_complex_type(Expr annotationExpr) {\n  (annotationExpr instanceof Subscript and not is_optional_type(annotationExpr))\n  or\n  annotationExpr instanceof Tuple\n  or\n  annotationExpr instanceof List\n}\n\n/** Identifies Optional types */\npredicate is_optional_type(Subscript annotationExpr) { \n  annotationExpr.getObject().(Name).getId() = \"Optional\" \n_______________ // 补全条件\n\n/** Identifies simple user-defined types */\npredicate is_simple_type(Expr annotationExpr) {\n  (annotationExpr instanceof Name and not annotationExpr instanceof BuiltinType)\n  or\n  is_simple_type(annotationExpr.(Attribute).getObject())\n}\n\n/** Identifies built-in types */\npredicate is_builtin_type(Expr annotationExpr) { \n  annotationExpr instanceof BuiltinType \n}\n\n// Computes type annotation metrics for different annotation categories\npredicate type_count(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  category = \"Parameter annotation\" and\n  totalCount = count(AnnotatedParameter annotatedParam) and\n  builtinCount = count(AnnotatedParameter annotatedParam | is_builtin_type(annotatedParam.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedParameter annotatedParam | is_forward_declaration(annotatedParam.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedParameter annotatedParam | is_simple_type(annotatedParam.getAnnotation())) and\n  complexTypeCount = count(AnnotatedParameter annotatedParam | is_complex_type(annotatedParam.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedParameter annotatedParam | is_optional_type(annotatedParam.getAnnotation()))\n  or\n  // Return type annotation metrics\n  category = \"Return type annotation\" and\n  totalCount = count(AnnotatedFunction annotatedFunc) and\n  builtinCount = count(AnnotatedFunction annotatedFunc | is_builtin_type(annotatedFunc.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedFunction annotatedFunc | is_forward_declaration(annotatedFunc.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedFunction annotatedFunc | is_simple_type(annotatedFunc.getAnnotation())) and\n  complexTypeCount = count(AnnotatedFunction annotatedFunc | is_complex_type(annotatedFunc.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedFunction annotatedFunc | is_optional_type(annotatedFunc.getAnnotation()))\n  or\n  // Annotated assignment metrics\n  category = \"Annotated assignment\" and\n  totalCount = count(AnnotatedAssignment annotatedAssign) and\n  builtinCount = count(AnnotatedAssignment annotatedAssign | is_builtin_type(annotatedAssign.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedAssignment annotatedAssign | is_forward_declaration(annotatedAssign.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedAssignment annotatedAssign | is_simple_type(annotatedAssign.getAnnotation())) and\n  complexTypeCount = count(AnnotatedAssignment annotatedAssign | is_complex_type(annotatedAssign.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedAssignment annotatedAssign | is_optional_type(annotatedAssign.getAnnotation()))\n}\n\n// Query execution and result projection\nfrom\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_count(category, totalCount, builtinCount, forwardDeclCount, simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount",
    "output": "}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commit-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Establishes connections between version control commits and the source files",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commit-to-source file associations\n * @kind source-link\n * @id py/commit-source-links\n * @metricType commit\n * @description Establishes connections between version control commits and the source files\n *              they modify by analyzing the commit history and tracking file modifications\n *              across different revisions of the codebase.\n */\n\n// Import Python module to enable Python code analysis capabilities\nimport python\n// Import external version control system module for accessing commit history and file change information\nimport external.VCS\n\n// Define variables to represent commit records and affected source files\nfrom Commit commitRecord, File affectedSourceFile\n// Apply filtering conditions to ensure we only process legitimate source files that were modified in commits\nwhere \n  // Confirm that the file is a source code file\n  affectedSourceFile.fromSource() and\n  // Verify the file was actually modified in the specified commit\n  affectedSourceFile = commitRecord.getAnAffectedFile()\n// Output the commit revision identifier and the corresponding affected source file\nselect commitRecord.getRevisionName(), affectedSourceFile"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/constant-conditional-expression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects conditionals that always evaluate to true or false due to constant expressions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Constant in conditional expression or statement\n * @description Detects conditionals that always evaluate to true or false due to constant expressions\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/constant-conditional-expression\n */\n\nimport python\n\n/**\n * Identifies expressions used as test conditions in control flow statements\n * @param conditionExpr - The expression being evaluated as a condition\n */\npredicate is_condition(Expr conditionExpr) {\n  // Check if the expression serves as the test condition in either:\n  // 1. An if statement (If)\n  // 2. A conditional expression (IfExp)\n  exists(If ifStmt | ifStmt.getTest() = conditionExpr) or\n  exists(IfExp ifExpr | ifExpr.getTest() = conditionExpr)\n}\n\n/**\n * Recognizes specific unmodified builtin constants that behave as constants\n * @param constName - The name node representing the constant\n */\npredicate effective_constant(Name constName) {\n  // Verify the name refers to one of these global builtin constants:\n  // True, False, or NotImplemented\n  // Ensure no other definitions exist for this variable\n  exists(GlobalVariable globalVar | \n    globalVar = constName.getVariable() and \n    not exists(NameNode definingNode | definingNode.defines(globalVar)) |\n    globalVar.getId() = \"True\" or \n    globalVar.getId() = \"False\" or \n    globalVar.getId() = \"NotImplemented\"\n  )\n}\n\n/**\n * Determines if a test condition creates unreachable code branches\n * @param conditionExpr - The expression being evaluated\n */\npredicate test_makes_code_unreachable(Expr conditionExpr) {\n  // Identify if statements where either branch becomes unreachable\n  // due to the constant condition\n  exists(If ifStmt | \n    ifStmt.getTest() = conditionExpr and \n    (ifStmt.getStmt(0).isUnreachable() or ifStmt.getOrelse(0).isUnreachable())\n  )\n  or\n  // Identify while loops where the body becomes unreachable\n  // due to the constant condition\n  exists(While whileLoop | \n    whileLoop.getTest() = conditionExpr and \n    whileLoop.getStmt(0).isUnreachable()\n  )\n}\n\n// Main query to identify constant conditional expressions\nfrom Expr conditionExpr\nwhere\n  // The expression must serve as a condition in control flow\n  is_condition(conditionExpr) and\n  // The expression must be either a literal constant or a recognized builtin constant\n  (conditionExpr.isConstant() or effective_constant(conditionExpr)) and\n  // Exclude cases where the constant condition creates unreachable code\n  // (handled separately in a different query)\n  not test_makes_code_unreachable(conditionExpr)\n// Report findings with consistent message\nselect conditionExpr, \"Testing a constant will always give the same result.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/functions-and-methods-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides a quantitative analysis of functions and methods distribution across Python files.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Functions and methods per file\n * @description Provides a quantitative analysis of functions and methods distribution across Python files.\n * @kind treemap\n * @id py/functions-and-methods-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python // Import Python module for code structure analysis\n\n// Define the main query to analyze Python modules and their function counts\nfrom Module pythonModule, int functionCount\n// Calculate the total number of non-lambda functions within each Python module\nwhere functionCount = count(Function function | \n       // Ensure the function is contained within the current module\n       function.getEnclosingModule() = pythonModule and \n       // Exclude lambda functions from the count\n       function.getName() != \"lambda\")\n// Output results showing each Python module with its corresponding function count,\n// sorted in descending order to highlight files with the most functions\nselect pythonModule, functionCount order by functionCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__init__` method is a generator\n * @description 检测作为生成器的`__init__`方法。在Python中，`__init__`方法通常不应该作为生成器，因为它用于初始化对象实例。\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/init-method-is-generator\n */\n\nimport python\n\nfrom Function initMethod\nwhere\n  // 确认函数是类的初始化方法（即 __init__ 方法）\n  initMethod.isInitMethod() and\n  // 检查函数体内是否存在 yield 或 yield from 语句，这些语句表明函数是生成器\n  (\n    exists(Yield yieldNode | yieldNode.getScope() = initMethod) or\n_______________ // 补全条件\n  )\nselect initMethod, \"__init__ method is a generator.\"",
    "output": "exists(YieldFrom yieldFromNode | yieldFromNode.getScope() = initMethod)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-of-constants]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies comparisons between two constant expressions. Such comparisons",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comparison of constants\n * @description Identifies comparisons between two constant expressions. Such comparisons\n *              have predetermined results at compile time. Replacing them with their\n *              actual boolean values (True or False) improves code clarity, readability,\n *              and maintainability. This query helps detect unnecessary comparisons\n *              to enhance overall code quality.\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/comparison-of-constants\n */\n\nimport python\n\n// Identify comparison operations between constant expressions that are not used in assertions\nfrom Compare constantComparison, Expr leftConstantOperand, Expr rightConstantOperand\nwhere\n  // Verify the operation is a comparison with constant operands on both sides\n  constantComparison.compares(leftConstantOperand, _, rightConstantOperand) and\n  // Ensure both operands are constant expressions\n  leftConstantOperand.isConstant() and\n  rightConstantOperand.isConstant() and\n  // Exclude comparisons used in assertion statements (explicit comparisons may be needed there)\n  not exists(Assert assertStmt | assertStmt.getTest() = constantComparison)\nselect constantComparison, \"Comparison of constants; use 'True' or 'False' instead.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'To Do' comment detection\n * @description Detects comments containing 'TODO' or 'TO DO' markers that indicate\n *              incomplete features or pending tasks in the code.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n *       external/cwe/cwe-546\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/todo-comment\n */\n_______________ // 补全条件\nimport python  // Python language library for code analysis\n\nfrom Comment pendingTaskComment  // Select all comment nodes\nwhere \n  // Check if comment contains task markers\n  pendingTaskComment.getText().matches(\"%TODO%\") or \n  pendingTaskComment.getText().matches(\"%TO DO%\")\nselect \n  pendingTaskComment,  // The matching comment node\n  pendingTaskComment.getText()  // and its text content",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 检查特定类名的类层次结构关系\n * 包括目标类本身、其所有父类和子类\n */\n\nimport python\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n\n// 查询目标类及其直接父类（递归获取所有祖先类）\nquery predicate findSuperClasses(Class childClass, Class parentClass) {\n  // 筛选目标类：类名匹配指定名称\n  childClass.getName() = \"YourClassName\"\n  // 可选：限制类所在文件路径（取消注释以启用）\n  // and childClass.getLocation().getFile().getAbsolutePath().matches(\"%/folder/file.py\")\n  and\n  // 递归获取所有直接父类\n  parentClass = getADirectSuperclass+(childClass)\n}\n\n// 查询目标类及其直接子类（递归获取所有后代类）\nquery predicate findSubClasses(Class parentClass, Class childClass) {\n  // 筛选目标类：类名匹配指定名称\n  parentClass.getName() = \"YourClassName\"\n  // 可选：限制类所在文件路径（取消注释以启用）\n  // and parentClass.getLocation().getFile().getAbsolutePath().matches(\"%/folder/file.py\")\n  and\n  // 递归获取所有直接子类\n  childClass = getADirectSubclass+(parentClass)\n}\n\n_______________ // 补全条件\nfrom Class targetCls\nwhere \n  // 筛选条件：类名匹配指定名称\n  targetCls.getName() = \"YourClassName\"\n  // 可选：限制类所在文件路径（取消注释以启用）\n  // and targetCls.getLocation().getFile().getAbsolutePath().matches(\"%/folder/file.py\")\nselect targetCls",
    "output": "// 选择所有匹配目标名称的类"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python Class Display Strings\n * @description Identifies and enumerates all Python classes in the codebase, \n *              presenting their names as formatted strings for convenient reference.\n * @kind display-string\n * @id py/lgtm/class-display-strings\n_______________ // 补全条件\n */\n\nimport python\n\n// Obtain all Python class definitions found in the analyzed codebase\nfrom Class cls\n\n// Output each class entity paired with its corresponding name as a display string\nselect cls, cls.getName()",
    "output": "* @metricType reftype"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-small-salt-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Key Derivation Function (KDF) salts must be at least 128 bits (16 bytes) in length.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insufficient KDF Salt Size\n * @description Key Derivation Function (KDF) salts must be at least 128 bits (16 bytes) in length.\n *\n * This rule identifies two types of issues:\n * 1. When a salt size configuration is less than the required 128 bits\n * 2. When the salt size cannot be statically determined at analysis time\n * \n * The rule specifically checks for salt configurations using os.urandom() calls.\n * @kind problem\n * @id py/kdf-small-salt-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\n// Identify KDF operations with problematic salt configurations\nfrom KeyDerivationOperation kdfOp, DataFlow::Node saltSizeNode, API::CallNode urandomCall, string alertMessage\nwhere\n  // Verify the KDF operation requires salt configuration\n  kdfOp.requiresSalt() and\n  \n  // Confirm salt source is an os.urandom() call\n  urandomCall = kdfOp.getSaltConfigSrc() and\n  urandomCall = API::moduleImport(\"os\").getMember(\"urandom\").getACall() and\n  \n  // Trace the salt size parameter to its source\n  saltSizeNode = Utils::getUltimateSrcFromApiNode(urandomCall.getParameter(0, \"size\")) and\n  \n  // Detect two distinct salt configuration issues\n  (\n    // Case 1: Salt size is not statically determinable\n    not exists(saltSizeNode.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Salt config is not a statically verifiable size. \"\n    or\n    // Case 2: Salt size is below minimum requirement\n    saltSizeNode.asExpr().(IntegerLiteral).getValue() < 16 and\n    alertMessage = \"Salt config is insufficiently large. \"\n  )\n\n// Report findings with contextual information\nselect kdfOp,\n  alertMessage + \"Salt size must be a minimum of 16 (bytes). os.urandom Config: $@, Size Config: $@\", \n  urandomCall,\n  urandomCall.toString(), \n  saltSizeNode, \n  saltSizeNode.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary delete statement in function\n * @description Detects redundant 'delete' operations on local variables that\n *              would be automatically cleaned up when the function terminates.\n * @kind problem\n * @tags maintainability\n_______________ // 补全条件\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/unnecessary-delete\n */\n\nimport python\n\n// Recursively determines if a node is nested within any loop structure\npredicate isInsideLoop(AstNode currentNode) {\n  // Direct child of a While or For loop\n  currentNode.getParentNode() instanceof While\n  or\n  currentNode.getParentNode() instanceof For\n  // Descendant of a node already inside a loop\n  or\n  exists(AstNode loopAncestor | \n    isInsideLoop(loopAncestor) and \n    currentNode = loopAncestor.getAChildNode()\n  )\n}\n\n// Query for identifying unnecessary delete statements at function end\nfrom Delete deleteOperation, Expr deletedVariable, Function containingFunction\nwhere\n  // Verify the delete is the final statement in the function\n  containingFunction.getLastStatement() = deleteOperation and\n  // Identify the expression being deleted\n  deletedVariable = deleteOperation.getATarget() and\n  // Ensure the expression is within the function's scope\n  containingFunction.containsInScope(deletedVariable) and\n  // Exclude subscript operations (e.g., del list[0])\n  not deletedVariable instanceof Subscript and\n  // Exclude attribute access (e.g., del obj.attr)\n  not deletedVariable instanceof Attribute and\n  // Exclude deletes within loop constructs\n  not isInsideLoop(deleteOperation) and\n  // Exclude functions calling sys.exc_info which may need explicit cleanup\n  not exists(FunctionValue sysExcInfoCall |\n    sysExcInfoCall = Value::named(\"sys.exc_info\") and\n    sysExcInfoCall.getACall().getScope() = containingFunction\n  )\nselect deleteOperation, \"Unnecessary deletion of local variable $@ in function $@.\", \n  deletedVariable, deletedVariable.toString(), containingFunction,\n  containingFunction.getName()",
    "output": "*       useless-code"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Block cipher mode of operation detection\n * @description This query identifies cryptographic operations that utilize block cipher modes\n *              within supported cryptographic libraries, helping to assess quantum readiness\n *              by detecting classic encryption models that may be vulnerable to quantum attacks.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/block-cipher-mode\n * @problem.severity error\n * @tags cbom\n_______________ // 补全条件\n */\n\nimport python\nimport semmle.python.Concepts\n\n// Identify cryptographic operations and extract their block cipher mode configuration\nfrom Cryptography::CryptographicOperation cipherOperation, string blockCipherMode\nwhere \n  // Extract the block cipher mode name for each detected cryptographic operation\n  blockCipherMode = cipherOperation.getBlockMode()\n  // Ensure we only report operations with a defined block cipher mode\n  and blockCipherMode != \"\"\nselect \n  cipherOperation, \n  \"Cryptographic operation uses block cipher mode: \" + blockCipherMode",
    "output": "*       cryptography"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-using-is]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Comparison using 'is' when equivalence is not the same as identity",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comparison using is when operands support `__eq__`\n * @description Comparison using 'is' when equivalence is not the same as identity\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/comparison-using-is\n */\n\nimport python\n\n/** Determines if a comparison operation uses identity operators ('is'/'is not') */\npredicate identity_comparison(Compare comp, ControlFlowNode leftOperand, Cmpop operator, ControlFlowNode rightOperand) {\n  exists(CompareNode flowNode | flowNode = comp.getAFlowNode() |\n    flowNode.operands(leftOperand, operator, rightOperand) and\n    (operator instanceof Is or operator instanceof IsNot)\n  )\n}\n\n/**\n * Identifies expressions that are interned by CPython\n * @param expr The expression to evaluate\n * @return True if the expression is interned by CPython\n */\nprivate predicate is_interned_value(Expr expr) {\n  // Check for empty or single-byte ASCII strings\n  exists(string strText | strText = expr.(StringLiteral).getText() |\n    strText.length() = 0\n    or\n    strText.length() = 1 and strText.regexpMatch(\"[U+0000-U+00ff]\")\n  )\n  // Check for integers in the cached range [-5, 256]\n  or\n  exists(int intValue | intValue = expr.(IntegerLiteral).getN().toInt() | -5 <= intValue and intValue <= 256)\n  // Check for empty tuples\n  or\n  exists(Tuple tuple | tuple = expr and not exists(tuple.getAnElt()))\n}\n\n/**\n * Identifies literal expressions that are not interned\n * @param expr The expression to evaluate\n * @return True if the expression is a non-interned literal\n */\npredicate non_interned_literal(Expr expr) {\n  (\n    expr instanceof StringLiteral\n    or\n    expr instanceof IntegerLiteral\n    or\n    expr instanceof FloatLiteral\n    or\n    expr instanceof Dict\n    or\n    expr instanceof List\n    or\n    expr instanceof Tuple\n  ) and\n  not is_interned_value(expr)\n}\n\nfrom Compare comp, Cmpop operator, string alternativeOperator\nwhere\n  exists(ControlFlowNode leftOperand, ControlFlowNode rightOperand |\n    identity_comparison(comp, leftOperand, operator, rightOperand) and\n    (\n      operator instanceof Is and alternativeOperator = \"==\"\n      or\n      operator instanceof IsNot and alternativeOperator = \"!=\"\n    )\n  |\n    non_interned_literal(leftOperand.getNode())\n    or\n    non_interned_literal(rightOperand.getNode())\n  )\nselect comp,\n  \"Values compared using '\" + operator.getSymbol() +\n    \"' when equivalence is not the same as identity. Use '\" + alternativeOperator + \"' instead.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects Python syntax errors that can cause runtime failures and impede static code analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import the Python library for code analysis and query processing\nimport python\n\n// Query for syntax error instances, filtering out encoding-related issues\nfrom SyntaxError syntaxFailure\nwhere \n  // Exclude encoding-related errors from the results\n  not syntaxFailure instanceof EncodingError\nselect \n  syntaxFailure, \n  // Format the error message to include Python version information\n  syntaxFailure.getMessage() + \" (detected in Python \" + major_version() + \").\"",
    "output": "* @name Syntax error detection"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-permissive-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly permissive file permissions\n * @description Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.\n * @kind problem\n * @id py/overly-permissive-file\n * @problem.severity warning\n * @security-severity 7.8\n * @sub-severity high\n * @precision medium\n * @tags external/cwe/cwe-732\n *       security\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// 定义一个绑定集，用于计算文件权限中的“world”部分。\nbindingset[p]\nint world_permission(int p) { result = p % 8 }\n\n// 定义一个绑定集，用于计算文件权限中的“group”部分。\nbindingset[p]\nint group_permission(int p) { result = (p / 8) % 8 }\n\n// 定义一个绑定集，用于将权限数值转换为可读的字符串表示形式。\nbindingset[p]\nstring access(int p) {\n  p % 4 >= 2 and result = \"writable\" // 如果权限数值的最后两位大于等于2，则表示可写。\n  or\n  p % 4 < 2 and p != 0 and result = \"readable\" // 如果权限数值的最后两位小于2且不为0，则表示可读。\n}\n\n// 定义一个绑定集，用于判断权限是否过于宽松，并返回相应的描述。\nbindingset[p]\nstring permissive_permission(int p) {\n  result = \"world \" + access(world_permission(p)) // 如果world权限不为0，则返回world权限的描述。\n  or\n  world_permission(p) = 0 and result = \"group \" + access(group_permission(p)) // 如果world权限为0，则返回group权限的描述。\n}\n\n// 定义一个谓词，用于匹配调用os.chmod函数的API调用节点。\npredicate chmod_call(API::CallNode call, string name, int mode) {\n  call = API::moduleImport(\"os\").getMember(\"chmod\").getACall() and // 匹配os.chmod函数调用。\n  mode = call.getParameter(1, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue() and // 获取mode参数的值。\n  name = \"chmod\" // 设置name为\"chmod\"。\n}\n\n// 定义一个谓词，用于匹配调用os.open函数的API调用节点。\npredicate open_call(API::CallNode call, string name, int mode) {\n  call = API::moduleImport(\"os\").getMember(\"open\").getACall() and // 匹配os.open函数调用。\n  mode = call.getParameter(2, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue() and // 获取mode参数的值。\n  name = \"open\" // 设置name为\"open\"。\n}\n\n// 查询语句：查找所有调用os.chmod或os.open函数时设置了过于宽松的文件权限的情况。\nfrom API::CallNode call, string name, int mode, string permission\nwhere\n  (chmod_call(call, name, mode) or open_call(call, name, mode)) and // 匹配调用os.chmod或os.open函数的API调用节点。\n  permission = permissive_permission(mode) // 检查权限是否过于宽松。\nselect call, \"Overly permissive mask in \" + name + \" sets file to \" + permission + \".\" // 选择并报告这些调用节点及其对应的权限描述。"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Membership test with a non-container\n * @description Identifies membership tests (e.g., 'item in sequence') where the right-hand side \n *              is not a container type, potentially raising TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n_______________ // 补全条件\n */\n\nimport python  // Core Python language analysis capabilities\nimport semmle.python.pointsto.PointsTo  // Points-to analysis for value flow tracking\n\n// Identifies comparison operations containing In/NotIn operators with specified right-hand side\npredicate isMembershipTestRhs(ControlFlowNode rhsNode, Compare comparison) {\n  exists(Cmpop operator, int operandIndex |\n    comparison.getOp(operandIndex) = operator and\n    comparison.getComparator(operandIndex) = rhsNode.getNode() and\n    (operator instanceof In or operator instanceof NotIn)\n  )\n}\n\n// Analyzes membership tests where RHS may be non-container\nfrom ControlFlowNode rhsNode, Compare membershipComparison, Value rhsValue, ClassValue rhsClass, ControlFlowNode valueOriginNode\nwhere\n  // Confirm RHS is part of membership test\n  isMembershipTestRhs(rhsNode, membershipComparison) and\n  // Track value flow to RHS and extract its class\n  rhsNode.pointsTo(_, rhsValue, valueOriginNode) and\n  rhsValue.getClass() = rhsClass and\n  // Exclude cases with type inference failures\n  not Types::failedInference(rhsClass, _) and\n  // Verify absence of container protocol methods\n  not rhsClass.hasAttribute(\"__contains__\") and\n  not rhsClass.hasAttribute(\"__iter__\") and\n  not rhsClass.hasAttribute(\"__getitem__\") and\n  // Exclude special cases with non-standard container behavior\n  not rhsClass = ClassValue::nonetype() and\n  not rhsClass = Value::named(\"types.MappingProxyType\")\nselect membershipComparison, \"Membership test may fail as the $@ belongs to non-container class $@.\", valueOriginNode,\n  \"target\", rhsClass, rhsClass.getName()",
    "output": "* @id py/member-test-non-container"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cyclomatic-complexity-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the cyclomatic complexity of Python functions, which calculates the number of",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Function cyclomatic complexity analysis\n * @description Measures the cyclomatic complexity of Python functions, which calculates the number of\n *              independent paths through a function's source code. Higher values indicate more\n *              branching logic, requiring more thorough testing and potentially reducing code\n *              maintainability.\n * @kind treemap\n * @id py/cyclomatic-complexity-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max sum\n * @tags testability\n *       complexity\n *       maintainability\n */\n\nimport python\n\n// Extract all Python functions and determine their cyclomatic complexity values\nfrom Function targetFunction, int cyclomaticValue\n// Calculate the cyclomatic complexity metric for each identified function\nwhere cyclomaticValue = targetFunction.getMetrics().getCyclomaticComplexity()\n// Present the results showing each function with its corresponding complexity score, sorted from highest to lowest\nselect targetFunction, cyclomaticValue order by cyclomaticValue desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Import of deprecated module\n * @description Identifies imports of deprecated Python modules\n * @kind problem\n * @tags maintainability\n *       external/cwe/cwe-477\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/import-deprecated-module\n */\n\nimport python\n\n/**\n * Determines if a module has been deprecated in a specific Python version.\n * \n * @param importedModuleName The name of the module being checked for deprecation\n * @param replacementSuggestion The recommended replacement module\n * @param majorVer Major version number where deprecation occurred\n * @param minorVer Minor version number where deprecation occurred\n * @return true if the module is deprecated in the specified version\n */\npredicate moduleIsDeprecated(string importedModuleName, string replacementSuggestion, int majorVer, int minorVer) {\n  // POSIX file operations module\n  importedModuleName = \"posixfile\" and replacementSuggestion = \"fcntl\" and majorVer = 1 and minorVer = 5\n  or\n  // Gopher protocol client module\n  importedModuleName = \"gopherlib\" and replacementSuggestion = \"no replacement\" and majorVer = 2 and minorVer = 5\n  or\n  // RGB image processing module\n  importedModuleName = \"rgbimgmodule\" and replacementSuggestion = \"no replacement\" and majorVer = 2 and minorVer = 5\n  or\n  // Regular expression operations (old module)\n  importedModuleName = \"pre\" and replacementSuggestion = \"re\" and majorVer = 1 and minorVer = 5\n  or\n  // Pseudo-random number generator (old module)\n  importedModuleName = \"whrandom\" and replacementSuggestion = \"random\" and majorVer = 2 and minorVer = 1\n  or\n  // RFC-822 message handling module\n  importedModuleName = \"rfc822\" and replacementSuggestion = \"email\" and majorVer = 2 and minorVer = 3\n  or\n  // MIME tools module\n  importedModuleName = \"mimetools\" and replacementSuggestion = \"email\" and majorVer = 2 and minorVer = 3\n  or\n_______________ // 补全条件\n  importedModuleName = \"MimeWriter\" and replacementSuggestion = \"email\" and majorVer = 2 and minorVer = 3\n  or\n  // MIME message handling module\n  importedModuleName = \"mimify\" and replacementSuggestion = \"email\" and majorVer = 2 and minorVer = 3\n  or\n  // Enigma-like encryption module\n  importedModuleName = \"rotor\" and replacementSuggestion = \"no replacement\" and majorVer = 2 and minorVer = 4\n  or\n  // Cached file status module\n  importedModuleName = \"statcache\" and replacementSuggestion = \"no replacement\" and majorVer = 2 and minorVer = 2\n  or\n  // Multiple precision integers module\n  importedModuleName = \"mpz\" and replacementSuggestion = \"a third party\" and majorVer = 2 and minorVer = 2\n  or\n  // Line-oriented file interface module\n  importedModuleName = \"xreadlines\" and replacementSuggestion = \"no replacement\" and majorVer = 2 and minorVer = 3\n  or\n  // Multi-file handling module\n  importedModuleName = \"multifile\" and replacementSuggestion = \"email\" and majorVer = 2 and minorVer = 5\n  or\n  // Set data type module (replaced by built-in)\n  importedModuleName = \"sets\" and replacementSuggestion = \"builtins\" and majorVer = 2 and minorVer = 6\n  or\n  // Build tools module\n  importedModuleName = \"buildtools\" and replacementSuggestion = \"no replacement\" and majorVer = 2 and minorVer = 3\n  or\n  // Macintosh resource fork module\n  importedModuleName = \"cfmfile\" and replacementSuggestion = \"no replacement\" and majorVer = 2 and minorVer = 4\n  or\n  // Macintosh file system module\n  importedModuleName = \"macfs\" and replacementSuggestion = \"no replacement\" and majorVer = 2 and minorVer = 3\n  or\n  // MD5 hash algorithm module\n  importedModuleName = \"md5\" and replacementSuggestion = \"hashlib\" and majorVer = 2 and minorVer = 5\n  or\n  // SHA hash algorithm module\n  importedModuleName = \"sha\" and replacementSuggestion = \"hashlib\" and majorVer = 2 and minorVer = 5\n}\n\n/**\n * Constructs a formatted string containing deprecation version information for a module.\n * \n * @param importedModuleName The name of the module to check\n * @return A formatted string with deprecation version details\n */\nstring getDeprecationVersionInfo(string importedModuleName) {\n  exists(int majorVer, int minorVer |\n    moduleIsDeprecated(importedModuleName, _, majorVer, minorVer) and\n    result = \"The \" + importedModuleName + \" module was deprecated in version \" + \n             majorVer.toString() + \".\" + minorVer.toString() + \".\"\n  )\n}\n\n/**\n * Generates a replacement recommendation message for a deprecated module.\n * \n * @param importedModuleName The name of the module to check\n * @return Replacement suggestion message or empty string if no replacement exists\n */\nstring getReplacementRecommendation(string importedModuleName) {\n  exists(string replacementSuggestion |\n    moduleIsDeprecated(importedModuleName, replacementSuggestion, _, _) and\n    (\n      result = \" Use \" + replacementSuggestion + \" module instead.\" and \n      replacementSuggestion != \"no replacement\"\n      or\n      result = \"\" and replacementSuggestion = \"no replacement\"\n    )\n  )\n}\n\nfrom ImportExpr importExpr, string importedModuleName, string replacementSuggestion\nwhere\n  // Match imported module name\n  importedModuleName = importExpr.getName()\n  // Check if module is deprecated\n  and moduleIsDeprecated(importedModuleName, replacementSuggestion, _, _)\n  // Exclude imports wrapped in ImportError handling\n  and not exists(Try tryStmt, ExceptStmt exceptClause |\n    exceptClause = tryStmt.getAHandler() and\n    exceptClause.getType().pointsTo(ClassValue::importError()) and\n    exceptClause.containsInScope(importExpr)\n  )\nselect importExpr, \n       getDeprecationVersionInfo(importedModuleName) + getReplacementRecommendation(importedModuleName)",
    "output": "// MIME writer module"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Raising a tuple\n * @description Raising a tuple will result in all but the first element being discarded\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n_______________ // 补全条件\n * @precision very-high\n * @id py/raises-tuple\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// 从Raise类中选择r，并从DataFlow::LocalSourceNode类中选择origin\nfrom Raise r, DataFlow::LocalSourceNode origin\nwhere\n  // 存在一个DataFlow::Node类型的exception，并且该exception的表达式等于r.getException()，且origin流到exception\n  exists(DataFlow::Node exception | exception.asExpr() = r.getException() |\n    origin.flowsTo(exception)\n  ) and\n  // origin的表达式是一个Tuple类型\n  origin.asExpr() instanceof Tuple and\n  // Python的主版本号是2\n  major_version() = 2\n/* Raising a tuple is a type error in Python 3, so is handled by the IllegalRaise query. */\nselect r,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  origin, \"tuple\"",
    "output": "* @sub-severity high"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-lines-deleted]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes the total number of lines deleted from each file across the repository's complete commit history.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File Deletion Analysis\n * @description Computes the total number of lines deleted from each file across the repository's complete commit history.\n *              This metric identifies files that have experienced substantial code refactoring or feature elimination.\n * @kind treemap\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\nfrom Module fileModule, int cumulativeDeletedLines\nwhere\n  // Verify that the module contains valid code metrics for accurate analysis\n  exists(fileModule.getMetrics().getNumberOfLinesOfCode()) and\n  // Compute the cumulative count of lines removed from this file across all commits\n  cumulativeDeletedLines = sum(Commit revision, int linesRemovedInRevision |\n    // For each commit, determine the number of lines deleted from this file, excluding trivial or automated changes\n    linesRemovedInRevision = revision.getRecentDeletionsForFile(fileModule.getFile()) and \n    not artificialChange(revision)\n  |\n    linesRemovedInRevision\n  )\nselect fileModule, cumulativeDeletedLines order by cumulativeDeletedLines desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/slots-in-old-style-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies legacy classes (not inheriting from 'object') that define `__slots__`.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__slots__` in old-style class\n * @description Identifies legacy classes (not inheriting from 'object') that define `__slots__`. \n *              In old-style classes, `__slots__` doesn't provide memory optimization and \n *              functions as a regular attribute, potentially causing unexpected behavior. \n *              This is critical during Python 2.x to 3.x migration due to behavioral differences.\n * @kind problem\n * @problem.severity error\n * @tags portability\n *       correctness\n * @sub-severity low\n * @precision very-high\n * @id py/slots-in-old-style-class\n */\n\nimport python\n\nfrom ClassObject legacyClassWithSlots\nwhere \n  // Ensure class analysis completed successfully without inference failures\n  not legacyClassWithSlots.failedInference()\n  and\n  // Filter for classes not inheriting from 'object' (old-style classes)\n  not legacyClassWithSlots.isNewStyle() \n  and \n  // Verify explicit declaration of __slots__ attribute\n  legacyClassWithSlots.declaresAttribute(\"__slots__\") \nselect legacyClassWithSlots,\n  \"Using '__slots__' in an old style class just creates a class attribute called '__slots__'.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Missing docstring\n * @description Lack of documentation strings in public classes, functions, \n *              or methods impedes code maintainability, as it becomes difficult \n *              for other developers to understand the code's purpose and usage.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n_______________ // 补全条件\n * @id py/missing-docstring\n */\n\n/*\n * Note: This query exhibits medium precision since the necessity of a docstring \n * is inherently subjective. The requirement frequently depends on the code's context \n * and its target audience.\n */\n\nimport python\n\n// Determines if a scope requires documentation\npredicate needsDocumentation(Scope currentScope) {\n  currentScope.isPublic() and\n  (\n    not currentScope instanceof Function\n    or\n    functionRequiresDoc(currentScope)\n  )\n}\n\n// Determines if a function requires documentation\npredicate functionRequiresDoc(Function functionObj) {\n  // Exclude lambda functions\n  functionObj.getName() != \"lambda\" and\n  // Calculate actual code lines (excluding decorators)\n  (functionObj.getMetrics().getNumberOfLinesOfCode() - count(functionObj.getADecorator())) > 2 and\n  // Ensure it's not a property getter/setter\n  not exists(PythonPropertyObject prop |\n    prop.getGetter().getFunction() = functionObj or\n    prop.getSetter().getFunction() = functionObj\n  ) and\n  // Validate override documentation requirements\n  not exists(FunctionValue overrideFunc, FunctionValue baseFuncObj | \n    overrideFunc.overrides(baseFuncObj) and overrideFunc.getScope() = functionObj |\n    not functionRequiresDoc(baseFuncObj.getScope())\n  )\n}\n\n// Returns the type name of a scope (Module, Class, or Function)\nstring getScopeTypeName(Scope currentScope) {\n  // Handle non-package modules\n  result = \"Module\" and currentScope instanceof Module and not currentScope.(Module).isPackage()\n  or\n  // Handle classes\n  result = \"Class\" and currentScope instanceof Class\n  or\n  // Handle functions\n  result = \"Function\" and currentScope instanceof Function\n}\n\n// Identifies scopes requiring documentation but missing it\nfrom Scope currentScope\nwhere needsDocumentation(currentScope) and not exists(currentScope.getDocString())\nselect currentScope, getScopeTypeName(currentScope) + \" \" + currentScope.getName() + \" does not have a docstring.\"",
    "output": "* @precision medium"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/asymmetric-key-generation]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别代码库中所有通过受支持的加密库生成的非对称密钥。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 已知非对称密钥源生成\n * @description 识别代码库中所有通过受支持的加密库生成的非对称密钥。\n *              此查询追踪密钥生成操作及其配置源，有助于评估系统对量子计算威胁的抵御能力。\n * @kind problem\n * @id py/quantum-readiness/cbom/asymmetric-key-generation\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找所有非对称密钥生成操作及其关联的配置源\nfrom AsymmetricKeyGen keyGenOp, DataFlow::Node configSrc\nwhere \n  // 确保配置源与密钥生成操作相关联\n  keyGenOp.getKeyConfigSrc() = configSrc\nselect \n  keyGenOp,\n  // 构建描述性消息，包含算法名称和配置源引用\n  \"使用算法 \" + keyGenOp.getAlgorithm().getName() + \" 的非对称密钥生成，密钥配置源 $@\", \n  configSrc, \n  configSrc.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Descriptor objects are shared across instances. Mutating them may cause unexpected side effects or race conditions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n_______________ // 补全条件\npredicate has_descriptor_mutation(ClassObject descriptorClass, SelfAttributeStore attributeMutation) {\n  // 验证目标类实现了描述符协议\n  descriptorClass.isDescriptorType() and\n  // 定位描述符协议方法及其调用链\n  exists(\n    PyFunctionObject descriptorMethod, string descriptorMethodName, \n    PyFunctionObject invokedMemberFunction\n  |\n    // 识别描述符协议方法 (__get__/__set__/__delete__)\n    descriptorClass.lookupAttribute(descriptorMethodName) = descriptorMethod and\n    (\n      descriptorMethodName = \"__get__\" or \n      descriptorMethodName = \"__set__\" or \n      descriptorMethodName = \"__delete__\"\n    ) and\n    // 查找被描述符方法调用的类成员函数\n    descriptorClass.lookupAttribute(_) = invokedMemberFunction and\n    // 排除初始化方法并验证调用关系\n    not invokedMemberFunction.getName() = \"__init__\" and\n    descriptorMethod.getACallee*() = invokedMemberFunction and\n    // 确认变异操作发生在被调用函数的作用域内\n    attributeMutation.getScope() = invokedMemberFunction.getFunction()\n  )\n}\n\n// 定位存在描述符变异的类及其操作\nfrom ClassObject descriptorClass, SelfAttributeStore attributeMutation\nwhere has_descriptor_mutation(descriptorClass, attributeMutation)\n// 输出变异操作位置、警告信息、相关类及其名称\nselect attributeMutation,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorClass, descriptorClass.getName()",
    "output": "// 检测描述符类中的变异操作"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/tarslip]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies directory traversal vulnerabilities in tar extraction where",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description Identifies directory traversal vulnerabilities in tar extraction where\n *              untrusted archive contents could overwrite files outside the target directory.\n * @kind path-problem\n * @id py/tarslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\n// Detect vulnerable extraction flows from untrusted sources to extraction sinks\nfrom TarSlipFlow::PathNode untrustedSrc, TarSlipFlow::PathNode vulnerableSink\nwhere \n  // Ensure data flow path exists between untrusted source and extraction sink\n  TarSlipFlow::flowPath(untrustedSrc, vulnerableSink)\nselect \n  vulnerableSink.getNode(), \n  untrustedSrc, \n  vulnerableSink, \n  \"This file extraction depends on a $@.\", \n  untrustedSrc.getNode(),\n  \"potentially untrusted source\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Invalid caret placement in regex pattern\n * @description Detects regular expressions with a caret symbol '^' \n *              in non-starting positions, rendering the pattern unmatchable.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/regex/unmatchable-caret\n */\n\nimport python\nimport semmle.python.regex\n\n// Define regex pattern and caret position variables\nfrom RegExp regex, int caretPos\n// Validate problematic caret placement conditions\nwhere \n  // Exclude multi-line mode where caret has line-start semantics\n  not regex.getAMode() = \"MULTILINE\" and\n  // Exclude verbose mode where whitespace/comments alter parsing\n  not regex.getAMode() = \"VERBOSE\" and\n  // Identify caret symbol occurrence at specific position\n_______________ // 补全条件\n  // Verify caret is not at pattern start position\n  not regex.firstItem(caretPos, caretPos + 1)\n// Output regex pattern with diagnostic message\nselect regex,\n  \"Unmatchable caret found at offset \" + caretPos.toString() + \" in this regular expression.\"",
    "output": "regex.specialCharacter(caretPos, caretPos + 1, \"^\") and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode IV or nonce\n * @description Detects vulnerable initialization vector (IV) or nonce usage in block cipher operations.\n *              This query identifies cases where IVs/nonces are either missing or not generated\n *              using cryptographically secure methods like os.urandom.\n *              \n *              Fernet encryption is excluded from this check as it manages IV generation internally.\n *              Complex cryptographic patterns may require manual verification by security experts.\n *\n *            NOTE: This query flags any IV/nonce that doesn't originate from os.urandom or has\n *                  an unclear source. Sophisticated nonce usage patterns (e.g., in GCM mode)\n *                  should be reviewed manually. Functions that infer both mode and IV might\n *                  generate false positives - these can be suppressed as needed.\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify block cipher modes with weak IV/nonce configurations\nfrom BlockMode cipherMode, string diagnosticMsg, DataFlow::Node sourceNode\nwhere\n  // Exclude Fernet as it handles IV generation internally with os.urandom\n  not cipherMode instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet and\n  (\n    // Check for either missing IV/nonce OR IV/nonce not from os.urandom\n    not cipherMode.hasIVorNonce() or\n    not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = cipherMode.getIVorNonce()\n  ) and\n  // Determine diagnostic details based on IV/nonce presence\n  (\n    // Case 1: IV/nonce is missing\n    if not cipherMode.hasIVorNonce()\n_______________ // 补全条件\n      sourceNode = cipherMode and \n      diagnosticMsg = \"Block mode is missing IV/Nonce initialization.\"\n    )\n    // Case 2: IV/nonce is present but from insecure source\n    else (\n      sourceNode = cipherMode.getIVorNonce() and\n      diagnosticMsg = \"Block mode is not using an accepted IV/Nonce initialization: $@\"\n    )\n  )\nselect cipherMode, diagnosticMsg, sourceNode, sourceNode.toString()",
    "output": "then ("
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class inheritance hierarchy inference failure\n * @description Detects classes for which the inheritance hierarchy cannot be inferred,\n *              which may negatively impact the analysis accuracy.\n * @id py/failed-inheritance-inference\n * @kind problem\n * @problem.severity info\n * @tags debug\n */\n\nimport python\n\n// 查找所有继承层次结构推断失败的类及其失败原因\n_______________ // 补全条件\nwhere exists(ClassObject classObj | \n    classObj.getPyClass() = targetClass and \n    classObj.failedInference(failureReason))\nselect targetClass, \"Inference of class hierarchy failed for class '\" + targetClass.getName() + \"': \" + failureReason + \".\"",
    "output": "from Class targetClass, string failureReason"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Should use a 'with' statement\n * @description Identifies try-finally blocks that exclusively close context manager resources.\n *              These patterns should be replaced with 'with' statements for improved code clarity\n *              and automatic resource management.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n_______________ // 补全条件\n * @id py/should-use-with\n */\n\nimport python\n\n// Determines if a function call invokes the 'close' method\npredicate isCloseMethodCall(Call closeCall) { \n    exists(Attribute attr | \n        closeCall.getFunc() = attr and \n        attr.getName() = \"close\"\n    ) \n}\n\n// Checks if a try statement's finally block contains only a single close call\npredicate hasOnlyCloseInFinally(Try tryStmt, Call closeCall) {\n    exists(ExprStmt stmt |\n        tryStmt.getAFinalstmt() = stmt and \n        stmt.getValue() = closeCall and \n        strictcount(tryStmt.getAFinalstmt()) = 1\n    )\n}\n\n// Verifies if a control flow node references a context manager instance\npredicate referencesContextManager(ControlFlowNode flowNode, ClassValue managerType) {\n    forex(Value value | flowNode.pointsTo(value) | \n        value.getClass() = managerType\n    ) and\n    managerType.isContextManager()\n}\n\n// Identifies try-finally blocks that only close context managers\nfrom Call closeCall, Try tryStmt, ClassValue managerType, ControlFlowNode objectNode\nwhere\n    hasOnlyCloseInFinally(tryStmt, closeCall) and\n    isCloseMethodCall(closeCall) and\n    objectNode = closeCall.getFunc().getAFlowNode().(AttrNode).getObject() and\n    referencesContextManager(objectNode, managerType)\nselect closeCall,\n    \"Instance of context-manager class $@ is closed in a finally block. Consider using 'with' statement.\",\n    managerType, managerType.getName()",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during a tarball extraction from a user controlled source\n * @description 在解压用户控制的tar文件时，若未验证目标路径是否在目标目录内，\n *             可能导致目录遍历攻击。此漏洞常见于tar文件源自不受信任位置\n *             （如远程服务器或用户输入参数）的场景。\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// 定义数据流路径的起点和终点\nfrom UnsafeUnpackFlow::PathNode untrustedSource, \n_______________ // 补全条件\nwhere \n  // 检测是否存在从不受信任源到危险解包操作的数据流\n  UnsafeUnpackFlow::flowPath(untrustedSource, dangerousExtractionSink)\nselect \n  dangerousExtractionSink.getNode(), \n  untrustedSource, \n  dangerousExtractionSink,\n  \"危险解包操作：从不信任的远程位置获取的恶意tar文件可能导致目录遍历攻击\"",
    "output": "UnsafeUnpackFlow::PathNode dangerousExtractionSink"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/explicit-call-to-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The special method `__del__` is intended to be invoked by the Python runtime during garbage collection. Explicitly calling this method can lead to unexpected behavior and should be avoided.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Explicit invocation of `__del__` method\n * @description The special method `__del__` is intended to be invoked by the Python runtime during garbage collection. Explicitly calling this method can lead to unexpected behavior and should be avoided.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/explicit-call-to-delete\n */\n\nimport python\n\nclass ExplicitDelCall extends Call {\n  ExplicitDelCall() {\n    // Verify the target is an attribute access with name \"__del__\"\n    exists(Attribute attr | attr = this.getFunc() and attr.getName() = \"__del__\")\n  }\n\n  predicate isSuperInvocation() {\n    // Check if call occurs within a __del__ method\n    exists(Function delMethod | \n      delMethod = this.getScope() and \n      delMethod.getName() = \"__del__\" |\n      // Case 1: Direct self invocation (e.g., self.__del__())\n      delMethod.getArg(0).asName().getVariable() = this.getArg(0).(Name).getVariable()\n      or\n      // Case 2: Super invocation (e.g., super().__del__() or super(Class, self).__del__())\n      exists(Call superCall | \n        superCall = this.getFunc().(Attribute).getObject() and\n        superCall.getFunc().(Name).getId() = \"super\"\n      )\n    )\n  }\n}\n\nfrom ExplicitDelCall explicitInvocation\nwhere not explicitInvocation.isSuperInvocation()\nselect explicitInvocation, \"The __del__ special method is called explicitly.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inconsistent-mro]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent method resolution order\n * @description Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n// 检测目标类是否存在无效方法解析顺序(MRO)\n// 无效MRO发生在继承链中，右侧基类的不当超类型出现在其左侧位置\npredicate hasInvalidMRO(ClassObject targetClass, ClassObject precedingBase, ClassObject followingBase) {\n  // 验证目标类采用新式类定义\n  targetClass.isNewStyle() and\n  \n  // 定位继承列表中相邻的基类对\n  exists(int index | \n    index > 0 and \n    // 获取右侧基类及其直接左侧基类\n    followingBase = targetClass.getBaseType(index) and \n    precedingBase = targetClass.getBaseType(index - 1)\n  ) and\n  \n  // 确认左侧基类是右侧基类的不当超类型\n  precedingBase = followingBase.getAnImproperSuperType()\n}\n\n// 识别所有具有无效方法解析顺序的类，并提供详细诊断信息\nfrom ClassObject targetClass, ClassObject precedingBase, ClassObject followingBase\nwhere hasInvalidMRO(targetClass, precedingBase, followingBase)\nselect targetClass,\n  \"Construction of class \" + targetClass.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", precedingBase,\n  precedingBase.getName(), followingBase, followingBase.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Nested loops with same variable reused after inner loop body\n * @description Redefining a variable in an inner loop and then using\n *              the variable in an outer loop causes unexpected behavior.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/nested-loops-with-same-variable-reused\n */\n\nimport python\n\n// 定义一个谓词，用于判断变量是否在循环中被重新定义\npredicate loop_variable_ssa(For f, Variable v, SsaVariable s) {\n  // 检查循环的目标节点是否与SSA变量的定义节点相同，并且变量v等于SSA变量的变量\n  f.getTarget().getAFlowNode() = s.getDefinition() and v = s.getVariable()\n}\n\n// 定义一个谓词，用于判断变量是否在嵌套循环中使用\npredicate variableUsedInNestedLoops(For inner, For outer, Variable v, Name n) {\n  /* 忽略没有使用变量的情况或仅在内层循环中使用的情况。 */\n  outer.contains(n) and\n  not inner.contains(n) and\n  /* 只处理在循环体中的内层循环。忽略else子句中的循环。 */\n  outer.getBody().contains(inner) and\n  exists(SsaVariable s |\n    // 检查内层循环和外层循环中变量的SSA定义\n    loop_variable_ssa(inner, v, s.getAnUltimateDefinition()) and\n    loop_variable_ssa(outer, v, _) and\n    // 检查变量的使用节点是否为给定的名称节点\n    s.getAUse().getNode() = n\n  )\n}\n\n// 查询语句，选择满足条件的内层循环、变量名、使用节点以及外层循环\n_______________ // 补全条件\nwhere variableUsedInNestedLoops(inner, outer, v, n)\nselect inner, \"Nested for statement $@ loop variable '\" + v.getId() + \"' of enclosing $@.\", n,\n  \"uses\", outer, \"for statement\"",
    "output": "from For inner, For outer, Variable v, Name n"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes with lowercase initial letters, which violates naming conventions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed class\n * @description Identifies classes with lowercase initial letters, which violates naming conventions\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-class\n * @tags maintainability\n */\n\nimport python\n\n// Identify classes violating naming conventions\nfrom Class targetClass\nwhere\n  // Only consider classes present in source code\n  targetClass.inSource() and\n  // Check if class name starts with lowercase letter\n  exists(string initialChar |\n    initialChar = targetClass.getName().prefix(1) and\n    not initialChar = initialChar.toUpperCase()\n  ) and\n  // Ensure this is the only misnamed class in its file\n  not exists(Class otherClass |\n    otherClass != targetClass and\n    otherClass.getLocation().getFile() = targetClass.getLocation().getFile() and\n    // Verify other class also violates naming convention\n    exists(string otherInitialChar |\n      otherInitialChar = otherClass.getName().prefix(1) and\n      not otherInitialChar = otherInitialChar.toUpperCase()\n    )\n  )\nselect targetClass, \"Class names should start in uppercase.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Assert statement tests the truth value of a literal constant\n * @description An assert statement testing a literal constant value may exhibit\n *              different behavior when optimizations are enabled.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/assert-literal-constant\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom Assert assertStmt, string literalValue\nwhere\n  // Filter out assertions within test scopes to prevent false positives\n  not assertStmt.getScope().getScope*() instanceof TestScope and\n_______________ // 补全条件\n  exists(Expr assertExpr | \n    assertExpr = assertStmt.getTest() and (\n      // Process integer literal constants\n      literalValue = assertExpr.(IntegerLiteral).getN() or\n      // Process string literal constants with escaped quotes\n      literalValue = \"\\\"\" + assertExpr.(StringLiteral).getS() + \"\\\"\" or\n      // Process name constants (None, True, False)\n      literalValue = assertExpr.(NameConstant).toString()\n    )\n  ) and\n  // Exclude assertions that appear at the end of elif chains\n  not exists(If conditionalStmt | \n    conditionalStmt.getElif().getAnOrelse() = assertStmt\n  )\nselect assertStmt, \"Assert of literal constant \" + literalValue + \".\"",
    "output": "// Identify literal constant expressions used in assertion tests"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/slots-in-old-style-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects old-style classes declaring `__slots__`, which creates a regular",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__slots__` in old-style class\n * @description Detects old-style classes declaring `__slots__`, which creates a regular \n *              class attribute instead of overriding the class dictionary as intended.\n *              This feature is unsupported in old-style classes.\n * @kind problem\n * @problem.severity error\n * @tags portability\n *       correctness\n * @sub-severity low\n * @precision very-high\n * @id py/slots-in-old-style-class\n */\n\nimport python\n\nfrom ClassObject oldStyleClass\nwhere\n  // Validate class inference integrity\n  not oldStyleClass.failedInference()\n  // Identify non-new-style classes\n  and not oldStyleClass.isNewStyle()\n  // Check for explicit `__slots__` declaration\n  and oldStyleClass.declaresAttribute(\"__slots__\")\nselect oldStyleClass, \n  \"Using '__slots__' in an old style class just creates a class attribute called '__slots__'.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import CodeQL alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing module\nprivate import semmle.python.Comment as P\n\n// Represents AST nodes equipped with location tracking capabilities\nclass AstNode instanceof P::AstNode {\n  // Verify node matches specified location coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n_______________ // 补全条件\n\n  // Provide string representation of the AST node\n  string toString() { result = super.toString() }\n}\n\n// Represents single-line comments with location tracking\nclass SingleLineComment instanceof P::Comment {\n  // Verify comment matches specified location coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Retrieve textual content of the comment\n  string getText() { result = super.getContents() }\n\n  // Provide string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships using AS template\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Represents noqa-style suppression comments\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Initialize by identifying noqa comment pattern\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Return suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define code coverage scope for this suppression\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Extract and validate location details from comment\n    exists(int commentStart, int commentEnd, int commentEndColumn |\n      this.hasLocationInfo(filePath, commentStart, _, commentEnd, commentEndColumn) and\n      // Enforce line-start position and match boundaries\n      startLine = commentStart and\n      endLine = commentEnd and\n      startCol = 1 and\n      endCol = commentEndColumn\n    )\n  }\n}",
    "output": "}"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Iterable can be either a string or a sequence\n * @description Detects loops that iterate over both string and sequence types, \n * which can cause hard-to-diagnose runtime errors due to inconsistent iteration behavior\n * @kind problem\n * @tags reliability\n *       maintainability\n *       non-local\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iteration-string-and-sequence\n */\n\nimport python\nimport semmle.python.filters.Tests\n\n// Identifies string types (str or Python 2 unicode)\npredicate is_string_type(Value value) {\n  value.getClass() = ClassValue::str() \n  or \n  value.getClass() = ClassValue::unicode() and major_version() = 2\n}\n\nfrom \n  For loop, \n  ControlFlowNode iterNode, \n  Value strValue, \n  Value seqValue, \n  ControlFlowNode seqOrigin,\n  ControlFlowNode strOrigin\nwhere \n  // Connect loop iterator to both string and sequence values\n  loop.getIter().getAFlowNode() = iterNode and\n  iterNode.pointsTo(strValue, strOrigin) and\n  iterNode.pointsTo(seqValue, seqOrigin) and\n  \n  // Type validation: string and non-string iterable\n  is_string_type(strValue) and\n  seqValue.getClass().isIterable() and\n_______________ // 补全条件\n  \n  // Exclude test-related code paths\n  not seqOrigin.getScope().getScope*() instanceof TestScope and\n  not strOrigin.getScope().getScope*() instanceof TestScope\nselect loop,\n  \"Iteration over $@, of class \" + seqValue.getClass().getName() + \n  \", may also iterate over $@.\",\n  seqOrigin, \"sequence\", strOrigin, \"string\"",
    "output": "not is_string_type(seqValue) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/multiple-imports-on-line]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Defining multiple imports on one line makes code more difficult to read;",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Multiple imports on one line\n * @description Defining multiple imports on one line makes code more difficult to read;\n *              PEP8 states that imports should usually be on separate lines.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/multiple-imports-on-line\n */\n\n/*\n * Look for imports of the form:\n * import modA, modB\n * (Imports should be one per line according PEP 8)\n */\n\n// 导入Python库，用于处理Python代码的解析和分析\nimport python\n\n// 定义一个谓词函数，用于判断是否为多模块导入\npredicate multiple_import(Import imp) { \n    // 获取导入语句中的模块名称列表，并检查其数量是否大于1\n    count(imp.getAName()) > 1 and \n    // 确保该导入语句不是从某个模块中导入特定名称的形式\n    not imp.isFromImport() \n}\n\n// 从所有导入语句中查找符合multiple_import条件的导入语句\nfrom Import i\nwhere multiple_import(i)\nselect i, \"Multiple imports on one line.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-star-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies wildcard imports that cause namespace pollution and reduce code clarity",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Wildcard import usage detected\n * @description Identifies wildcard imports that cause namespace pollution and reduce code clarity\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// Enable Python code analysis capabilities through the Python module\nimport python\n\n// Locate all wildcard import statements in the codebase\n// These imports introduce all names from a module into the current namespace\nfrom ImportStar starImport\n// Report detected wildcard imports with explanatory warning\n// The warning highlights namespace pollution risks and maintainability concerns\nselect starImport, \"Wildcard import 'from ... import *' pollutes namespace and reduces code clarity\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/afferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the afferent coupling metric for each class, which counts the number of classes that depend on it.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class Afferent Coupling Analysis\n * @description Calculates the afferent coupling metric for each class, which counts the number of classes that depend on it.\n *              High afferent coupling suggests a class is a central component, making it harder to change without\n *              impacting many parts of the system. This metric is vital for evaluating modularity.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\nfrom ClassMetrics targetClass\nwhere exists(targetClass.getAfferentCoupling())\nselect \n  targetClass,\n  targetClass.getAfferentCoupling() as afferentCouplingCount\norder by afferentCouplingCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/improper-ldap-auth]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies LDAP bind operations lacking proper authentication mechanisms",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Improper LDAP Authentication\n * @description Identifies LDAP bind operations lacking proper authentication mechanisms\n * @kind problem\n * @problem.severity warning\n * @id py/improper-ldap-auth\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\n\n/**\n * Detects LDAP bind operations with authentication deficiencies:\n * - Absence of password parameter\n * - Explicitly set to None value\n * - Configured with empty string\n */\npredicate hasImproperAuthentication(LdapBind ldapBind) {\n  // Scenario 1: Password parameter not provided\n  not exists(ldapBind.getPassword())\n  or\n  // Scenario 2: Password explicitly assigned None\n  exists(None noneValue |\n    DataFlow::localFlow(DataFlow::exprNode(noneValue), ldapBind.getPassword())\n  )\n  or\n  // Scenario 3: Password configured as empty string\n  exists(StringLiteral emptyStr |\n    emptyStr.getText() = \"\" and\n    DataFlow::localFlow(DataFlow::exprNode(emptyStr), ldapBind.getPassword())\n  )\n}\n\nfrom LdapBind ldapBind\nwhere hasImproperAuthentication(ldapBind)\nselect ldapBind, \"The following LDAP bind operation is executed without authentication.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raise-not-implemented]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies incorrect usage of 'NotImplemented' in raise statements.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name NotImplemented is not an Exception\n * @description Identifies incorrect usage of 'NotImplemented' in raise statements.\n *              'NotImplemented' is a constant value, not an exception class, and should not be raised.\n *              This can lead to runtime type errors. The correct exception to use is 'NotImplementedError'.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\nimport python\nimport Exceptions.NotImplemented\n\n// Identify expressions where NotImplemented is used in raise statements\nfrom Expr problematicNotImplementedUsage\n// Filter cases where NotImplemented appears in raise contexts\nwhere use_of_not_implemented_in_raise(_, problematicNotImplementedUsage)\n// Report the problematic expression with remediation guidance\nselect problematicNotImplementedUsage, \"NotImplemented is not an Exception. Use NotImplementedError instead.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Hashing of non-hashable object\n * @description Attempting to hash an object that is not hashable leads to a TypeError during execution.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/hash-unhashable-value\n */\n\nimport python\n\n/*\n * This analysis assumes that any indexing operation where the value is not a sequence or numpy array involves hashing.\n * For sequences, the index must be an int (which are hashable), so they don't require special handling.\n * For numpy arrays, the index may be a list (which are not hashable) and needs special treatment.\n */\n\n// Identifies numpy array types through inheritance from numpy.ndarray\npredicate numpy_array_type(ClassValue arrType) {\n  exists(ModuleValue numpyModule | \n    numpyModule.getName() = \"numpy\" or numpyModule.getName() = \"numpy.core\" |\n    arrType.getASuperType() = numpyModule.attr(\"ndarray\")\n  )\n}\n\n// Checks if a value implements custom __getitem__ behavior\npredicate has_custom_getitem(Value obj) {\n  obj.getClass().lookup(\"__getitem__\") instanceof PythonFunctionValue\n  or\n  numpy_array_type(obj.getClass())\n}\n\n// Detects explicit hash() function calls\npredicate explicitly_hashed(ControlFlowNode nodeToHash) {\n  exists(CallNode hashCall, GlobalVariable hashVar |\n    hashCall.getArg(0) = nodeToHash and \n    hashCall.getFunction().(NameNode).uses(hashVar) and \n    hashVar.getId() = \"hash\"\n  )\n}\n\n// Determines if an object is unhashable by examining its __hash__ attribute\n_______________ // 补全条件\n  exists(Value val | \n    nodeToCheck.pointsTo(val, originNode) and \n    val.getClass() = unhashableCls |\n    (\n      not unhashableCls.hasAttribute(\"__hash__\") and \n      not unhashableCls.failedInference(_) and \n      unhashableCls.isNewStyle()\n    )\n    or\n    unhashableCls.lookup(\"__hash__\") = Value::named(\"None\")\n  )\n}\n\n// Identifies subscript operations using unhashable indices\npredicate unhashable_subscript(ControlFlowNode indexNode, ClassValue unhashableCls, ControlFlowNode originNode) {\n  is_unhashable(indexNode, unhashableCls, originNode) and\n  exists(SubscriptNode subscript | \n    subscript.getIndex() = indexNode |\n    exists(Value targetValue |\n      subscript.getObject().pointsTo(targetValue) and\n      not has_custom_getitem(targetValue)\n    )\n  )\n}\n\n/**\n * Holds if `nodeInTry` is within a try block that catches TypeError. For example:\n *\n *    try:\n *       ... nodeInTry ...\n *    except TypeError:\n *       ...\n *\n * This predicate reduces false positives by identifying proper exception handling\n * for unhashable operations that would otherwise raise TypeError.\n */\n// Checks if a node is protected by a TypeError handler\npredicate typeerror_is_caught(ControlFlowNode nodeInTry) {\n  exists(Try tryBlock |\n    tryBlock.getBody().contains(nodeInTry.getNode()) and\n    tryBlock.getAHandler().getType().pointsTo(ClassValue::typeError())\n  )\n}\n\n// Detects unhandled unhashable operations in hashing or subscript contexts\nfrom ControlFlowNode issueNode, ClassValue issueType, ControlFlowNode sourceNode\nwhere\n  not typeerror_is_caught(issueNode) and\n  (\n    explicitly_hashed(issueNode) and is_unhashable(issueNode, issueType, sourceNode)\n    or\n    unhashable_subscript(issueNode, issueType, sourceNode)\n  )\nselect issueNode.getNode(), \"This $@ of $@ is unhashable.\", sourceNode, \"instance\", issueType, issueType.getQualifiedName()",
    "output": "predicate is_unhashable(ControlFlowNode nodeToCheck, ClassValue unhashableCls, ControlFlowNode originNode) {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raises-tuple]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Raising a tuple will result in all but the first element being discarded",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Raising a tuple\n * @description Raising a tuple will result in all but the first element being discarded\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// Identify raise statements where the exception originates from a tuple\nfrom Raise raiseStmt, DataFlow::LocalSourceNode tupleExprSource\nwhere\n  // Only applicable in Python 2 (Python 3 handles this as a type error)\n  major_version() = 2 and\n  // The source node must be a tuple expression\n  tupleExprSource.asExpr() instanceof Tuple and\n  // Verify data flow from tuple to the exception being raised\n  exists(DataFlow::Node exceptionExprNode |\n    exceptionExprNode.asExpr() = raiseStmt.getException() and\n    tupleExprSource.flowsTo(exceptionExprNode)\n  )\n/* Raising a tuple is a type error in Python 3, so is handled by the IllegalRaise query. */\nselect raiseStmt,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleExprSource, \"tuple\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Commented-out code\n * @description Commented-out code makes the remaining code more difficult to read.\n * @kind problem\n_______________ // 补全条件\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code\n */\n\n// Import the Python language library\nimport python\n\n// Import the CommentedOutCode class from the Lexical module\nimport Lexical.CommentedOutCode\n\n// Define the source of commented-out code blocks\nfrom CommentedOutCodeBlock commentedBlock\n\n// Filter out blocks that might be example code\nwhere not commentedBlock.maybeExampleCode()\n\n// Select the remaining blocks with an appropriate message\nselect commentedBlock, \"This comment appears to contain commented-out code.\"",
    "output": "* @tags maintainability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-exception in 'except' clause\n * @description Identifies exception handlers that use non-exception types,\n *              making them ineffective for catching actual exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Variables for analyzing exception handling constructs\nfrom ExceptFlowNode exceptionHandler, Value caughtType, ClassValue exceptionBase, \n     ControlFlowNode sourceNode, string typeInfo\nwhere\n  // Ensure the handler processes a specific exception type from the source\n  exceptionHandler.handledException(caughtType, exceptionBase, sourceNode) and\n_______________ // 补全条件\n    // First scenario: Type is a class but not a valid exception\n    exists(ClassValue invalidExceptionType | \n      invalidExceptionType = caughtType and\n      not invalidExceptionType.isLegalExceptionType() and\n      not invalidExceptionType.failedInference(_) and\n      typeInfo = \"class '\" + invalidExceptionType.getName() + \"'\"\n    )\n    or\n    // Second scenario: Type is not a class value\n    not caughtType instanceof ClassValue and\n    typeInfo = \"instance of '\" + exceptionBase.getName() + \"'\"\n  )\nselect exceptionHandler.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  sourceNode, typeInfo",
    "output": "("
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/useless-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：An exception handler specifying a non-exception type will never handle any exception.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-exception in 'except' clause\n * @description An exception handler specifying a non-exception type will never handle any exception.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Select exception handling nodes with invalid exception types\nfrom ExceptFlowNode exceptNode, Value handledType, ClassValue exceptionClass, ControlFlowNode sourceNode, string description\nwhere\n  // Identify handled exception and its origin\n  exceptNode.handledException(handledType, exceptionClass, sourceNode) and\n  (\n    // Case 1: Handled type is a class that isn't a valid exception\n    exists(ClassValue invalidClass | invalidClass = handledType |\n      not invalidClass.isLegalExceptionType() and\n      not invalidClass.failedInference(_) and\n      description = \"class '\" + invalidClass.getName() + \"'\"\n    )\n    or\n    // Case 2: Handled type is an instance (not a class)\n    not handledType instanceof ClassValue and\n    description = \"instance of '\" + exceptionClass.getName() + \"'\"\n  )\nselect exceptNode.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", sourceNode, description"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Duplicate key in dict literal\n * @description Identifies dictionary literals containing duplicate keys, where earlier key-value pairs are silently overwritten by later ones.\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/duplicate-key-dict-literal\n */\n\nimport python\nimport semmle.python.strings\n\n/**\n * Converts dictionary keys to a normalized string format for comparison.\n * Handles numeric literals and string literals (including byte and unicode strings).\n */\npredicate normalizedKeyFormat(Dict dictLiteral, Expr key, string normalizedValue) {\n  key = dictLiteral.getAKey() and\n_______________ // 补全条件\n    // Numeric keys: convert directly to string representation\n    normalizedValue = key.(Num).getN()\n    or\n    // String literals: add type prefix and validate content\n    not \"�\" = normalizedValue.charAt(_) and\n    exists(StringLiteral str | \n      str = key and\n      (\n        // Unicode strings: prefix with 'u'\n        normalizedValue = \"u\\\"\" + str.getText() + \"\\\"\" and str.isUnicode()\n        or\n        // Byte strings: prefix with 'b'\n        normalizedValue = \"b\\\"\" + str.getText() + \"\\\"\" and not str.isUnicode()\n      )\n    )\n  )\n}\n\n// Find dictionary literals with duplicate keys\nfrom Dict dictLiteral, Expr originalKey, Expr duplicateKey\nwhere\n  // Both keys have identical normalized representations\n  exists(string normalizedValue | \n    normalizedKeyFormat(dictLiteral, originalKey, normalizedValue) and \n    normalizedKeyFormat(dictLiteral, duplicateKey, normalizedValue) and \n    originalKey != duplicateKey\n  ) and\n  // Verify the ordering relationship between keys\n  (\n    // Case 1: Keys in same basic block with originalKey before duplicateKey\n    exists(BasicBlock block, int originalPos, int duplicatePos |\n      originalKey.getAFlowNode() = block.getNode(originalPos) and\n      duplicateKey.getAFlowNode() = block.getNode(duplicatePos) and\n      originalPos < duplicatePos\n    )\n    or\n    // Case 2: Original key's block strictly dominates duplicate key's block\n    originalKey.getAFlowNode().getBasicBlock().strictlyDominates(\n      duplicateKey.getAFlowNode().getBasicBlock()\n    )\n  )\n\n// Report the first occurrence of the duplicate key and indicate which later key overwrites it\nselect originalKey, \n       \"Dictionary key \" + repr(originalKey) + \" is subsequently $@.\", \n       duplicateKey, \n       \"overwritten\"",
    "output": "("
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides statistics on different kinds of type annotations in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Provides statistics on different kinds of type annotations in Python code.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents built-in types in Python.\nclass CoreType extends Name {\n  // Constructor that checks if the current instance is one of the core types.\n  CoreType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Defines a new type TTypeAnnotated that can be one of three cases:\nnewtype TTypeAnnotated =\n  TFuncWithReturn(FunctionExpr function) { exists(function.getReturns()) } or // Function expressions with return type\n  TParamWithAnnotation(Parameter parameter) { exists(parameter.getAnnotation()) } or // Parameters with annotations\n  TAssignWithAnnotation(AnnAssign assignment) { exists(assignment.getAnnotation()) } // Assignment statements with annotations\n\n// Abstract class TypeAnnotated, inheriting from TTypeAnnotated, representing elements that can have type annotations.\nabstract class TypeAnnotated extends TTypeAnnotated {\n  // Converts the object to its string representation.\n  string toString() { result = \"TypeAnnotated\" }\n\n  // Abstract method to get the annotation expression.\n  abstract Expr getAnnotation();\n}\n\n// Class FuncWithReturn, inheriting from TFuncWithReturn and TypeAnnotated, representing functions with return type annotations.\nclass FuncWithReturn extends TFuncWithReturn, TypeAnnotated {\n  FunctionExpr function; // Function expression\n\n  // Constructor that initializes the function attribute.\n  FuncWithReturn() { this = TFuncWithReturn(function) }\n\n  // Overrides getAnnotation method to return the function's return type annotation.\n  override Expr getAnnotation() { result = function.getReturns() }\n}\n\n// Class ParamWithAnnotation, inheriting from TParamWithAnnotation and TypeAnnotated, representing parameters with annotations.\nclass ParamWithAnnotation extends TParamWithAnnotation, TypeAnnotated {\n  Parameter parameter; // Parameter\n\n  // Constructor that initializes the parameter attribute.\n  ParamWithAnnotation() { this = TParamWithAnnotation(parameter) }\n\n  // Overrides getAnnotation method to return the parameter's annotation.\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\n// Class AssignWithAnnotation, inheriting from TAssignWithAnnotation and TypeAnnotated, representing assignment statements with annotations.\nclass AssignWithAnnotation extends TAssignWithAnnotation, TypeAnnotated {\n  AnnAssign assignment; // Assignment statement\n\n  // Constructor that initializes the assignment attribute.\n  AssignWithAnnotation() { this = TAssignWithAnnotation(assignment) }\n\n  // Overrides getAnnotation method to return the assignment's annotation.\n  override Expr getAnnotation() { result = assignment.getAnnotation() }\n}\n\n/** True if `expr` is a string literal used as a forward declaration of a type. */\npredicate is_forward_decl(Expr expr) { expr instanceof StringLiteral }\n\n/** True if `expr` represents a type that is complex to analyze. */\npredicate is_complicated_type(Expr expr) {\n  expr instanceof Subscript and not is_optional(expr) // If expr is a subscript but not an optional type\n  or\n  expr instanceof Tuple // If expr is a tuple type\n  or\n  expr instanceof List // If expr is a list type\n}\n\n/** True if `expr` is a type of the form `Optional[...]`. */\npredicate is_optional(Subscript expr) { expr.getObject().(Name).getId() = \"Optional\" }\n\n/** True if `expr` is a simple type, i.e., an identifier (excluding core types) or an attribute of a simple type. */\npredicate is_basic_type(Expr expr) {\n  expr instanceof Name and not expr instanceof CoreType // If expr is a name but not a core type\n  or\n  is_basic_type(expr.(Attribute).getObject()) // If expr is an attribute and its object is a basic type\n}\n\n/** True if `expr` is a core type. */\npredicate is_core_type(Expr expr) { expr instanceof CoreType }\n\n// Predicate to calculate counts of different types of annotations.\npredicate annotation_metrics(\n  string category, int overall, int core_count, int forward_count, int basic_count,\n  int complicated_count, int optional_count\n) {\n  // For parameter annotations\n  category = \"Parameter annotation\" and \n  overall = count(ParamWithAnnotation annotatedParam) and \n  core_count = count(ParamWithAnnotation annotatedParam | is_core_type(annotatedParam.getAnnotation())) and \n  forward_count = count(ParamWithAnnotation annotatedParam | is_forward_decl(annotatedParam.getAnnotation())) and \n  basic_count = count(ParamWithAnnotation annotatedParam | is_basic_type(annotatedParam.getAnnotation())) and \n  complicated_count = count(ParamWithAnnotation annotatedParam | is_complicated_type(annotatedParam.getAnnotation())) and \n  optional_count = count(ParamWithAnnotation annotatedParam | is_optional(annotatedParam.getAnnotation()))\n  or\n  // For return type annotations\n  category = \"Return type annotation\" and \n  overall = count(FuncWithReturn annotatedFunc) and \n  core_count = count(FuncWithReturn annotatedFunc | is_core_type(annotatedFunc.getAnnotation())) and \n  forward_count = count(FuncWithReturn annotatedFunc | is_forward_decl(annotatedFunc.getAnnotation())) and \n  basic_count = count(FuncWithReturn annotatedFunc | is_basic_type(annotatedFunc.getAnnotation())) and \n  complicated_count = count(FuncWithReturn annotatedFunc | is_complicated_type(annotatedFunc.getAnnotation())) and \n  optional_count = count(FuncWithReturn annotatedFunc | is_optional(annotatedFunc.getAnnotation()))\n  or\n  // For annotated assignments\n  category = \"Annotated assignment\" and \n  overall = count(AssignWithAnnotation annotatedAssign) and \n  core_count = count(AssignWithAnnotation annotatedAssign | is_core_type(annotatedAssign.getAnnotation())) and \n  forward_count = count(AssignWithAnnotation annotatedAssign | is_forward_decl(annotatedAssign.getAnnotation())) and \n  basic_count = count(AssignWithAnnotation annotatedAssign | is_basic_type(annotatedAssign.getAnnotation())) and \n  complicated_count = count(AssignWithAnnotation annotatedAssign | is_complicated_type(annotatedAssign.getAnnotation())) and \n  optional_count = count(AssignWithAnnotation annotatedAssign | is_optional(annotatedAssign.getAnnotation()))\n}\n\n// Query statement to select data from the database that satisfies the annotation_metrics predicate.\nfrom\n  string category, int overall, int core, int forward, int basic, int complicated, int optional\nwhere annotation_metrics(category, overall, core, forward, basic, complicated, optional)\nselect category, overall, core, forward, basic, complicated, optional"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/key-derivation]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of key derivation functions through supported",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Key Derivation Algorithms\n * @description Detects usage of key derivation functions through supported \n *              cryptographic libraries, highlighting potential quantum vulnerabilities.\n * @kind problem\n * @id py/quantum-readiness/cbom/key-derivation\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify cryptographic operations implementing key derivation\nfrom KeyDerivationOperation keyDerivationInstance\nwhere keyDerivationInstance.getAlgorithm() instanceof KeyDerivationAlgorithm\n// Generate alert with algorithm-specific vulnerability context\nselect keyDerivationInstance,\n  \"Key derivation function detected: \" + \n  keyDerivationInstance.getAlgorithm().(KeyDerivationAlgorithm).getKDFName() + \n  \" - This cryptographic operation may have quantum vulnerabilities\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Elliptic Curve Cryptography Detection\n * @description Identifies implementations of elliptic curve cryptographic algorithms in various libraries.\n *              Provides curve names and key sizes for evaluating quantum computing resistance.\n * @kind problem\n * @id py/quantum-readiness/cbom/elliptic-curve-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import fundamental Python language analysis capabilities\nimport python\n// Import cryptographic definitions and concepts for algorithm detection\nimport experimental.cryptography.Concepts\n\n// Define source of elliptic curve cryptographic implementations\nfrom EllipticCurveAlgorithm curveCryptoImpl\n\n// Extract curve name and bit size for each implementation\nselect curveCryptoImpl,\n_______________ // 补全条件\n  \" | Key Size (bits): \" + curveCryptoImpl.getCurveBitSize().toString()",
    "output": "\"Algorithm: \" + curveCryptoImpl.getCurveName() +"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python 2 不安全的 input 函数检测\n * @description 此查询识别 Python 2 代码中对 'input' 内置函数的危险使用。\n *              Python 2 中的 input 函数会执行用户输入的代码，导致潜在的代码注入漏洞。\n_______________ // 补全条件\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/use-of-input\n */\n\nimport python  // Python 代码静态分析核心库\nimport semmle.python.dataflow.new.DataFlow  // 数据流分析工具\nimport semmle.python.ApiGraphs  // API 调用图分析工具\n\n// 查找 Python 2 中不安全的 input 函数调用\nfrom DataFlow::CallCfgNode vulnerableInputCall\nwhere\n  // 确认是对 input 内置函数的调用\n  vulnerableInputCall = API::builtin(\"input\").getACall()\n  // 排除对更安全的 raw_input 函数的调用\n  and vulnerableInputCall != API::builtin(\"raw_input\").getACall()\n  // 限制为 Python 2 环境，因为 Python 3 中的 input 函数是安全的\n  and major_version() = 2\nselect vulnerableInputCall, \"在 Python 2 中使用了不安全的内置函数 'input'，可能导致代码注入攻击。\"",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Syntax error detection\n * @description Identifies Python syntax errors that may lead to runtime failures\n *              and impede static analysis. This query specifically filters out\n *              encoding-related issues to concentrate on genuine syntax problems.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import the Python module for source code analysis\nimport python\n\n// Identify syntax issues in Python code\nfrom SyntaxError syntaxProblem\n// Filter out encoding-related errors to focus on pure syntax problems\nwhere not syntaxProblem instanceof EncodingError\n// Display the syntax problem with its message and Python version info\nselect syntaxProblem, syntaxProblem.getMessage() + \" (in Python \" + major_version() + \").\"",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-commented-out-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Quantifies and presents the count of lines containing commented-out code for each Python file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lines of commented-out code in files\n * @description Quantifies and presents the count of lines containing commented-out code for each Python file.\n *              This metric excludes lines that are identified as potential example code to avoid false positives.\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// Import required modules for Python code analysis and commented code detection\nimport python\nimport Lexical.CommentedOutCode\n\n// Primary query to analyze commented code across Python files\nfrom File pythonFile, int commentedCodeLines\nwhere \n    // Compute the aggregate count of commented-out code lines for each file,\n    // filtering out lines that represent example code\n    commentedCodeLines = count(CommentedOutCodeLine codeLine | \n        // Exclude lines that are likely example code\n        not codeLine.maybeExampleCode() and \n        // Ensure the line belongs to the current file being analyzed\n        codeLine.getLocation().getFile() = pythonFile)\n// Generate output showing each Python file with its corresponding commented code line count,\n// ordered from highest to lowest to prioritize files needing attention\nselect pythonFile, commentedCodeLines order by commentedCodeLines desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/truncated-division]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：In Python 2, dividing two integers using '/' performs integer division,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Integer division result may be truncated in Python 2\n * @description In Python 2, dividing two integers using '/' performs integer division,\n *              truncating the fractional part. This query identifies such operations\n *              where truncation may not be intended.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// 识别Python 2中可能导致结果截断的整数除法操作\nfrom BinaryExpr divisionOperation, ControlFlowNode leftArgNode, ControlFlowNode rightArgNode\nwhere\n  // 仅在Python 2中存在此问题（Python 3已实现真除法）\n  major_version() = 2 and\n  exists(BinaryExprNode binaryNode, Value leftValue, Value rightValue |\n    binaryNode = divisionOperation.getAFlowNode() and\n    binaryNode.getNode().getOp() instanceof Div and // 确认是除法操作符\n    binaryNode.getLeft().pointsTo(leftValue, leftArgNode) and\n    leftValue.getClass() = ClassValue::int_() and // 左操作数为整数类型\n    binaryNode.getRight().pointsTo(rightValue, rightArgNode) and\n    rightValue.getClass() = ClassValue::int_() and // 右操作数为整数类型\n    \n    // 排除整除无余数的情况（不会导致截断）\n    not leftValue.(NumericValue).getIntValue() % rightValue.(NumericValue).getIntValue() = 0 and\n    \n    // 排除已启用真除法的模块（通过future导入）\n    not binaryNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // 排除结果被显式转换为整数的情况（表明开发者已知并接受截断）\n    not exists(CallNode intConversionCall |\n      intConversionCall = ClassValue::int_().getACall() and\n      intConversionCall.getAnArg() = binaryNode\n    )\n  )\nselect divisionOperation, \n  \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftArgNode, \"left\", rightArgNode, \"right\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * 识别特定类名和文件路径的类继承关系\n * 该查询用于定位目标类及其继承体系中的直接父类和子类\n */\n\nimport python\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n\n// 判断类是否为目标类的谓词\npredicate isTargetClass(Class cls) {\n  // 验证类名是否匹配目标名称\n  cls.getName() = \"YourClassName\"\n  // 可选：验证类是否位于特定文件路径\n  // and cls.getLocation().getFile().getAbsolutePath().matches(\"%/folder/file.py\")\n}\n\n// 查询目标类的直接父类（包括间接父类）\nquery predicate findSuperClasses(Class derivedClass, Class baseClass) {\n  isTargetClass(derivedClass) and\n  baseClass = getADirectSuperclass+(derivedClass)\n}\n\n// 查询目标类的直接子类（包括间接子类）\nquery predicate findSubClasses(Class baseClass, Class derivedClass) {\n  isTargetClass(baseClass) and\n  derivedClass = getADirectSubclass+(baseClass)\n}\n\n// 选择所有符合目标条件的类\nfrom Class clsOfInterest\nwhere isTargetClass(clsOfInterest)\nselect clsOfInterest"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-star-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python files containing wildcard imports ('from ... import *'),",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Wildcard Import Usage\n * @description Detects Python files containing wildcard imports ('from ... import *'),\n *              which can lead to namespace pollution and reduced code readability.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// Import necessary Python analysis components for code examination\nimport python\n\n// Identify all wildcard import statements in the codebase\nfrom ImportStar starImport\n// Report each instance of wildcard import with a descriptive message\nselect starImport, \"Usage of 'from ... import *' may introduce namespace pollution and negatively impact code maintainability.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Cookie construction with unvalidated user input\n * @description Detects when HTTP cookies are constructed using user-supplied input without proper validation,\n *              which could lead to Cookie Poisoning attacks where an attacker manipulates cookie values\n *              to bypass security controls, perform session fixation, or execute other malicious activities.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// Import base Python code analysis library\nimport python\n\n// Import specialized module for Cookie Injection security analysis\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Import data flow path visualization utilities\nimport CookieInjectionFlow::PathGraph\n\n// Define variables representing the start and end points of the data flow\nfrom CookieInjectionFlow::PathNode userInputNode, CookieInjectionFlow::PathNode cookieConstructionNode\n\n_______________ // 补全条件\nwhere CookieInjectionFlow::flowPath(userInputNode, cookieConstructionNode)\n\n// Output the detection results including the sink node, source node, path information,\n// and a security description highlighting the vulnerability\nselect cookieConstructionNode.getNode(), userInputNode, cookieConstructionNode, \n       \"Cookie is constructed from a $@.\", userInputNode.getNode(), \n       \"user-supplied input\"",
    "output": "// Check if there exists a data flow path from user input to cookie construction"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 指向关系图压缩效率评估\n * @description 此查询分析指向关系图的压缩效率，通过比较唯一事实数量与关系图总规模，\n *              计算不同上下文深度下的压缩效率百分比，评估数据压缩效果。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义查询输出变量：唯一事实数量、关系总规模、上下文深度和压缩效率\nfrom int uniqueFactsCount, int totalRelationsCount, int ctxDepth, float compressionEfficiency\nwhere\n  // 获取当前分析的上下文深度\n_______________ // 补全条件\n  (\n    // 计算唯一事实数量：统计不同的(控制流节点, 目标对象, 类类型)组合\n    uniqueFactsCount =\n      strictcount(ControlFlowNode controlNode, Object targetObject, ClassObject classType |\n        exists(PointsToContext ctx |\n          // 验证在指定上下文中，控制流节点指向目标对象，且该对象是类类型的实例\n          PointsTo::points_to(controlNode, ctx, targetObject, classType, _) and\n          ctx.getDepth() = ctxDepth\n        )\n      )\n  ) and\n  (\n    // 计算关系总规模：统计所有(控制流节点, 目标对象, 类类型, 上下文, 源控制流节点)组合\n    totalRelationsCount =\n      strictcount(ControlFlowNode controlNode, Object targetObject, ClassObject classType, \n        PointsToContext ctx, ControlFlowNode sourceControlNode |\n        // 验证在指定上下文中，控制流节点指向目标对象，且该对象是类类型的实例，并记录源控制流节点\n        PointsTo::points_to(controlNode, ctx, targetObject, classType, sourceControlNode) and\n        ctx.getDepth() = ctxDepth\n      )\n  ) and\n  (\n    // 计算压缩效率：唯一事实数量占关系总规模的百分比\n    compressionEfficiency = 100.0 * uniqueFactsCount / totalRelationsCount\n  )\n// 输出结果：上下文深度、唯一事实数量、关系总规模和压缩效率\nselect ctxDepth, uniqueFactsCount, totalRelationsCount, compressionEfficiency",
    "output": "exists(PointsToContext ctx | ctxDepth = ctx.getDepth()) and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 不可哈希对象被哈希\n * @description 对不可哈希的对象进行哈希操作会在运行时引发TypeError。\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/hash-unhashable-value\n */\n\nimport python\n\n/*\n * 本查询假设：任何索引操作中，如果索引值不是序列或numpy数组，则涉及哈希操作。\n * 对于序列，索引必须是整数（整数是可哈希的），因此不需要特殊处理。\n * 对于numpy数组，索引可能是列表（列表不可哈希），需要特殊处理。\n */\n\n// 检查类是否继承自numpy的ndarray类型\npredicate isNumpyArrayType(ClassValue numpyArrayClass) {\n  exists(ModuleValue numpyModule | \n    (numpyModule.getName() = \"numpy\" or numpyModule.getName() = \"numpy.core\") |\n    numpyArrayClass.getASuperType() = numpyModule.attr(\"ndarray\")\n  )\n}\n\n// 检查值是否具有自定义的__getitem__方法\npredicate hasCustomGetitem(Value targetValue) {\n  targetValue.getClass().lookup(\"__getitem__\") instanceof PythonFunctionValue\n  or\n  isNumpyArrayType(targetValue.getClass())\n}\n\n// 检查控制流节点是否作为hash()函数的参数被显式哈希\npredicate isExplicitlyHashed(ControlFlowNode cfNode) {\n  exists(CallNode hashCall, GlobalVariable hashGlobalVar |\n    hashCall.getArg(0) = cfNode and \n    hashCall.getFunction().(NameNode).uses(hashGlobalVar) and \n    hashGlobalVar.getId() = \"hash\"\n  )\n}\n\n// 检查控制流节点是否指向不可哈希对象\npredicate isUnhashable(ControlFlowNode cfNode, ClassValue objClass, ControlFlowNode originNode) {\n  exists(Value pointedValue | \n    cfNode.pointsTo(pointedValue, originNode) and \n    pointedValue.getClass() = objClass |\n    (not objClass.hasAttribute(\"__hash__\") and \n     not objClass.failedInference(_) and \n     objClass.isNewStyle())\n    or\n    objClass.lookup(\"__hash__\") = Value::named(\"None\")\n  )\n}\n\n_______________ // 补全条件\npredicate isUnhashableSubscript(ControlFlowNode cfNode, ClassValue objClass, ControlFlowNode originNode) {\n  isUnhashable(cfNode, objClass, originNode) and\n  exists(SubscriptNode subscriptNode | subscriptNode.getIndex() = cfNode |\n    exists(Value containerValue |\n      subscriptNode.getObject().pointsTo(containerValue) and\n      not hasCustomGetitem(containerValue)\n    )\n  )\n}\n\n/**\n * 检查控制流节点是否位于捕获TypeError的try块内。\n * 如果节点位于try块中，并且该try块有except TypeError子句，\n * 则认为该异常已被处理，不报告为问题。\n */\npredicate isTypeErrorCaught(ControlFlowNode cfNode) {\n  exists(Try tryStmt |\n    tryStmt.getBody().contains(cfNode.getNode()) and\n    tryStmt.getAHandler().getType().pointsTo(ClassValue::typeError())\n  )\n}\n\n// 查询未捕获的不可哈希对象哈希操作\nfrom ControlFlowNode node, ClassValue cls, ControlFlowNode origin\nwhere\n  not isTypeErrorCaught(node) and\n  (\n    isExplicitlyHashed(node) and isUnhashable(node, cls, origin)\n    or\n    isUnhashableSubscript(node, cls, origin)\n  )\nselect node.getNode(), \"This $@ of $@ is unhashable.\", origin, \"instance\", cls, cls.getQualifiedName()",
    "output": "// 检查控制流节点是否在作为下标时使用了不可哈希对象"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Hardcoded SECRET_KEY in Flask/Django Applications\n * @description Detects constant values assigned to SECRET_KEY configuration\n * in Flask/Django applications, which may lead to authentication bypass\n * @kind path-problem\n * @id py/flask-constant-secret-key\n * @problem.severity error\n * @security-severity 8.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.filters.Tests\n\n// Enumeration of supported web frameworks\nnewtype WebFramework =\n  Flask() or\n  Django()\n\n// Configuration module for detecting hardcoded secret keys\nprivate module SecretKeyDetectionConfig {\n  import semmle.python.dataflow.new.DataFlow\n\n  // Identify potential secret key sources (non-empty strings)\n  predicate isPotentialSecretSource(DataFlow::Node secretSourceNode) {\n    exists(string secretValue |\n_______________ // 补全条件\n      secretValue.length() > 0 and\n      // Exclude common placeholder values\n      not secretValue in [\"\", \"changeme\", \"secret\", \"password\", \"default\"]\n    )\n  }\n\n  // Identify SECRET_KEY assignment targets\n  predicate isSecretKeyAssignmentSink(DataFlow::Node secretKeySinkNode) {\n    exists(DataFlow::Node secretKeyAttributeNode |\n      secretKeyAttributeNode.asExpr().(Attribute).getName() = \"SECRET_KEY\" and\n      secretKeySinkNode.asExpr() = secretKeyAttributeNode.asExpr().(Attribute).getObject()\n    )\n  }\n}\n\n// Data flow configuration with framework state tracking\nprivate module WebAppSecretKeyConfig implements DataFlow::StateConfigSig {\n  // Framework state type\n  class FlowState = WebFramework;\n\n  // Barrier nodes to filter false positives\n  predicate isBarrier(DataFlow::Node node) {\n    // Standard library exclusions\n    node.getLocation().getFile().inStdlib()\n    or\n    // Test/demo/example file exclusions\n    exists(string relativePath |\n      relativePath = node.getLocation().getFile().getRelativePath() and\n      relativePath.matches([\"%test%\", \"%demo%\", \"%example%\", \"%sample%\"]) and\n      not relativePath.matches(\"%query-tests/Security/CWE-287%\")\n    )\n    or\n    // Non-secret literal exclusions\n    exists(string literalText |\n      literalText = node.asExpr().(StringLiteral).getText() and\n      literalText in [\"\", \"changeme\", \"secret\", \"password\", \"default\"]\n    )\n  }\n\n  // Source identification for both frameworks\n  predicate isSource(DataFlow::Node source, FlowState framework) {\n    framework = Flask() and SecretKeyDetectionConfig::isPotentialSecretSource(source)\n    or\n    framework = Django() and SecretKeyDetectionConfig::isPotentialSecretSource(source)\n  }\n\n  // Sink identification for both frameworks\n  predicate isSink(DataFlow::Node sink, FlowState framework) {\n    framework = Flask() and SecretKeyDetectionConfig::isSecretKeyAssignmentSink(sink)\n    or\n    framework = Django() and SecretKeyDetectionConfig::isSecretKeyAssignmentSink(sink)\n  }\n\n  // Enable differential analysis in incremental mode\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global taint tracking with framework state\nmodule WebAppSecretKeyFlow = TaintTracking::GlobalWithState<WebAppSecretKeyConfig>;\n\n// Path graph for flow visualization\nimport WebAppSecretKeyFlow::PathGraph\n\n// Query to detect hardcoded secret key assignments\nfrom WebAppSecretKeyFlow::PathNode source, WebAppSecretKeyFlow::PathNode sink\nwhere WebAppSecretKeyFlow::flowPath(source, sink)\nselect sink, source, sink, \"The SECRET_KEY config variable is assigned by $@.\", source,\n  \" this constant String\"",
    "output": "secretValue = secretSourceNode.asExpr().(StringLiteral).getText() and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Integer division result may be truncated in Python 2\n * @description In Python 2, dividing two integers using '/' performs integer division,\n_______________ // 补全条件\n *              where truncation may not be intended.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// 识别Python 2中可能导致结果截断的整数除法操作\nfrom BinaryExpr divisionOperation, ControlFlowNode leftArgNode, ControlFlowNode rightArgNode\nwhere\n  // 仅在Python 2中存在此问题（Python 3已实现真除法）\n  major_version() = 2 and\n  exists(BinaryExprNode binaryNode, Value leftValue, Value rightValue |\n    binaryNode = divisionOperation.getAFlowNode() and\n    binaryNode.getNode().getOp() instanceof Div and // 确认是除法操作符\n    binaryNode.getLeft().pointsTo(leftValue, leftArgNode) and\n    leftValue.getClass() = ClassValue::int_() and // 左操作数为整数类型\n    binaryNode.getRight().pointsTo(rightValue, rightArgNode) and\n    rightValue.getClass() = ClassValue::int_() and // 右操作数为整数类型\n    \n    // 排除整除无余数的情况（不会导致截断）\n    not leftValue.(NumericValue).getIntValue() % rightValue.(NumericValue).getIntValue() = 0 and\n    \n    // 排除已启用真除法的模块（通过future导入）\n    not binaryNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // 排除结果被显式转换为整数的情况（表明开发者已知并接受截断）\n    not exists(CallNode intConversionCall |\n      intConversionCall = ClassValue::int_().getACall() and\n      intConversionCall.getAnArg() = binaryNode\n    )\n  )\nselect divisionOperation, \n  \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftArgNode, \"left\", rightArgNode, \"right\"",
    "output": "*              truncating the fractional part. This query identifies such operations"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name NotImplemented is not an Exception\n * @description Detects code that raises 'NotImplemented' instead of the proper 'NotImplementedError' exception.\n *              This pattern causes type errors since NotImplemented is intended for comparison methods.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Import Python analysis library\nimport python\n\n// Import module containing NotImplemented exception handling logic\nimport Exceptions.NotImplemented\n_______________ // 补全条件\n// Find problematic raise expressions that use NotImplemented instead of NotImplementedError\nfrom Expr problematicRaiseExpr\nwhere \n  // Identify expressions where NotImplemented is incorrectly used in raise statements\n  use_of_not_implemented_in_raise(_, problematicRaiseExpr)\n// Output the problematic expression with a helpful fix suggestion\nselect problematicRaiseExpr, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Mostly similar module\n * @description There is another module that shares a lot of the code with this module. Notice that names of variables and types may have been changed. Merge the two modules to improve maintainability.\n * @kind problem\n * @problem.severity recommendation\n_______________ // 补全条件\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @sub-severity low\n * @precision high\n * @id py/mostly-similar-file\n */\n\nimport python // 导入Python库，用于处理Python代码的查询\n\n// 从模块m和other中选择数据，并生成消息\nfrom Module m, Module other, string message\nwhere none() // 条件为none()，表示没有过滤条件\nselect m, message, other, other.getName() // 选择模块m、消息、模块other以及other的名称",
    "output": "* @tags testability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies cryptographic operations using elliptic curve algorithms that are either unrecognized or classified as weak security risks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak elliptic curve\n * @description Identifies cryptographic operations using elliptic curve algorithms that are either unrecognized or classified as weak security risks.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm ecUsage, string alertMessage, string curveIdentifier\nwhere\n  curveIdentifier = ecUsage.getCurveName() and\n  (\n    // Case 1: Unrecognized curve algorithm detected\n    curveIdentifier = unknownAlgorithm() and\n    alertMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: Recognized but weak curve algorithm detected\n    curveIdentifier != unknownAlgorithm() and\n    not curveIdentifier =\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    alertMessage = \"Use of weak curve algorithm \" + curveIdentifier + \".\"\n  )\nselect ecUsage, alertMessage"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/repeated-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Importing a module a second time has no effect and impairs readability",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module is imported more than once\n * @description Importing a module a second time has no effect and impairs readability\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/repeated-import\n */\n\nimport python\n\n// 检查导入语句是否为简单导入形式（即不包含属性访问）\npredicate isPlainImport(Import importStmt) { \n  not exists(Attribute attrAccess | importStmt.contains(attrAccess)) \n}\n\n// 确定重复导入：同一模块被多次导入且使用相同别名\npredicate identifiesRedundantImport(Import initialImport, Import repeatedImport, Module targetModule) {\n  // 基本条件：两个导入语句不同且都是简单导入\n  initialImport != repeatedImport and\n  isPlainImport(initialImport) and \n  isPlainImport(repeatedImport) and\n  \n  // 检查两个导入是否引用相同模块\n  exists(ImportExpr initialExpr, ImportExpr repeatedExpr |\n    initialExpr.getName() = targetModule.getName() and\n    repeatedExpr.getName() = targetModule.getName() and\n    initialExpr = initialImport.getAName().getValue() and\n    repeatedExpr = repeatedImport.getAName().getValue()\n  ) and\n  \n  // 确保别名相同\n  initialImport.getAName().getAsname().(Name).getId() = repeatedImport.getAName().getAsname().(Name).getId() and\n  \n  // 检查作用域和位置关系\n  exists(Module enclosingModule |\n    initialImport.getScope() = enclosingModule and\n    repeatedImport.getEnclosingModule() = enclosingModule and\n    (\n      /* 重复导入不在顶层作用域 */\n      repeatedImport.getScope() != enclosingModule\n      or\n      /* 初始导入在代码中位置靠前 */\n      initialImport.getAnEntryNode().dominates(repeatedImport.getAnEntryNode())\n    )\n  )\n}\n\n// 查找并报告重复导入的情况\nfrom Import initialImport, Import repeatedImport, Module targetModule\nwhere identifiesRedundantImport(initialImport, repeatedImport, targetModule)\nselect repeatedImport,\n  \"This import of module \" + targetModule.getName() + \" is redundant, as it was previously imported $@.\",\n  initialImport, \"on line \" + initialImport.getLocation().getStartLine().toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Duplicate key in dict literal\n * @description Detects duplicate keys in dictionary literals where all but the last occurrence are overwritten\n_______________ // 补全条件\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/duplicate-key-dict-literal\n */\n\nimport python\nimport semmle.python.strings\n\n/**\n * Converts dictionary keys to their normalized string representation for comparison.\n * Handles numeric values and string literals (both Unicode and byte strings).\n */\npredicate dictKeyToString(Dict dict, Expr keyExpr, string normalizedKey) {\n  keyExpr = dict.getAKey() and\n  (\n    // Numeric keys: convert value to string\n    normalizedKey = keyExpr.(Num).getN()\n    or\n    // String keys: handle Unicode/byte string representation\n    // Special character handling: '�' represents unrepresentable characters\n    not \"�\" = normalizedKey.charAt(_) and\n    exists(StringLiteral strLiteral | strLiteral = keyExpr |\n      normalizedKey = \"u\\\"\" + strLiteral.getText() + \"\\\"\" and strLiteral.isUnicode()\n      or\n      normalizedKey = \"b\\\"\" + strLiteral.getText() + \"\\\"\" and not strLiteral.isUnicode()\n    )\n  )\n}\n\nfrom Dict dict, Expr overwrittenKey, Expr retainedKey\nwhere\n  // Find distinct keys with identical normalized representations\n  exists(string keyRepresentation | \n    dictKeyToString(dict, overwrittenKey, keyRepresentation) and \n    dictKeyToString(dict, retainedKey, keyRepresentation) and \n    overwrittenKey != retainedKey\n  ) and\n  // Verify position relationship ensuring overwrittenKey appears before retainedKey\n  (\n    // Case 1: Keys in same basic block with overwrittenKey at lower index\n    exists(BasicBlock block, int overwrittenIdx, int retainedIdx |\n      overwrittenKey.getAFlowNode() = block.getNode(overwrittenIdx) and\n      retainedKey.getAFlowNode() = block.getNode(retainedIdx) and\n      overwrittenIdx < retainedIdx\n    )\n    or\n    // Case 2: overwrittenKey's block strictly dominates retainedKey's block\n    overwrittenKey.getAFlowNode().getBasicBlock().strictlyDominates(\n      retainedKey.getAFlowNode().getBasicBlock()\n    )\n  )\n// Report the overwritten key with location information\nselect overwrittenKey, \n  \"Dictionary key \" + repr(overwrittenKey) + \" is subsequently $@.\", \n  retainedKey, \n  \"overwritten\"",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description 在解压用户提供的tar文件时，若未验证目标路径是否在目标目录内，可能导致目录遍历攻击。\n *             此漏洞常见于tar文件源自不可信位置（如远程服务器或用户输入参数）的场景。\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// 指定数据流分析的起始点（用户控制源）和结束点（不安全的解压操作）\nfrom UnsafeUnpackFlow::PathNode startNode, UnsafeUnpackFlow::PathNode endNode\n// 检查是否存在从用户控制源到不安全解压操作的数据流路径\nwhere UnsafeUnpackFlow::flowPath(startNode, endNode)\n// 输出漏洞节点、数据流起点和终点，并附带安全警告信息\nselect endNode.getNode(), startNode, endNode,\n  \"解压操作存在风险：来自不可信远程源的恶意tar文件可能被利用进行目录遍历攻击\"",
    "output": "* @name Arbitrary file write during a tarball extraction from a user controlled source"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unsafe-unpacking]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测从用户控制的源提取tar文件时，未验证目标路径是否在目标目录内的情况。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file write during a tarball extraction from a user controlled source\n * @description 检测从用户控制的源提取tar文件时，未验证目标路径是否在目标目录内的情况。\n *             此漏洞可能被攻击者利用进行目录遍历攻击，特别是当tar文件源自不可信来源时。\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// 查询目标：识别从不可信输入源到危险解包函数的数据流路径\nfrom \n  // 数据流起点：表示用户控制的或不可信的输入源\n  UnsafeUnpackFlow::PathNode maliciousInputSource,\n  // 数据流终点：表示存在漏洞的解包操作点\n  UnsafeUnpackFlow::PathNode vulnerableExtraction\nwhere \n  // 验证从输入源到解包操作存在完整的数据流路径，表明存在潜在安全风险\n  UnsafeUnpackFlow::flowPath(maliciousInputSource, vulnerableExtraction)\n// 输出漏洞信息，包括漏洞位置、数据流路径和风险描述\nselect vulnerableExtraction.getNode(), maliciousInputSource, vulnerableExtraction,\n  \"不安全的解包操作：从不可信远程源获取的恶意tar文件可能导致目录遍历攻击\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-inference-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query identifies 'object' instances where type inference is unsuccessful,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type inference fails for 'object'\n * @description This query identifies 'object' instances where type inference is unsuccessful,\n *              potentially leading to reduced recall in various analyses.\n * @kind problem\n * @id py/type-inference-failure\n * @deprecated\n */\n\nimport python\n\nfrom ControlFlowNode node, Object instance\nwhere\n  // The control flow node refers to the object instance\n  node.refersTo(instance) and\n  // The control flow node does not refer to the object instance with additional parameters\n  not node.refersTo(instance, _, _)\nselect instance, \"Type inference fails for 'object'.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-misconfiguration-with-credentials]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies CORS middleware configurations permitting authenticated requests",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name CORS misconfiguration with credentials enabled\n * @description Identifies CORS middleware configurations permitting authenticated requests\n *              from any origin, potentially enabling cross-site attacks.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n/** Checks if CORS middleware is configured with wildcard/null origins */\npredicate containsUnsafeOrigin(DataFlow::Node originValueNode) {\n  // Direct wildcard/null string literals\n  exists(StringLiteral lit | \n    lit = originValueNode.asExpr() and \n    lit.getText() in [\"*\", \"null\"]\n  )\n  or\n  // Lists containing wildcard/null elements\n  exists(List lst | \n    lst = originValueNode.asExpr() and\n    exists(StringLiteral elem | \n      elem = lst.getASubExpression() and\n      elem.getText() in [\"*\", \"null\"]\n    )\n  )\n}\n\n/** Validates CORS middleware type */\npredicate isCorsMiddleware(Http::Server::CorsMiddleware middlewareConfig) {\n  middlewareConfig.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n/** Verifies credentials are explicitly enabled */\npredicate credentialsAreEnabled(Http::Server::CorsMiddleware middlewareConfig) {\n  exists(True lit | lit = middlewareConfig.getCredentialsAllowed().asExpr())\n}\n\nfrom Http::Server::CorsMiddleware misconfiguredMiddleware\nwhere\n  // Confirm middleware type\n  isCorsMiddleware(misconfiguredMiddleware) and\n  // Check credential configuration\n  credentialsAreEnabled(misconfiguredMiddleware) and\n  // Detect unsafe origin settings\n  containsUnsafeOrigin(misconfiguredMiddleware.getOrigins().getALocalSource())\nselect misconfiguredMiddleware,\n  \"This CORS middleware uses a vulnerable configuration that allows arbitrary websites to make authenticated cross-site requests\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comment-density-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the percentage of comment lines relative to total lines in Python modules.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python source code comment ratio evaluation\n * @description Measures the percentage of comment lines relative to total lines in Python modules.\n *              Docstrings are excluded from this calculation as they serve a different purpose\n *              than regular code comments.\n * @kind treemap\n * @id py/comment-density-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\nfrom Module pyModule\nwhere pyModule.getMetrics().getNumberOfLines() > 0\nselect pyModule,\n       (100.0 * pyModule.getMetrics().getNumberOfLinesOfComments()) / pyModule.getMetrics().getNumberOfLines() as density\norder by density desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/encoding-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies encoding-related issues that trigger runtime failures and impede code analysis",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Encoding error\n * @description Identifies encoding-related issues that trigger runtime failures and impede code analysis\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/encoding-error\n */\n\nimport python\n\n// Detect encoding problems and retrieve their diagnostic details\nfrom EncodingError encodingProblem\nselect encodingProblem, encodingProblem.getMessage()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-default-protocol]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Failing to specify an SSL/TLS protocol version can lead to the use of",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insecure default SSL/TLS protocol version\n * @description Failing to specify an SSL/TLS protocol version can lead to the use of\n *              an insecure default protocol.\n * @id py/insecure-default-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\n// This query identifies deprecated SSL socket calls that lack protocol specification.\n// When ssl.wrap_socket is called without the ssl_version parameter, it may fall back\n// to using insecure default protocols. For comprehensive secure context analysis,\n// refer to the py/insecure-protocol dataflow query.\nimport python\nimport semmle.python.ApiGraphs\n\n// Define the SSL module and its wrap_socket method for clarity\nfrom DataFlow::CallCfgNode unsafeSocketInvocation\nwhere\n  // Locate all invocations of the ssl.wrap_socket method\n  unsafeSocketInvocation = API::moduleImport(\"ssl\").getMember(\"wrap_socket\").getACall()\n  // Ensure that the ssl_version parameter is explicitly omitted\n  and not exists(unsafeSocketInvocation.getArgByName(\"ssl_version\"))\nselect unsafeSocketInvocation,\n  \"Call to deprecated method ssl.wrap_socket does not specify a protocol, which may result in an insecure default being used.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class should be a context manager\n * @description Finds classes that have a __del__ method (often used for resource cleanup)\n *              but do not implement the context manager protocol. Such classes would benefit\n *              from being refactored as context managers, enabling more predictable resource\n *              management through 'with' statements and enhancing code clarity and robustness.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n_______________ // 补全条件\n * @precision medium\n * @id py/should-be-context-manager\n */\n\nimport python\n\n// Identify classes that would benefit from being implemented as context managers\nfrom ClassValue candidateClass\nwhere \n  // Exclude built-in classes as they cannot be modified\n  not candidateClass.isBuiltin()\n  and \n  // Only consider classes that are not already context managers\n  not candidateClass.isContextManager()\n  and \n  // Focus on classes implementing __del__ method, typically for resource cleanup\n  exists(candidateClass.declaredAttribute(\"__del__\"))\nselect candidateClass, \n  \"Class \" + candidateClass.getName() + \n    \" implements __del__ (presumably to release some resource). Consider making it a context manager.\"",
    "output": "* @sub-severity high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary delete statement in function\n * @description Detects unnecessary 'delete' operations on local variables. \n *              These operations are redundant because local variables are automatically\n *              cleaned up when function execution completes. The analysis excludes\n *              cases where deletion might be necessary, such as inside loops\n *              or when dealing with sys.exc_info() exception handling.\n * @kind problem\n * @tags maintainability\n_______________ // 补全条件\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/unnecessary-delete\n */\n\nimport python\n\n// Determines whether an AST node is positioned inside any loop structure\npredicate isWithinLoopContext(AstNode node) {\n  // Check for direct containment in loop statements\n  node.getParentNode() instanceof While\n  or\n  node.getParentNode() instanceof For\n  // Recursively check for nested containment\n  or\n  exists(AstNode parent | \n    isWithinLoopContext(parent) and \n    node = parent.getAChildNode()\n  )\n}\n\n// Main analysis to identify superfluous variable deletions\nfrom Delete deleteStmt, Expr deletedVar, Function hostFunction\nwhere\n  // Condition 1: Deletion is the final statement in the function body\n  hostFunction.getLastStatement() = deleteStmt and\n  // Condition 2: Identify the expression being deleted\n  deletedVar = deleteStmt.getATarget() and\n  // Condition 3: Verify variable is in function's scope\n  hostFunction.containsInScope(deletedVar) and\n  // Condition 4: Exclude complex deletion targets (subscripts and attributes)\n  not deletedVar instanceof Subscript and  // e.g., del dict[key]\n  not deletedVar instanceof Attribute and  // e.g., del obj.attr\n  // Condition 5: Exclude deletions within loop contexts\n  not isWithinLoopContext(deleteStmt) and\n  // Condition 6: Exclude functions that use sys.exc_info() (requires explicit cleanup)\n  not exists(FunctionValue excInfoFunc |\n    excInfoFunc = Value::named(\"sys.exc_info\") and\n    excInfoFunc.getACall().getScope() = hostFunction\n  )\nselect deleteStmt, \"Unnecessary deletion of local variable $@ in function $@.\", \n  deletedVar, deletedVar.toString(), hostFunction, hostFunction.getName()",
    "output": "*       useless-code"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Hash Verification Timing Vulnerability\n * @description Message hash verification should use constant-time algorithms.\n *              Attackers can forge valid hashes by analyzing response time differences,\n *              potentially bypassing authentication mechanisms.\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/possible-timing-attack-against-hash\n * @tags security\n *       external/cwe/cwe-208\n *       experimental\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\n_______________ // 补全条件\nprivate module TimingAttackConfig implements DataFlow::ConfigSig {\n  // Source: Cryptographic operation calls (e.g., hash generation)\n  predicate isSource(DataFlow::Node cryptographicOperation) { \n    cryptographicOperation instanceof ProduceCryptoCall \n  }\n\n  // Sink: Non-constant-time comparison operations\n  predicate isSink(DataFlow::Node comparisonOperation) { \n    comparisonOperation instanceof NonConstantTimeComparisonSink \n  }\n}\n\n// Initialize global taint tracking with the configuration\nmodule TimingAttackFlow = TaintTracking::Global<TimingAttackConfig>;\nimport TimingAttackFlow::PathGraph\n\n// Main query logic: Detect potential timing attack vulnerability paths\nfrom\n  TimingAttackFlow::PathNode cryptoSourceNode,    // Source node representing cryptographic operation\n  TimingAttackFlow::PathNode comparisonSinkNode    // Sink node representing comparison operation\nwhere \n  TimingAttackFlow::flowPath(cryptoSourceNode, comparisonSinkNode)\nselect \n  comparisonSinkNode.getNode(), \n  cryptoSourceNode, \n  comparisonSinkNode, \n  \"Timing attack vulnerability on $@ verification\",\n  cryptoSourceNode.getNode().(ProduceCryptoCall).getResultType(), \n  \"message\"",
    "output": "// Global taint tracking module configuration"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Integer division result truncation risk\n * @description Identifies division operations where both operands are integers,\n *              which may lead to truncated results in Python 2.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// Find division expressions with integer operands that might truncate the result\nfrom BinaryExpr divisionOperation, ControlFlowNode leftValueNode, ControlFlowNode rightValueNode\nwhere\n  // Only applicable in Python 2 (true division was introduced in later versions)\n_______________ // 补全条件\n  exists(BinaryExprNode binaryNode, Value leftIntValue, Value rightIntValue |\n    // Confirm division operator\n    binaryNode = divisionOperation.getAFlowNode() and\n    binaryNode.getNode().getOp() instanceof Div and\n    \n    // Check left operand type\n    binaryNode.getLeft().pointsTo(leftIntValue, leftValueNode) and\n    leftIntValue.getClass() = ClassValue::int_() and\n    \n    // Check right operand type\n    binaryNode.getRight().pointsTo(rightIntValue, rightValueNode) and\n    rightIntValue.getClass() = ClassValue::int_() and\n    \n    // Exclude cases where division results in no remainder (exact division)\n    not leftIntValue.(NumericValue).getIntValue() % rightIntValue.(NumericValue).getIntValue() = 0 and\n    \n    // Exclude modules that have imported future division\n    not binaryNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // Exclude explicit integer type conversions of the division result\n    not exists(CallNode intTypeConversion |\n      intTypeConversion = ClassValue::int_().getACall() and\n      intTypeConversion.getAnArg() = binaryNode\n    )\n  )\nselect divisionOperation, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftValueNode, \"left\", rightValueNode, \"right\"",
    "output": "major_version() = 2 and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/pam-auth-bypass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：当PAM认证流程中，在调用`pam_authenticate`后未调用`pam_acct_mgmt`进行账户有效性验证时，可能导致授权绕过。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name PAM授权绕过漏洞\n * @description 当PAM认证流程中，在调用`pam_authenticate`后未调用`pam_acct_mgmt`进行账户有效性验证时，可能导致授权绕过。\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 8.1\n * @precision high\n * @id py/pam-auth-bypass\n * @tags security\n *       external/cwe/cwe-285\n */\n\nimport python\nimport PamAuthorizationFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.security.dataflow.PamAuthorizationQuery\n\n// 定义PAM认证流程的起始节点和终止节点\nfrom PamAuthorizationFlow::PathNode authStartNode, PamAuthorizationFlow::PathNode authEndNode\n// 验证从认证起始点到终止点是否存在完整的数据流路径\nwhere \n  PamAuthorizationFlow::flowPath(authStartNode, authEndNode)\n// 输出检测结果，标识存在授权绕过风险的代码位置\nselect authEndNode.getNode(), authStartNode, authEndNode,\n  \"PAM认证流程中存在$@，且后续未调用'pam_acct_mgmt'进行账户有效性验证。\",\n  authStartNode.getNode(), \"用户输入值\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-iterable used in for loop\n * @description Detects for loops that attempt to iterate over non-iterable objects, which would cause a TypeError at runtime.\n * @kind problem\n * @tags reliability\n_______________ // 补全条件\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/non-iterable-in-for-loop\n */\n\nimport python\n\n// 查找在for循环中使用的非可迭代对象\nfrom For forStmt, ControlFlowNode iterationExprNode, Value targetValue, ClassValue targetClass, ControlFlowNode valueOrigin\nwhere\n  // 步骤1：关联for循环与其迭代表达式节点，并追溯到被迭代的值和源位置\n  forStmt.getIter().getAFlowNode() = iterationExprNode and\n  iterationExprNode.pointsTo(_, targetValue, valueOrigin) and\n  \n  // 步骤2：获取被迭代值的类类型，并验证其不可迭代性\n  targetValue.getClass() = targetClass and\n  not targetClass.isIterable() and\n  not targetClass.failedInference(_) and\n  \n  // 步骤3：排除特殊情况，避免误报\n  not (targetValue = Value::named(\"None\") or targetClass.isDescriptorType())\nselect forStmt, \"This for-loop may attempt to iterate over a $@ of class $@.\", valueOrigin,\n  \"non-iterable instance\", targetClass, targetClass.getName()",
    "output": "*       correctness"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-commented-out-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and quantifies commented-out code lines in Python source files,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lines of commented-out code in files\n * @description Identifies and quantifies commented-out code lines in Python source files,\n *              excluding lines that appear to be example code. Results are visualized\n *              as a treemap emphasizing files with significant comment density.\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// Import necessary modules for Python code analysis and comment detection\nimport python\nimport Lexical.CommentedOutCode\n\n// Analysis process: Calculate commented-out code lines per Python file\nfrom File pyFile, int commentedCodeLines\nwhere \n    // Count commented lines that are not example code for each file\n    commentedCodeLines = count(CommentedOutCodeLine commentedLine | \n        // Exclude lines that might be example code\n        not commentedLine.maybeExampleCode() and \n        // Ensure the line belongs to the current file being analyzed\n        commentedLine.getLocation().getFile() = pyFile)\n// Output results: Show each file with its commented code line count,\n// sorted in descending order to highlight files needing attention\nselect pyFile, commentedCodeLines order by commentedCodeLines desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name String concatenation in loop\n * @description Detects inefficient string concatenation inside loops that causes quadratic performance.\n * @kind problem\n * @tags efficiency\n *       maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision low\n * @id py/string-concatenation-in-loop\n */\n\nimport python\n\n/**\n * Identifies inefficient string concatenation operations within loops.\n * This predicate detects binary addition expressions where strings are concatenated\n * in a loop context, causing quadratic performance degradation due to repeated\n * string recreation. The pattern involves a variable being repeatedly updated\n * through concatenation operations.\n */\npredicate string_concat_in_loop(BinaryExpr concatOp) {\n  // Verify the operation is string concatenation (addition)\n_______________ // 补全条件\n  \n  // Analyze SSA variables involved in the concatenation\n  exists(SsaVariable originalVar, SsaVariable updatedVar, BinaryExprNode opNode |\n    // Connect the expression node to our binary operation\n    opNode.getNode() = concatOp and \n    // Establish SSA variable relationship: originalVar is the source definition\n    originalVar = updatedVar.getAnUltimateDefinition()\n  |\n    // Verify the operation defines the target string variable\n    originalVar.getDefinition().(DefinitionNode).getValue() = opNode and\n    // Confirm the variable is used as an operand in concatenation\n    updatedVar.getAUse() = opNode.getAnOperand() and\n    // Ensure at least one operand is of string type\n    opNode.getAnOperand().pointsTo().getClass() = ClassValue::str()\n  )\n}\n\n// Identify and report inefficient string concatenation patterns\nfrom BinaryExpr concatOp, Stmt loopContainer\nwhere \n  // Match inefficient concatenation pattern\n  string_concat_in_loop(concatOp) and\n  // Find the loop statement containing this operation\n  loopContainer.getASubExpression() = concatOp\n// Generate alert with performance impact information\nselect loopContainer, \"String concatenation in a loop is quadratic in the number of iterations.\"",
    "output": "concatOp.getOp() instanceof Add and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Result of integer division may be truncated\n * @description Detects division operations where both operands are integers,\n *              potentially causing truncation in Python 2 due to floor division behavior.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// Identify division operations that may truncate results in Python 2\nfrom BinaryExpr divOperation, ControlFlowNode leftOperand, ControlFlowNode rightOperand\nwhere\n  // Only relevant for Python 2 where integer division truncates\n  major_version() = 2 and\n  exists(BinaryExprNode divNode, Value leftIntVal, Value rightIntVal |\n    // Get the AST node for the division operation\n    divNode = divOperation.getAFlowNode() and\n    // Verify the operator is division\n    divNode.getNode().getOp() instanceof Div and\n    \n    // Check left operand is an integer\n    divNode.getLeft().pointsTo(leftIntVal, leftOperand) and\n    leftIntVal.getClass() = ClassValue::int_() and\n    \n    // Check right operand is an integer\n    divNode.getRight().pointsTo(rightIntVal, rightOperand) and\n    rightIntVal.getClass() = ClassValue::int_() and\n    \n    // Exclude cases where division has no remainder (exact division)\n    not leftIntVal.(NumericValue).getIntValue() % rightIntVal.(NumericValue).getIntValue() = 0 and\n    \n    // Exclude modules using true division from __future__\n    not divNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // Exclude cases where result is explicitly converted to int\n    not exists(CallNode intCastCall |\n      intCastCall = ClassValue::int_().getACall() and\n_______________ // 补全条件\n    )\n  )\nselect divOperation, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftOperand, \"left\", rightOperand, \"right\"",
    "output": "intCastCall.getAnArg() = divNode"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jump-to-definition]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and maps code usage locations to their corresponding definitions.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python Definition Locator\n * @description Identifies and maps code usage locations to their corresponding definitions.\n *              This query serves as a jump-to-definition helper by establishing relationships\n *              between usage instances and their source definitions.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import Python language support module for Python code analysis\nimport python\n\n// Import definition tracking capabilities for establishing usage-definition relationships\nimport analysis.DefinitionTracking\n\n// Query to establish mapping between usage locations and their source definitions\nfrom NiceLocationExpr usageLocation, Definition definitionRef, string definitionType\n// Establish relationship where the definition reference corresponds to the usage location\n// and maintain type consistency between usage and definition\nwhere definitionRef = definitionOf(usageLocation, definitionType)\n// Output the usage location, its corresponding definition, and the type of definition\nselect usageLocation, definitionRef, definitionType"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/file-classifier]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Categorizes files in a codebase snapshot as either",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File Classification\n * @description Categorizes files in a codebase snapshot as either \n *              auto-generated code or test-related files.\n * @kind file-classifier\n * @id py/file-classifier\n */\n\n// Import core Python analysis module\nimport python\n// Import filter for detecting auto-generated files\nimport semmle.python.filters.GeneratedCode\n// Import filter for identifying test files\nimport semmle.python.filters.Tests\n\n// Select files with their classification tags\nfrom File targetFile, string classificationTag\nwhere \n  // Check if file is auto-generated\n  (targetFile instanceof GeneratedFile and classificationTag = \"generated\")\n  or\n  // Check if file is part of test scope\n  (exists(TestScope testScope | testScope.getLocation().getFile() = targetFile) \n   and classificationTag = \"test\")\nselect targetFile, classificationTag"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Untrusted Cookie Value Injection\n_______________ // 补全条件\n *              potentially enabling session hijacking or data tampering. This pattern violates\n *              CWE-20 (Improper Input Validation) and exposes systems to cookie-based attacks.\n * @id py/untrusted-cookie-injection\n * @kind path-problem\n * @precision medium\n * @problem.severity high\n * @security-severity 8.7\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\nfrom \n  CookieInjectionFlow::PathNode untrustedInputOrigin, \n  CookieInjectionFlow::PathNode cookieValueSink, \n  int configurationIdentifier\nwhere \n  configurationIdentifier = 1\n  and CookieInjectionFlow::flowPath(untrustedInputOrigin, cookieValueSink)\nselect \n  cookieValueSink.getNode(), \n  untrustedInputOrigin, \n  cookieValueSink, \n  \"Cookie value constructed from $@.\", \n  untrustedInputOrigin.getNode(), \n  \"untrusted user input\"",
    "output": "* @description Identifies security flaws where cookie values are directly constructed from user-controlled inputs,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Summarized Callable Call Sites\n * @description Identifies call sites covered by flow summaries, \n *              including both direct function calls and callback invocations.\n_______________ // 补全条件\n * @problem.severity recommendation\n * @id py/meta/summarized-callable-call-sites\n * @tags meta\n * @precision very-low\n */\n\n// Import Python language core library\nimport python\n// Import data flow analysis modules\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\n// Import meta metrics analysis module\nimport meta.MetaMetrics\n\n// Define analysis variables: call site node, target summarized callable, and call type\nfrom DataFlow::Node callSite, SummarizedCallable targetCallable, string callType\nwhere\n  // Check if the call site is a direct invocation of the summarized target\n  (callSite = targetCallable.getACall() and callType = \"Call\")\n  or\n  // Check if the call site is a callback invocation of the summarized target\n  (callSite = targetCallable.getACallback() and callType = \"Callback\")\n  and\n  // Ensure the call site is not located in an ignored file\n  not callSite.getLocation().getFile() instanceof IgnoredFile\n// Format result message and select the call site with its description\nselect callSite, callType + \" to \" + targetCallable",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Redundant comparison\n * @description The result of a comparison is implied by a previous comparison.\n * @kind problem\n * @tags useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/redundant-comparison\n_______________ // 补全条件\n\nimport python\nimport semmle.python.Comparisons\n\n/*\n * Determines if a comparison expression has a complex structure such as 'a op b op c'\n * rather than a simple form 'a op b'.\n */\nprivate predicate hasComplexStructure(Expr comparisonExpr) {\n  // Check if the comparison contains multiple operators, indicating a complex form\n  exists(comparisonExpr.(Compare).getOp(1))\n  or\n  // Recursively check if the operand of a unary expression has a complex structure\n  hasComplexStructure(comparisonExpr.(UnaryExpr).getOperand())\n}\n\n/**\n * Identifies a test as useless if there exists another test that is at least as strict\n * and controls the same blocks.\n */\nprivate predicate isUselessTest(Comparison comparisonExpr, ComparisonControlBlock controlBlock, boolean evaluationResult) {\n  // Verify that the control block is governed by a more stringent test\n  controlBlock.impliesThat(comparisonExpr.getBasicBlock(), comparisonExpr, evaluationResult) and\n  /* Exclude complex comparisons like 'a < x < y', as current flow control analysis is incomplete for these */\n  // Exclude complex-form comparisons due to imperfect flow control handling\n  not hasComplexStructure(controlBlock.getTest().getNode())\n}\n\nprivate predicate identifiesUselessTestInAST(AstNode comparisonNode, AstNode precedingNode, boolean evaluationResult) {\n  // Iterate through all qualifying comparison nodes and condition blocks to identify useless tests\n  forex(Comparison comparisonExpr, ConditionBlock conditionBlock |\n    comparisonExpr.getNode() = comparisonNode and\n    conditionBlock.getLastNode().getNode() = precedingNode\n  |\n    isUselessTest(comparisonExpr, conditionBlock, evaluationResult)\n  )\n}\n\nfrom Expr testExpr, Expr precedingExpr, boolean evaluationResult\nwhere\n  // Identify useless tests while ensuring their child nodes are not also useless tests\n  identifiesUselessTestInAST(testExpr, precedingExpr, evaluationResult) and \n  not identifiesUselessTestInAST(testExpr.getAChildNode+(), precedingExpr, _)\nselect testExpr, \"Test is always \" + evaluationResult + \", because of $@.\", precedingExpr, \"this condition\"",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-of-identical-expressions]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects redundant comparisons where values are compared to themselves,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comparison of identical values\n * @description Detects redundant comparisons where values are compared to themselves,\n *              often indicating logical errors or unclear implementation intent.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\nimport python\nimport Expressions.RedundantComparison\n\nfrom RedundantComparison identicalComparison\nwhere \n  // Exclude intentional constant comparisons to reduce noise\n  not identicalComparison.isConstant()\n  // Filter potential false positives from missing 'self' references\n  and not identicalComparison.maybeMissingSelf()\nselect identicalComparison, \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies sources of remote user input in Python code\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/alerts/remote-flow-sources\n * @tags meta\n * @precision very-low\n */\n\n// Core Python analysis libraries\nprivate import python\n\n// Data flow tracking capabilities\nprivate import semmle.python.dataflow.new.DataFlow\n\n// Remote input source identification\nprivate import semmle.python.dataflow.new.RemoteFlowSources\n\n// Metadata collection and reporting\nprivate import meta.MetaMetrics\n\n// Identify all remote flow sources\nfrom RemoteFlowSource remoteSource\n\n// Exclude sources from ignored files\nwhere not remoteSource.getLocation().getFile() instanceof IgnoredFile\n\n// Report remote source with type description\nselect remoteSource, \"RemoteFlowSource: \" + remoteSource.getSourceType()",
    "output": "* @name Remote flow sources"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/loop-variable-capture]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies instances where loop variables are captured by closures rather than their values, potentially causing unintended behavior.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Loop Variable Capture in Closures\n * @description Identifies instances where loop variables are captured by closures rather than their values, potentially causing unintended behavior.\n * @kind problem\n * @tags correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/loop-variable-capture\n */\n\nimport python\n\n/**\n * Obtains the scope that holds the iteration variables for a given loop node.\n * In the case of For-loops, the scope of the loop itself is returned.\n * For comprehensions, the scope of the enclosing function is returned.\n */\nScope getIterationScope(AstNode loopNode) {\n  result = loopNode.(For).getScope()\n  or\n  result = loopNode.(Comp).getFunction()\n}\n\n/**\n * Checks whether a callable expression captures a loop variable in the iteration scope.\n * The conditions are:\n * 1. The variable is defined in the iteration scope of the loop.\n * 2. The variable is accessed within the inner scope of the callable.\n * 3. The callable is nested within the loop node.\n * 4. The variable is either a target in a For-loop or an iteration variable in a comprehension.\n */\npredicate capturesLoopVariable(CallableExpr capturedClosure, AstNode loopNode, Variable loopVar) {\n  loopVar.getScope() = getIterationScope(loopNode) and\n  loopVar.getAnAccess().getScope() = capturedClosure.getInnerScope() and\n  capturedClosure.getParentNode+() = loopNode and\n  (\n    loopNode.(For).getTarget() = loopVar.getAnAccess()\n    or\n    loopVar = loopNode.(Comp).getAnIterationVariable()\n  )\n}\n\n/**\n * Determines whether the captured loop variable escapes the original loop node.\n * Escape conditions:\n * 1. For For-loops: A reference to the callable exists outside the loop body.\n * 2. For comprehensions: The callable is used as the element or as an element in a tuple.\n */\npredicate escapesLoopCapture(CallableExpr capturedClosure, AstNode loopNode, Variable loopVar) {\n  capturesLoopVariable(capturedClosure, loopNode, loopVar) and\n  (\n    loopNode instanceof For and\n    exists(Expr reference | reference.pointsTo(_, _, capturedClosure) | not loopNode.contains(reference))\n    or\n    loopNode.(Comp).getElt() = capturedClosure\n    or\n    loopNode.(Comp).getElt().(Tuple).getAnElt() = capturedClosure\n  )\n}\n\n// Identify callable expressions that capture and escape loop variables\nfrom CallableExpr capturedClosure, AstNode loopNode, Variable loopVar\nwhere escapesLoopCapture(capturedClosure, loopNode, loopVar)\nselect capturedClosure, \"Capture of loop variable $@.\", loopNode, loopVar.getId()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects potentially confusing use of '\\b' inside regex character sets.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Backspace escape in regular expression\n * @description Detects potentially confusing use of '\\b' inside regex character sets.\n *              While '\\b' typically means word boundary, it represents backspace\n *              when used within character sets, which may lead to unintended behavior.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int backslashPos\nwhere\n  // Identify backslash characters acting as escape sequences\n  regexPattern.escapingChar(backslashPos) and\n  // Verify the escaped character is 'b' (backspace)\n  regexPattern.getChar(backslashPos + 1) = \"b\" and\n  // Ensure the escape sequence occurs within a character set\n  exists(int charSetBegin, int charSetEnd | \n    regexPattern.charSet(charSetBegin, charSetEnd) and\n    // Position validation: backslash must be inside character set boundaries\n    backslashPos > charSetBegin and \n    backslashPos < charSetEnd\n  )\nselect regexPattern, \"Backspace escape in regular expression at offset \" + backslashPos + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-misconfiguration-with-credentials]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Disabling or weakening SOP protection may make the application",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cors misconfiguration with credentials\n * @description Disabling or weakening SOP protection may make the application\n *              vulnerable to a CORS attack.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n/** \n * Checks if a configuration node contains unsafe wildcard or null values.\n * Two cases are covered:\n * 1. List containing \"*\" or \"null\" elements\n * 2. Direct \"*\" or \"null\" string literal\n */\npredicate hasUnsafeOriginConfig(DataFlow::Node configNode) {\n  // Case 1: Check for unsafe values in list elements\n  exists(List listNode | listNode = configNode.asExpr() |\n    exists(StringLiteral strLit | strLit = listNode.getASubExpression() |\n      strLit.getText() in [\"*\", \"null\"]\n    )\n  )\n  // Case 2: Check for direct unsafe string literals\n  or\n  exists(StringLiteral strLit | strLit = configNode.asExpr() |\n    strLit.getText() in [\"*\", \"null\"]\n  )\n}\n\nfrom Http::Server::CorsMiddleware corsMiddleware\nwhere\n  // Verify middleware type and credential configuration\n  corsMiddleware.getMiddlewareName() = \"CORSMiddleware\" and\n  corsMiddleware.getCredentialsAllowed().asExpr() instanceof True\n  and\n  // Check for unsafe origin configuration\n  exists(DataFlow::Node originConfigNode | \n    originConfigNode = corsMiddleware.getOrigins().getALocalSource() and\n    hasUnsafeOriginConfig(originConfigNode)\n  )\nselect corsMiddleware,\n  \"This CORS middleware uses a vulnerable configuration that allows arbitrary websites to make authenticated cross-site requests\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Modification of dictionary returned by locals()\n * @description Detects attempts to modify the dictionary returned by locals() which do not affect the actual local variables.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n_______________ // 补全条件\n */\n\nimport python\n\n// Determines if a control flow node references the result of a locals() call\npredicate nodeReferencesLocalsCall(ControlFlowNode flowNode) { \n    flowNode.pointsTo(_, _, Value::named(\"locals\").getACall()) \n}\n\n// Identifies dictionary write/delete operations on locals() result\npredicate isDictionaryWriteOrDelete(ControlFlowNode modificationNode) {\n    exists(SubscriptNode subscript |\n        subscript = modificationNode and\n        nodeReferencesLocalsCall(subscript.getObject()) and\n        (subscript.isStore() or subscript.isDelete())\n    )\n}\n\n// Identifies mutating method calls on locals() result\npredicate isDictionaryMutatingMethodCall(ControlFlowNode modificationNode) {\n    exists(CallNode methodCall, AttrNode attributeAccess, string mutatingMethod |\n        methodCall = modificationNode and\n        attributeAccess = methodCall.getFunction() and\n        nodeReferencesLocalsCall(attributeAccess.getObject(mutatingMethod)) and\n        mutatingMethod in [\"pop\", \"popitem\", \"update\", \"clear\"]\n    )\n}\n\n// Combines all modification patterns targeting locals() dictionary\npredicate modifiesLocalsReturnedDict(ControlFlowNode modificationNode) {\n    isDictionaryWriteOrDelete(modificationNode) or\n    isDictionaryMutatingMethodCall(modificationNode)\n}\n\nfrom AstNode astNode, ControlFlowNode modificationNode\nwhere\n    // Find operations modifying the locals() dictionary\n    modifiesLocalsReturnedDict(modificationNode) and\n    // Map control flow node to corresponding AST node\n    astNode = modificationNode.getNode() and\n    // Exclude module-level scope where locals() equals globals()\n    not astNode.getScope() instanceof ModuleScope\n// Output results with warning message\nselect astNode, \"Modification of the locals() dictionary will have no effect on the local variables.\"",
    "output": "* @id py/modification-of-locals"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Descriptor objects are shared across many instances. Mutating them can cause side effects or race conditions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Identifies descriptor classes containing mutation operations in descriptor methods or their callees\npredicate has_descriptor_mutation(ClassObject descClass, SelfAttributeStore mutationOp) {\n  // Ensure class implements descriptor protocol\n  descClass.isDescriptorType() and\n  // Find descriptor protocol methods\n  exists(PyFunctionObject descriptorMethod, string protocolMethodName |\n    descClass.lookupAttribute(protocolMethodName) = descriptorMethod and\n    (protocolMethodName = \"__get__\" or protocolMethodName = \"__set__\" or protocolMethodName = \"__delete__\") and\n    // Trace mutation operations through call chain\n    exists(PyFunctionObject invokedMethod |\n      // Invoked method belongs to same descriptor class\n      descClass.lookupAttribute(_) = invokedMethod and\n      // Establish call relationship from descriptor method\n      descriptorMethod.getACallee*() = invokedMethod and\n      // Exclude initialization methods\n      not invokedMethod.getName() = \"__init__\" and\n      // Mutation occurs within invoked method's scope\n      mutationOp.getScope() = invokedMethod.getFunction()\n    )\n  )\n}\n\n// Identify problematic descriptor classes and mutation locations\nfrom ClassObject descClass, SelfAttributeStore mutationOp\nwhere has_descriptor_mutation(descClass, mutationOp)\n// Output mutation location with contextual warning\nselect mutationOp,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descClass, descClass.getName()",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies security flaws where untrusted user input is directly\n *              output to web content without adequate sanitization, allowing\n *              attackers to inject malicious scripts.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @sub-severity high\n * @precision high\n * @id py/reflective-xss\n * @tags security\n *       external/cwe/cwe-079\n *       external/cwe/cwe-116\n */\n\n// Import Python language library for security analysis\nimport python\n// Import specialized module for detecting reflected cross-site scripting vulnerabilities\nimport semmle.python.security.dataflow.ReflectedXssQuery\n// Import path graph module for visualizing data flow paths\nimport ReflectedXssFlow::PathGraph\n\n// Define source and sink nodes for XSS vulnerability detection\nfrom \n  ReflectedXssFlow::PathNode untrustedInputSource,  // Represents the origin of untrusted user input\n  ReflectedXssFlow::PathNode xssSinkPoint           // Represents the vulnerable output point\n// Verify data flow from untrusted input to XSS sink\nwhere ReflectedXssFlow::flowPath(untrustedInputSource, xssSinkPoint)\n// Generate alert with sink location, source information, and path details\nselect \n  xssSinkPoint.getNode(),                           // The vulnerable sink location\n  untrustedInputSource,                             // The source of untrusted input\n  xssSinkPoint,                                     // Path node information\n  \"Cross-site scripting vulnerability caused by a $@.\", // Alert message\n  untrustedInputSource.getNode(),                   // Source node location\n  \"user-provided input\"                             // Source description",
    "output": "* @name Reflected server-side cross-site scripting"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jinja2/autoescape-false]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of Jinja2 templates with 'autoescape=False'",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Jinja2 templating with autoescape=False\n * @description Detects usage of Jinja2 templates with 'autoescape=False'\n *              which can lead to cross-site scripting vulnerabilities.\n * @kind problem\n * @problem.severity error\n * @security-severity 6.1\n * @precision medium\n * @id py/jinja2/autoescape-false\n * @tags security\n *       external/cwe/cwe-079\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n/*\n * References:\n * Jinja2 Environment API: https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Environment\n * Jinja2 Template API: https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template\n *\n * Note: autoescape parameter is valid for both Environment and Template constructors\n * Example vulnerable code:\n *   unsafe_tmpl = Template('Hello {{ name }}!')\n *   unsafe_env = Environment(autoescape=False)\n */\n\n// Identifies Jinja2 Environment or Template API nodes\nprivate API::Node jinja2EnvOrTemplate() {\n  result = API::moduleImport(\"jinja2\").getMember(\"Environment\")\n  or\n  result = API::moduleImport(\"jinja2\").getMember(\"Template\")\n}\n\n// Main detection logic for unsafe Jinja2 instantiations\nfrom API::CallNode jinja2Call\nwhere\n  // Check if this is a Jinja2 Environment or Template constructor call\n  jinja2Call = jinja2EnvOrTemplate().getACall() and\n  // Exclude calls using dynamic argument expansion (*args or **kwargs)\n  not exists(jinja2Call.asCfgNode().(CallNode).getNode().getStarargs()) and\n  not exists(jinja2Call.asCfgNode().(CallNode).getNode().getKwargs()) and\n  (\n    // Case 1: autoescape parameter is omitted (defaults to False in some contexts)\n    not exists(jinja2Call.getArgByName(\"autoescape\"))\n    or\n    // Case 2: autoescape parameter is explicitly set to False\n    jinja2Call.getKeywordParameter(\"autoescape\")\n        .getAValueReachingSink()\n        .asExpr()\n        .(ImmutableLiteral)\n        .booleanValue() = false\n  )\nselect jinja2Call, \"Using jinja2 templates with autoescape=False can potentially allow XSS attacks.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Nested loops reusing iteration variable\n * @description Identifies nested loops where both inner and outer loops utilize the same iteration variable.\n *              This pattern can cause the inner loop to overwrite the outer loop's variable,\n *              resulting in unexpected behavior and diminished code maintainability.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\nfrom For innerLoop, For outerLoop, Variable sharedVar\nwhere \n  // Verify direct nesting relationship between loops\n  outerLoop.getBody().contains(innerLoop) and\n  // Confirm shared iteration variable usage in both loops\n  innerLoop.getTarget().defines(sharedVar) and\n  outerLoop.getTarget().defines(sharedVar) and\n  // Validate variable access outside inner loop scope\n  exists(Name varRef | \n    varRef.uses(sharedVar) and \n    outerLoop.contains(varRef) and \n_______________ // 补全条件\n  )\nselect innerLoop, \n  \"Nested for loop reuses iteration variable '\" + sharedVar.getId() + \n  \"' from enclosing $@.\", \n  outerLoop, \n  \"outer for loop\"",
    "output": "not innerLoop.contains(varRef)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/doc-string-ratio-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures docstring coverage percentage in Python files (docstring lines / total lines).",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Documentation coverage ratio\n * @description Measures docstring coverage percentage in Python files (docstring lines / total lines).\n *              Higher percentages indicate better documentation. Empty files are excluded.\n * @kind treemap\n * @id py/doc-string-ratio-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\n// Analyze Python modules with non-zero line counts\nfrom Module pyModule, ModuleMetrics metrics\nwhere \n  // Ensure metrics correspond to the module and file has content\n  metrics = pyModule.getMetrics() and \n  metrics.getNumberOfLines() > 0\nselect \n  pyModule,\n  // Calculate documentation coverage percentage\n  (100.0 * \n    (metrics.getNumberOfLinesOfDocStrings().(float) / \n     metrics.getNumberOfLines().(float))) as documentationPercentage\norder by \n  documentationPercentage desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/zipslip]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects unsafe archive extraction where malicious file paths containing '..'",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file access during archive extraction (\"Zip Slip\")\n * @description Detects unsafe archive extraction where malicious file paths containing '..' \n *              could bypass destination directory restrictions, leading to unauthorized \n *              file system access.\n * @kind path-problem\n * @id py/zipslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.semmle.python.security.ZipSlip\nimport ZipSlipFlow::PathGraph\n\n// Identify vulnerable path flows from archive entry to file operation\nfrom ZipSlipFlow::PathNode sourceNode, ZipSlipFlow::PathNode targetNode\nwhere ZipSlipFlow::flowPath(sourceNode, targetNode)\n\n// Report vulnerability details with path context\nselect sourceNode.getNode(), sourceNode, targetNode,\n  \"This unsanitized archive entry, which may contain '..', is used in a $@.\", targetNode.getNode(),\n  \"file system operation\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/syntax-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python syntax errors that lead to runtime failures and hinder effective code analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Syntax error\n * @description Detects Python syntax errors that lead to runtime failures and hinder effective code analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import the necessary Python module for performing code analysis and querying\nimport python\n\n// Identify syntax errors in Python code\nfrom SyntaxError syntaxIssue\n// Filter out encoding-related errors\nwhere not syntaxIssue instanceof EncodingError\n// Return the syntax error instance with a detailed message including Python version\nselect syntaxIssue, syntaxIssue.getMessage() + \" (in Python \" + major_version() + \").\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Co-committed Files Analysis\n * @description Measures the average quantity of extra files altered in commits \n *              that also modify a particular file. This metric helps discover \n *              files that are often changed concurrently, suggesting possible \n *              relationships or dependencies between them.\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Helper function that determines the count of files modified in a given commit\nint computeFilesAffectedInCommit(Commit commitObj) { \n    result = count(commitObj.getAnAffectedFile()) \n}\n\n// Main analysis: examine modules with line count statistics\nfrom Module analyzedModule\nwhere exists(analyzedModule.getMetrics().getNumberOfLinesOfCode())\nselect analyzedModule,\n  // Compute the mean number of co-modified files for each module\n  avg(Commit commitInstance, int coChangedFilesCount |\n    // Identify commits that modify the module's file and calculate co-change count\n    commitInstance.getAnAffectedFile() = analyzedModule.getFile() and \n    coChangedFilesCount = computeFilesAffectedInCommit(commitInstance) - 1\n  |\n    coChangedFilesCount\n  )",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-low-iteration-count]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies key derivation functions with insufficient iteration counts.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use iteration count at least 100k to prevent brute force attacks\n * @description Identifies key derivation functions with insufficient iteration counts.\n * Cryptographic keys derived from user inputs (like passwords) must use a high iteration count\n * (minimum 100,000 iterations) to mitigate brute force attacks.\n *\n * Flags two potential issues:\n * 1. Explicit iteration count below 100,000 threshold\n * 2. Iteration count source that cannot be statically verified\n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import standard Python analysis library\nimport python\n// Import experimental cryptography concepts for key derivation operations\nimport experimental.cryptography.Concepts\n// Import utility functions for cryptography analysis, aliased as CryptoUtils\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Select key derivation operations with insufficient iteration counts\nfrom KeyDerivationOperation kdfOperation, string warningMessage, DataFlow::Node iterationSource\nwhere\n  // Focus on operations requiring iteration configuration\n  kdfOperation.requiresIteration() and\n  // Identify the source of iteration count configuration\n  iterationSource = kdfOperation.getIterationSizeSrc() and\n  (\n    // Case 1: Explicitly defined iteration count below threshold\n    iterationSource.asExpr() instanceof IntegerLiteral and\n    iterationSource.asExpr().(IntegerLiteral).getValue() < 100000 and\n    warningMessage = \"Insufficient iteration count detected. \"\n    or\n    // Case 2: Iteration count cannot be statically verified\n    not iterationSource.asExpr() instanceof IntegerLiteral and\n    warningMessage = \"Iteration count cannot be statically verified. \"\n  )\nselect \n  // Report the key derivation operation with appropriate warning message\n  kdfOperation, warningMessage + \"Minimum required iteration count is 100000. Configuration source: $@\",\n  iterationSource.asExpr(), iterationSource.asExpr().toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mostly-similar-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies modules exhibiting substantial code similarity. Variable names and types may differ between modules. Consider consolidating similar modules to enhance maintainability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Substantial module similarity detection\n * @description Identifies modules exhibiting substantial code similarity. Variable names and types may differ between modules. Consider consolidating similar modules to enhance maintainability.\n * @kind problem\n * @problem.severity recommendation\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @sub-severity low\n * @precision high\n * @id py/mostly-similar-file\n */\n\nimport python\n\n// Define source and target modules with similarity details\nfrom Module srcModule, \n     Module tgtModule, \n     string similarityDetail\nwhere \n  // Placeholder condition (no actual filtering implemented)\n  none()\nselect \n  srcModule, \n  similarityDetail, \n  tgtModule, \n  tgtModule.getName()  // Display the name of the target module"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-recent-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：统计过去180天内非人工提交的代码变更数量",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 近期变更分析\n * @description 统计过去180天内非人工提交的代码变更数量\n * @kind treemap\n * @id py/historical-number-of-recent-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\nimport python // 导入Python语言分析库\nimport external.VCS // 导入外部版本控制系统(VCS)分析库\n\n// 从提交历史中筛选符合条件的记录\nfrom Commit commitRecord\n// 应用过滤条件：排除人工变更且时间在阈值内\nwhere \n  not artificialChange(commitRecord) and \n  commitRecord.daysToNow() <= 180\n// 输出修订名称和计数（用于聚合统计）\nselect commitRecord.getRevisionName(), 1"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-number-class-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测类实例化时传入参数数量与构造函数（__init__方法）定义不匹配的情况。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 错误的类实例化参数数量\n * @description 检测类实例化时传入参数数量与构造函数（__init__方法）定义不匹配的情况。\n *              当实例化类时传递的参数数量不符合构造函数的要求，程序会在运行时抛出TypeError异常。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call instanceCall, ClassValue targetClass, string errorDescription, string constraintDescription, int expectedCount, FunctionValue constructor\nwhere\n  // 获取目标类的构造函数（通常是__init__方法）\n  constructor = get_function_or_initializer(targetClass) and\n  (\n    // 检查参数数量超过上限的情况\n    too_many_args(instanceCall, targetClass, expectedCount) and\n    errorDescription = \"too many arguments\" and\n    constraintDescription = \"no more than \"\n    or\n    // 检查参数数量低于下限的情况\n    too_few_args(instanceCall, targetClass, expectedCount) and\n    errorDescription = \"too few arguments\" and\n    constraintDescription = \"no fewer than \"\n  )\nselect instanceCall, \n  \"Call to $@ with \" + errorDescription + \"; should be \" + constraintDescription + expectedCount.toString() + \".\", \n  constructor,\n  // 输出调用点、错误消息及构造函数的完全限定名\n  constructor.getQualifiedName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Detection of TODO comments\n_______________ // 补全条件\n *              typically indicate incomplete code, pending features, or areas\n *              requiring further attention during development.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n *       external/cwe/cwe-546\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/todo-comment\n */\n\nimport python\n\nfrom Comment commentWithTodo\nwhere \n  commentWithTodo.getText().matches(\"%TODO%\") or \n  commentWithTodo.getText().matches(\"%TO DO%\")\nselect commentWithTodo, commentWithTodo.getText()",
    "output": "* @description Identifies comments containing 'TODO' or 'TO DO' markers, which"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Timing Attack Vulnerability in Hash Verification\n * @description Detects potential timing attacks when verifying cryptographic hashes.\n *              Non-constant-time comparisons enable attackers to forge valid hashes\n *              through timing side-channels if they can submit verification requests.\n *              Successful exploitation may result in authentication bypass.\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/timing-attack-against-hash\n * @tags security\n *       external/cwe/cwe-208\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * Configuration module for tracking data flow from cryptographic operations\n_______________ // 补全条件\n */\nprivate module CryptoTimingAnalysisConfig implements DataFlow::ConfigSig {\n  // Define cryptographic operation outputs as data flow sources\n  predicate isSource(DataFlow::Node hashOutputSource) { \n    hashOutputSource instanceof ProduceCryptoCall \n  }\n\n  // Define non-constant-time comparisons as data flow sinks\n  predicate isSink(DataFlow::Node timingVulnerableSink) { \n    timingVulnerableSink instanceof NonConstantTimeComparisonSink \n  }\n}\n\n// Global taint tracking module using the configuration\nmodule CryptoTimingAnalysisFlow = TaintTracking::Global<CryptoTimingAnalysisConfig>;\n\nimport CryptoTimingAnalysisFlow::PathGraph\n\n// Query to identify timing attack paths involving user input\nfrom CryptoTimingAnalysisFlow::PathNode sourceNode, CryptoTimingAnalysisFlow::PathNode sinkNode\nwhere\n  // Data flow path exists from cryptographic operation to comparison\n  CryptoTimingAnalysisFlow::flowPath(sourceNode, sinkNode) and\n  // Comparison operation involves user-controllable input\n  sinkNode.getNode().(NonConstantTimeComparisonSink).includesUserInput()\nselect \n  sinkNode.getNode(), \n  sourceNode, \n  sinkNode, \n  \"Timing attack against $@ validation.\", \n  sourceNode.getNode().(ProduceCryptoCall).getResultType(), \n  \"message\"",
    "output": "* to equality comparisons that are vulnerable to timing attacks."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Superclass attribute shadows subclass method\n * @description 当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 检测子类中定义的方法是否被父类中的属性所遮蔽\n * 这种情况会导致方法调用被属性覆盖，可能引发意外行为\n_______________ // 补全条件\n\n/* 聚焦于在父类构造函数中定义的属性 */\nimport python\n\n// 判断子类方法是否被父类属性遮蔽\npredicate isMethodShadowedBySuperAttribute(\n  ClassObject subClass, ClassObject superClass, Assign attrAssignment, FunctionObject shadowedMethod\n) {\n  // 确认继承关系：subClass 继承自 superClass\n  subClass.getASuperType() = superClass and\n  // 子类声明了 shadowedMethod 作为其属性\n  subClass.declaredAttribute(_) = shadowedMethod and\n  // 检查父类构造函数中是否存在同名属性赋值\n  exists(FunctionObject initMethod, Attribute assignedAttr |\n    // 父类定义了 __init__ 方法\n    superClass.declaredAttribute(\"__init__\") = initMethod and\n    // 属性赋值的目标是 assignedAttr\n    assignedAttr = attrAssignment.getATarget() and\n    // 属性赋值对象是 self\n    assignedAttr.getObject().(Name).getId() = \"self\" and\n    // 属性名称与子类方法名称相同\n    assignedAttr.getName() = shadowedMethod.getName() and\n    // 赋值操作发生在父类的构造函数中\n    attrAssignment.getScope() = initMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  /*\n   * 排除父类中也定义了同名方法的情况\n   * 这种情况下，我们认为是有意为之的设计\n   */\n  // 确保父类没有定义同名属性\n  not superClass.hasAttribute(shadowedMethod.getName())\n}\n\n// 从子类、父类、属性赋值和被遮蔽的方法中查询\nfrom ClassObject subClass, ClassObject superClass, Assign attrAssignment, FunctionObject shadowedMethod\n// 应用谓词进行筛选\nwhere isMethodShadowedBySuperAttribute(subClass, superClass, attrAssignment, shadowedMethod)\n// 选择被遮蔽方法的位置、错误信息、属性赋值位置和属性类型\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superClass.getName() +\n    \"'.\", attrAssignment, \"attribute\"",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-complex-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python classes with destructor methods (`__del__`) that have",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly complex `__del__` method\n * @description Detects Python classes with destructor methods (`__del__`) that have \n *              high cyclomatic complexity. Destructor methods in Python are called during\n *              object cleanup, which can happen at unpredictable times or might be bypassed\n *              in certain situations. Complex destructors may lead to performance problems\n *              and unpredictable behavior during garbage collection. It's recommended to keep\n *              these special methods as simple as possible.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python\n\nfrom FunctionValue delMethod\nwhere\n  // Ensure the method is defined as a destructor (__del__) in some class\n  exists(ClassValue ownerClass | \n    ownerClass.declaredAttribute(\"__del__\") = delMethod\n  )\n  and\n  // Check if the cyclomatic complexity exceeds the recommended threshold\n  delMethod.getScope()\n      .getMetrics()\n      .getCyclomaticComplexity() > 3\nselect delMethod, \"Overly complex '__del__' method.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-statements-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Analyzes Python codebases to calculate and visualize the quantity of statements",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of statements\n * @description Analyzes Python codebases to calculate and visualize the quantity of statements \n *              within each module. This metric helps identify overly complex files that may \n *              require refactoring to improve maintainability and readability.\n * @kind treemap\n * @id py/number-of-statements-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python // Import Python language library for analyzing Python code structure\n\n// Define query result variables: source code module and its statement count\nfrom Module pythonModule, int stmtCount\n// Calculate the total number of statements in each module\nwhere \n    // Aggregate computation: count all statements that belong to the current module\n    stmtCount = count(Stmt stmt | stmt.getEnclosingModule() = pythonModule)\n// Return result set: module object and its corresponding statement count, sorted in descending order by statement count\nselect pythonModule, stmtCount order by stmtCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-misconfiguration-with-credentials]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Disabling or weakening Same-Origin Policy (SOP) protection may expose",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name CORS Misconfiguration with Credentials\n * @description Disabling or weakening Same-Origin Policy (SOP) protection may expose\n *              the application to CORS attacks when credentials are allowed.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n// 检查来源配置是否包含通配符或空值\npredicate hasWildcardOrigin(DataFlow::Node originSetting) {\n  // 情况1：来源配置是列表且包含 \"*\" 或 \"null\" 元素\n  originSetting.asExpr() instanceof List and\n  exists(StringLiteral literal |\n    literal = originSetting.asExpr().getASubExpression() and\n    literal.getText() in [\"*\", \"null\"]\n  )\n  // 情况2：来源配置直接是 \"*\" 或 \"null\" 字符串\n  or\n  exists(StringLiteral literal |\n    literal = originSetting.asExpr() and\n    literal.getText() in [\"*\", \"null\"]\n  )\n}\n\n// 验证中间件是否为 CORS 类型\npredicate isCorsMiddlewareType(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n// 检查中间件是否启用了凭证支持\npredicate supportsCredentials(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getCredentialsAllowed().asExpr() instanceof True\n}\n\n// 查询存在安全风险的 CORS 中间件配置\nfrom Http::Server::CorsMiddleware corsMiddleware\nwhere\n  // 条件组合：确认中间件类型 + 启用凭证 + 使用通配符来源\n  isCorsMiddlewareType(corsMiddleware) and\n  supportsCredentials(corsMiddleware) and\n  hasWildcardOrigin(corsMiddleware.getOrigins().getALocalSource())\nselect corsMiddleware,\n  // 安全风险说明：允许任意来源的认证请求可能导致敏感数据泄露\n  \"This CORS middleware configuration allows authenticated cross-origin requests from any source, potentially exposing sensitive data\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies situations where an attribute defined in a superclass's __init__ method",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description Identifies situations where an attribute defined in a superclass's __init__ method \n *              has the same name as a method in a subclass, rendering the method inaccessible.\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * This analysis detects methods in subclasses that are hidden by attribute assignments \n * with identical names in the superclass's __init__ method. This shadowing can cause \n * runtime errors when trying to invoke the obscured method.\n */\n\nimport python\n\n// Predicate identifying subclass methods hidden by superclass attributes\npredicate method_hidden_by_super_attribute(\n  ClassObject childClass, ClassObject parentClass, Assign obscuringAssignment, FunctionObject obscuredMethod\n) {\n  // Establish inheritance relationship between classes\n  childClass.getASuperType() = parentClass and\n  // Confirm the subclass contains the method being hidden\n  childClass.declaredAttribute(_) = obscuredMethod and\n  // Find the superclass __init__ method where the hiding occurs\n  exists(FunctionObject baseInit |\n    parentClass.declaredAttribute(\"__init__\") = baseInit and\n    // Ensure the assignment happens within the __init__ method's scope\n    obscuringAssignment.getScope() = baseInit.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  // Identify the attribute assignment causing the hiding\n  exists(Attribute targetAttr |\n    targetAttr = obscuringAssignment.getATarget() and\n    // Verify the attribute is assigned to 'self' (instance attribute)\n    targetAttr.getObject().(Name).getId() = \"self\" and\n    // Match the attribute name with the hidden method's name\n    targetAttr.getName() = obscuredMethod.getName()\n  ) and\n  // Exclude cases where the superclass defines the same method (normal override)\n  not parentClass.hasAttribute(obscuredMethod.getName())\n}\n\n// Query to find hidden methods and their hiding attributes\nfrom ClassObject childClass, ClassObject parentClass, Assign obscuringAssignment, FunctionObject obscuredMethod\nwhere method_hidden_by_super_attribute(childClass, parentClass, obscuringAssignment, obscuredMethod)\n// Output: hidden method location, detailed message, hiding attribute location\nselect obscuredMethod.getOrigin(),\n  \"Method '\" + obscuredMethod.getName() + \"' is hidden by an $@ in superclass '\" + parentClass.getName() +\n    \"', preventing normal access to the method.\", obscuringAssignment, \"attribute assignment\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-randomness]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies security-sensitive operations using cryptographically weak",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insecure randomness\n * @description Identifies security-sensitive operations using cryptographically weak \n *              pseudo-random number generators, enabling attackers to predict generated\n *              values and compromise system security.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// Import core Python analysis capabilities\nimport python\n\n// Import specialized security module for insecure randomness detection\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Import data flow tracking framework\nimport semmle.python.dataflow.new.DataFlow\n\n// Import path graph visualization components\nimport InsecureRandomness::Flow::PathGraph\n\n// Query detects data flows from weak random sources to security-sensitive contexts\nfrom \n  InsecureRandomness::Flow::PathNode weakRandomSource,    // Origin of insecure random value\n  InsecureRandomness::Flow::PathNode securitySensitiveSink // Security-critical usage point\nwhere \n  // Verify data flow path exists between source and sink\n  InsecureRandomness::Flow::flowPath(weakRandomSource, securitySensitiveSink)\nselect \n  securitySensitiveSink.getNode(),                      // Target location of insecure usage\n  weakRandomSource,                                      // Origin node for path tracking\n  securitySensitiveSink,                                 // Sink node for visualization\n  \"Cryptographically insecure $@ in security context.\", // Alert description\n  weakRandomSource.getNode(),                           // Reference node for alert message\n  \"random value\"                                        // Description of vulnerable element"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/function-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：该查询通过分析Python代码中的函数定义，建立函数实体与其源码文件位置的映射关系。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python函数源码位置映射\n * @description 该查询通过分析Python代码中的函数定义，建立函数实体与其源码文件位置的映射关系。\n *              这有助于代码审计和源码导航，使开发者能够快速定位函数定义在源文件中的具体位置。\n * @kind source-link\n * @id py/function-source-links\n * @metricType callable\n */\n\nimport python\n\n// 从Python代码中提取函数定义及其源文件位置\nfrom Function func, Location loc\nwhere loc = func.getLocation()\nselect func, loc.getFile()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Deserialization of user-controlled data\n * @description Deserializing user-controlled data may allow attackers to execute arbitrary code.\n * @kind path-problem\n * @id py/unsafe-deserialization\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @tags external/cwe/cwe-502\n *       security\n *       serialization\n */\n\n// 导入Python库，用于分析Python代码\nimport python\n\n// 导入与不安全反序列化相关的查询模块\nimport semmle.python.security.dataflow.UnsafeDeserializationQuery\n\n// 导入路径图类，用于表示数据流路径\nimport UnsafeDeserializationFlow::PathGraph\n\n// 从路径图中选择源节点和汇节点\nfrom UnsafeDeserializationFlow::PathNode source, UnsafeDeserializationFlow::PathNode sink\n_______________ // 补全条件\nwhere UnsafeDeserializationFlow::flowPath(source, sink)\n// 选择结果：汇节点、源节点、汇节点信息、描述信息、源节点信息、用户输入值\nselect sink.getNode(), source, sink, \"Unsafe deserialization depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
    "output": "// 条件：存在从源节点到汇节点的数据流路径"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commented-out-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code segments that were commented out during development.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commented-out code\n * @description Detects code segments that were commented out during development. \n *              This practice often leads to decreased code clarity and maintenance\n *              difficulties, as inactive code accumulates and potentially confuses\n *              developers about the intended functionality.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code */\n\n// Import necessary modules for Python code analysis\nimport python\n\n// Import the CommentedOutCode class from the Lexical module for comment analysis\nimport Lexical.CommentedOutCode\n\n// Main query logic to identify problematic commented code segments\nfrom CommentedOutCodeBlock commentedCodeSegment\n// Filter out legitimate examples or documentation comments to reduce false positives\nwhere not commentedCodeSegment.maybeExampleCode()\n// Output the identified commented code segments with an appropriate alert message\nselect commentedCodeSegment, \"This comment appears to contain commented-out code.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insufficient KDF Salt Size\n * @description Key Derivation Function (KDF) salts must be at least 128 bits (16 bytes) in length.\n *\n * This rule identifies two types of issues:\n * 1. When a salt size configuration is less than the required 128 bits\n * 2. When the salt size cannot be statically determined at analysis time\n * \n * The rule specifically checks for salt configurations using os.urandom() calls.\n * @kind problem\n * @id py/kdf-small-salt-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\n// Identify KDF operations with problematic salt configurations\nfrom KeyDerivationOperation kdfOp, DataFlow::Node saltSizeNode, API::CallNode urandomCall, string alertMessage\nwhere\n_______________ // 补全条件\n  kdfOp.requiresSalt() and\n  \n  // Confirm salt source is an os.urandom() call\n  urandomCall = kdfOp.getSaltConfigSrc() and\n  urandomCall = API::moduleImport(\"os\").getMember(\"urandom\").getACall() and\n  \n  // Trace the salt size parameter to its source\n  saltSizeNode = Utils::getUltimateSrcFromApiNode(urandomCall.getParameter(0, \"size\")) and\n  \n  // Detect two distinct salt configuration issues\n  (\n    // Case 1: Salt size is not statically determinable\n    not exists(saltSizeNode.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Salt config is not a statically verifiable size. \"\n    or\n    // Case 2: Salt size is below minimum requirement\n    saltSizeNode.asExpr().(IntegerLiteral).getValue() < 16 and\n    alertMessage = \"Salt config is insufficiently large. \"\n  )\n\n// Report findings with contextual information\nselect kdfOp,\n  alertMessage + \"Salt size must be a minimum of 16 (bytes). os.urandom Config: $@, Size Config: $@\", \n  urandomCall,\n  urandomCall.toString(), \n  saltSizeNode, \n  saltSizeNode.toString()",
    "output": "// Verify the KDF operation requires salt configuration"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of parameters without defaults\n * @description The number of parameters of a function that do not have default values defined.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // 导入Python模块，提供分析Python代码的基础功能\n_______________ // 补全条件\n// 查询每个函数的参数数量（不包括有默认值的参数）\nfrom FunctionMetrics functionObj\nselect \n    functionObj, \n    functionObj.getNumberOfParametersWithoutDefault() as paramCount \norder by paramCount desc\n// 按照无默认值参数数量降序排列结果，便于识别参数最多的函数",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Remote Input Taint Propagation\n * @description Detects code elements that can be influenced by remote user inputs through taint analysis.\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/alerts/remote-input-taint-propagation\n * @tags meta\n * @precision very-low\n */\n\n// Core Python language imports\nprivate import python\n// Data flow analysis framework\nprivate import semmle.python.dataflow.new.DataFlow\n// Taint tracking capabilities\nprivate import semmle.python.dataflow.new.TaintTracking\n// Remote flow source definitions\nprivate import semmle.python.dataflow.new.RemoteFlowSources\n// Meta metrics utilities\nprivate import meta.MetaMetrics\n// Internal print node handling\nprivate import semmle.python.dataflow.new.internal.PrintNode\n\n// Configuration for tracking taint propagation from remote inputs\n_______________ // 补全条件\n  // Define valid source nodes for taint analysis\n  predicate isSource(DataFlow::Node inputSource) {\n    // Sources must originate from remote flow sources and not be in ignored files\n    inputSource instanceof RemoteFlowSource and\n    not inputSource.getLocation().getFile() instanceof IgnoredFile\n  }\n\n  // Define valid sink nodes for taint analysis\n  predicate isSink(DataFlow::Node targetSink) {\n    // Sinks must not be located in ignored files\n    not targetSink.getLocation().getFile() instanceof IgnoredFile\n    // Optimization note: Sink reduction was evaluated (limiting to localFlowStep/readStep/storeStep)\n    // but resulted in only ~40% reduction with increased maintenance overhead\n  }\n}\n\n// Global taint tracking module based on remote input configuration\nmodule RemoteInputTaintTracking = TaintTracking::Global<RemoteInputTaintConfig>;\n\n// Main query to identify all nodes contaminated by remote input sources\nfrom DataFlow::Node contaminatedNode\nwhere RemoteInputTaintTracking::flow(_, contaminatedNode)\nselect contaminatedNode, prettyNode(contaminatedNode)",
    "output": "module RemoteInputTaintConfig implements DataFlow::ConfigSig {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Uncontrolled command line\n * @description Using externally controlled strings in a command line may allow a malicious\n *              user to change the meaning of the command.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/command-line-injection\n * @tags correctness\n *       security\n *       external/cwe/cwe-078\n *       external/cwe/cwe-088\n */\n\n_______________ // 补全条件\nimport python\n\n// 导入安全数据流分析库，用于检测命令注入问题\nimport semmle.python.security.dataflow.CommandInjectionQuery\n\n// 导入命令注入路径图类，用于表示数据流路径\nimport CommandInjectionFlow::PathGraph\n\n// 从命令注入路径图中选择源节点和汇节点\nfrom CommandInjectionFlow::PathNode source, CommandInjectionFlow::PathNode sink\n// 条件：存在从源节点到汇节点的路径\nwhere CommandInjectionFlow::flowPath(source, sink)\n// 选择汇节点、源节点、路径信息以及描述信息\nselect sink.getNode(), source, sink, \"This command line depends on a $@.\", source.getNode(),\n  // 描述信息：该命令行依赖于用户提供的值\n  \"user-provided value\"",
    "output": "// 导入Python库，用于分析Python代码"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/flask-debug]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：在调试模式下运行 Flask 应用程序可能允许攻击者通过 Werkzeug 调试器执行任意代码。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Flask 应用以调试模式运行\n * @description 在调试模式下运行 Flask 应用程序可能允许攻击者通过 Werkzeug 调试器执行任意代码。\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/flask-debug\n * @tags security\n *       external/cwe/cwe-215\n *       external/cwe/cwe-489\n */\n\nimport python  // Python 代码分析的基础库\nimport semmle.python.dataflow.new.DataFlow  // 提供数据流分析能力\nimport semmle.python.ApiGraphs  // API 调用图分析支持\nimport semmle.python.frameworks.Flask  // Flask 框架特定分析\n\n// 查找所有以调试模式运行的 Flask 应用\nfrom API::CallNode flaskRunCall, ImmutableLiteral debugFlag\nwhere\n  // 确认是 Flask 应用实例的 run 方法调用\n  flaskRunCall = Flask::FlaskApp::instance().getMember(\"run\").getACall() and\n  // 检查 debug 参数是否显式设置为 true\n  debugFlag = flaskRunCall.getParameter(2, \"debug\").getAValueReachingSink().asExpr() and\n  debugFlag.booleanValue() = true\nselect flaskRunCall,\n  // 报告发现的安全问题\n  \"检测到 Flask 应用以调试模式运行。这可能导致攻击者通过调试器执行任意代码。\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-randomness]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of cryptographically weak pseudo-random number generators",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insecure randomness\n * @description Detects usage of cryptographically weak pseudo-random number generators\n *              for security-sensitive values, enabling attackers to predict generated values.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// Core Python analysis libraries\nimport python\n\n// Specialized module for insecure randomness detection\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Data flow tracking capabilities\nimport semmle.python.dataflow.new.DataFlow\n\n// Path graph representation for security flows\nimport InsecureRandomness::Flow::PathGraph\n\n// Query identifying insecure random value flows to security-sensitive contexts\nfrom InsecureRandomness::Flow::PathNode insecureRandomSource, \n     InsecureRandomness::Flow::PathNode securitySensitiveSink\nwhere \n  // Data flow path exists between insecure source and sensitive sink\n  InsecureRandomness::Flow::flowPath(insecureRandomSource, securitySensitiveSink)\nselect \n  securitySensitiveSink.getNode(),\n  insecureRandomSource,\n  securitySensitiveSink,\n  \"Cryptographically insecure $@ used in security-sensitive context.\",\n  insecureRandomSource.getNode(),\n  \"random value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/dependency-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：外部依赖源链接",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name 外部依赖源链接\n * @kind source-link\n * @metricType externalDependency\n * @id py/dependency-source-links\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 此查询为外部依赖关系创建源链接映射。\n * \n * 背景：依赖实体表示为'/file/path<|>dependency'格式，其中\n * /file/path是源代码存档根目录的相对路径，未绑定到特定版本。\n * 我们需要File实体(输出第二列)以便在仪表板数据库中通过\n * ExternalEntity.getASourceLink()方法恢复源链接信息。\n * \n * 查询逻辑概述：\n * - 遍历所有源文件与外部包之间的引用关系\n * - 为每个依赖关系生成唯一标识符\n * - 返回依赖标识符及其关联的源文件\n */\n\nfrom File srcFile, string depId\nwhere\n  exists(PackageObject pkg, AstNode refNode |\n    // 步骤1: 确认代码节点引用了外部包\n    dependency(refNode, pkg) and\n    \n    // 步骤2: 验证引用节点位于当前源文件中\n    refNode.getLocation().getFile() = srcFile and\n    \n    // 步骤3: 生成依赖实体标识符，组合源文件与包信息\n    depId = munge(srcFile, pkg)\n  )\nselect depId, srcFile"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'super' in old style class\n * @description Detects incorrect usage of super() in legacy class definitions that lack proper inheritance support.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * Locates super() function invocations within methods of legacy class definitions.\n * \n * This predicate identifies super() calls that are destined to fail at execution time\n * due to the absence of proper inheritance mechanisms in old-style classes.\n */\npredicate superCallInOldClass(Call superCall) {\n  // Validate that the invocation targets the built-in super function\n_______________ // 补全条件\n  // Examine the surrounding context of the super() call\n  exists(Function methodInClass |\n    // The super() call must be located within a method definition\n    superCall.getScope() = methodInClass and\n    // This method must be nested inside an old-style class\n    exists(ClassObject parentClass |\n      // Establish the relationship between method and containing class\n      methodInClass.getScope() = parentClass.getPyClass() and\n      // Ensure the class type inference was successful\n      not parentClass.failedInference() and\n      // Verify the class uses old-style conventions (doesn't inherit from object)\n      not parentClass.isNewStyle()\n    )\n  )\n}\n\n// Primary query to identify problematic super() invocations\nfrom Call problematicSuperCall\n// Apply filter to isolate super() calls within old-style class contexts\nwhere superCallInOldClass(problematicSuperCall)\n// Generate alert with descriptive message for each identified issue\nselect problematicSuperCall, \"'super()' will not work in old-style classes.\"",
    "output": "superCall.getFunc().(Name).getId() = \"super\" and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mutable-descriptor]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects mutations within descriptor protocol methods that can cause shared state issues.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Detects mutations within descriptor protocol methods that can cause shared state issues.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Identifies descriptor classes containing mutation operations in protocol methods\npredicate has_descriptor_mutation(ClassObject descriptorClass, SelfAttributeStore mutationOperation) {\n  // Verify class implements descriptor protocol\n  descriptorClass.isDescriptorType() and\n  // Find descriptor protocol methods (__get__/__set__/__delete__)\n  exists(PyFunctionObject protocolMethod, string methodName |\n    descriptorClass.lookupAttribute(methodName) = protocolMethod and\n    (methodName = \"__get__\" or methodName = \"__set__\" or methodName = \"__delete__\") and\n    // Locate methods invoked by descriptor protocol methods\n    exists(PyFunctionObject invokedMethod |\n      // Invoked method belongs to the same descriptor class\n      descriptorClass.lookupAttribute(_) = invokedMethod and\n      // Trace call chain from protocol method to invoked method\n      protocolMethod.getACallee*() = invokedMethod and\n      // Exclude initialization methods from analysis\n      not invokedMethod.getName() = \"__init__\" and\n      // Mutation occurs within the invoked method's scope\n      mutationOperation.getScope() = invokedMethod.getFunction()\n    )\n  )\n}\n\n// Identify descriptor classes and their mutation operations\nfrom ClassObject descriptorClass, SelfAttributeStore mutationOperation\nwhere has_descriptor_mutation(descriptorClass, mutationOperation)\n// Output mutation location with warning message and class details\nselect mutationOperation,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorClass, descriptorClass.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/efferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the count of external classes that a given class relies on.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class Efferent Coupling Analysis\n * @description Measures the count of external classes that a given class relies on.\n * @kind treemap\n * @id py/efferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags testability\n *       modularity\n */\n\nimport python\n\n// 分析每个类的外部依赖数量\nfrom ClassMetrics analyzedClass\nselect analyzedClass, \n       analyzedClass.getEfferentCoupling() as dependencyCount \norder by dependencyCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/local-shadows-builtin]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Defining a local variable with the same name as a built-in object",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Builtin shadowed by local variable\n * @description Defining a local variable with the same name as a built-in object\n *              makes the built-in object unusable within the current scope and makes the code\n *              more difficult to read.\n * @kind problem\n * @tags maintainability\n *       readability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/local-shadows-builtin\n */\n\nimport python\nimport Shadowing\nimport semmle.python.types.Builtins\n\n// 定义一个谓词函数，用于判断给定的名称是否在允许列表中。\npredicate allow_list(string name) {\n  name in [\n      /* 这些很少使用，因此不太可能引起混淆 */\n      \"iter\", \"next\", \"input\", \"file\", \"apply\", \"slice\", \"buffer\", \"coerce\", \"intern\", \"exit\",\n      \"quit\", \"license\",\n      /* 这些名称较短且/或难以避免 */\n      \"dir\", \"id\", \"max\", \"min\", \"sum\", \"cmp\", \"chr\", \"ord\", \"bytes\", \"_\",\n    ]\n}\n\n// 定义一个谓词函数，用于判断某个名称是否在当前作用域内被局部变量遮蔽。\npredicate shadows(Name d, string name, Function scope, int line) {\n  exists(LocalVariable l |\n    d.defines(l) and // 检查名称定义了一个局部变量\n    l.getId() = name and // 检查局部变量的名称与给定名称相同\n    exists(Builtin::builtin(l.getId())) // 检查该名称是一个内置对象\n  ) and\n  d.getScope() = scope and // 检查名称的作用域\n  d.getLocation().getStartLine() = line and // 检查名称的定义行号\n  not allow_list(name) and // 检查名称不在允许列表中\n  not optimizing_parameter(d) // 检查名称不是优化参数\n}\n\n// 定义一个谓词函数，用于判断某个名称是否是第一次在当前作用域内被局部变量遮蔽。\npredicate first_shadowing_definition(Name d, string name) {\n  exists(int first, Scope scope |\n    shadows(d, name, scope, first) and // 检查名称在当前作用域内被局部变量遮蔽\n    first = min(int line | shadows(_, name, scope, line)) // 获取第一次遮蔽的行号\n  )\n}\n\n// 查询语句：查找所有在当前作用域内被局部变量遮蔽的内置对象。\nfrom Name d, string name\nwhere first_shadowing_definition(d, name) // 条件：名称是第一次在当前作用域内被局部变量遮蔽\nselect d, \"Local variable \" + name + \" shadows a builtin variable.\" // 选择结果：返回遮蔽的局部变量及其信息"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name JWT encoding with empty key or algorithm\n * @description Identifies JWT token encoding operations that utilize empty cryptographic keys \n *              or algorithms, potentially introducing security vulnerabilities in token validation.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-empty-secret-or-algorithm\n * @tags security\n *       experimental\n */\n\n// Import Python analysis core libraries\nimport python\nimport experimental.semmle.python.Concepts\nimport experimental.semmle.python.frameworks.JWT\n_______________ // 补全条件\n// Detect JWT encoding calls with missing or null security parameters\nfrom JwtEncoding jwtEncodeCall, string vulnParam\nwhere\n  // Check for either empty algorithm or key in JWT encoding\n  exists(string param |\n    (\n      param = \"algorithm\" and isEmptyOrNone(jwtEncodeCall.getAlgorithm()) or\n      param = \"key\" and isEmptyOrNone(jwtEncodeCall.getKey())\n    ) and\n    vulnParam = param\n  )\nselect jwtEncodeCall, \"This JWT encoding uses an empty \" + vulnParam + \" parameter.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 此查询旨在评估指向关系在不同上下文深度层级中的分布模式与效率特征：\n * - 唯一浅层计数：仅在最小深度层级上存在的指向关系数量\n * - 总关系计数：在特定深度层级上出现的所有指向关系总和\n * - 浅层效率率：唯一浅层关系占总关系的百分比，用于衡量该层级指向关系的有效性\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 计算指定控制流节点、目标对象和类对象在指向上下文中的深度层级\nint calculateContextDepth(ControlFlowNode cfgNode, Object targetObj, ClassObject classObj) {\n  // 当存在指向上下文使节点在该上下文中指向对象并关联类对象时，返回该上下文的深度值\n  exists(PointsToContext ctx |\n    PointsTo::points_to(cfgNode, ctx, targetObj, classObj, _) and\n    result = ctx.getDepth()\n  )\n}\n\n// 获取控制流节点、对象和类对象的最小上下文深度\nint findMinimumContextDepth(ControlFlowNode cfgNode, Object targetObj, ClassObject classObj) {\n  // 返回所有可能深度值中的最小值\n  result = min(int depth | depth = calculateContextDepth(cfgNode, targetObj, classObj))\n}\n\n// 分析各深度层级指向关系的分布特征与效率指标\nfrom int currentDepth, \n     int uniqueShallowCount, \n     int totalRelationCount, \n     float shallowEfficiencyRate\nwhere\n  // 计算唯一浅层关系：最小深度等于当前深度层级的指向关系数量\n  uniqueShallowCount = strictcount(ControlFlowNode cfgNode, Object targetObj, ClassObject classObj |\n    currentDepth = findMinimumContextDepth(cfgNode, targetObj, classObj)\n  ) and\n  // 计算整体频次：深度等于当前深度层级的所有指向关系数量\n  totalRelationCount = strictcount(ControlFlowNode cfgNode, Object targetObj, ClassObject classObj, \n                              PointsToContext ctx, ControlFlowNode origin |\n    PointsTo::points_to(cfgNode, ctx, targetObj, classObj, origin) and\n    currentDepth = ctx.getDepth()\n  ) and\n  // 避免除以零的错误，确保整体频次大于零\n  totalRelationCount > 0 and\n_______________ // 补全条件\n  shallowEfficiencyRate = 100.0 * uniqueShallowCount / totalRelationCount\n// 输出深度层级、唯一浅层关系、整体频次和效率比率\nselect currentDepth, uniqueShallowCount, totalRelationCount, shallowEfficiencyRate",
    "output": "// 计算效率比率：唯一浅层关系占整体频次的百分比"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Nested loops reusing iteration variable\n * @description Identifies nested loops where inner and outer loops utilize the same iteration variable.\n *              This practice can cause the inner loop to overwrite the outer loop's variable,\n *              potentially leading to unintended behavior and reduced code maintainability.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\n// Checks if a loop statement uses the specified variable as its iteration target\npredicate isIterationVariable(For loopStmt, Variable iterVar) { \n  loopStmt.getTarget().defines(iterVar) \n}\n_______________ // 补全条件\n// Finds nested loops sharing an iteration variable where the variable is accessed\n// outside the inner loop's scope within the outer loop's context\npredicate nestedLoopWithSharedVar(For innerLoop, For outerLoop, Variable commonVar) {\n  // Ensure inner loop is directly nested within outer loop's body\n  outerLoop.getBody().contains(innerLoop) and\n  // Verify both loops use the same iteration variable\n  isIterationVariable(innerLoop, commonVar) and\n  isIterationVariable(outerLoop, commonVar) and\n  // Confirm variable usage in outer loop beyond inner loop's boundaries\n  exists(Name varUsage | \n    varUsage.uses(commonVar) and \n    outerLoop.contains(varUsage) and \n    not innerLoop.contains(varUsage)\n  )\n}\n\n// Query: Detect problematic nested loops with shared iteration variables\nfrom For innerForLoop, For outerForLoop, Variable iterationVariable\nwhere nestedLoopWithSharedVar(innerForLoop, outerForLoop, iterationVariable)\nselect innerForLoop, \n  \"Nested for loop reuses iteration variable '\" + iterationVariable.getId() + \n  \"' from enclosing $@.\", \n  outerForLoop, \n  \"outer for loop\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name URL redirection from remote source\n * @description URL redirection based on unvalidated user input\n *              may cause redirection to malicious web sites.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @sub-severity low\n * @id py/url-redirection\n * @tags security\n *       external/cwe/cwe-601\n * @precision high\n */\n\n// 引入Python语言分析支持库\nimport python\n\n// 引入URL重定向安全数据流分析模块\nimport semmle.python.security.dataflow.UrlRedirectQuery\n\n// 引入数据流路径图可视化模块\nimport UrlRedirectFlow::PathGraph\n_______________ // 补全条件\n// 查询主体：检测未经验证的URL重定向漏洞路径\nfrom UrlRedirectFlow::PathNode inputOriginNode, UrlRedirectFlow::PathNode redirectTargetNode\nwhere \n  // 确保存在从不可信输入源到重定向目标的数据流路径\n  UrlRedirectFlow::flowPath(inputOriginNode, redirectTargetNode)\nselect \n  // 输出重定向目标位置作为主要结果\n  redirectTargetNode.getNode(), \n  // 输出完整数据流路径用于可视化展示\n  inputOriginNode, redirectTargetNode, \n  // 提供描述性消息，标识漏洞依赖的输入源\n  \"Untrusted URL redirection depends on a $@.\", \n  inputOriginNode.getNode(), \n  \"user-provided value\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mostly-similar-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies modules with substantial code similarity. Differences in variable/type names suggest intentional duplication. Merging these modules improves maintainability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Mostly Similar Module Detection\n * @description Identifies modules with substantial code similarity. Differences in variable/type names suggest intentional duplication. Merging these modules improves maintainability.\n * @kind problem\n * @problem.severity recommendation\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @sub-severity low\n * @precision high\n * @id py/mostly-similar-file\n */\n\nimport python\n\nfrom\n  Module sourceModule,    // Primary module under analysis\n  Module targetModule,    // Module exhibiting high similarity\n  string alertMessage     // Descriptive alert notification\nwhere\n  none()                  // Placeholder condition (no active filtering)\nselect\n  sourceModule,\n  alertMessage,\n  targetModule,\n  targetModule.getName()  // Name of the similar module"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A module imports itself",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description A module imports itself\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n/**\n * Identifies modules that perform self-import operations\n * \n * This predicate detects scenarios where a Python module imports itself, either directly\n * or indirectly. Self-imports represent unnecessary code patterns that can introduce\n * circular dependencies and create maintenance difficulties in the codebase.\n * \n * Parameters:\n * - importDeclaration: The import statement being analyzed\n * - targetModule: The module value object that is being imported\n */\npredicate selfImportDetected(ImportingStmt importDeclaration, ModuleValue targetModule) {\n  // Core verification: ensure the enclosing module of the import statement\n  // corresponds to the scope of the imported module\n  importDeclaration.getEnclosingModule() = targetModule.getScope() and\n  // Utilize aggregation to identify the most appropriate module value\n  // Prioritize longest matching names to properly handle relative imports\n  targetModule = \n    max(string moduleName, ModuleValue potentialModule |\n      // Obtain the module name referenced in the import statement\n      moduleName = importDeclaration.getAnImportedModuleName() and\n      // Confirm that the candidate module is imported with this name\n      potentialModule.importedAs(moduleName)\n    |\n      // Sort by module name length in descending order to ensure longest match takes precedence\n      potentialModule order by moduleName.length() desc\n    )\n}\n\n// Primary query: Detect all instances of self-importing modules\n// \n// This query examines all import statements and applies the selfImportDetected predicate\n// to identify those that satisfy the self-import criteria, generating appropriate\n// warning messages for each detected instance.\nfrom ImportingStmt importDeclaration, ModuleValue targetModule\nwhere selfImportDetected(importDeclaration, targetModule)\nselect importDeclaration, \"The module '\" + targetModule.getName() + \"' imports itself.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Cookie construction from user-supplied input\n * @description Identifies cookie creation using untrusted user input,\n *              which could enable Cookie Poisoning attacks.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// Import core Python analysis library\nimport python\n\n// Import dataflow tracking for cookie injection vulnerabilities\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Import path representation for data flow visualization\nimport CookieInjectionFlow::PathGraph\n\n// Identify untrusted sources and cookie construction sinks\nfrom CookieInjectionFlow::PathNode untrustedSource, CookieInjectionFlow::PathNode cookieSink\nwhere CookieInjectionFlow::flowPath(untrustedSource, cookieSink)\n// Report findings with security context\nselect cookieSink.getNode(), untrustedSource, cookieSink,\n       \"Cookie constructed from $@.\", untrustedSource.getNode(),\n_______________ // 补全条件",
    "output": "\"untrusted user input\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Cookie construction from user-controlled data\n * @description Detects cookie poisoning vulnerabilities where cookies are built using \n *              untrusted user input, allowing attackers to manipulate cookie values\n *              and compromise application security.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// Import core Python analysis framework\nimport python\n\n// Import specialized cookie injection vulnerability detection module\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Import path graph utilities for data flow visualization\nimport CookieInjectionFlow::PathGraph\n\n// Identify tainted input sources and vulnerable cookie sinks\nfrom CookieInjectionFlow::PathNode taintedSource, CookieInjectionFlow::PathNode cookieSink\n// Verify data flow propagation from user input to cookie creation\nwhere CookieInjectionFlow::flowPath(taintedSource, cookieSink)\n// Generate vulnerability report with detailed flow information\nselect \n  cookieSink.getNode(), \n  taintedSource, \n  cookieSink, \n  \"Cookie is constructed from a $@.\", \n_______________ // 补全条件\n  \"user-controlled input\"",
    "output": "taintedSource.getNode(),"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * 分析指向关系的深度分布特征：\n * - 边界计数：在最浅深度层级上出现的唯一指向关系数量\n * - 总出现次数：在特定深度层级上的所有指向关系总数\n * - 效率比率：边界计数占总出现次数的比例，表示该深度层级的效率\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 获取指定控制流节点、对象值和类对象的上下文深度\nint getContextDepth(ControlFlowNode node, Object obj, ClassObject clsObj) {\n  // 当存在一个指向上下文，使得节点在该上下文中指向对象并关联类对象时，返回该上下文的深度\n  exists(PointsToContext context |\n    PointsTo::points_to(node, context, obj, clsObj, _) and\n    result = context.getDepth()\n  )\n}\n\n// 获取指定控制流节点、对象值和类对象的最浅上下文深度\nint getMinimumContextDepth(ControlFlowNode node, Object obj, ClassObject clsObj) {\n  // 返回所有可能深度的最小值\n  result = min(int depth | depth = getContextDepth(node, obj, clsObj))\n}\n\n// 分析各深度层级的指向关系特征\nfrom int boundaryCount, int totalOccurrences, int currentDepth, float efficiencyRatio\nwhere\n  // 计算边界计数：最浅深度等于当前深度层级的唯一指向关系数量\n  boundaryCount = strictcount(ControlFlowNode node, Object obj, ClassObject clsObj |\n    currentDepth = getMinimumContextDepth(node, obj, clsObj)\n  ) and\n  // 计算总出现次数：深度等于当前深度层级的所有指向关系数量\n  totalOccurrences = strictcount(ControlFlowNode node, Object obj, ClassObject clsObj, \n                          PointsToContext context, ControlFlowNode origin |\n    PointsTo::points_to(node, context, obj, clsObj, origin) and\n    currentDepth = context.getDepth()\n  ) and\n  // 计算效率比率：边界计数占总出现次数的百分比\n  totalOccurrences > 0 and  // 避免除以零\n  efficiencyRatio = 100.0 * boundaryCount / totalOccurrences\n// 输出深度层级、边界计数、总出现次数和效率比率\nselect currentDepth, boundaryCount, totalOccurrences, efficiencyRatio"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 分析指向关系在不同深度层级上的分布特征与效率指标：\n * - 唯一浅层指针：仅在最小深度层级上出现的指向关系数量\n * - 总体指针频次：在特定深度层级上出现的所有指向关系总和\n * - 指针效率：唯一浅层指针占总体指针频次的百分比，反映该层级指向关系的有效性\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 确定控制流节点、目标对象和类对象在指向上下文中的深度层级\nint calculateContextDepth(ControlFlowNode node, Object obj, ClassObject clsObj) {\n  // 当存在指向上下文使节点在该上下文中指向目标对象并关联类对象时，返回该上下文的深度值\n  exists(PointsToContext context |\n    PointsTo::points_to(node, context, obj, clsObj, _) and\n    result = context.getDepth()\n  )\n}\n\n// 获取控制流节点、对象和类对象的最小上下文深度值\nint getMinimumContextDepth(ControlFlowNode node, Object obj, ClassObject clsObj) {\n  // 返回所有可能深度值中的最小值\n  result = min(int depth | depth = calculateContextDepth(node, obj, clsObj))\n}\n\n// 分析各深度层级指向关系的分布特征与效率指标\nfrom int uniqueShallowPointers, int totalPointersAtDepth, int currentDepth, float pointerEfficiency\nwhere\n  // 计算唯一浅层指针：最小深度等于当前深度层级的指向关系数量\n  uniqueShallowPointers = strictcount(ControlFlowNode node, Object obj, ClassObject clsObj |\n    currentDepth = getMinimumContextDepth(node, obj, clsObj)\n  ) and\n  // 计算总体指针频次：深度等于当前深度层级的所有指向关系数量\n  totalPointersAtDepth = strictcount(ControlFlowNode node, Object obj, ClassObject clsObj, \n_______________ // 补全条件\n    PointsTo::points_to(node, context, obj, clsObj, origin) and\n    currentDepth = context.getDepth()\n  ) and\n  // 确保总体指针频次大于零，避免除以零错误\n  totalPointersAtDepth > 0 and\n  // 计算指针效率：唯一浅层指针占总体指针频次的百分比\n  pointerEfficiency = 100.0 * uniqueShallowPointers / totalPointersAtDepth\n// 输出深度层级、唯一浅层指针、总体指针频次和指针效率\nselect currentDepth, uniqueShallowPointers, totalPointersAtDepth, pointerEfficiency",
    "output": "PointsToContext context, ControlFlowNode origin |"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Complete server-side request forgery vulnerability\n * @description Detects HTTP requests where the entire URL is controlled by external input, enabling SSRF attacks\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision high\n * @id py/full-ssrf\n * @tags security\n *       external/cwe/cwe-918\n */\n_______________ // 补全条件\n// Import required Python analysis modules\nimport python\n// Import SSRF detection framework\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\n// Import path tracking for SSRF flows\nimport FullServerSideRequestForgeryFlow::PathGraph\n\n// Identify SSRF vulnerability paths with enhanced variable naming\nfrom\n  // Origin point of user-controlled data\n  FullServerSideRequestForgeryFlow::PathNode taintedSource,\n  // Destination point where tainted data reaches HTTP request\n  FullServerSideRequestForgeryFlow::PathNode requestSink,\n  // HTTP client request susceptible to SSRF\n  Http::Client::Request compromisedRequest\nwhere\n  // Link sink node to actual HTTP request\n  compromisedRequest = requestSink.getNode().(Sink).getRequest() and\n  // Verify complete user control over request URL\n  fullyControlledRequest(compromisedRequest) and\n  // Trace data flow from source to sink\n  FullServerSideRequestForgeryFlow::flowPath(taintedSource, requestSink)\nselect\n  // Report vulnerable request and flow path\n  compromisedRequest, taintedSource, requestSink,\n  // Generate vulnerability description\n  \"Complete URL controlled by $@.\", taintedSource.getNode(),\n  \"untrusted user input\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/assert-literal-constant]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects assert statements that evaluate literal constants,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Assert statement tests the truth value of a literal constant\n * @description Detects assert statements that evaluate literal constants,\n *              which may behave unexpectedly under compiler optimizations.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/assert-literal-constant\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom Assert assertionStmt, string constantValue\nwhere\n  // Exclude assertions within test scopes to reduce false positives\n  not assertionStmt.getScope().getScope*() instanceof TestScope\n  and\n  // Filter out assertions positioned at the end of elif branches\n  not exists(If ifStatement | \n    ifStatement.getElif().getAnOrelse() = assertionStmt\n  )\n  and\n  // Identify assertions evaluating literal constants\n  exists(Expr testedExpr | \n    testedExpr = assertionStmt.getTest() and (\n      // Handle integer literals\n      constantValue = testedExpr.(IntegerLiteral).getN()\n      or\n      // Process string literals with escaped quotes\n      constantValue = \"\\\"\" + testedExpr.(StringLiteral).getS() + \"\\\"\"\n      or\n      // Handle name constants (None, True, False)\n      constantValue = testedExpr.(NameConstant).toString()\n    )\n  )\nselect assertionStmt, \"Assert of literal constant \" + constantValue + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-exception in 'except' clause\n * @description Identifies exception handlers that specify non-exception types,\n *              which are ineffective at catching actual runtime exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n_______________ // 补全条件\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Detect ineffective exception handlers that reference non-exception types\nfrom ExceptFlowNode exceptHandler, Value caughtType, ClassValue exceptionCls, \n     ControlFlowNode exceptionOrigin, string typeDescription\nwhere\n  // Establish the relationship between the exception handler and its handled type\n  exceptHandler.handledException(caughtType, exceptionCls, exceptionOrigin) and\n  (\n    // First case: The type is a class but not a valid exception class\n    exists(ClassValue invalidExcClass | \n      invalidExcClass = caughtType and\n      not invalidExcClass.isLegalExceptionType() and\n      not invalidExcClass.failedInference(_) and\n      typeDescription = \"class '\" + invalidExcClass.getName() + \"'\"\n    )\n    or\n    // Second case: The type is not a class at all\n    not caughtType instanceof ClassValue and\n    typeDescription = \"instance of '\" + exceptionCls.getName() + \"'\"\n  )\nselect exceptHandler.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  exceptionOrigin, typeDescription",
    "output": "* @sub-severity low"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Invalid keyword argument in class instantiation\n * @description Detects class instantiations using keyword arguments that don't match \n *              any parameter in the class's __init__ method, which will cause runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstantiation, ClassValue targetClass, string invalidKeyword, FunctionValue initializerMethod\n_______________ // 补全条件\n  // Retrieve the initializer method for the target class\n  initializerMethod = get_function_or_initializer(targetClass)\n  and\n  // Identify invalid keyword arguments in the class instantiation\n  illegally_named_parameter(classInstantiation, targetClass, invalidKeyword)\nselect classInstantiation, \n       \"Keyword argument '\" + invalidKeyword + \"' is not a supported parameter name of $@.\", \n       initializerMethod,\n       initializerMethod.getQualifiedName()",
    "output": "where"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/catch-base-exception]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers that intercept BaseException or all exceptions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Exception handler catches BaseException without re-raising\n * @description Identifies exception handlers that intercept BaseException or all exceptions\n *              without re-raising, potentially mishandling system exits and interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n/**\n * Determines if an exception handler fails to re-raise the caught exception.\n * This is verified by checking if the handler's basic block reaches an exit point.\n */\npredicate doesNotReraise(ExceptStmt exceptBlock) { \n  exceptBlock.getAFlowNode()\n             .getBasicBlock()\n             .reachesExit() \n}\n\n/**\n * Checks if an exception handler catches BaseException or all exceptions.\n * Two scenarios are covered:\n * 1. Explicitly catching BaseException\n * 2. Using a bare except clause (catches all exceptions)\n */\npredicate catchesBaseExceptionOrAll(ExceptStmt exceptBlock) {\n  (\n    // Explicitly catches BaseException\n    exceptBlock.getType() = API::builtin(\"BaseException\")\n                                 .getAValueReachableFromSource()\n                                 .asExpr()\n  )\n  or\n  (\n    // Bare except clause catches all exceptions\n    not exists(exceptBlock.getType())\n  )\n}\n\n// Core query: Find exception handlers that catch BaseException or all exceptions\n// and do not re-raise them\nfrom ExceptStmt exceptHandler\nwhere\n  catchesBaseExceptionOrAll(exceptHandler) and  // Catches BaseException or all exceptions\n  doesNotReraise(exceptHandler)                // Does not re-raise the exception\nselect exceptHandler, \"Except block directly handles BaseException.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Comparison of constants\n * @description Identifies constant-to-constant comparisons that always evaluate \n *              to the same boolean result. These can be replaced with literal \n *              True/False to improve code readability.\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/comparison-of-constants\n */\n_______________ // 补全条件\nimport python\n\n// Locate comparison operations between constant expressions\nfrom Compare constantCompare, Expr leftExpr, Expr rightExpr\nwhere\n  // Establish the comparison relationship between operands\n  constantCompare.compares(leftExpr, _, rightExpr) and\n  // Verify both operands are constant values\n  leftExpr.isConstant() and\n  rightExpr.isConstant() and\n  // Exclude intentional constant comparisons in assert statements\n  not exists(Assert assertStmt | assertStmt.getTest() = constantCompare)\nselect constantCompare, \"Comparison of constants; use 'True' or 'False' instead.\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/member-test-non-container]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects membership tests (e.g., 'item in sequence') where the right-hand side",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Membership test with a non-container\n * @description Detects membership tests (e.g., 'item in sequence') where the right-hand side \n *              is a non-container object, which would raise a 'TypeError' at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n * Determines if a node serves as the right operand in an In/NotIn comparison.\n * @param node - The control flow node being evaluated\n * @param compareNode - The comparison expression containing the operation\n */\npredicate isRightHandSideOfInTest(ControlFlowNode node, Compare compareNode) {\n  exists(Cmpop operation, int operandIndex |\n    compareNode.getOp(operandIndex) = operation and \n    compareNode.getComparator(operandIndex) = node.getNode() and\n    (operation instanceof In or operation instanceof NotIn)\n  )\n}\n\nfrom \n  ControlFlowNode nonContainerNode, \n  Compare comparisonExpr, \n  Value pointedValue, \n  ClassValue valueClass, \n  ControlFlowNode originNode\nwhere\n  // Identify In/NotIn operations with the node as right operand\n  isRightHandSideOfInTest(nonContainerNode, comparisonExpr) and\n  \n  // Resolve the node's pointed value and its class\n  nonContainerNode.pointsTo(_, pointedValue, originNode) and\n  pointedValue.getClass() = valueClass and\n  \n  // Exclude cases where type inference failed\n  not Types::failedInference(valueClass, _) and\n  \n  // Verify the class lacks container-like capabilities\n  not valueClass.hasAttribute(\"__contains__\") and\n  not valueClass.hasAttribute(\"__iter__\") and\n  not valueClass.hasAttribute(\"__getitem__\") and\n  \n  // Exclude special types that might appear as containers\n  not valueClass = ClassValue::nonetype() and\n  not valueClass = Value::named(\"types.MappingProxyType\")\nselect \n  comparisonExpr, \n  \"This test may raise an Exception as the $@ may be of non-container class $@.\", \n  originNode, \"target\", valueClass, valueClass.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/external-dependencies]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：计算一个Python源文件对外部包的依赖数量。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name 外部依赖关系\n * @description 计算一个Python源文件对外部包的依赖数量。\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType externalDependency\n * @id py/external-dependencies\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 本查询用于分析Python源文件与外部包之间的依赖关系，并量化每个文件对外部包的依赖程度。\n * \n * 查询核心要素：\n * - 源代码文件路径（作为依赖关系的主体）\n * - 外部包对象（来自PyPI或类似外部源的包）\n * - 包版本信息（在可用的情况下）\n * - 源文件对该包的依赖数量统计\n * \n * 输出格式：\n * - 第一列：依赖实体标识符（由文件路径和外部包信息组合而成）\n * - 第二列：依赖计数\n * \n * 注意：文件路径前会添加'/'前缀，以确保与仪表板数据库中的相对文件路径格式保持一致。\n */\n\n// 定义查询变量：源文件、依赖计数、依赖实体和外部包\nfrom File codeFile, int dependencyCount, string dependencyEntity, ExternalPackage externalPkg\nwhere\n  // 计算指定源文件对特定外部包的依赖数量\n  dependencyCount =\n    strictcount(AstNode node |\n      // 验证AST节点是否依赖于指定的外部包\n      dependency(node, externalPkg) and\n      // 确认AST节点位于指定的源文件中\n      node.getLocation().getFile() = codeFile\n    ) and\n  // 将源文件和外部包信息合并为统一的实体标识符\n  dependencyEntity = munge(codeFile, externalPkg)\n// 输出结果：依赖实体和依赖计数，按依赖数量降序排列\nselect dependencyEntity, dependencyCount order by dependencyCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/all-cryptographic-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and catalogs all potential cryptographic algorithm",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Complete Cryptographic Algorithm Inventory\n * @description Identifies and catalogs all potential cryptographic algorithm \n *              implementations found across supported cryptographic libraries\n * @kind problem\n * @id py/quantum-readiness/cbom/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python analysis module for code examination\nimport python\n// Import experimental cryptography concepts for algorithm identification\nimport experimental.cryptography.Concepts\n\n// Query for all cryptographic algorithm instances in the codebase\nfrom CryptographicAlgorithm cipherAlgorithm\n// Generate alert message containing the algorithm name\nselect cipherAlgorithm, \"Use of algorithm \" + cipherAlgorithm.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Identifies cryptographic implementations that employ elliptic curve algorithms\n *              which are either unapproved or deemed cryptographically weak, potentially\n *              leading to security vulnerabilities.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm ecImplementation, string securityAlert, string curveName\nwhere\n  // Define the set of cryptographically secure elliptic curves\n  exists(string secureCurve |\n    secureCurve = [\n      \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n      \"SECP384R1\",              // P-384 curve\n      \"SECP521R1\",              // P-521 curve\n      \"ED25519\",                // Ed25519 curve\n      \"X25519\"                  // X25519 curve\n_______________ // 补全条件\n  |\n    // Extract the curve name from the elliptic curve implementation\n    curveName = ecImplementation.getCurveName() and\n    (\n      // Check for unrecognized curve algorithm\n      curveName = unknownAlgorithm() and\n      securityAlert = \"Use of unrecognized curve algorithm.\"\n      or\n      // Check for recognized but cryptographically weak curve algorithm\n      curveName != unknownAlgorithm() and\n      not curveName = secureCurve and\n      securityAlert = \"Use of weak curve algorithm \" + curveName + \".\"\n    )\n  )\nselect ecImplementation, securityAlert",
    "output": "]"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak cryptographic hash algorithms\n * @description Detects the utilization of cryptographic hash functions that have been\n *              deprecated or are deemed insecure for security-critical implementations.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import required Python language support and cryptographic analysis libraries\nimport python\nimport experimental.cryptography.Concepts\n\n// Locate hash function implementations utilizing weak or deprecated cryptographic algorithms\nfrom HashAlgorithm hashImplementation, string algorithmIdentifier, string alertMessage\nwhere\n  // Retrieve the algorithm name from the hash function implementation\n  algorithmIdentifier = hashImplementation.getHashName() and\n  // Filter out implementations employing secure, approved hash algorithms\n  not algorithmIdentifier = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // Construct appropriate security alert based on algorithm identification status\n  (\n    // Scenario: Algorithm is identified but not approved for security-sensitive use\n    algorithmIdentifier != \"\" and\n    alertMessage = \"Detected usage of unapproved hash algorithm or API: \" + algorithmIdentifier + \".\"\n  )\n  or\n  (\n    // Scenario: Algorithm cannot be identified or is unrecognized\n_______________ // 补全条件\n    alertMessage = \"Detected usage of unrecognized hash algorithm.\"\n  )\nselect hashImplementation, alertMessage",
    "output": "algorithmIdentifier = \"\" and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Generates a treemap visualization that illustrates the cumulative count of lines removed from each source file across the entire commit history of the project.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File Deletion Metrics\n * @description Generates a treemap visualization that illustrates the cumulative count of lines removed from each source file across the entire commit history of the project.\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\n// Locate source modules and compute their cumulative deletion metrics\nfrom Module sourceModule, int deletedLinesCount\nwhere\n  // Ensure the module has quantifiable code content\n  exists(sourceModule.getMetrics().getNumberOfLinesOfCode()) and\n  // Calculate the total number of lines eliminated in all relevant commits\n  deletedLinesCount = sum(\n    Commit commitEntry, int linesRemoved |\n      // Retrieve the count of lines removed in each commit that modifies this module\n      linesRemoved = commitEntry.getRecentDeletionsForFile(sourceModule.getFile()) and\n      // Filter out synthetic commits that do not represent genuine development activities\n      not artificialChange(commitEntry)\n    |\n      linesRemoved\n  )\nselect sourceModule, deletedLinesCount order by deletedLinesCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/modification-of-default-value]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code paths where parameters with default values are modified,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Modification of parameter with default\n * @description Detects code paths where parameters with default values are modified,\n *              which can lead to unexpected behavior since default values are created\n *              only once when the function is defined.\n * @kind path-problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/modification-of-default-value\n */\n\nimport python\nimport semmle.python.functions.ModificationOfParameterWithDefault\nimport ModificationOfParameterWithDefault::Flow::PathGraph\n\nfrom\n  ModificationOfParameterWithDefault::Flow::PathNode startNode,\n  ModificationOfParameterWithDefault::Flow::PathNode endNode\nwhere\n  ModificationOfParameterWithDefault::Flow::flowPath(startNode, endNode)\nselect\n  endNode.getNode(), \n  startNode, \n  endNode, \n  \"This expression mutates a $@.\", \n  startNode.getNode(),\n  \"default value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-of-mutable-attribute]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects direct imports of mutable attribute values, which prevents local observation of global state changes.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Importing value of mutable attribute\n * @description Detects direct imports of mutable attribute values, which prevents local observation of global state changes.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity high\n * @precision medium\n * @id py/import-of-mutable-attribute\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom ImportMember importedMember, ModuleValue sourceModule, AttrNode mutationSite, string attrName\nwhere\n  // Attribute name consistency between import and mutation\n  importedMember.getName() = attrName and\n  // Imported attribute must be module-scoped (not function-local)\n  not importedMember.getScope() instanceof Function and\n  // Mutation must be a write operation within function scope\n  mutationSite.isStore() and\n  mutationSite.getScope() instanceof Function and\n  // Import and mutation must reside in different modules\n  not importedMember.getEnclosingModule() = mutationSite.getScope().getEnclosingModule() and\n  // Mutation target references the source module\n  mutationSite.getObject(attrName).pointsTo(sourceModule) and\n  // Module equivalence verification through import aliasing\n  exists(string importedModuleName |\n    importedModuleName = importedMember.getModule().(ImportExpr).getImportedModuleName() and\n    sourceModule.importedAs(importedModuleName)\n  ) and\n  // Exclude mutations within test code\n  not mutationSite.getScope().getScope*() instanceof TestScope\nselect importedMember,\n  \"Importing the value of '\" + attrName +\n    \"' from $@ means that any change made to $@ will be not be observed locally.\", sourceModule,\n  \"module \" + sourceModule.getName(), mutationSite, sourceModule.getName() + \".\" + mutationSite.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Mostly similar module detection\n * @description Identifies modules with substantial code similarity. Note that variable names and types may differ between modules. Consolidation is recommended for maintainability.\n * @kind problem\n * @problem.severity recommendation\n_______________ // 补全条件\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @sub-severity low\n * @precision high\n * @id py/mostly-similar-file\n */\n\nimport python\n\n// Define source modules and similarity characteristics\nfrom Module sourceModule, \n     Module targetModule, \n     string similarityDetails\nwhere \n  // Placeholder condition - no actual filtering implemented\n  none()\nselect \n  sourceModule, \n  similarityDetails, \n  targetModule, \n  targetModule.getName()  // Output target module name",
    "output": "* @tags testability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Generates information about alert suppressions in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// 导入 CodeQL 工具库中的 AlertSuppression 模块，用于处理抑制逻辑\nprivate import codeql.util.suppression.AlertSuppression as SuppressionHelper\n// 导入 Python 注释处理模块，用于处理代码注释\nprivate import semmle.python.Comment as CommentHandler\n\n// 定义抽象语法树节点类，表示 Python 代码中的语法结构元素\nclass PythonAstNode instanceof CommentHandler::AstNode {\n  /** 获取节点的位置信息（文件路径和行列范围） */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // 通过父类方法获取节点的精确位置\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  /** 返回节点的字符串表示形式 */\n  string toString() { result = super.toString() }\n}\n\n// 定义单行注释类，表示 Python 代码中的单行注释元素\nclass SingleLineComment instanceof CommentHandler::Comment {\n  /** 获取注释的位置信息（文件路径和行列范围） */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // 通过父类方法获取注释的精确位置\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  /** 获取注释的文本内容 */\n  string getText() { result = super.getContents() }\n\n  /** 返回注释的字符串表示形式 */\n  string toString() { result = super.toString() }\n}\n\n// 应用模板生成 AST 节点和单行注释之间的抑制关系\nimport SuppressionHelper::Make<PythonAstNode, SingleLineComment>\n\n/**\n * Pylint 和 Pyflakes 兼容的 noqa 抑制注释\n * LGTM 分析器应识别此类注释\n */\nclass NoqaStyleSuppressor extends SuppressionComment instanceof SingleLineComment {\n  /** 构造函数：验证注释是否符合 noqa 格式 */\n  NoqaStyleSuppressor() {\n    // 检查注释文本是否符合 noqa 格式（不区分大小写，允许前后有空格）\n    super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  /** 返回注解标识符 \"lgtm\" */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /** 定义注释覆盖的代码范围 */\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // 确保注释位于行首且位置信息匹配\n    hasLocationInfo(filePath, startLine, _, endLine, endCol) and\n    startCol = 1\n  }\n}"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak symmetric encryption algorithm\n * @description Finds uses of symmetric cryptography algorithms that are weak, obsolete, or otherwise unaccepted.\n *\n *              The key lengths allowed are 128, 192, and 256 bits. These are all the key lengths supported by AES, so any\n *              application of AES is considered acceptable.\n * @id py/weak-symmetric-encryption\n_______________ // 补全条件\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python // 导入python库，用于分析Python代码\nimport experimental.cryptography.Concepts // 导入实验性加密概念库，用于处理加密相关的概念\n\n// 从SymmetricEncryptionAlgorithm操作符中选择op、name和msg字段\nfrom SymmetricEncryptionAlgorithm op, string name, string msg\nwhere\n  // 获取加密算法的名称并赋值给变量name\n  name = op.getEncryptionName() and\n  // 过滤掉AES及其变种（AES128, AES192, AES256）的加密算法\n  not name = [\"AES\", \"AES128\", \"AES192\", \"AES256\"] and\n  // 如果算法名称未知，则设置消息为“使用未识别的对称加密算法”\n  if name = unknownAlgorithm()\n  then msg = \"Use of unrecognized symmetric encryption algorithm.\"\n  // 否则，设置消息为“使用未经批准的对称加密算法或API”并附加算法名称\n  else msg = \"Use of unapproved symmetric encryption algorithm or API \" + name + \".\"\n// 选择操作符op和消息msg作为查询结果\nselect op, msg",
    "output": "* @kind problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unsafe-unpacking]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Extracting tar files from user-controlled sources without validating",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file write during tarball extraction from user-controlled source\n * @description Extracting tar files from user-controlled sources without validating \n *              destination paths may allow overwriting files outside the target directory.\n *              This occurs when tarballs originate from user-controlled locations,\n *              whether remote sources or command-line arguments.\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// Define origin and destination points for unsafe unpacking flows\nfrom UnsafeUnpackFlow::PathNode maliciousOrigin, UnsafeUnpackFlow::PathNode vulnerableTarget\n// Ensure data flows from malicious origin to vulnerable target\nwhere UnsafeUnpackFlow::flowPath(maliciousOrigin, vulnerableTarget)\n// Report the vulnerable target location with flow context\nselect vulnerableTarget.getNode(), maliciousOrigin, vulnerableTarget,\n  \"Unsafe extraction of malicious tarball from untrusted remote source\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n_______________ // 补全条件\n * cryptographically weak or not explicitly approved by security standards.\n * This analysis excludes secure padding methods (OAEP, KEM, PSS) and flags\n * all other padding schemes as potential security vulnerabilities.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define secure padding schemes that should be excluded from detection\nstring secureScheme() {\n  result = [\"OAEP\", \"KEM\", \"PSS\"]\n}\n\n// Identify asymmetric padding implementations and analyze their scheme names\nfrom AsymmetricPadding asymmetricPaddingInstance, string paddingSchemeName\nwhere\n  // Retrieve the padding scheme name from the implementation\n  paddingSchemeName = asymmetricPaddingInstance.getPaddingName()\n  // Exclude known secure padding schemes from detection\n  and paddingSchemeName != secureScheme()\nselect asymmetricPaddingInstance, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + paddingSchemeName",
    "output": "* Identifies asymmetric encryption padding schemes that are either"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/loop-variable-capture]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies loop iteration variables captured by reference instead of value,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Loop variable capture\n * @description Identifies loop iteration variables captured by reference instead of value,\n *              potentially causing unexpected behavior when accessed after loop completion.\n * @kind problem\n * @tags correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/loop-variable-capture\n */\n\nimport python\n\n// Determine the appropriate scope for loop iteration variables\nScope resolveIterationVariableScope(AstNode loopConstruct) {\n  // For standard for-loops: return the loop's local scope\n  result = loopConstruct.(For).getScope()\n  or\n  // For comprehensions: return the enclosing function's scope\n  result = loopConstruct.(Comp).getFunction()\n}\n\n// Identify loop variables captured by callables that escape their intended context\npredicate loopVariableCaptureEscapes(CallableExpr capturedCallable, AstNode loopConstruct, Variable iterationVar) {\n  // Ensure the variable belongs to the loop's iteration scope\n  iterationVar.getScope() = resolveIterationVariableScope(loopConstruct) and\n  // Verify variable access occurs within the captured callable's scope\n  iterationVar.getAnAccess().getScope() = capturedCallable.getInnerScope() and\n  // Confirm the callable is nested inside the loop structure\n  capturedCallable.getParentNode+() = loopConstruct and\n  // Validate the variable is an iteration variable of the loop\n  (\n    // Case 1: For-loop iteration variable\n    loopConstruct.(For).getTarget() = iterationVar.getAnAccess()\n    or\n    // Case 2: Comprehension iteration variable\n    iterationVar = loopConstruct.(Comp).getAnIterationVariable()\n  ) and\n  // Check escape conditions based on loop type\n  (\n    // For-loop escape: variable referenced outside loop body\n    loopConstruct instanceof For and\n    exists(Expr escapingReference | \n      escapingReference.pointsTo(_, _, capturedCallable) and \n      not loopConstruct.contains(escapingReference)\n    )\n    or\n    // Comprehension escape: variable captured as element or tuple element\n    loopConstruct.(Comp).getElt() = capturedCallable\n    or\n    loopConstruct.(Comp).getElt().(Tuple).getAnElt() = capturedCallable\n  )\n}\n\n// Find all instances where loop variables are improperly captured and escape context\nfrom CallableExpr capturedCallable, AstNode loopConstruct, Variable iterationVar\nwhere loopVariableCaptureEscapes(capturedCallable, loopConstruct, iterationVar)\nselect capturedCallable, \"Capture of loop variable $@.\", loopConstruct, iterationVar.getId()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description Detects when malicious tar archives overwrite files outside target directory due to unvalidated extraction paths\n * @kind path-problem\n * @id py/tarslip-extended\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport TarSlipFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.internal.Attributes\nimport semmle.python.dataflow.new.BarrierGuards\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n/**\n * Identifies tarfile opening methods:\n *  - `tarfile.open()`\n *  - `tarfile.TarFile()`\n *  - Subclasses' `open` methods\n */\nAPI::Node tarfileOpenApiNode() {\n  result in [\n      API::moduleImport(\"tarfile\").getMember([\"open\", \"TarFile\"]),\n      API::moduleImport(\"tarfile\").getMember(\"TarFile\").getASubclass().getMember(\"open\")\n    ]\n}\n\n/**\n * Handles direct tarfile calls and contextlib.closing wrappers\n */\nclass TarfileOpenCall extends API::CallNode {\n  TarfileOpenCall() {\n    this = tarfileOpenApiNode().getACall()\n    or\n    exists(API::Node contextlibClosingNode, Node tarfileCallNode |\n      contextlibClosingNode = API::moduleImport(\"contextlib\").getMember(\"closing\") and\n      this = contextlibClosingNode.getACall() and\n      tarfileCallNode = this.getArg(0) and\n      tarfileCallNode = tarfileOpenApiNode().getACall()\n    )\n  }\n}\n\n/**\n * Enhanced taint tracking configuration for TarSlip vulnerability detection\n */\nprivate module TarSlipConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node sourceNode) { \n    sourceNode = tarfileOpenApiNode().getACall() \n  }\n\n  predicate isSink(DataFlow::Node sinkNode) {\n    exists(TarfileOpenCall tarOpener |\n      // Handle extractall() without members parameter\n      (\n        exists(MethodCallNode extractCall |\n          extractCall = tarOpener.getReturn().getMember(\"extractall\").getACall() and\n          not extractCall.getArgByName(\"members\") instanceof Node and\n          sinkNode = extractCall.getObject()\n        )\n      )\n      or\n      // Handle extractall() with members parameter\n      (\n        exists(MethodCallNode extractCall, Node membersArg |\n          extractCall = tarOpener.getReturn().getMember(\"extractall\").getACall() and\n          membersArg = extractCall.getArgByName(\"members\") and\n          (\n            membersArg.asCfgNode() instanceof NameConstantNode or\n            membersArg.asCfgNode() instanceof ListNode\n          ) and\n          sinkNode = extractCall.getObject()\n        )\n      )\n      or\n      // Handle extractall() with dynamic members\n      (\n        exists(MethodCallNode extractCall, MethodCallNode getMembersCall |\n          extractCall = tarOpener.getReturn().getMember(\"extractall\").getACall() and\n_______________ // 补全条件\n          getMembersCall.getMethodName() = \"getmembers\" and\n          sinkNode = getMembersCall.getObject()\n        )\n      )\n      or\n      // Handle extract() method\n      (\n        exists(MethodCallNode extractCall |\n          extractCall = tarOpener.getReturn().getMember(\"extract\").getACall() and\n          sinkNode = extractCall.getArg(0)\n        )\n      )\n      or\n      // Handle _extract_member() method\n      (\n        exists(MethodCallNode extractCall, AttrRead nameAttr |\n          extractCall = tarOpener.getReturn().getMember(\"_extract_member\").getACall() and\n          nameAttr = extractCall.getArg(1).(AttrRead) and\n          nameAttr.accesses(sinkNode, \"name\")\n        )\n      )\n    ) and\n    not sinkNode.getScope().getLocation().getFile().inStdlib()\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node fromNode, DataFlow::Node toNode) {\n    // Flow through getmembers() method calls\n    (\n      toNode.(MethodCallNode).calls(fromNode, \"getmembers\") and\n      fromNode instanceof TarfileOpenCall\n    )\n    or\n    // Flow through contextlib.closing wrapper\n    (\n      exists(API::CallNode closingCall |\n        closingCall = API::moduleImport(\"contextlib\").getMember(\"closing\").getACall() and\n        toNode = closingCall and\n        fromNode = closingCall.getArg(0) and\n        fromNode = tarfileOpenApiNode().getReturn().getAValueReachableFromSource()\n      )\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n/** Global taint tracking for enhanced TarSlip vulnerability detection */\nmodule TarSlipFlow = TaintTracking::Global<TarSlipConfig>;\n\nfrom TarSlipFlow::PathNode source, TarSlipFlow::PathNode sink\nwhere TarSlipFlow::flowPath(source, sink)\nselect sink, source, sink, \"Extraction of tarfile from $@ to potentially unsafe location $@.\",\n  source.getNode(), source.getNode().toString(), sink.getNode(), sink.getNode().toString()",
    "output": "getMembersCall = extractCall.getArgByName(\"members\") and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Generates information about alert suppressions in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// 导入 CodeQL 工具库中的 AlertSuppression 模块，用于处理警告抑制机制\nprivate import codeql.util.suppression.AlertSuppression as SuppressionUtil\n// 导入 Python 注释处理模块，用于解析和操作代码注释\nprivate import semmle.python.Comment as CommentProcessor\n\n// 定义抽象语法树节点类，表示 Python 代码中的语法结构元素\nclass PythonAstNode instanceof CommentProcessor::AstNode {\n  /** 获取节点的位置信息（源文件路径和行列范围） */\n  predicate hasLocationInfo(\n    string sourcePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // 通过父类方法获取节点的精确位置信息\n    super.getLocation().hasLocationInfo(sourcePath, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  /** 返回节点的字符串表示形式 */\n  string toString() { result = super.toString() }\n}\n\n// 定义单行注释类，表示 Python 代码中的单行注释元素\nclass SingleLineComment instanceof CommentProcessor::Comment {\n  /** 获取注释的位置信息（源文件路径和行列范围） */\n  predicate hasLocationInfo(\n    string sourcePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // 通过父类方法获取注释的精确位置信息\n    super.getLocation().hasLocationInfo(sourcePath, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  /** 获取注释的文本内容 */\n  string getText() { result = super.getContents() }\n\n  /** 返回注释的字符串表示形式 */\n  string toString() { result = super.toString() }\n}\n\n// 应用模板生成 AST 节点和单行注释之间的抑制关系\nimport SuppressionUtil::Make<PythonAstNode, SingleLineComment>\n\n/**\n * Pylint 和 Pyflakes 兼容的 noqa 抑制注释\n * LGTM 分析器应识别此类注释\n */\nclass NoqaStyleSuppressor extends SuppressionComment instanceof SingleLineComment {\n  /** 构造函数：验证注释是否符合 noqa 格式 */\n  NoqaStyleSuppressor() {\n    // 检查注释文本是否符合 noqa 格式（不区分大小写，允许前后有空格）\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  /** 返回注解标识符 \"lgtm\" */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /** 定义注释覆盖的代码范围 */\n  override predicate covers(\n    string sourcePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // 确保注释位于行首且位置信息匹配\n    this.hasLocationInfo(sourcePath, beginLine, _, finishLine, finishColumn) and\n    beginColumn = 1\n  }\n}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-crypto-key]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cryptographic keys that are generated with bit lengths too short to resist brute-force attacks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insufficient cryptographic key strength\n * @description Detects cryptographic keys that are generated with bit lengths too short to resist brute-force attacks.\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/weak-crypto-key\n * @tags security\n *       external/cwe/cwe-326\n */\n\nimport python\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.filters.Tests\n\nfrom Cryptography::PublicKey::KeyGeneration keyGenerator, DataFlow::Node keySizeSource\nwhere\n  // Check if a cryptographic key is generated with insufficient bit length\n  exists(int keyBitLength |\n    // Extract the key bit length from the generation context\n    keyBitLength = keyGenerator.getKeySizeWithOrigin(keySizeSource) and\n    // Verify if the key length is below the minimum secure threshold\n    keyBitLength < keyGenerator.minimumSecureKeySize() and\n    // Exclude test code from security analysis\n    not keySizeSource.getScope().getScope*() instanceof TestScope\n  )\nselect keyGenerator,\n  \"Generation of $@ key with \" + \n    keyGenerator.getKeySizeWithOrigin(keySizeSource).toString() + \n    \" bits is insecure; minimum recommended is \" + keyGenerator.minimumSecureKeySize() + \n    \" bits.\", \n  keySizeSource, keyGenerator.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-small-salt-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies key derivation functions using salt values with inadequate length.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insufficient KDF Salt Length Detection\n * @description Identifies key derivation functions using salt values with inadequate length.\n * \n * This analysis detects cryptographic key derivation functions (KDFs) that utilize\n * salt values with insufficient length. It flags instances where the salt size is\n * either below 128 bits (16 bytes) or cannot be statically determined.\n * @kind problem\n * @id py/kdf-small-salt-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\nfrom KeyDerivationOperation kdfOperation, DataFlow::Node saltSizeSource, API::CallNode urandomCall, string warningMessage\nwhere\n  // Identify KDF operations that require salt for security\n  kdfOperation.requiresSalt() and\n  \n  // Locate os.urandom invocations used for salt generation and trace the size parameter\n  exists(API::CallNode saltGenerationCall |\n    API::moduleImport(\"os\").getMember(\"urandom\").getACall() = saltGenerationCall and\n    saltGenerationCall = kdfOperation.getSaltConfigSrc() and\n    urandomCall = saltGenerationCall and\n    saltSizeSource = CryptoUtils::getUltimateSrcFromApiNode(urandomCall.getParameter(0, \"size\"))\n  ) and\n  \n  // Evaluate salt size for security compliance\n  (\n    // Scenario 1: Salt size cannot be statically verified\n    not exists(saltSizeSource.asExpr().(IntegerLiteral).getValue()) and\n    warningMessage = \"Salt size cannot be statically verified. \"\n    or\n    // Scenario 2: Salt size is below the security threshold\n    saltSizeSource.asExpr().(IntegerLiteral).getValue() < 16 and\n    warningMessage = \"Salt size is below the minimum required. \"\n  )\nselect kdfOperation,\n  warningMessage + \"Salt size must be at least 16 bytes. os.urandom Configuration: $@, Size Parameter: $@\", \n  urandomCall, urandomCall.toString(), \n  saltSizeSource, saltSizeSource.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Denial of Service using Unicode Characters\n * @description Identifies paths where remote user input reaches Unicode normalization operations\n *              (NFKC/NFKD) that can cause denial of service. These operations can exponentially\n *              increase payload size (e.g., U+2100 ℀ triples in size during normalization).\n * @kind path-problem\n * @id py/unicode-dos\n * @precision high\n * @problem.severity error\n * @tags security\n *       experimental\n *       external/cwe/cwe-770\n */\n\nimport python\nimport semmle.python.ApiGraphs\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n// Represents Unicode normalization function calls that process compatibility characters\n// (NFKC/NFKD forms). Tracks which argument contains the string to be normalized.\nclass UnicodeCompatibilityNormalizationCall extends API::CallNode {\n  int normalizedArgIndex; // Position of the normalized string argument\n\n  UnicodeCompatibilityNormalizationCall() {\n    // Case 1: normalize() calls with explicit NFKC/NFKD form (2nd arg normalized)\n    (\n      this = API::moduleImport(\"unicodedata\").getMember(\"normalize\").getACall()\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember(\"normalize\").getACall()\n    ) and\n    this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n        \"NFKC\", \"NFKD\"\n      ] and\n    normalizedArgIndex = 1\n    or\n    // Case 2: Direct normalization calls (1st arg normalized)\n    (\n_______________ // 补全条件\n      this.getParameter(1).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"unidecode\").getMember(\"unidecode\").getACall()\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember([\"NFKC\", \"NFKD\"]).getACall()\n    ) and\n    normalizedArgIndex = 0\n  }\n\n  // Retrieves the argument node containing the string to normalize\n  DataFlow::Node getNormalizedStringArg() { \n    result = this.getArg(normalizedArgIndex) \n  }\n}\n\n// Detects guard conditions enforcing size limits on input values\npredicate hasSizeLimitGuard(DataFlow::GuardNode guardNode, ControlFlowNode controlledNode, boolean branchValue) {\n  exists(CompareNode compareNode | compareNode = guardNode |\n    exists(API::CallNode lengthCall, Cmpop compareOperator, Node lengthNode |\n      lengthCall = lengthNode.getALocalSource() and\n      (\n        // Patterns: input <= LIMIT or input < LIMIT (true branch)\n        (compareOperator instanceof LtE or compareOperator instanceof Lt) and\n        branchValue = true and\n        compareNode.operands(lengthNode.asCfgNode(), compareOperator, _)\n        or\n        // Patterns: LIMIT >= input or LIMIT > input (true branch)\n        (compareOperator instanceof GtE or compareOperator instanceof Gt) and\n        branchValue = true and\n        compareNode.operands(_, compareOperator, lengthNode.asCfgNode())\n        or\n        // Patterns: not input >= LIMIT or not input > LIMIT (false branch)\n        (compareOperator instanceof GtE or compareOperator instanceof Gt) and\n        branchValue = false and\n        compareNode.operands(lengthNode.asCfgNode(), compareOperator, _)\n        or\n        // Patterns: not LIMIT <= input or not LIMIT < input (false branch)\n        (compareOperator instanceof LtE or compareOperator instanceof Lt) and\n        branchValue = false and\n        compareNode.operands(_, compareOperator, lengthNode.asCfgNode())\n      )\n    |\n      lengthCall = API::builtin(\"len\").getACall() and\n      controlledNode = lengthCall.getArg(0).asCfgNode()\n    )\n  )\n}\n\n// Taint tracking configuration for Unicode DoS vulnerability analysis\nprivate module UnicodeDoSAnalysisConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node sourceNode) { \n    sourceNode instanceof RemoteFlowSource \n  }\n\n  predicate isBarrier(DataFlow::Node barrierGuardNode) {\n    // Size limit checks prevent uncontrolled input expansion\n    barrierGuardNode = DataFlow::BarrierGuard<hasSizeLimitGuard/3>::getABarrierNode()\n  }\n\n  predicate isSink(DataFlow::Node sinkArgNode) {\n    // Direct normalization calls\n    exists(UnicodeCompatibilityNormalizationCall normCall |\n      sinkArgNode = normCall.getNormalizedStringArg()\n    )\n    or\n    // werkzeug's secure_filename() uses Unicode normalization internally\n    exists(API::CallNode werkzeugCall |\n      (\n        werkzeugCall = API::moduleImport(\"werkzeug\").getMember(\"secure_filename\").getACall()\n        or\n        werkzeugCall = API::moduleImport(\"werkzeug\")\n                          .getMember(\"utils\")\n                          .getMember(\"secure_filename\")\n                          .getACall()\n      ) and\n      sinkArgNode = werkzeugCall.getArg(_)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global taint tracking analysis using Unicode DoS configuration\nmodule UnicodeDoSFlow = TaintTracking::Global<UnicodeDoSAnalysisConfig>;\n\nimport UnicodeDoSFlow::PathGraph\n\nfrom UnicodeDoSFlow::PathNode source, UnicodeDoSFlow::PathNode sink\nwhere UnicodeDoSFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This $@ can reach a $@.\", source.getNode(),\n  \"user-provided value\", sink.getNode(), \"costly Unicode normalization operation\"",
    "output": "this = API::moduleImport(\"textnorm\").getMember(\"normalize_unicode\").getACall() and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unused-exception-object]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects instances where exception objects are created but never used,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unused exception object\n * @description Detects instances where exception objects are created but never used,\n *              which may indicate programming mistakes or unnecessary code.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unused-exception-object\n */\n\nimport python  // 导入Python库，用于分析Python代码\n\n// 查找创建了异常对象但没有使用的代码位置\nfrom Call exceptionCreation\nwhere\n  // 确保调用是创建一个异常类的实例\n  exists(ClassValue exceptionClass | \n    exceptionCreation.getFunc().pointsTo(exceptionClass) and\n    // 验证该类继承自Exception类\n    exceptionClass.getASuperType() = ClassValue::exception()\n  ) and\n  // 检查异常对象仅作为独立语句存在，没有被使用\n  exists(ExprStmt unusedStatement | \n    unusedStatement.getValue() = exceptionCreation\n  )\nselect exceptionCreation, \"Exception object created but not used. Consider raising the exception or removing this statement.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/nested-loops-with-same-variable-reused]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cases where a loop variable is redefined within an inner loop",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Reuse of loop variable in nested loops after inner loop redefinition\n * @description Detects cases where a loop variable is redefined within an inner loop\n *              and subsequently utilized in the outer loop, leading to potential logic errors.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/nested-loops-with-same-variable-reused\n */\n\nimport python\n\n// Locates instances of nested for-loops where a variable is reused after being\n// redefined in an inner loop, which may result in unintended program behavior\npredicate detectNestedLoopVarConflict(For nestedForLoop, For enclosingForLoop, Variable conflictedVar, Name varReference) {\n  // Ensure the inner loop is directly contained within the outer loop's body\n  enclosingForLoop.getBody().contains(nestedForLoop) and\n  \n  // Confirm the variable reference occurs in the outer loop but not in the inner loop\n  enclosingForLoop.contains(varReference) and \n  not nestedForLoop.contains(varReference) and \n  \n  // Establish SSA definition relationships for the conflicted variable\n  exists(SsaVariable nestedSsaDef |\n    // The inner loop redefines the variable at its target node\n    nestedForLoop.getTarget().getAFlowNode() = nestedSsaDef.getAnUltimateDefinition().getDefinition() and \n    conflictedVar = nestedSsaDef.getVariable() and \n    \n    // Verify the outer loop also defines the same variable\n    exists(SsaVariable enclosingSsaDef |\n      enclosingForLoop.getTarget().getAFlowNode() = enclosingSsaDef.getDefinition() and \n      conflictedVar = enclosingSsaDef.getVariable()\n    ) and \n    \n    // Connect the variable reference to the inner loop's SSA definition\n    nestedSsaDef.getAUse().getNode() = varReference\n  )\n}\n\n// Main query entry point: Identify problematic variable reuse patterns in nested loops\nfrom For nestedForLoop, For enclosingForLoop, Variable conflictedVar, Name varReference\nwhere detectNestedLoopVarConflict(nestedForLoop, enclosingForLoop, conflictedVar, varReference)\nselect nestedForLoop, \"Nested for statement $@ loop variable '\" + conflictedVar.getId() + \"' of enclosing $@.\", \n       varReference, \"uses\", enclosingForLoop, \"for statement\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/* 识别子类方法被超类属性遮蔽的潜在问题：在继承层次结构中，如果超类在初始化方法中定义了与子类方法同名的属性，则子类方法将无法通过正常方式访问 */\nimport python\n\n// 查找子类方法被超类属性遮蔽的实例\nfrom ClassObject derivedClass, ClassObject baseClass, Assign attributeAssignment, FunctionObject overriddenMethod\nwhere \n  // 确立继承关系：派生类继承自基类\n  derivedClass.getASuperType() = baseClass and\n  // 派生类中定义了被遮蔽的方法\n  derivedClass.declaredAttribute(_) = overriddenMethod and\n  // 检查基类初始化方法中是否存在同名属性赋值\n  exists(FunctionObject constructor, Attribute assignedAttribute |\n    // 基类定义了构造函数__init__\n    baseClass.declaredAttribute(\"__init__\") = constructor and\n    // 属性赋值的目标是assignedAttribute\n    assignedAttribute = attributeAssignment.getATarget() and\n    // 属性赋值对象是self实例\n    assignedAttribute.getObject().(Name).getId() = \"self\" and\n    // 属性名称与派生类方法名称相同\n    assignedAttribute.getName() = overriddenMethod.getName() and\n    // 赋值操作发生在基类的构造函数中\n    attributeAssignment.getScope() = constructor.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  // 排除基类中也定义了同名方法的情况（表明是故意的设计选择）\n  not baseClass.hasAttribute(overriddenMethod.getName())\n// 选择被遮蔽方法的位置、错误信息、属性赋值位置和属性类型\nselect overriddenMethod.getOrigin(),\n  \"Method \" + overriddenMethod.getName() + \" is shadowed by an $@ in super class '\" + baseClass.getName() +\n    \"'.\", attributeAssignment, \"attribute\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Calculates the aggregate count of Python code lines throughout the entire\n *   database, encompassing both external libraries and auto-generated files. This metric\n *   provides insight into the overall scale of the codebase. The calculation specifically\n *   excludes blank lines and comments, focusing only on actual code lines.\n * @kind metric\n * @tags summary\n *       telemetry\n * @id py/summary/lines-of-code\n */\n\nimport python // 引入Python分析模块，用于执行Python代码库的度量分析\n\n// 遍历数据库中的每个Python模块，累加其有效代码行数\n// 该查询统计所有Python模块中排除空白行和注释后的实际代码行数总和\nfrom Module pythonModule\nselect sum(pythonModule.getMetrics().getNumberOfLinesOfCode())",
    "output": "* @name Total lines of Python code in the database"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/paramiko-missing-host-key-validation]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects configurations where Paramiko accepts unknown host keys,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Accepting unknown SSH host keys when using Paramiko\n * @description Detects configurations where Paramiko accepts unknown host keys,\n *              which could enable man-in-the-middle attacks.\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/paramiko-missing-host-key-validation\n * @tags security\n *       external/cwe/cwe-295\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Identify unsafe Paramiko policy classes that accept unknown host keys\nprivate API::Node getInsecurePolicyNode(string policyName) {\n  policyName in [\"AutoAddPolicy\", \"WarningPolicy\"] and\n  (\n    result = API::moduleImport(\"paramiko\").getMember(\"client\").getMember(policyName)\n    or\n    result = API::moduleImport(\"paramiko\").getMember(policyName)\n  )\n}\n\n// Obtain Paramiko SSHClient instance references\nprivate API::Node getSshClientConstructor() {\n  result = API::moduleImport(\"paramiko\").getMember(\"client\").getMember(\"SSHClient\").getReturn()\n  or\n  result = API::moduleImport(\"paramiko\").getMember(\"SSHClient\").getReturn()\n}\n\n// Detect unsafe host key policy configurations\nfrom DataFlow::CallCfgNode cfgNode, DataFlow::Node policyArgument, string insecurePolicyName\nwhere\n  // Reference: http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.set_missing_host_key_policy\n  cfgNode = getSshClientConstructor().getMember(\"set_missing_host_key_policy\").getACall() and\n  (\n    policyArgument = cfgNode.getArg(0) \n    or \n    policyArgument = cfgNode.getArgByName(\"policy\")\n  ) and\n  insecurePolicyName = \"AutoAddPolicy\" or insecurePolicyName = \"WarningPolicy\" and\n  (\n    policyArgument = getInsecurePolicyNode(insecurePolicyName).getAValueReachableFromSource()\n    or\n    policyArgument = getInsecurePolicyNode(insecurePolicyName).getReturn().getAValueReachableFromSource()\n  )\nselect cfgNode, \"Setting missing host key policy to \" + insecurePolicyName + \" may be unsafe.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable code\n * @description Code is unreachable\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n_______________ // 补全条件\n * @precision very-high\n * @id py/unreachable-statement\n */\n\nimport python\n\n// 判断导入语句是否与类型提示相关\n// 类型提示相关的导入语句通常不应被视为不可达代码\npredicate is_typing_related_import(ImportingStmt importStmt) {\n  exists(Module moduleScope |\n    importStmt.getScope() = moduleScope and // 确定导入语句的作用域\n    exists(TypeHintComment typeHint | typeHint.getLocation().getFile() = moduleScope.getFile()) // 检查模块中是否存在类型提示注释\n  )\n}\n\n// 判断语句是否包含函数作用域内唯一的yield表达式\n// 包含唯一yield表达式的代码块可能是有意设计的生成器函数\npredicate contains_unique_yield_in_function(Stmt targetStmt) {\n  exists(Yield yieldExpr | targetStmt.contains(yieldExpr)) and // 检查目标语句中是否包含yield表达式\n  exists(Function functionScope |\n    functionScope = targetStmt.getScope() and // 获取目标语句的作用域函数\n    strictcount(Yield yieldExpr | functionScope.containsInScope(yieldExpr)) = 1 // 确保函数作用域内只有一个yield表达式\n  )\n}\n\n// 判断目标语句是否与contextlib.suppress在同一作用域中使用\n// 使用contextlib.suppress的代码块可能有意捕获异常，使某些代码看似不可达\npredicate shares_scope_with_suppression(Stmt targetStmt) {\n  exists(With withStmt |\n    withStmt.getContextExpr().(Call).getFunc().pointsTo(Value::named(\"contextlib.suppress\")) and // 检查with语句是否使用contextlib.suppress\n    withStmt.getScope() = targetStmt.getScope() // 确保with语句与目标语句在同一作用域\n  )\n}\n\n// 判断语句是否标记了不可能的else分支\n// 在if-elif-else链末尾引发异常的语句可能是有意设计的防御性编程\npredicate marks_impossible_else_branch(Stmt targetStmt) {\n  exists(If ifStmt | ifStmt.getOrelse().getItem(0) = targetStmt |\n    targetStmt.(Assert).getTest() instanceof False // 检查是否为断言False的语句\n    or\n    targetStmt instanceof Raise // 检查是否为引发异常的语句\n  )\n}\n\n// 判断语句是否为可报告的不可达代码\n// 综合考虑多种情况，过滤掉不应报告的不可达代码\npredicate is_reportable_unreachable(Stmt targetStmt) {\n  targetStmt.isUnreachable() and // 基本条件：语句必须是不可达的\n  not is_typing_related_import(targetStmt) and // 排除类型提示相关的导入语句\n  not shares_scope_with_suppression(targetStmt) and // 排除与contextlib.suppress共享作用域的语句\n  not contains_unique_yield_in_function(targetStmt) and // 排除包含唯一yield表达式的代码块\n  not marks_impossible_else_branch(targetStmt) and // 排除标记不可能else分支的语句\n  // 排除被其他不可达语句包含或在其他不可达语句之后的语句\n  not exists(Stmt otherUnreachableStmt | otherUnreachableStmt.isUnreachable() |\n    otherUnreachableStmt.contains(targetStmt) // 排除被其他不可达语句包含的语句\n    or\n    exists(StmtList stmtList, int prevIndex, int currentIndex | \n      stmtList.getItem(prevIndex) = otherUnreachableStmt and \n      stmtList.getItem(currentIndex) = targetStmt and \n      prevIndex < currentIndex // 排除在其他不可达语句之后的语句\n    )\n  )\n}\n\n// 查询所有可报告的不可达代码\nfrom Stmt targetStmt\nwhere is_reportable_unreachable(targetStmt)\nselect targetStmt, \"This statement is unreachable.\"",
    "output": "* @sub-severity low"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/azure-storage/unsafe-client-side-encryption-in-use]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using version v1 of Azure Storage client-side encryption is insecure, and may enable an attacker to decrypt encrypted data",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unsafe usage of v1 version of Azure Storage client-side encryption.\n * @description Using version v1 of Azure Storage client-side encryption is insecure, and may enable an attacker to decrypt encrypted data\n * @kind path-problem\n * @tags security\n *       experimental\n *       cryptography\n *       external/cwe/cwe-327\n * @id py/azure-storage/unsafe-client-side-encryption-in-use\n * @problem.severity error\n * @precision medium\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Represents Azure Storage client types and their initialization paths\nAPI::Node blobServiceClientNode(boolean isSource) {\n  // Direct BlobServiceClient initialization\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getReturn()\n  or\n  // BlobServiceClient from connection string\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getMember(\"from_connection_string\")\n        .getReturn()\n}\n\nAPI::CallNode transitionToContainerClientCall() {\n  // Container client transition from blob service client\n  result = blobServiceClientNode(_).getMember(\"get_container_client\").getACall()\n  or\n  // Container client transition from blob client\n  result = blobClientNode(_).getMember(\"_get_container_client\").getACall()\n}\n\nAPI::Node containerClientNode(boolean isSource) {\n  // Container client from transition calls\n  isSource = false and\n  result = transitionToContainerClientCall().getReturn()\n  or\n  // Direct ContainerClient initialization\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getReturn()\n  or\n  // ContainerClient from connection string or URL\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getMember([\"from_connection_string\", \"from_container_url\"])\n        .getReturn()\n}\n\nAPI::CallNode transitionToBlobClientCall() {\n  // Blob client transition from service or container clients\n  result = [blobServiceClientNode(_), containerClientNode(_)]\n        .getMember(\"get_blob_client\")\n        .getACall()\n}\n\nAPI::Node blobClientNode(boolean isSource) {\n  // Blob client from transition calls\n  isSource = false and\n  result = transitionToBlobClientCall().getReturn()\n  or\n  // Direct BlobClient initialization\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getReturn()\n  or\n  // BlobClient from connection string or URL\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getMember([\"from_connection_string\", \"from_blob_url\"])\n        .getReturn()\n}\n\n// Unified representation of all Azure Storage client types\nAPI::Node anyAzureStorageClientNode(boolean isSource) {\n  result in [blobServiceClientNode(isSource), containerClientNode(isSource), blobClientNode(isSource)]\n}\n\n// States representing encryption configuration\nnewtype TAzureEncryptionState =\n  MkV1EncryptionState() or\n  MkNoEncryptionState()\n\n// Data flow configuration for tracking encryption states\nprivate module AzureEncryptionFlowConfig implements DataFlow::StateConfigSig {\n  class FlowState = TAzureEncryptionState;\n\n  // Source: Any client without explicit encryption configuration\n  predicate isSource(DataFlow::Node node, FlowState state) {\n    state = MkNoEncryptionState() and\n    node = anyAzureStorageClientNode(true).asSource()\n  }\n\n  // Barrier: Explicit v2 encryption configuration or state transition\n  predicate isBarrier(DataFlow::Node node, FlowState state) {\n    // v2 encryption version barrier\n    exists(DataFlow::AttrWrite versionAttr |\n      node = anyAzureStorageClientNode(_).getAValueReachableFromSource() and\n      versionAttr.accesses(node, \"encryption_version\") and\n      versionAttr.getValue().asExpr().(StringLiteral).getText() in [\"'2.0'\", \"2.0\"]\n    ) and\n    exists(state)\n    or\n    // State transition barrier\n    isAdditionalFlowStep(_, MkNoEncryptionState(), node, MkV1EncryptionState()) and\n    state = MkNoEncryptionState()\n  }\n\n  // Client transition flow steps\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(DataFlow::MethodCallNode transitionCall |\n      transitionCall in [transitionToContainerClientCall(), transitionToBlobClientCall()] and\n      node1 = transitionCall.getObject() and\n      node2 = transitionCall\n    )\n  }\n\n  // State transition: No encryption -> v1 encryption\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    node1 = node2.(DataFlow::PostUpdateNode).getPreUpdateNode() and\n    state1 = MkNoEncryptionState() and\n    state2 = MkV1EncryptionState() and\n    exists(DataFlow::AttrWrite encryptionAttr |\n      node1 = anyAzureStorageClientNode(_).getAValueReachableFromSource() and\n      encryptionAttr.accesses(node1, [\"key_encryption_key\", \"key_resolver_function\"])\n    )\n  }\n\n  // Sink: Blob upload with v1 encryption\n  predicate isSink(DataFlow::Node node, FlowState state) {\n    state = MkV1EncryptionState() and\n    exists(DataFlow::MethodCallNode uploadCall |\n      uploadCall = blobClientNode(_).getMember(\"upload_blob\").getACall() and\n      node = uploadCall.getObject()\n    )\n  }\n\n  // Incremental mode configuration\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global data flow analysis module\nmodule AzureEncryptionFlow = DataFlow::GlobalWithState<AzureEncryptionFlowConfig>;\nimport AzureEncryptionFlow::PathGraph\n\n// Query: Find paths from unconfigured clients to v1 encrypted blob uploads\nfrom AzureEncryptionFlow::PathNode sourceNode, AzureEncryptionFlow::PathNode sinkNode\nwhere AzureEncryptionFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode, sourceNode, sinkNode, \"Unsafe usage of v1 version of Azure Storage client-side encryption\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Importing value of mutable attribute\n * @description Detects direct imports of mutable attribute values, which prevents local observation of global state changes.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity high\n * @precision medium\n * @id py/import-of-mutable-attribute\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom ImportMember importedAttr, ModuleValue srcModule, AttrNode writeNode, string attributeName\n_______________ // 补全条件\n  // Ensure attribute name consistency between import and mutation operations\n  importedAttr.getName() = attributeName and\n  // Verify module equivalence through import aliasing mechanism\n  exists(string moduleName |\n    moduleName = importedAttr.getModule().(ImportExpr).getImportedModuleName() and\n    srcModule.importedAs(moduleName)\n  ) and\n  // Mutation must be a write operation targeting the source module\n  writeNode.isStore() and\n  writeNode.getObject(attributeName).pointsTo(srcModule) and\n  // Validate scope constraints: module-level import and function-level mutation\n  not importedAttr.getScope() instanceof Function and\n  writeNode.getScope() instanceof Function and\n  // Ensure import and mutation occur in different modules\n  not importedAttr.getEnclosingModule() = writeNode.getScope().getEnclosingModule() and\n  // Exclude mutations within test code scope\n  not writeNode.getScope().getScope*() instanceof TestScope\nselect importedAttr,\n  \"Importing the value of '\" + attributeName +\n    \"' from $@ means that any change made to $@ will be not be observed locally.\", srcModule,\n  \"module \" + srcModule.getName(), writeNode, srcModule.getName() + \".\" + writeNode.getName()",
    "output": "where"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Detects asymmetric encryption padding schemes that are either\n * cryptographically weak or not explicitly recognized as secure.\n * This analysis excludes approved padding methods (OAEP, KEM, PSS)\n_______________ // 补全条件\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define the set of approved secure padding algorithms\nstring approvedPaddingScheme() {\n  result = [\"OAEP\", \"KEM\", \"PSS\"]\n}\n\n// Identify asymmetric padding implementations that use non-approved schemes\nfrom AsymmetricPadding paddingImpl, string paddingScheme\nwhere\n  // Extract the padding scheme name from the implementation\n  paddingScheme = paddingImpl.getPaddingName()\n  // Filter out implementations using approved secure padding schemes\n  and not paddingScheme = approvedPaddingScheme()\nselect paddingImpl, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + paddingScheme",
    "output": "* and flags all other padding schemes as potential security vulnerabilities."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Nested loops with same variable\n * @description Nested loops in which the target variable is the same for each loop make\n *              the behavior of the loops difficult to understand.\n * @kind problem\n_______________ // 补全条件\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\n// 定义一个谓词，用于判断给定的循环是否使用了指定的变量作为目标变量。\npredicate loop_variable(For f, Variable v) { f.getTarget().defines(v) }\n\n// 定义一个谓词，用于判断内层循环和外层循环是否使用了相同的变量，并且该变量在内层循环中被使用。\npredicate variableUsedInNestedLoops(For inner, For outer, Variable v) {\n  /* 仅处理在循环体内嵌套的循环。忽略else子句中的循环。 */\n  outer.getBody().contains(inner) and\n  loop_variable(inner, v) and\n  loop_variable(outer, v) and\n  /* 忽略没有使用变量的情况或变量仅在内层循环中使用的情况 */\n  exists(Name n | n.uses(v) and outer.contains(n) and not inner.contains(n))\n}\n\n// 查询语句：查找所有满足条件的内层循环、外层循环和变量，并选择这些元素进行报告。\nfrom For inner, For outer, Variable v\nwhere variableUsedInNestedLoops(inner, outer, v)\nselect inner, \"Nested for statement uses loop variable '\" + v.getId() + \"' of enclosing $@.\", outer,\n  \"for statement\"",
    "output": "* @tags maintainability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Exception block catches 'BaseException'\n * @description Identifies exception handlers that catch 'BaseException' without re-raising,\n *              potentially mishandling system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Main query logic: Identify problematic exception handlers\nfrom ExceptStmt exceptionHandler\nwhere\n  // Handler catches BaseException or uses bare except clause\n  (\n    exceptionHandler.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n    or\n    not exists(exceptionHandler.getType())\n  )\n  and\n  // Handler's control flow reaches program exit without re-raising\n_______________ // 补全条件\nselect exceptionHandler, \"Except block directly handles BaseException.\"",
    "output": "exceptionHandler.getAFlowNode().getBasicBlock().reachesExit()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete regular expression for hostnames\n * @description Identifies security vulnerabilities where regular expressions for URL or hostname matching contain unescaped dots, potentially allowing broader hostname matches than intended.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-hostname-regexp\n * @tags correctness\n *       security\n *       external/cwe/cwe-020\n_______________ // 补全条件\n\n// 引入用于主机名正则表达式安全性分析的专用库\nprivate import semmle.python.security.regexp.HostnameRegex as HostnameRegExp\n\n// 声明查询谓词，用于发现并标记存在安全风险的不完整主机名正则表达式\nquery predicate securityVulnerabilities = HostnameRegExp::incompleteHostnameRegExp/4;",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Critical vulnerability: Python 2 'input' function usage\n * @description Identifies hazardous usage of Python 2's built-in 'input' function.\n *              In Python 2, 'input()' evaluates user input as Python code, creating\n *              a critical code injection vulnerability. This contrasts with 'raw_input()',\n *              which safely returns input as a string without evaluation.\n * @kind problem\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n_______________ // 补全条件\n */\n\nimport python  // Import the Python library for analyzing Python code\nimport semmle.python.dataflow.new.DataFlow  // Import data flow analysis library\nimport semmle.python.ApiGraphs  // Import API graph analysis library\n\n// Identify dangerous input function calls in Python 2 applications\nfrom DataFlow::CallCfgNode riskyInputCall\nwhere\n  // Restrict analysis to Python 2 codebases only\n  major_version() = 2\n  and \n  // Locate calls to the hazardous 'input' builtin function\n  riskyInputCall = API::builtin(\"input\").getACall()\n  and \n  // Exclude the safe 'raw_input' alternative from detection\n  riskyInputCall != API::builtin(\"raw_input\").getACall()\nselect riskyInputCall, \"The unsafe built-in function 'input' is used in Python 2, which can lead to code injection.\"",
    "output": "* @id py/use-of-input"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-weak-salt-gen]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when key derivation functions use salt values not generated by os.urandom",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak KDF salt generation\n * @description Detects when key derivation functions use salt values not generated by os.urandom\n * @kind problem\n * @id py/kdf-weak-salt-gen\n * @problem.severity error\n * @precision high\n */\n\n// Import Python language support\nimport python\n// Import cryptographic concepts for analysis\nimport experimental.cryptography.Concepts\n// Import cryptographic utilities with alias\nprivate import experimental.cryptography.utils.Utils as Utils\n\n// Identify key derivation operations with weak salt generation\nfrom KeyDerivationOperation kdfOperation, DataFlow::Node saltSource\nwhere\n  // Verify the KDF operation requires salt and identify its source\n  kdfOperation.requiresSalt() and\n  saltSource = kdfOperation.getSaltConfigSrc() and\n  // Ensure the salt source is not generated by os.urandom\n  not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = saltSource\n// Report KDF operations with weak salt generation\nselect kdfOperation, \"Salt configuration is not from an accepted random source: $@. Must be os.urandom\",\n  saltSource, saltSource.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 混合显式返回与隐式返回（fall through）\n * @description 当函数同时包含显式返回（非None值）和隐式返回时，通常表示逻辑错误，\n *              因为隐式返回总是返回None值，可能导致意外行为。\n * @kind problem\n * @tags reliability\n_______________ // 补全条件\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mixed-returns\n */\n\nimport python\n\n// 判断函数是否包含显式返回非None值的语句\npredicate contains_explicit_non_none_return(Function targetFunction) {\n  // 存在返回语句：作用域属于当前函数 且 返回值存在 且 返回值不是None\n  exists(Return retStmt |\n    retStmt.getScope() = targetFunction and\n    exists(Expr returnValue | returnValue = retStmt.getValue() | not returnValue instanceof None)\n  )\n}\n\n// 判断函数是否包含隐式返回（fall through）\npredicate contains_implicit_return(Function targetFunction) {\n  // 条件1：存在可到达的fallthrough节点（函数末尾未显式返回）\n  exists(ControlFlowNode fallthroughNode |\n    fallthroughNode = targetFunction.getFallthroughNode() and \n    not fallthroughNode.unlikelyReachable()\n  )\n  or\n  // 条件2：存在无返回值的显式return语句（等价于隐式返回None）\n  exists(Return retStmt | \n    retStmt.getScope() = targetFunction and \n    not exists(retStmt.getValue())\n  )\n}\n\n// 查询同时满足两个条件的函数：包含显式非None返回 + 包含隐式返回\nfrom Function targetFunction\nwhere \n  contains_explicit_non_none_return(targetFunction) and \n  contains_implicit_return(targetFunction)\nselect targetFunction,\n  \"混合使用隐式和显式返回可能表示错误，因为隐式返回总是返回None值。\"",
    "output": "*       maintainability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unknown-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别非对称密钥生成过程中，密钥长度参数无法通过静态分析确定的代码实例",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 非对称加密密钥大小静态分析不可确认\n * @description 识别非对称密钥生成过程中，密钥长度参数无法通过静态分析确定的代码实例\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找所有非对称密钥生成操作及其密钥大小配置源\nfrom AsymmetricKeyGen asymmetricKeyOp, DataFlow::Node keySizeSource\nwhere\n  // 确认配置源与密钥生成操作的关联\n  keySizeSource = asymmetricKeyOp.getKeyConfigSrc()\n  // 检查密钥大小是否无法静态验证\n  and not asymmetricKeyOp.hasKeySize(keySizeSource)\nselect asymmetricKeyOp,\n  // 构建包含算法信息和配置源位置的诊断消息\n  \"算法 \" + asymmetricKeyOp.getAlgorithm().getName() + \" 的密钥生成过程中使用了无法静态验证的密钥长度，配置源自 $@\", keySizeSource, keySizeSource.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Deleted lines per file\n * @description Number of deleted lines per file, across the revision history in the database.\n * @kind treemap\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python // 导入python模块，用于处理Python代码相关的查询\nimport external.VCS // 导入外部版本控制系统（VCS）模块，用于访问版本控制数据\n\n// 从Module m和int n中选择数据\nfrom Module m, int n\nwhere\n  // 计算每个文件的删除行数总和，并赋值给n\n  n =\n_______________ // 补全条件\n      // 获取最近一次提交中指定文件的删除行数，并排除人工变更\n      churn = entry.getRecentDeletionsForFile(m.getFile()) and not artificialChange(entry)\n    |\n      // 将计算出的删除行数赋值给churn\n      churn\n    ) and\n  // 确保模块有代码行数的度量数据\n  exists(m.getMetrics().getNumberOfLinesOfCode())\nselect m, n order by n desc // 按删除行数降序排列结果",
    "output": "sum(Commit entry, int churn |"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inconsistent-mro]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent method resolution order\n * @description Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n// 获取指定基类在继承列表中的左侧相邻基类\nClassObject getLeftBase(ClassObject cls, ClassObject baseClass) {\n  // 存在位置索引index，使index>0且cls的第index个基类是baseClass，返回第index-1个基类\n  exists(int index | \n    index > 0 and \n    cls.getBaseType(index) = baseClass and \n    result = cls.getBaseType(index - 1)\n  )\n}\n\n// 检测类是否存在无效的方法解析顺序\npredicate hasInvalidMRO(ClassObject targetClass, ClassObject leftBase, ClassObject rightBase) {\n  // 验证目标类是新式类，且leftBase是rightBase的不当超类型\n  targetClass.isNewStyle() and\n  leftBase = getLeftBase(targetClass, rightBase) and\n  leftBase = rightBase.getAnImproperSuperType()\n}\n\n// 查询所有存在无效MRO的类并生成诊断信息\nfrom ClassObject targetClass, ClassObject leftBase, ClassObject rightBase\nwhere hasInvalidMRO(targetClass, leftBase, rightBase)\nselect targetClass,\n  \"Construction of class \" + targetClass.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", leftBase,\n  leftBase.getName(), rightBase, rightBase.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：在旧式类中使用 super() 访问继承的方法是不被支持的。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description 在旧式类中使用 super() 访问继承的方法是不被支持的。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n// 定义谓词：检测在旧式类中对 super() 的无效调用\npredicate superCallInOldStyleClass(Call superInvocation) {\n  // 检查是否存在包含调用的函数和类，满足以下条件：\n  exists(Function enclosingFunction, ClassObject enclosingClass |\n    // 调用点位于函数作用域内\n    superInvocation.getScope() = enclosingFunction and\n    // 函数位于类的作用域内\n    enclosingFunction.getScope() = enclosingClass.getPyClass() and\n    // 类类型推断成功\n    not enclosingClass.failedInference() and\n    // 类不是新式类\n    not enclosingClass.isNewStyle() and\n    // 调用函数名为 \"super\"\n    superInvocation.getFunc().(Name).getId() = \"super\"\n  )\n}\n\n// 查找所有无效的 super() 调用实例\nfrom Call invalidSuperCall\n// 筛选条件：调用发生在旧式类中\nwhere superCallInOldStyleClass(invalidSuperCall)\n// 输出结果和相应的错误信息\nselect invalidSuperCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-protocol]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects configurations using deprecated SSL/TLS protocol versions vulnerable to attacks",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of insecure SSL/TLS version\n * @description Detects configurations using deprecated SSL/TLS protocol versions vulnerable to attacks\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n/* Represents protocol configuration nodes using insecure SSL/TLS versions */\nclass InsecureProtocolConfig extends DataFlow::Node {\n  InsecureProtocolConfig() {\n    /* Case 1: Insecure connection with context */\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    /* Case 2: Insecure connection without context */\n    unsafe_connection_creation_without_context(this, _)\n    or\n    /* Case 3: Insecure context creation */\n    unsafe_context_creation(this, _)\n  }\n\n  /* Retrieves the function node associated with this configuration */\n  DataFlow::Node getFunctionNode() { result = this.(DataFlow::CallCfgNode).getFunction() }\n}\n\n/* Represents nodes that can be qualified (function calls or attribute references) */\nclass QualifiedNode extends DataFlow::Node {\n  QualifiedNode() {\n    /* Case 1: Node from protocol configuration function */\n    this = any(InsecureProtocolConfig insecureConfig).getFunctionNode()\n    or\n    /* Case 2: Attribute reference of another qualified node */\n    this = any(QualifiedNode baseNode).(DataFlow::AttrRef).getObject()\n  }\n}\n\n/* Builds qualified name for nodes with hierarchical naming */\nstring getQualifiedName(QualifiedNode qualifiedNode) {\n  /* Case 1: Direct function name */\n  result = qualifiedNode.asExpr().(Name).getId()\n  or\n  /* Case 2: Attribute access chain */\n  exists(DataFlow::AttrRef attributeRef | attributeRef = qualifiedNode |\n    result = getQualifiedName(attributeRef.getObject()) + \".\" + attributeRef.getAttributeName()\n  )\n}\n\n/* Generates descriptive label for protocol configuration */\nstring getConfigLabel(InsecureProtocolConfig insecureConfig) {\n  /* Case 1: Function call configuration */\n  exists(DataFlow::CallCfgNode callNode | callNode = insecureConfig |\n    result = \"call to \" + getQualifiedName(callNode.getFunction())\n  )\n  or\n  /* Case 2: Non-call context modification */\n  not insecureConfig instanceof DataFlow::CallCfgNode and\n  not insecureConfig instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n/* Determines appropriate verb based on specificity flag */\nstring getVerb(boolean isSpecific) {\n  isSpecific = true and result = \"specified\"\n  or\n  isSpecific = false and result = \"allowed\"\n}\n\n/* Main query detecting insecure SSL/TLS version usage */\nfrom\n  DataFlow::Node connectionNode, string version, \n  InsecureProtocolConfig configNode, boolean isSpecific\nwhere\n  /* Case 1: Insecure connection with context */\n  unsafe_connection_creation_with_context(connectionNode, version, configNode, isSpecific)\n  or\n  /* Case 2: Insecure connection without context */\n  unsafe_connection_creation_without_context(connectionNode, version) and\n  configNode = connectionNode and\n  isSpecific = true\n  or\n  /* Case 3: Insecure context creation */\n  unsafe_context_creation(configNode, version) and\n  connectionNode = configNode and\n  isSpecific = true\nselect connectionNode,\n  \"Insecure SSL/TLS protocol version \" + version + \" \" + getVerb(isSpecific) + \" by $@.\",\n  configNode, getConfigLabel(configNode)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class should be a context manager\n * @description Detects classes that implement __del__ for resource management\n *              but do not support the context manager protocol. Converting these\n *              classes to context managers would enhance resource handling\n *              and code clarity.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision medium\n * @id py/should-be-context-manager\n */\n\nimport python\n\nfrom ClassValue targetClass\nwhere\n_______________ // 补全条件\n  not targetClass.isBuiltin() and\n  // Check if the class defines a __del__ method for resource cleanup\n  exists(targetClass.declaredAttribute(\"__del__\")) and\n  // Ensure the class does not already implement the context manager protocol\n  not targetClass.isContextManager()\nselect targetClass,\n  \"Class \" + targetClass.getName() +\n    \" implements __del__ (presumably to release some resource). Consider making it a context manager.\"",
    "output": "// Exclude built-in classes from our analysis"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'exec' used\n * @description Detects usage of 'exec' statement/function which could lead to arbitrary code execution.\n * @kind problem\n * @tags security\n *       correctness\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec\n */\n\nimport python\n\n// Generates a version-specific alert message for 'exec' usage\nstring generateExecWarning() {\n  // In Python 2: 'exec' is implemented as a statement\n_______________ // 补全条件\n  // In Python 3: 'exec' is implemented as a built-in function\n  or\n  result = \"The 'exec' function is used.\" and major_version() = 3\n}\n\n// Main query to identify all 'exec' usage patterns in the codebase\nfrom AstNode execNode\nwhere \n  // Check for 'exec' function calls via global variable access\n  (exists(GlobalVariable execGlobalVar | \n    execNode instanceof Call and\n    execGlobalVar = execNode.(Call).getFunc().(Name).getVariable() and \n    execGlobalVar.getId() = \"exec\"\n  ))\n  or\n  // Check for 'exec' statement (Python 2 specific syntax)\n  execNode instanceof Exec\n// Report each identified node with its corresponding version-specific warning\nselect execNode, generateExecWarning()",
    "output": "result = \"The 'exec' statement is used.\" and major_version() = 2"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/paramiko-command-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：user provided command can lead to execute code on an external server that can belong to other users or admins",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Command execution on a secondary remote server\n * @description user provided command can lead to execute code on an external server that can belong to other users or admins\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.3\n * @precision high\n * @id py/paramiko-command-injection\n * @tags security\n *       experimental\n *       external/cwe/cwe-074\n */\n\n// 导入Python语言库\nimport python\n// 导入实验性的远程命令执行安全分析模块\nimport experimental.semmle.python.security.RemoteCommandExecution\n// 从远程命令执行流中导入路径图类\nimport RemoteCommandExecutionFlow::PathGraph\n\n// 定义数据流源节点和汇节点\nfrom RemoteCommandExecutionFlow::PathNode source, RemoteCommandExecutionFlow::PathNode sink\n// 条件：存在从源节点到汇节点的流路径\nwhere RemoteCommandExecutionFlow::flowPath(source, sink)\n// 选择汇节点、源节点、汇节点信息，并生成警告信息\nselect sink.getNode(), source, sink, \"This code execution depends on a $@.\", source.getNode(),\n  \"a user-provided value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/tarslip]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects potential directory traversal vulnerabilities during tar extraction where untrusted archive contents could overwrite files outside the target directory.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description Detects potential directory traversal vulnerabilities during tar extraction where untrusted archive contents could overwrite files outside the target directory.\n * @kind path-problem\n * @id py/tarslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\n// Identify vulnerable extraction flows from untrusted sources to extraction sinks\nfrom TarSlipFlow::PathNode untrustedSourceNode, TarSlipFlow::PathNode extractionSinkNode\nwhere \n  // Verify data flow path exists between source and sink\n  TarSlipFlow::flowPath(untrustedSourceNode, extractionSinkNode)\nselect \n  extractionSinkNode.getNode(), \n  untrustedSourceNode, \n  extractionSinkNode, \n  \"This file extraction depends on a $@.\", \n  untrustedSourceNode.getNode(),\n  \"potentially untrusted source\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-commented-out-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the quantity of commented-out code lines in each source file, while intentionally excluding lines that might represent example code",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File-based commented code line counter\n * @description Measures the quantity of commented-out code lines in each source file, while intentionally excluding lines that might represent example code\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\nimport python\nimport Lexical.CommentedOutCode\n\nfrom File fileToAnalyze, int commentedLinesTotal\nwhere commentedLinesTotal = count(CommentedOutCodeLine lineOfCommentedCode | \n        lineOfCommentedCode.getLocation().getFile() = fileToAnalyze and\n        not lineOfCommentedCode.maybeExampleCode()\n)\nselect fileToAnalyze, commentedLinesTotal order by commentedLinesTotal desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/efferent-coupling-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：此查询用于量化每个 Python 模块的传出耦合度，即该模块所依赖的其他模块数量。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python 模块传出耦合分析\n * @description 此查询用于量化每个 Python 模块的传出耦合度，即该模块所依赖的其他模块数量。\n *              传出耦合度高可能表明模块职责过多，降低了代码的可维护性和可测试性。\n * @kind 树状图\n * @id py/efferent-coupling-per-file\n * @treemap.warnOn 高值警告\n * @metricType 文件\n * @metricAggregate 平均值 最大值\n * @tags 可测试性\n *       模块化\n */\n\nimport python // 导入Python语言分析库\n\n// 从ModuleMetrics类中获取每个模块的分析对象\nfrom ModuleMetrics moduleAnalysis\n\n// 选择模块及其传出耦合度，按耦合度降序排列\nselect moduleAnalysis, \n       moduleAnalysis.getEfferentCoupling() as dependencyCount \norder by dependencyCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-authors]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes the number of unique contributors who have made changes to each Python file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of authors\n * @description Computes the number of unique contributors who have made changes to each Python file.\n *              This metric is useful for identifying files with high collaboration levels or potential knowledge concentration.\n * @kind treemap\n * @id py/historical-number-of-authors\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\n// Import required modules for analysis\nimport python\nimport external.VCS\n\n// Define the source of our analysis: Python modules representing files\nfrom Module pyFile\n// Apply filtering condition to ensure we only analyze files with actual code content\nwhere exists(pyFile.getMetrics().getNumberOfLinesOfCode())\n// Project the file module along with the count of distinct authors who have modified it\nselect pyFile, \n       count(Author contributor | \n             // An author is counted if they have edited this file\n             contributor.getAnEditedFile() = pyFile.getFile()\n       )"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/utils/modeleditor/framework-mode-endpoints]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and catalogs all accessible endpoints (both methods and attributes)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Model Editor Framework Endpoint Inventory\n * @description Identifies and catalogs all accessible endpoints (both methods and attributes) \n *              available in the model editor's framework mode. Excludes test files and \n *              generated code to focus solely on production endpoints.\n * @kind table\n * @id py/utils/modeleditor/framework-mode-endpoints\n * @tags modeleditor endpoints framework-mode\n */\n\n// Import ModelEditor module to leverage endpoint analysis functionality\nimport modeling.ModelEditor\n\n// Retrieve endpoint data from the ModelEditor framework\nfrom Endpoint editorFrameworkEndpoint\nselect \n  // Core endpoint reference\n  editorFrameworkEndpoint,\n  // Namespace that contains the endpoint\n  editorFrameworkEndpoint.getNamespace(),\n  // Class that defines the endpoint\n  editorFrameworkEndpoint.getClass(),\n  // Function/method name of the endpoint\n  editorFrameworkEndpoint.getFunctionName(),\n  // Parameter signature for the endpoint\n  editorFrameworkEndpoint.getParameters(),\n  // HTTP status codes supported by the endpoint\n  editorFrameworkEndpoint.getSupportedStatus(),\n  // Source file where endpoint is defined\n  editorFrameworkEndpoint.getFileName(),\n  // Data types supported by the endpoint\n  editorFrameworkEndpoint.getSupportedType(),\n  // Endpoint type classification (method or attribute)\n  editorFrameworkEndpoint.getKind()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 已知非对称密钥源生成\n * @description 识别代码库中所有通过受支持的加密库生成的非对称密钥。\n *              此查询追踪密钥生成操作及其配置源，有助于评估系统对量子计算威胁的抵御能力。\n * @kind problem\n * @id py/quantum-readiness/cbom/asymmetric-key-generation\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找所有非对称密钥生成操作及其关联的配置源\nfrom AsymmetricKeyGen asymmetricKeyGeneration, DataFlow::Node keyConfigSource\nwhere asymmetricKeyGeneration.getKeyConfigSrc() = keyConfigSource\n// 提取算法名称以提高可读性\nselect asymmetricKeyGeneration,\n_______________ // 补全条件\n    \" 的非对称密钥生成，密钥配置源 $@\", keyConfigSource, keyConfigSource.toString()",
    "output": "\"使用算法 \" + asymmetricKeyGeneration.getAlgorithm().getName() +"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'super' in old style class\n * @description 在旧式类中使用 super() 调用会导致运行时错误，因为旧式类不支持这种继承机制。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * 识别在旧式类中使用 super() 函数的调用点\n * \n * Python 中的旧式类（未显式继承自 object 的类）不支持使用 super() 内置函数\n * 来访问父类的方法或属性。当在这种类中使用 super() 时，会引发 TypeError。\n * 此谓词用于定位这些不兼容的用法。\n */\npredicate superCallInOldStyleClass(Call superCall) {\n  exists(Function parentFunction, ClassObject parentClass |\n    // 作用域验证：确保调用发生在类的方法中\n    superCall.getScope() = parentFunction and\n    parentFunction.getScope() = parentClass.getPyClass() and\n    \n    // 类属性验证：确保是有效的旧式类\n    not parentClass.failedInference() and\n    not parentClass.isNewStyle() and\n    \n    // 调用验证：确保是 super() 函数调用\n    superCall.getFunc().(Name).getId() = \"super\"\n  )\n}\n\n_______________ // 补全条件\nfrom Call problematicSuperCall\nwhere superCallInOldStyleClass(problematicSuperCall)\nselect problematicSuperCall, \"'super()' will not work in old-style classes.\"",
    "output": "// 查询所有在旧式类中使用的不兼容 super() 调用"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description 检测tar存档解压过程中的路径遍历漏洞。当解压操作未验证文件路径是否\n *              限制在目标目录内时，攻击者可能利用包含\"../\"序列的路径覆盖任意文件。\n * @kind path-problem\n * @id py/tarslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n_______________ // 补全条件\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\n// 定义不可信输入源和不安全的文件提取操作\nfrom TarSlipFlow::PathNode taintedSource, \n     TarSlipFlow::PathNode unsafeExtraction\n// 验证从不可信输入源到不安全文件提取操作的数据流路径是否存在\nwhere TarSlipFlow::flowPath(taintedSource, unsafeExtraction)\n// 输出结果：不安全的文件提取操作、不可信输入源、提取操作详情及安全警告\nselect unsafeExtraction.getNode(), \n       taintedSource, \n       unsafeExtraction, \n       \"This file extraction depends on a $@.\", \n       taintedSource.getNode(),\n       \"potentially untrusted source\"",
    "output": "* @tags security"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 多项式时间复杂度正则表达式应用于不可控数据\n * @description 检测具有多项式时间复杂度的正则表达式在处理特定输入时可能导致拒绝服务攻击\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @id py/polynomial-redos\n * @tags security\n *       external/cwe/cwe-1333\n *       external/cwe/cwe-730\n *       external/cwe/cwe-400\n */\n\n// 导入Python代码分析基础模块，提供Python语言分析的核心功能\nimport python\n// 导入多项式ReDoS安全查询模块，用于识别正则表达式中的复杂度问题\nimport semmle.python.security.dataflow.PolynomialReDoSQuery\n// 导入路径图模块，用于追踪数据流传播路径\nimport PolynomialReDoSFlow::PathGraph\n\n// 定义查询所需的核心变量和组件\nfrom\n  // 存在回溯问题的正则表达式，可能导致性能问题\n  PolynomialBackTrackingTerm regexWithBacktrackingIssue,\n  // 数据流接收器节点，即正则表达式使用点\n  Sink regexUsageLocation,\n  // 数据流路径的起点，通常为用户输入源\n  PolynomialReDoSFlow::PathNode inputSource,\n  // 数据流路径的终点，即数据到达接收器的位置\n  PolynomialReDoSFlow::PathNode dataDestination\n// 设置查询条件，确保数据流路径存在且关联到易受攻击的正则表达式\nwhere\n  // 检查从输入源到目标节点的完整数据流路径\n  PolynomialReDoSFlow::flowPath(inputSource, dataDestination) and\n  // 确认目标节点与正则表达式使用位置对应\n  regexUsageLocation = dataDestination.getNode() and\n  // 从正则表达式使用位置中提取存在回溯问题的正则表达式\n  regexWithBacktrackingIssue = regexUsageLocation.getABacktrackingTerm()\n// 输出查询结果，包含路径信息和警告消息\nselect\n  // 高亮显示正则表达式使用位置\n_______________ // 补全条件\n  inputSource, \n  dataDestination,\n  // 构建详细的警告消息，说明潜在的性能风险\n  \"This $@ that depends on a $@ may run slow on strings \" + \n  regexWithBacktrackingIssue.getPrefixMessage() +\n  \"with many repetitions of '\" + regexWithBacktrackingIssue.getPumpString() + \"'.\",\n  // 标识易受攻击的正则表达式对象\n  regexWithBacktrackingIssue, \n  \"regular expression\",\n  // 标识用户提供的输入源\n  inputSource.getNode(), \n  \"user-provided value\"",
    "output": "regexUsageLocation.getHighlight(),"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/bind-socket-all-network-interfaces]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects socket configurations bound to all network interfaces (0.0.0.0, ::, etc.),",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Socket binding to all network interfaces\n * @description Detects socket configurations bound to all network interfaces (0.0.0.0, ::, etc.),\n * which exposes services to any network source and creates significant security vulnerabilities.\n * @kind problem\n * @tags security\n *       external/cwe/cwe-200\n * @problem.severity error\n * @security-severity 6.5\n * @sub-severity low\n * @precision high\n * @id py/bind-socket-all-network-interfaces\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n/** Identifies wildcard hostnames representing all network interfaces */\nprivate string getWildcardHostname() {\n  result in [\n      // IPv4 wildcards\n      \"0.0.0.0\", \"\",\n      // IPv6 wildcards\n      \"::\", \"::0\"\n    ]\n}\n\n/** Propagates wildcard hostname references through type tracking */\nprivate DataFlow::TypeTrackingNode propagateHostnameReference(DataFlow::TypeTracker tracker, string hostname) {\n  tracker.start() and\n  exists(StringLiteral wildcardLiteral | hostname = getWildcardHostname() |\n    wildcardLiteral.getText() = hostname and\n    result.asExpr() = wildcardLiteral\n  )\n  or\n  exists(DataFlow::TypeTracker prevTracker | \n    result = propagateHostnameReference(prevTracker, hostname).track(prevTracker, tracker)\n  )\n}\n\n/** Retrieves data flow nodes containing wildcard hostname references */\nDataFlow::Node findHostnameReference(string hostname) {\n  propagateHostnameReference(DataFlow::TypeTracker::end(), hostname).flowsTo(result)\n}\n\n/** Tracks address tuples containing wildcard hostnames as their first element */\nprivate DataFlow::TypeTrackingNode propagateAddressTuple(DataFlow::TypeTracker tracker, string hostname) {\n  tracker.start() and\n  result.asExpr() = any(Tuple addressTuple | \n    addressTuple.getElt(0) = findHostnameReference(hostname).asExpr()\n  )\n  or\n  exists(DataFlow::TypeTracker prevTracker | \n    result = propagateAddressTuple(prevTracker, hostname).track(prevTracker, tracker)\n  )\n}\n\n/** Obtains data flow nodes representing address tuples with wildcard hostnames */\nDataFlow::Node findAddressTuple(string hostname) {\n  propagateAddressTuple(DataFlow::TypeTracker::end(), hostname).flowsTo(result)\n}\n\n/**\n * Identifies socket objects created with specific address families.\n * \n * Reference: https://docs.python.org/3/library/socket.html\n */\nAPI::Node identifySocketInstance() { \n  result = API::moduleImport(\"socket\").getMember(\"socket\").getReturn() \n}\n\nfrom DataFlow::CallCfgNode bindInvocation, DataFlow::Node addressArg, string hostname\nwhere\n  bindInvocation = identifySocketInstance().getMember(\"bind\").getACall() and\n  addressArg = bindInvocation.getArg(0) and\n  addressArg = findAddressTuple(hostname)\nselect bindInvocation.asExpr(), \"Socket bound to all network interfaces via '\" + hostname + \"' configuration.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Improper LDAP Authentication\n * @description Identifies LDAP bind operations lacking proper authentication mechanisms\n * @kind problem\n * @problem.severity warning\n * @id py/improper-ldap-auth\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\n\n/**\n * Detects LDAP bind operations with authentication deficiencies:\n * - Absence of password parameter\n * - Explicitly set to None value\n * - Configured with empty string\n */\npredicate hasImproperAuthentication(LdapBind ldapBind) {\n  // Scenario 1: Password parameter not provided\n  not exists(ldapBind.getPassword())\n  or\n  // Scenario 2: Password explicitly assigned None\n  exists(None noneValue |\n    DataFlow::localFlow(DataFlow::exprNode(noneValue), ldapBind.getPassword())\n  )\n_______________ // 补全条件\n  // Scenario 3: Password configured as empty string\n  exists(StringLiteral emptyStr |\n    emptyStr.getText() = \"\" and\n    DataFlow::localFlow(DataFlow::exprNode(emptyStr), ldapBind.getPassword())\n  )\n}\n\nfrom LdapBind ldapBind\nwhere hasImproperAuthentication(ldapBind)\nselect ldapBind, \"The following LDAP bind operation is executed without authentication.\"",
    "output": "or"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/useless-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers that use non-exception types,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-exception type in exception handler\n * @description Identifies exception handlers that use non-exception types,\n *              making them ineffective at catching runtime exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Define variables for analyzing exception handling constructs\nfrom ExceptFlowNode handlerNode, Value handledType, ClassValue typeClass, \n     ControlFlowNode sourceNode, string typeDescription\nwhere\n  // Verify that the exception handler processes a specific exception type from the source\n  handlerNode.handledException(handledType, typeClass, sourceNode) and\n  (\n    // Case 1: The handled type is a class but not a valid exception class\n    exists(ClassValue invalidClass | \n      invalidClass = handledType and\n      not invalidClass.isLegalExceptionType() and\n      not invalidClass.failedInference(_) and\n      typeDescription = \"class '\" + invalidClass.getName() + \"'\"\n    )\n    or\n    // Case 2: The handled type is not a class at all\n    not handledType instanceof ClassValue and\n    typeDescription = \"instance of '\" + typeClass.getName() + \"'\"\n  )\nselect handlerNode.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  sourceNode, typeDescription"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Parameter with default value modification\n * @description Detects modifications of parameters that have default values, which can cause unexpected behavior since default values are shared across function calls.\n * @kind path-problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n_______________ // 补全条件\n */\n\nimport python\nimport semmle.python.functions.ModificationOfParameterWithDefault\nimport ModificationOfParameterWithDefault::Flow::PathGraph\n\nfrom\n  ModificationOfParameterWithDefault::Flow::PathNode startNode,\n  ModificationOfParameterWithDefault::Flow::PathNode endNode\nwhere \n  ModificationOfParameterWithDefault::Flow::flowPath(startNode, endNode)\nselect \n  endNode.getNode(), \n  startNode, \n  endNode, \n  \"This expression mutates a $@.\", \n  startNode.getNode(),\n  \"default value\"",
    "output": "* @id py/modification-of-default-value"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-re-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Counts re-commits (commits to files modified within the last 5 days)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of re-commits for each file\n * @description Counts re-commits (commits to files modified within the last 5 days)\n * @kind treemap\n * @id py/historical-number-of-re-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\n// Import Python and external version control system libraries\nimport python\nimport external.VCS\n\n// Predicate to determine if two commits are within the re-commit time window\npredicate commitsInRange(Commit earlierCommit, Commit laterCommit) {\n  // Both commits must affect the same file and be distinct\n  earlierCommit.getAnAffectedFile() = laterCommit.getAnAffectedFile() and\n  earlierCommit != laterCommit and\n  // Calculate days between commits (must be 0-4 days)\n  exists(int daysBetween |\n    daysBetween = earlierCommit.getDate().daysTo(laterCommit.getDate()) and\n    daysBetween >= 0 and\n    daysBetween < 5\n  )\n}\n\n// Calculate total re-commits for a given file\nint countRecommits(File targetFile) {\n  // Count all commits that qualify as re-commits\n  result = count(Commit subsequentCommit |\n    // Commit affects the target file\n    targetFile = subsequentCommit.getAnAffectedFile() and\n    // Exists a previous commit within re-commit window\n    exists(Commit previousCommit | \n      commitsInRange(previousCommit, subsequentCommit)\n    )\n  )\n}\n\n// Query modules with available code metrics\nfrom Module sourceModule\n// Ensure module has lines-of-code metrics available\nwhere exists(sourceModule.getMetrics().getNumberOfLinesOfCode())\n// Select module and its re-commit count\nselect sourceModule, countRecommits(sourceModule.getFile())"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cryptographic implementations utilizing elliptic curve algorithms that are either unrecognized or identified as having insufficient security strength.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak elliptic curve\n * @description Detects cryptographic implementations utilizing elliptic curve algorithms that are either unrecognized or identified as having insufficient security strength.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm curveOperation, string securityAlert, string curveName\nwhere\n  curveName = curveOperation.getCurveName() and\n  (\n    // Scenario 1: Algorithm is not recognized by the system\n    curveName = unknownAlgorithm() and\n    securityAlert = \"Use of unrecognized curve algorithm.\"\n    or\n    // Scenario 2: Algorithm is recognized but classified as weak\n    curveName != unknownAlgorithm() and\n    not curveName =\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    securityAlert = \"Use of weak curve algorithm \" + curveName + \".\"\n  )\nselect curveOperation, securityAlert"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mutable-descriptor]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Identifies classes with descriptor protocol methods that perform mutation operations\npredicate has_descriptor_mutation(ClassObject descriptorCls, SelfAttributeStore mutatingOperation) {\n  // Verify the class implements descriptor protocol\n  descriptorCls.isDescriptorType() and\n  // Find descriptor protocol methods (__get__/__set__/__delete__)\n  exists(PyFunctionObject protocolMethod, string protocolMethodName |\n    descriptorCls.lookupAttribute(protocolMethodName) = protocolMethod and\n    (protocolMethodName = \"__get__\" or protocolMethodName = \"__set__\" or protocolMethodName = \"__delete__\") and\n    // Locate methods called by descriptor protocol methods\n    exists(PyFunctionObject calledMethod |\n      // Called method belongs to the same class\n      descriptorCls.lookupAttribute(_) = calledMethod and\n      // Trace call chain from descriptor method to called method\n      protocolMethod.getACallee*() = calledMethod and\n      // Exclude initialization methods\n      not calledMethod.getName() = \"__init__\" and\n      // Mutation occurs within the called method's scope\n      mutatingOperation.getScope() = calledMethod.getFunction()\n    )\n  )\n}\n\n// Identify classes and operations where descriptor mutation occurs\nfrom ClassObject descriptorCls, SelfAttributeStore mutatingOperation\nwhere has_descriptor_mutation(descriptorCls, mutatingOperation)\n// Output mutation location, warning message, and related class details\nselect mutatingOperation,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorCls, descriptorCls.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/efferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the count of external classes that each class relies upon.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Outgoing class dependencies\n * @description Measures the count of external classes that each class relies upon.\n *              This metric indicates how coupled a class is to other components.\n * @kind treemap\n * @id py/efferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags testability\n *       modularity\n */\n\nimport python\n\n// Analyze class metrics to determine efferent coupling (outgoing dependencies)\n// Higher values indicate classes with more external dependencies\nfrom ClassMetrics analyzedClass\nselect analyzedClass, analyzedClass.getEfferentCoupling() as dependencyCount order by dependencyCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * 计算边际增加的指向关系事实、指向关系的总大小以及这两者相对于上下文深度的比例。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义一个函数，用于计算给定控制流节点、对象值和类对象的上下文深度。\nint depth(ControlFlowNode f, Object value, ClassObject cls) {\n  // 存在一个指向上下文ctx，使得在ctx中f指向value且cls为指定类对象，并且结果为ctx的深度。\n  exists(PointsToContext ctx |\n    PointsTo::points_to(f, ctx, value, cls, _) and\n    result = ctx.getDepth()\n  )\n}\n\n// 定义一个函数，用于计算给定控制流节点、对象值和类对象的最浅深度。\nint shallowest(ControlFlowNode f, Object value, ClassObject cls) {\n  // 结果为所有可能深度中的最小值。\n  result = min(int x | x = depth(f, value, cls))\n}\n\n// 从total_facts（总事实数）、total_size（总大小）、depth（深度）和efficiency（效率）中选择数据。\nfrom int total_facts, int total_size, int depth, float efficiency\nwhere\n  // 计算总事实数，即满足条件的(f, value, cls)的数量，其中depth为shallowest(f, value, cls)。\n  total_facts =\n    strictcount(ControlFlowNode f, Object value, ClassObject cls | depth = shallowest(f, value, cls)) and\n  // 计算总大小，即满足条件的(f, value, cls, ctx, orig)的数量，其中在ctx中f指向value且cls为指定类对象，并且depth为ctx的深度。\n  total_size =\n    strictcount(ControlFlowNode f, Object value, ClassObject cls, PointsToContext ctx,\n      ControlFlowNode orig |\n      PointsTo::points_to(f, ctx, value, cls, orig) and\n      depth = ctx.getDepth()\n    ) and\n  // 计算效率，即总事实数占总大小的比例乘以100。\n  efficiency = 100.0 * total_facts / total_size\nselect depth, total_facts, total_size, efficiency"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-hostname-regexp]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies security vulnerabilities in regular expressions used for hostname or URL validation, specifically where dots are not correctly escaped, resulting in excessively permissive hostname matching.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Vulnerable hostname regular expression patterns\n * @description Identifies security vulnerabilities in regular expressions used for hostname or URL validation, specifically where dots are not correctly escaped, resulting in excessively permissive hostname matching.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-hostname-regexp\n * @tags correctness\n *       security\n *       external/cwe/cwe-020\n */\n\n// Import the dedicated module for examining security vulnerabilities in regular expressions for hostnames\nprivate import semmle.python.security.regexp.HostnameRegex as HostnamePatternChecker\n\n// Main query predicate designed to uncover security issues in hostname regular expression patterns\nquery predicate hostnameRegexVulnerabilities = HostnamePatternChecker::incompleteHostnameRegExp/4;"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/hash-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects all cryptographic hash algorithm implementations across supported libraries.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cryptographic Hash Algorithm Usage\n * @description Detects all cryptographic hash algorithm implementations across supported libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/hash-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import core Python analysis modules\nimport python\n\n// Import experimental cryptography detection utilities\nimport experimental.cryptography.Concepts\n\n// Identify cryptographic hash algorithm instances\nfrom HashAlgorithm cryptoHash\n\n// Generate alert for each detected hash algorithm\nselect cryptoHash, \"Cryptographic hash algorithm detected: \" + cryptoHash.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * 调用图结构量化分析：评估调用图的密度与结构效率。\n * 该查询通过统计调用事实数量、关系规模、上下文深度以及计算密度比率，\n * 对调用图的数据密度和结构效率进行量化评估，为代码性能优化提供数据支持。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义输出变量：callFactCount（调用事实总数）、callRelationCount（关系总规模）、\n// callContextDepth（上下文深度）和callDensityRatio（密度比率）\nfrom int callFactCount, int callRelationCount, int callContextDepth, float callDensityRatio\nwhere\n  // 第一部分：计算调用图中的事实总数\n  // 统计所有(调用点, 目标函数)对的数量，反映调用图的基本规模\n  callFactCount =\n    strictcount(ControlFlowNode invocationPoint, CallableValue targetFunction |\n      exists(PointsToContext invocationContext |\n        invocationPoint = targetFunction.getACall(invocationContext) and // 获取targetFunction在invocationContext中的调用点invocationPoint\n        callContextDepth = invocationContext.getDepth() // 记录invocationContext的深度\n      )\n    ) and\n  // 第二部分：计算调用图关系的总规模\n  // 统计所有(调用点, 目标函数, 调用上下文)三元组的数量，反映调用图的详细程度\n  callRelationCount =\n    strictcount(ControlFlowNode invocationPoint, CallableValue targetFunction, PointsToContext invocationContext |\n      invocationPoint = targetFunction.getACall(invocationContext) and // 获取targetFunction在invocationContext中的调用点invocationPoint\n      callContextDepth = invocationContext.getDepth() // 记录invocationContext的深度\n    ) and\n  // 第三部分：计算密度比率\n  // 将调用事实总数转换为相对于关系总规模的百分比，反映调用图的紧凑程度\n  callDensityRatio = 100.0 * callFactCount / callRelationCount\nselect callContextDepth, callFactCount, callRelationCount, callDensityRatio // 返回上下文深度、调用事实总数、关系总规模和密度比率"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 错误的类实例化参数数量\n * @description 识别类实例化时传入参数数量与构造函数(__init__)定义不符的情况，这类错误会在运行时引发TypeError异常。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstanceCall, ClassValue targetClass, string errorType, string constraintText, int expectedArgCount, FunctionValue classInitializer\nwhere\n  // 获取目标类的初始化方法（即__init__函数）\n  classInitializer = get_function_or_initializer(targetClass) and\n  (\n    // 检测参数数量超过构造函数允许上限的情况\n    too_many_args(classInstanceCall, targetClass, expectedArgCount) and\n    errorType = \"too many arguments\" and\n    constraintText = \"no more than \"\n    or\n    // 检测参数数量低于构造函数要求下限的情况\n    too_few_args(classInstanceCall, targetClass, expectedArgCount) and\n    errorType = \"too few arguments\" and\n    constraintText = \"no fewer than \"\n  )\nselect classInstanceCall, \"Call to $@ with \" + errorType + \"; should be \" + constraintText + expectedArgCount.toString() + \".\", classInitializer,\n_______________ // 补全条件\n  classInitializer.getQualifiedName()",
    "output": "// 输出类实例化调用点、错误描述及构造函数的完全限定名"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary 'else' clause in loop\n * @description Identifies 'for' or 'while' loops containing an 'else' clause that never serves its purpose\n *              because the loop body lacks a 'break' statement, making the 'else' clause redundant.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-else\n */\n\nimport python\n\n_______________ // 补全条件\nwhere\n  // Identify for loops with an else clause\n  (exists(For forStmt | \n      targetLoop = forStmt and \n      loopContent = forStmt.getBody() and \n      elseSection = forStmt.getOrelse() and \n      loopKind = \"for\")\n   // Identify while loops with an else clause\n   or\n   exists(While whileStmt | \n      targetLoop = whileStmt and \n      loopContent = whileStmt.getBody() and \n      elseSection = whileStmt.getOrelse() and \n      loopKind = \"while\"))\n  and\n  // Ensure no break statements exist in the loop body\n  not exists(Break breakStatement | loopContent.contains(breakStatement))\nselect targetLoop,\n  \"This '\" + loopKind + \"' statement has a redundant 'else' as no 'break' is present in the body.\"",
    "output": "from Stmt targetLoop, StmtList loopContent, StmtList elseSection, string loopKind"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies the use of unapproved or weak elliptic curve cryptography algorithms.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak elliptic curve\n * @description Identifies the use of unapproved or weak elliptic curve cryptography algorithms.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n/**\n * Retrieves a list of cryptographically secure elliptic curve algorithms\n * that are approved for use in secure systems.\n */\nstring getApprovedEllipticCurves() {\n  result =\n    [\n      \"SECP256R1\", \"PRIME256V1\",  // NIST P-256 curves\n      \"SECP384R1\",               // NIST P-384 curve\n      \"SECP521R1\",               // NIST P-521 curve\n      \"ED25519\",                 // EdDSA Ed25519 curve\n      \"X25519\"                   // ECDH X25519 curve\n    ]\n}\n\n/**\n * Detects weak or unrecognized elliptic curve algorithms in cryptographic operations.\n */\nfrom EllipticCurveAlgorithm curveAlgorithm, string securityAlert, string ellipticCurveName\nwhere\n  // Extract the curve name from the algorithm instance\n  ellipticCurveName = curveAlgorithm.getCurveName() and\n  (\n    // Case 1: Check for unrecognized curve algorithms\n    ellipticCurveName = unknownAlgorithm() and\n    securityAlert = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: Check for weak curve algorithms not in the approved list\n    ellipticCurveName != unknownAlgorithm() and\n    not ellipticCurveName = getApprovedEllipticCurves() and\n    securityAlert = \"Use of weak curve algorithm \" + ellipticCurveName + \".\"\n  )\nselect curveAlgorithm, securityAlert"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Suboptimal None comparison using equality operator\n * @description Detects code locations where objects are compared to 'None' using the == operator,\n *              which may cause unexpected behavior due to potential operator overloading.\n *              The 'is' operator should be used for identity comparison with None.\n * @kind problem\n * @tags efficiency\n *       maintainability\n * @problem.severity recommendation\n_______________ // 补全条件\n * @precision very-high\n * @id py/test-equals-none\n */\n\nimport python\n\n// Identify comparison expressions involving None equality checks\nfrom Compare noneComparison\nwhere \n    // Check for equality operator usage\n    noneComparison.getOp(0) instanceof Eq\n    // Verify one operand is the None literal\n    and exists(None noneLiteral | noneComparison.getAComparator() = noneLiteral)\nselect noneComparison, \"Testing for None should use the 'is' operator.\"",
    "output": "* @sub-severity high"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/conflicting-attributes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects classes that inherit from multiple base classes where more than one base class defines the same attribute. Such conflicts can lead to unexpected behavior due to attribute resolution ambiguity.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Conflicting attributes in base classes\n * @description Detects classes that inherit from multiple base classes where more than one base class defines the same attribute. Such conflicts can lead to unexpected behavior due to attribute resolution ambiguity.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n/**\n * Determines if a Python function implementation is effectively empty.\n * A function is considered empty if its body contains only pass statements or docstrings.\n */\npredicate is_empty_implementation(PyFunctionObject function) {\n  // Verify no non-trivial statements exist in function body\n  not exists(Stmt stmt | stmt.getScope() = function.getFunction() |\n    not stmt instanceof Pass and \n    not stmt.(ExprStmt).getValue() = function.getFunction().getDocString()\n  )\n}\n\n/**\n * Checks if a function explicitly invokes super() for method resolution.\n * This indicates the function is designed to work in multiple inheritance scenarios\n * by properly calling the parent class implementation.\n */\npredicate invokes_super(FunctionObject function) {\n  // Identify super().method_name() call pattern in function body\n  exists(Call superCall, Call methodCall, Attribute attr, GlobalVariable superVar |\n    methodCall.getScope() = function.getFunction() and\n    methodCall.getFunc() = attr and\n    attr.getObject() = superCall and\n    attr.getName() = function.getName() and\n    superCall.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/**\n * Identifies attribute names exempt from conflict detection.\n * These attributes have known patterns of usage in multiple inheritance scenarios\n * where conflicts are expected and handled appropriately.\n */\npredicate is_exempt_attribute(string attributeName) {\n  /*\n   * Exemption for process_request as documented in Python's socketserver module:\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   * This attribute is intentionally overridden in multiple inheritance patterns\n   * and does not represent a problematic conflict.\n   */\n  attributeName = \"process_request\"\n}\n\nfrom\n  ClassObject derivedClass, \n  ClassObject firstBaseClass, \n  ClassObject secondBaseClass, \n  string conflictingAttributeName, \n  int firstInheritanceOrder, \n  int secondInheritanceOrder, \n  Object attributeInFirstBase, \n  Object attributeInSecondBase\nwhere\n  // Establish inheritance relationships between derived class and its base classes\n  derivedClass.getBaseType(firstInheritanceOrder) = firstBaseClass and\n  derivedClass.getBaseType(secondInheritanceOrder) = secondBaseClass and\n  \n  // Ensure distinct base classes ordered by inheritance position\n  firstInheritanceOrder < secondInheritanceOrder and\n  \n  // Identify conflicting attributes in different base classes\n  attributeInFirstBase = firstBaseClass.lookupAttribute(conflictingAttributeName) and\n  attributeInSecondBase = secondBaseClass.lookupAttribute(conflictingAttributeName) and\n  attributeInFirstBase != attributeInSecondBase and\n  \n  // Filter out non-problematic conflicts\n  not conflictingAttributeName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and           // Exclude special methods\n  not is_exempt_attribute(conflictingAttributeName) and              // Exclude known exempt attributes\n  not derivedClass.declaresAttribute(conflictingAttributeName) and   // Ensure derived class doesn't override\n  not attributeInFirstBase.overrides(attributeInSecondBase) and      // No override relationship between attributes\n  not attributeInSecondBase.overrides(attributeInFirstBase) and\n  not invokes_super(attributeInFirstBase) and                        // Skip if first base handles resolution\n  not is_empty_implementation(attributeInSecondBase)                 // Ignore trivial implementations in second base\nselect derivedClass, \n  \"Base classes have conflicting values for attribute '\" + conflictingAttributeName + \"': $@ and $@.\", \n  attributeInFirstBase, attributeInFirstBase.toString(), \n  attributeInSecondBase, attributeInSecondBase.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Confusing octal literal\n * @description Octal literal with a leading 0 is easily misread as a decimal value\n * @kind problem\n * @tags readability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/old-style-octal-literal\n */\n\nimport python\n\n// 定义谓词函数，用于识别旧式八进制字面量（以0开头但不包含0o前缀的八进制数）\npredicate is_old_octal(IntegerLiteral literal) {\n  exists(string literalText, int textLength |\n    literalText = literal.getText() and\n    textLength = literalText.length() and\n    // 检查字面量以0开头，且不是特殊情况\"00\"\n    literalText.charAt(0) = \"0\" and\n    not literalText = \"00\" and\n    // 确保第二个字符是数字（即这是一个有效的八进制数）\n_______________ // 补全条件\n    /* 排除文件权限掩码（通常为4、5或7位） */\n    textLength != 4 and\n    textLength != 5 and\n    textLength != 7\n  )\n}\n\n// 从所有整数字面量中筛选出旧式八进制字面量\nfrom IntegerLiteral literal\nwhere is_old_octal(literal)\nselect literal, \"Confusing octal literal, use 0o\" + literal.getText().suffix(1) + \" instead.\"",
    "output": "exists(literalText.charAt(1).toInt()) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：使用 super() 访问继承的方法在旧式类中是不被支持的。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description 使用 super() 访问继承的方法在旧式类中是不被支持的。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * 检测在旧式类中使用 super() 调用的情况。\n * 在 Python 中，这种用法会导致运行时错误。\n */\nfrom Call superCallExpr\nwhere\n  // 确认调用的是 super 函数\n  superCallExpr.getFunc().(Name).getId() = \"super\" and\n  exists(Function enclosingMethod, ClassObject oldStyleClass |\n    // super() 调用必须位于方法内部\n    superCallExpr.getScope() = enclosingMethod and\n    // 方法必须定义在类内部\n    enclosingMethod.getScope() = oldStyleClass.getPyClass() and\n    // 确保类的类型推断成功\n    not oldStyleClass.failedInference() and\n    // 确认类是旧式类（非新式类）\n    not oldStyleClass.isNewStyle()\n  )\nselect superCallExpr, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mixed-returns]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies functions that combine explicit return statements with implicit returns,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Explicit returns mixed with implicit (fall through) returns\n * @description Identifies functions that combine explicit return statements with implicit returns,\n *              which can cause unexpected behavior since implicit returns always yield None.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mixed-returns\n */\n\nimport python\n\n// Predicate to identify functions containing explicit return statements that yield non-None values\npredicate explicitly_returns_non_none(Function func) {\n  // Verify existence of a return statement within the function scope that returns a non-None value\n  exists(Return returnStmt |\n    returnStmt.getScope() = func and\n    exists(Expr returnedValue | \n      returnedValue = returnStmt.getValue() and \n      not returnedValue instanceof None\n    )\n  )\n}\n\n// Predicate to identify functions with implicit return paths\npredicate has_implicit_return(Function func) {\n  // A function has implicit returns if either:\n  // 1. It contains a reachable fallthrough node, or\n  // 2. It includes return statements without explicit values\n  (exists(ControlFlowNode fallThroughNode |\n    fallThroughNode = func.getFallthroughNode() and \n    not fallThroughNode.unlikelyReachable()\n  ))\n  or\n  (exists(Return returnStmt | \n    returnStmt.getScope() = func and \n    not exists(returnStmt.getValue())\n  ))\n}\n\n// Select functions that both explicitly return non-None values and have implicit return paths\nfrom Function func\nwhere explicitly_returns_non_none(func) and has_implicit_return(func)\nselect func,\n  \"Mixing implicit and explicit returns may indicate an error as implicit returns always return None.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-recent-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：计算最近六个月内有效代码提交的总量，排除自动生成的变更",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 近期代码提交分析\n * @description 计算最近六个月内有效代码提交的总量，排除自动生成的变更\n * @kind treemap\n * @id py/historical-number-of-recent-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\nimport python // Python语言分析模块\nimport external.VCS // 外部版本控制支持模块\n\n// 从版本控制系统中提取所有提交记录\nfrom Commit commitRecord\n// 应用过滤条件，筛选出符合条件的有效提交\nwhere \n  // 时间过滤：仅包含最近180天内的提交\n  commitRecord.daysToNow() <= 180 and \n  // 内容过滤：排除自动生成的变更（如CI/CD工具生成的提交）\n  not artificialChange(commitRecord)\n// 输出结果：返回修订名称作为分组依据，值1用于后续聚合计算\nselect commitRecord.getRevisionName(), 1"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary pass\n * @description Identifies redundant 'pass' statements in Python code that can be safely removed\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unnecessary-pass\n */\n\nimport python\n\n// Helper predicate to determine if an expression statement represents a docstring\npredicate is_doc_string(ExprStmt docExprStmt) {\n  // Verify the expression value is either a Unicode or Bytes literal\n  docExprStmt.getValue() instanceof Unicode or docExprStmt.getValue() instanceof Bytes\n}\n\n// Helper predicate to check if a statement list begins with a docstring\npredicate has_doc_string(StmtList statementList) {\n  // Ensure the parent is a Scope and the first statement is a docstring\n  statementList.getParent() instanceof Scope and\n  is_doc_string(statementList.getItem(0))\n}\n\n// Helper predicate to identify contexts where a pass statement is redundant\npredicate is_unnecessary_pass_context(StmtList statementList) {\n  exists(Pass unnecessaryPass |\n    statementList.getAnItem() = unnecessaryPass and\n    (\n      // Scenario 1: Statement list has exactly 2 items and no docstring\n      strictcount(statementList.getAnItem()) = 2 and not has_doc_string(statementList)\n      or\n      // Scenario 2: Statement list contains more than 2 items\n      strictcount(statementList.getAnItem()) > 2\n_______________ // 补全条件\n  )\n}\n\nfrom Pass unnecessaryPass, StmtList parentStmtList\nwhere\n  parentStmtList.getAnItem() = unnecessaryPass and\n  is_unnecessary_pass_context(parentStmtList)\nselect unnecessaryPass, \"Unnecessary 'pass' statement.\"",
    "output": ")"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：超类属性遮蔽子类方法是指在继承体系中，超类的 __init__ 方法中定义的实例属性",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 超类属性遮蔽子类方法是指在继承体系中，超类的 __init__ 方法中定义的实例属性\n *              与子类中定义的方法同名，导致子类方法无法正常访问的问题。这种情况会导致\n *              运行时行为异常，因为属性赋值会覆盖方法引用。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 此查询检测子类方法是否被超类初始化方法中定义的属性遮蔽。\n * \n * 检测流程：\n * 1. 识别类继承关系：确定子类和超类之间的关系\n * 2. 检查子类方法：在子类中查找可能被遮蔽的方法\n * 3. 检查超类属性：在超类的 __init__ 方法中查找同名属性赋值\n * 4. 排除有意设计：如果超类也定义了同名方法，则视为有意设计，不报告\n */\n\nimport python\n\n// 判断子类方法是否被超类属性遮蔽\npredicate isMethodShadowedBySuperAttribute(\n  ClassObject subclass, ClassObject superclass, Assign attributeAssignment, FunctionObject overriddenMethod\n) {\n  // 步骤1：确认继承关系\n  subclass.getASuperType() = superclass and\n  \n  // 步骤2：确认子类声明了可能被遮蔽的方法\n  subclass.declaredAttribute(_) = overriddenMethod and\n  \n  // 步骤3：在超类初始化方法中查找同名属性赋值\n  exists(FunctionObject initializerMethod, Attribute assignedAttribute |\n    // 超类定义了 __init__ 方法\n    superclass.declaredAttribute(\"__init__\") = initializerMethod and\n    \n    // 属性赋值的目标是 assignedAttribute\n    assignedAttribute = attributeAssignment.getATarget() and\n    \n    // 属性赋值对象是 self\n    assignedAttribute.getObject().(Name).getId() = \"self\" and\n    \n    // 属性名称与子类方法名称相同\n    assignedAttribute.getName() = overriddenMethod.getName() and\n    \n    // 赋值操作发生在超类的初始化方法中\n    attributeAssignment.getScope() = initializerMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  \n  // 步骤4：排除超类中定义同名方法的情况（视为有意设计）\n  not superclass.hasAttribute(overriddenMethod.getName())\n}\n\n// 查询被遮蔽的方法及其相关信息\nfrom ClassObject subclass, ClassObject superclass, Assign attributeAssignment, FunctionObject overriddenMethod\nwhere isMethodShadowedBySuperAttribute(subclass, superclass, attributeAssignment, overriddenMethod)\nselect overriddenMethod.getOrigin(),\n  \"Method \" + overriddenMethod.getName() + \" is shadowed by an $@ in super class '\" + superclass.getName() +\n    \"'.\", attributeAssignment, \"attribute\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Overly complex `__del__` method\n * @description Identifies `__del__` methods that have high cyclomatic complexity.\n_______________ // 补全条件\n *              garbage collection and should be implemented with minimal complexity\n *              to avoid potential issues with resource management and performance.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python\n\nfrom FunctionValue destructorMethod\nwhere\n  // Verify the method serves as a class destructor\n  exists(ClassValue definingClass | \n    definingClass.declaredAttribute(\"__del__\") = destructorMethod\n  ) and\n  // Check if complexity exceeds safety threshold\n  destructorMethod.getScope().getMetrics().getCyclomaticComplexity() > 3\nselect destructorMethod, \"Overly complex '__del__' method.\"",
    "output": "*              These special methods can be invoked at unpredictable times during"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name 'import *' used\n * @description Identifies wildcard imports that may cause namespace pollution\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// Enable Python code analysis capabilities\nimport python\n\n// Define pattern for wildcard import statements\nfrom ImportStar starImport\n\n// Report findings with contextual warning message\nselect starImport, \"Using 'from ... import *' pollutes the namespace.\"",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/string-concatenation-in-loop]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects string concatenation operations inside loops,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name String concatenation in loop\n * @description Detects string concatenation operations inside loops, \n *              which can lead to quadratic performance degradation.\n * @kind problem\n * @tags efficiency\n *       maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision low\n * @id py/string-concatenation-in-loop\n */\n\nimport python\n\n// 定义谓词，用于识别在循环中执行的字符串连接操作\npredicate string_concat_in_loop(BinaryExpr concatExpr) {\n  // 检查表达式是否为加法操作\n  concatExpr.getOp() instanceof Add and\n  // 查找相关的SSA变量和连接节点\n  exists(SsaVariable definedVar, SsaVariable usedVar, BinaryExprNode concatNode |\n    // 建立节点与表达式之间的关联\n    concatNode.getNode() = concatExpr and \n    // 确定变量的定义关系\n    definedVar = usedVar.getAnUltimateDefinition()\n  |\n    // 验证字符串连接模式：变量被定义为连接操作，并在同一操作中被使用\n    definedVar.getDefinition().(DefinitionNode).getValue() = concatNode and\n    usedVar.getAUse() = concatNode.getAnOperand() and\n    // 确认操作数之一为字符串类型\n    concatNode.getAnOperand().pointsTo().getClass() = ClassValue::str()\n  )\n}\n\n// 从所有二元表达式和包含它们的语句中查找匹配项\nfrom BinaryExpr concatExpr, Stmt containerStmt\n// 筛选条件：表达式是字符串连接操作，且包含在某个语句中\nwhere string_concat_in_loop(concatExpr) and containerStmt.getASubExpression() = concatExpr\n// 选择包含字符串连接的语句，并生成警告信息\nselect containerStmt, \"String concatenation in a loop is quadratic in the number of iterations.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/efferent-coupling-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：计算每个Python模块依赖的外部模块数量，以此评估模块间的耦合关系和整体架构的健康状况。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python 模块传出耦合分析\n * @description 计算每个Python模块依赖的外部模块数量，以此评估模块间的耦合关系和整体架构的健康状况。\n * @kind 树状图\n * @id py/efferent-coupling-per-file\n * @treemap.warnOn 高值警告\n * @metricType 文件\n * @metricAggregate 平均值 最大值\n * @tags 可测试性\n *       模块化\n */\n\nimport python // 引入Python语言分析支持库\n\n// 查询每个模块的传出耦合度\nfrom ModuleMetrics moduleMetrics\nselect moduleMetrics, moduleMetrics.getEfferentCoupling() as couplingCount \norder by couplingCount desc // 按耦合度降序排列，高耦合度模块优先显示"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Classes per file\n * @description Provides a statistical overview of class definitions across Python source files\n * @kind treemap\n * @id py/classes-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python\n\n// Analyze each Python module to determine the quantity of class definitions it contains\nfrom Module pythonModule, int classCount\n\n// Calculate the total number of classes defined within each Python module\nwhere classCount = count(Class classDef | classDef.getEnclosingModule() = pythonModule)\n\n_______________ // 补全条件\nselect pythonModule, classCount order by classCount desc",
    "output": "// Output results showing each Python module and its corresponding class count, ordered by count in descending order"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/redundant-global-declaration]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies redundant 'global' keyword usage at module scope in Python code",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Redundant module-level global declarations\n * @description Identifies redundant 'global' keyword usage at module scope in Python code\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-global-declaration\n */\n\n// Import Python analysis framework\nimport python\n\n// Identify global declarations that are redundant at module level\nfrom Global redundantGlobalStmt\nwhere \n    // Verify the global statement is at module scope\n    redundantGlobalStmt.getScope() instanceof Module\nselect \n    redundantGlobalStmt, \n    // Construct warning message for the redundant global declaration\n    \"Redundant global declaration of '\" + redundantGlobalStmt.getAName() + \"' at module level.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies expressions that fail to point-to any object, which impedes type inference.\n * @kind problem\n * @id py/points-to-failure\n * @problem.severity info\n * @tags debug\n * @deprecated\n */\n\n// Import Python analysis capabilities for static code analysis\nimport python\n\n// Find expressions that have control flow nodes but fail to reference any object\nfrom Expr failedPointToExpr\nwhere \n    // Ensure the expression has at least one associated control flow node\n    exists(ControlFlowNode flowNode | \n        flowNode = failedPointToExpr.getAFlowNode()\n    ) and\n    // Confirm that none of the expression's control flow nodes reference any object\n    forall(ControlFlowNode flowNode | \n        flowNode = failedPointToExpr.getAFlowNode() |\n        not flowNode.refersTo(_)\n    )\n// Report the expression with a descriptive message\nselect failedPointToExpr, \"Expression does not 'point-to' any object.\"",
    "output": "* @name points-to fails for expression."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/pam-auth-bypass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：在`pam_authenticate`之后不使用`pam_acct_mgmt`来检查登录的有效性，可能导致授权绕过。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name PAM授权绕过问题由于不正确使用\n * @description 在`pam_authenticate`之后不使用`pam_acct_mgmt`来检查登录的有效性，可能导致授权绕过。\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 8.1\n * @precision high\n * @id py/pam-auth-bypass\n * @tags security\n *       external/cwe/cwe-285\n */\n\nimport python\nimport PamAuthorizationFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.security.dataflow.PamAuthorizationQuery\n\n// 定义PAM授权流程的起点（认证入口）和终点（潜在漏洞点）\nfrom PamAuthorizationFlow::PathNode authStart, PamAuthorizationFlow::PathNode vulnSink\n// 验证是否存在从认证入口到漏洞点的完整授权流程路径\nwhere PamAuthorizationFlow::flowPath(authStart, vulnSink)\n// 生成安全警告报告，包含漏洞位置、路径起点和详细描述\nselect vulnSink.getNode(), authStart, vulnSink,\n  \"PAM认证流程存在缺陷：依赖$@进行认证，但后续未调用'pam_acct_mgmt'验证账户有效性\",\n  authStart.getNode(), \"用户提供的认证凭据\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-of-identical-expressions]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies locations where identical values are compared, potentially indicating unclear programming logic.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Identical value comparison detection\n * @description Identifies locations where identical values are compared, potentially indicating unclear programming logic.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\nimport python\nimport Expressions.RedundantComparison\n\n/* Detect non-constant identical comparisons excluding cases involving missing self */\nfrom RedundantComparison redundantComparison\nwhere \n  not redundantComparison.isConstant() and \n  not redundantComparison.maybeMissingSelf()\n\n/* Report findings with remediation guidance for floating-point NaN checks */\nselect redundantComparison, \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unresolved import\n * @description Identifies imports that cannot be resolved, which may reduce analysis coverage and accuracy.\n * @kind problem\n * @problem.severity info\n * @id py/import-failure\n */\n\n// Import the Python analysis library\nimport python\n\n/**\n * Retrieves the current operating system platform from the Python interpreter.\n */\n_______________ // 补全条件\n  py_flags_versioned(\"sys.platform\", result, major_version().toString()) \n}\n\n/**\n * Determines if an import is specific to a particular operating system.\n * Returns the operating system name if the import is OS-specific.\n */\nstring determineOSSpecificImport(ImportExpr importExpr) {\n  exists(string importedName | importedName = importExpr.getImportedModuleName() |\n    // Java-related imports\n    (importedName.matches(\"org.python.%\") or importedName.matches(\"java.%\")) and \n    result = \"java\"\n    or\n    // macOS imports\n    importedName.matches(\"Carbon.%\") and \n    result = \"darwin\"\n    or\n    // Windows imports\n    result = \"win32\" and\n    (\n      importedName = \"_winapi\" or\n      importedName = \"_win32api\" or\n      importedName = \"_winreg\" or\n      importedName = \"nt\" or\n      importedName.matches(\"win32%\") or\n      importedName = \"ntpath\"\n    )\n    or\n    // Linux imports\n    result = \"linux2\" and\n    (importedName = \"posix\" or importedName = \"posixpath\")\n    or\n    // Unsupported platform imports\n    result = \"unsupported\" and\n    (importedName = \"__pypy__\" or importedName = \"ce\" or importedName.matches(\"riscos%\"))\n  )\n}\n\n/**\n * Identifies alternative import expressions used as fallback mechanisms.\n * This function finds imports used in conditional statements (if/else) or \n * exception handling (try/except) as alternatives to each other.\n */\nImportExpr getAlternativeImport(ImportExpr sourceImport) {\n  exists(Alias sourceAlias, Alias fallbackAlias |\n    // Source alias mapping\n    (sourceAlias.getValue() = sourceImport or \n     sourceAlias.getValue().(ImportMember).getModule() = sourceImport) and\n    // Fallback alias mapping\n    (fallbackAlias.getValue() = result or \n     fallbackAlias.getValue().(ImportMember).getModule() = result) and\n    (\n      // Conditional branches (if/else)\n      exists(If conditional | \n        (conditional.getBody().contains(sourceImport) and conditional.getOrelse().contains(result)) or\n        (conditional.getBody().contains(result) and conditional.getOrelse().contains(sourceImport))\n      )\n      or\n      // Exception handling (try/except)\n      exists(Try tryBlock | \n        (tryBlock.getBody().contains(sourceImport) and tryBlock.getAHandler().contains(result)) or\n        (tryBlock.getBody().contains(result) and tryBlock.getAHandler().contains(sourceImport))\n      )\n    )\n  )\n}\n\n/**\n * Determines if an unresolved import is acceptable based on fallback mechanisms\n * or OS-specific conditions.\n */\npredicate isImportAcceptableToFail(ImportExpr importExpr) {\n  // Check for working alternative import\n  getAlternativeImport(importExpr).refersTo(_)\n  or\n  // Check OS-specific import for different platform\n  determineOSSpecificImport(importExpr) != getCurrentPlatform()\n}\n\n/**\n * Represents control flow nodes that test Python interpreter version.\n * These nodes are typically used for version-specific conditional imports.\n */\nclass InterpreterVersionTest extends ControlFlowNode {\n  InterpreterVersionTest() {\n    exists(string versionAttr |\n      versionAttr.matches(\"%version%\") and\n      this.(CompareNode).getAChild+().pointsTo(Module::named(\"sys\").attr(versionAttr))\n    )\n  }\n\n  override string toString() { result = \"VersionTest\" }\n}\n\n/**\n * Represents conditional blocks guarding code based on Python interpreter version.\n * Used to identify version-specific imports that should not be flagged.\n */\nclass VersionBasedGuard extends ConditionBlock {\n  VersionBasedGuard() { this.getLastNode() instanceof InterpreterVersionTest }\n}\n\n// Main query: Identify unresolved imports requiring attention\nfrom ImportExpr unresolvedImport\nwhere\n  not unresolvedImport.refersTo(_) and // Import cannot be resolved\n  exists(Context validContext | validContext.appliesTo(unresolvedImport.getAFlowNode())) and // Import is in valid context\n  not isImportAcceptableToFail(unresolvedImport) and // No acceptable failure condition\n  not exists(VersionBasedGuard versionCheck | // Not protected by version guard\n    versionCheck.controls(unresolvedImport.getAFlowNode().getBasicBlock(), _)\n  )\nselect unresolvedImport, \"Unable to resolve import of '\" + unresolvedImport.getImportedModuleName() + \"'.\"",
    "output": "string getCurrentPlatform() {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/duplicate-block]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies blocks of code that are duplicated in the codebase.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Duplicate code block detection\n * @description Identifies blocks of code that are duplicated in the codebase. \n *              Refactoring shared code into a single location improves maintainability \n *              and reduces the risk of inconsistencies. Note that this is a general \n *              detection; more specific duplicate checks (like duplicate functions or classes) \n *              provide higher-confidence results.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @deprecated\n * @precision medium\n * @id py/duplicate-block\n */\n\nimport python\n\n// Identify basic blocks that may contain duplicated code\nfrom BasicBlock duplicateBlock\nwhere none()\n// Generate alert message with details about the duplicated code block\nselect duplicateBlock, \"Duplicate code: \" + \"-1\" + \" lines are duplicated at \" + \"<file>\" + \":\" + \"-1\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Membership test with non-container operand\n * @description Detects membership tests (e.g., 'item in sequence') where the right-hand \n *              operand is a non-container object, which would raise a 'TypeError' at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n * Holds when `rightOperandNode` is the right-hand operand in a membership comparison operation `comparisonExpr`.\n * @param rightOperandNode - Control flow node evaluated as the right operand\n * @param comparisonExpr - Comparison expression containing the membership test\n */\npredicate isRhsInMembershipTest(ControlFlowNode rightOperandNode, Compare comparisonExpr) {\n  exists(Cmpop operation, int operandIndex |\n    comparisonExpr.getOp(operandIndex) = operation and \n    comparisonExpr.getComparator(operandIndex) = rightOperandNode.getNode() and\n    (operation instanceof In or operation instanceof NotIn)\n  )\n_______________ // 补全条件\n\nfrom \n  ControlFlowNode rightOperandNode, \n  Compare comparisonExpr, \n  Value pointedToValue, \n  ClassValue rightOperandClass, \n  ControlFlowNode valueSourceNode\nwhere\n  // Identify membership tests and extract right operand\n  isRhsInMembershipTest(rightOperandNode, comparisonExpr) and\n  \n  // Resolve operand value and its class\n  rightOperandNode.pointsTo(_, pointedToValue, valueSourceNode) and\n  pointedToValue.getClass() = rightOperandClass and\n  \n  // Validate type inference success\n  not Types::failedInference(rightOperandClass, _) and\n  \n  // Verify non-container characteristics\n  (not rightOperandClass.hasAttribute(\"__contains__\") and\n   not rightOperandClass.hasAttribute(\"__iter__\") and\n   not rightOperandClass.hasAttribute(\"__getitem__\")) and\n  not rightOperandClass = ClassValue::nonetype() and\n  not rightOperandClass = Value::named(\"types.MappingProxyType\")\nselect \n  comparisonExpr, \n  \"This test may raise an Exception as the $@ may be of non-container class $@.\", \n  valueSourceNode, \"target\", rightOperandClass, rightOperandClass.getName()",
    "output": "}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raise-not-implemented]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies improper use of 'NotImplemented' in raise statements,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name NotImplemented is not an Exception\n * @description Identifies improper use of 'NotImplemented' in raise statements,\n *              which leads to runtime type errors instead of proper exception handling.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Import Python analysis framework\nimport python\n\n// Import module for NotImplemented exception handling\nimport Exceptions.NotImplemented\n\n// Define the source of our analysis: expressions that incorrectly use NotImplemented\nfrom Expr faultyRaiseExpr\n// Apply filter to identify expressions where NotImplemented is used in raise contexts\nwhere \n    // Check if the expression represents a misuse of NotImplemented in raise statements\n    use_of_not_implemented_in_raise(_, faultyRaiseExpr)\n// Report the identified issue with a corrective message\nselect faultyRaiseExpr, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Jinja2 templating with autoescape=False\n * @description Detects Jinja2 template instantiations with 'autoescape=False'\n *              which can enable cross-site scripting (XSS) attacks.\n * @kind problem\n * @problem.severity error\n * @security-severity 6.1\n * @precision medium\n * @id py/jinja2/autoescape-false\n * @tags security\n *       external/cwe/cwe-079\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n/*\n * References:\n * Jinja2 Environment API: https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Environment\n * Jinja2 Template API: https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template\n *\n * Note: autoescape parameter applies to both Environment and Template constructors\n * Example vulnerable code:\n *   unsafe_tmpl = Template('Hello {{ name }}!')\n *   unsafe_env = Environment(autoescape=False)\n */\n_______________ // 补全条件\n// Helper to identify Jinja2 Environment or Template API nodes\nprivate API::Node getJinja2EnvOrTemplateApi() {\n  result = API::moduleImport(\"jinja2\").getMember(\"Environment\")\n  or\n  result = API::moduleImport(\"jinja2\").getMember(\"Template\")\n}\n\n// Main query logic to detect dangerous Jinja2 template instantiations\nfrom API::CallNode jinja2Call\nwhere\n  // Verify this is a Jinja2 Environment or Template constructor call\n  jinja2Call = getJinja2EnvOrTemplateApi().getACall() and\n  // Exclude calls with dynamic arguments (*args or **kwargs)\n  not exists(jinja2Call.asCfgNode().(CallNode).getNode().getStarargs()) and\n  not exists(jinja2Call.asCfgNode().(CallNode).getNode().getKwargs()) and\n  (\n    // Case 1: autoescape parameter is omitted (defaults to False in some contexts)\n    not exists(jinja2Call.getArgByName(\"autoescape\"))\n    or\n    // Case 2: autoescape parameter is explicitly set to False\n    jinja2Call.getKeywordParameter(\"autoescape\")\n        .getAValueReachingSink()\n        .asExpr()\n        .(ImmutableLiteral)\n        .booleanValue() = false\n  )\nselect jinja2Call, \"Using jinja2 templates with autoescape=False can potentially allow XSS attacks.\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/truncated-division]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：In Python 2, when both operands of a division operation are integers,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Result of integer division may be truncated\n * @description In Python 2, when both operands of a division operation are integers,\n *              the result is truncated to an integer. This can lead to unexpected results\n *              if the developer intended to perform floating-point division.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// 查找可能导致结果被截断的整数除法操作\nfrom BinaryExpr divisionExpr, ControlFlowNode leftOperand, ControlFlowNode rightOperand\nwhere\n  // 仅在Python 2中相关，因为Python 3及以后版本默认实现真除法\n  major_version() = 2 and\n  exists(BinaryExprNode divisionNode, Value leftValue, Value rightValue |\n    divisionNode = divisionExpr.getAFlowNode() and // 获取除法表达式的控制流节点\n    divisionNode.getNode().getOp() instanceof Div and // 确保操作符是除法\n    // 检查左操作数是否为整数\n    divisionNode.getLeft().pointsTo(leftValue, leftOperand) and\n    leftValue.getClass() = ClassValue::int_() and\n    // 检查右操作数是否为整数\n    divisionNode.getRight().pointsTo(rightValue, rightOperand) and\n    rightValue.getClass() = ClassValue::int_() and\n    // 忽略整除没有余数的情况，因为这种情况下结果不会被截断\n    not leftValue.(NumericValue).getIntValue() % rightValue.(NumericValue).getIntValue() = 0 and\n    // 忽略包含`from __future__ import division`的模块，因为这会改变除法行为\n    not divisionNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    // 过滤掉用`int(...)`包装的结果，因为这是有意为之的截断\n    not exists(CallNode intConversionCall |\n      intConversionCall = ClassValue::int_().getACall() and\n      intConversionCall.getAnArg() = divisionNode\n    )\n  )\nselect divisionExpr, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftOperand, \"left\", rightOperand, \"right\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n_______________ // 补全条件\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Identifies descriptor classes containing mutation operations\n// Mutations must occur in non-initializer functions called through descriptor protocol methods\npredicate contains_descriptor_mutation(ClassObject descriptorClass, SelfAttributeStore mutationOperation) {\n  // Verify target class implements descriptor protocol\n  descriptorClass.isDescriptorType() and\n  \n  // Locate descriptor protocol methods (__get__/__set__/__delete__)\n  exists(PyFunctionObject protocolMethod, string methodName |\n    descriptorClass.lookupAttribute(methodName) = protocolMethod and\n    (methodName = \"__get__\" or methodName = \"__set__\" or methodName = \"__delete__\") and\n    \n    // Find functions invoked by descriptor methods\n    exists(PyFunctionObject invokedFunction |\n      // Invoked function must be a class member method\n      descriptorClass.lookupAttribute(_) = invokedFunction and\n      \n      // Descriptor method directly/indirectly invokes the function\n      protocolMethod.getACallee*() = invokedFunction and\n      \n      // Exclude initialization methods\n      not invokedFunction.getName() = \"__init__\" and\n      \n      // Mutation occurs within invoked function's scope\n      mutationOperation.getScope() = invokedFunction.getFunction()\n    )\n  )\n}\n\n// Retrieve all classes and operations with descriptor mutations\nfrom ClassObject descriptorClass, SelfAttributeStore mutationOperation\nwhere contains_descriptor_mutation(descriptorClass, mutationOperation)\n// Output mutation location, warning message, related class and its name\nselect mutationOperation,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorClass, descriptorClass.getName()",
    "output": "* @description Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-standard exception raised in special method\n * @description Special methods raising non-standard exceptions violate their expected interface contracts.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/unexpected-raise-in-special-method\n */\n\nimport python\n\n// Helper predicates to categorize special methods\nprivate predicate isAttributeMethod(string methodName) {\n  methodName = \"__getattribute__\" or \n  methodName = \"__getattr__\" or \n  methodName = \"__setattr__\"\n}\n\n_______________ // 补全条件\n  methodName = \"__getitem__\" or \n  methodName = \"__setitem__\" or \n  methodName = \"__delitem__\"\n}\n\nprivate predicate isArithmeticMethod(string methodName) {\n  methodName in [\n      \"__add__\", \"__sub__\", \"__or__\", \"__xor__\", \"__rshift__\", \"__pow__\", \"__mul__\", \"__neg__\",\n      \"__radd__\", \"__rsub__\", \"__rdiv__\", \"__rfloordiv__\", \"__div__\", \"__rdiv__\", \"__rlshift__\",\n      \"__rand__\", \"__ror__\", \"__rxor__\", \"__rrshift__\", \"__rpow__\", \"__rmul__\", \"__truediv__\",\n      \"__rtruediv__\", \"__pos__\", \"__iadd__\", \"__isub__\", \"__idiv__\", \"__ifloordiv__\", \"__idiv__\",\n      \"__ilshift__\", \"__iand__\", \"__ior__\", \"__ixor__\", \"__irshift__\", \"__abs__\", \"__ipow__\",\n      \"__imul__\", \"__itruediv__\", \"__floordiv__\", \"__div__\", \"__divmod__\", \"__lshift__\", \"__and__\"\n    ]\n}\n\nprivate predicate isOrderingMethod(string methodName) {\n  (methodName = \"__lt__\" or \n   methodName = \"__le__\" or \n   methodName = \"__gt__\" or \n   methodName = \"__ge__\") \n  or \n  (methodName = \"__cmp__\" and major_version() = 2)\n}\n\nprivate predicate isCastMethod(string methodName) {\n  (methodName = \"__nonzero__\" and major_version() = 2)\n  or\n  methodName = \"__int__\" or \n  methodName = \"__float__\" or \n  methodName = \"__long__\" or \n  methodName = \"__trunc__\" or \n  methodName = \"__complex__\"\n}\n\n// Maps special methods to their preferred exception types\npredicate isPreferredExceptionType(string methodName, ClassObject exType) {\n  // Attribute methods should raise AttributeError\n  isAttributeMethod(methodName) and exType = theAttributeErrorType()\n  or\n  // Indexing methods should raise LookupError\n  isIndexingMethod(methodName) and exType = Object::builtin(\"LookupError\")\n  or\n  // Ordering methods should raise TypeError\n  isOrderingMethod(methodName) and exType = theTypeErrorType()\n  or\n  // Arithmetic methods should raise ArithmeticError\n  isArithmeticMethod(methodName) and exType = Object::builtin(\"ArithmeticError\")\n  or\n  // __bool__ method should raise TypeError\n  methodName = \"__bool__\" and exType = theTypeErrorType()\n}\n\n// Validates exception type compatibility for special methods\npredicate isCorrectExceptionType(string methodName, ClassObject exType) {\n  // Handle TypeError compatibility for specific method categories\n  exType.getAnImproperSuperType() = theTypeErrorType() and\n  (\n    methodName = \"__copy__\" or \n    methodName = \"__deepcopy__\" or \n    methodName = \"__call__\" or \n    isIndexingMethod(methodName) or \n    isAttributeMethod(methodName)\n  )\n  or\n  // Check preferred exception types\n  isPreferredExceptionType(methodName, exType)\n  or\n  // Allow parent exception types\n  isPreferredExceptionType(methodName, exType.getASuperType())\n}\n\n// Identifies unnecessary exception raising cases\npredicate isUnnecessaryRaise(string methodName, string suggestion) {\n  // Hash method should use __hash__ = None\n  methodName = \"__hash__\" and suggestion = \"use __hash__ = None instead\"\n  or\n  // Cast methods don't need implementation\n  isCastMethod(methodName) and suggestion = \"there is no need to implement the method at all.\"\n}\n\n// Detects abstract functions through decorators\npredicate isAbstractFunction(FunctionObject func) {\n  func.getFunction().getADecorator().(Name).getId().matches(\"%abstract%\")\n}\n\n// Checks if function always raises a specific exception type\npredicate alwaysRaisesException(FunctionObject func, ClassObject exType) {\n  exType = func.getARaisedType() and\n  strictcount(func.getARaisedType()) = 1 and\n  not exists(func.getFunction().getANormalExit()) and\n  /* raising StopIteration is equivalent to return in generators */\n  not exType = theStopIterationType()\n}\n\n// Main detection logic for non-standard exceptions in special methods\nfrom FunctionObject func, ClassObject exType, string suggestion\nwhere\n  // Focus on non-abstract special methods\n  func.getFunction().isSpecialMethod() and\n  not isAbstractFunction(func) and\n  alwaysRaisesException(func, exType) and\n  (\n    // Handle unnecessary exception cases\n    isUnnecessaryRaise(func.getName(), suggestion) and \n    not exType.getName() = \"NotImplementedError\"\n    or\n    // Handle incorrect exception type cases\n    not isCorrectExceptionType(func.getName(), exType) and\n    not exType.getName() = \"NotImplementedError\" and\n    exists(ClassObject preferredExType | \n      isPreferredExceptionType(func.getName(), preferredExType) |\n      suggestion = \"raise \" + preferredExType.getName() + \" instead\"\n    )\n  )\nselect func, \"Function always raises $@; \" + suggestion, exType, exType.toString()",
    "output": "private predicate isIndexingMethod(string methodName) {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unguarded-next-in-generator]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects generator functions where next() is called without proper exhaustion checks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unguarded next in generator\n * @description Detects generator functions where next() is called without proper exhaustion checks.\n * @kind problem\n * @tags maintainability\n *       portability\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unguarded-next-in-generator\n */\n\nimport python\nprivate import semmle.python.ApiGraphs\n\n// API nodes for built-in functions and exceptions\nAPI::Node iterBuiltin() { result = API::builtin(\"iter\") }\nAPI::Node nextBuiltin() { result = API::builtin(\"next\") }\nAPI::Node stopIterationBuiltin() { result = API::builtin(\"StopIteration\") }\n\n// Identifies iter() calls with specific sequence source\npredicate iterCallWithSequenceSource(CallNode iterCall, EssaVariable originalSequence) {\n  iterCall = iterBuiltin().getACall().asCfgNode() and\n  iterCall.getArg(0) = originalSequence.getAUse()\n}\n\n// Identifies next() calls targeting specific iterator\npredicate nextCallOnIteratorVar(CallNode nextCallNode, ControlFlowNode iteratorVar) {\n  nextCallNode = nextBuiltin().getACall().asCfgNode() and\n  nextCallNode.getArg(0) = iteratorVar\n}\n\n// Checks if next() call includes default value parameter\npredicate nextCallWithDefault(CallNode nextCallNode) {\n  exists(nextCallNode.getArg(1)) or exists(nextCallNode.getArgByName(\"default\"))\n}\n\n// Determines if sequence has emptiness protection\npredicate sequenceIsGuarded(EssaVariable seqVar) {\n  seqVar.getDefinition() instanceof EssaEdgeRefinement\n}\n\n/**\n * Holds when iterator is verified non-exhausted.\n * \n * Detects patterns like next(iter(x)) where x is confirmed non-empty.\n */\npredicate iteratorIsNonExhausted(EssaVariable iterVar) {\n  exists(EssaVariable originalSequence |\n    iterCallWithSequenceSource(iterVar.getDefinition().(AssignmentDefinition).getValue(), originalSequence) and\n    sequenceIsGuarded(originalSequence)\n  )\n}\n\n// Verifies StopIteration exception handling in current scope\npredicate stopIterationIsHandled(CallNode nextCallNode) {\n  exists(Try tryStmt |\n    tryStmt.containsInScope(nextCallNode.getNode()) and\n    tryStmt.getAHandler().getType() = stopIterationBuiltin().getAValueReachableFromSource().asExpr()\n  )\n}\n\n// Main query detecting unguarded next() calls in generators\nfrom CallNode nextCall\nwhere\n  // Validate next() function call\n  nextCallOnIteratorVar(nextCall, _) and\n  // Ensure no default value protection\n  not nextCallWithDefault(nextCall) and\n  // Confirm iterator might be exhausted\n  not exists(EssaVariable iterVar |\n    nextCallOnIteratorVar(nextCall, iterVar.getAUse()) and\n    iteratorIsNonExhausted(iterVar)\n  ) and\n  // Restrict to generator functions\n  nextCall.getNode().getScope().(Function).isGenerator() and\n  // Exclude comprehensions\n  not exists(Comp comprehension | comprehension.contains(nextCall.getNode())) and\n  // Verify no StopIteration handling\n  not stopIterationIsHandled(nextCall) and\n  // PEP 479 resolved this issue in Python 3.7+\n  // Flag only for Python 2 (minor version not detectable)\n  major_version() = 2\nselect nextCall, \"Call to 'next()' in a generator.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/return-or-yield-outside-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using 'return' or 'yield' outside a function causes a 'SyntaxError' at runtime.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of 'return' or 'yield' outside a function\n * @description Using 'return' or 'yield' outside a function causes a 'SyntaxError' at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/return-or-yield-outside-function\n */\n\nimport python\n\n// 定义查询目标：查找不在函数作用域内的特定语句\nfrom AstNode stmt, string stmtType\nwhere \n  // 确保语句不在任何函数的作用域内\n  not exists(Function func | stmt.getScope() = func.getScope()) and\n  (\n    // 匹配 return 语句并设置类型标识\n    stmt instanceof Return and stmtType = \"return\"\n    or\n    // 匹配 yield 语句并设置类型标识\n    stmt instanceof Yield and stmtType = \"yield\"\n    or\n    // 匹配 yield from 语句并设置类型标识\n    stmt instanceof YieldFrom and stmtType = \"yield from\"\n  )\n// 输出违规语句节点及对应的错误信息\nselect stmt, \"'\" + stmtType + \"' is used outside a function.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/ineffectual-statement]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies statements that have no effect, which may indicate dead code or programming errors",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Statement has no effect\n * @description Identifies statements that have no effect, which may indicate dead code or programming errors\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/ineffectual-statement\n */\n\nimport python\n\n// ===== OPERATOR METHOD NAME HELPERS =====\n\n// Helper to determine special method names for operators\nprivate string getSpecialOperatorMethodName() {\n  result = any(Cmpop cmpOp).getSpecialMethodName()\n  or\n  result = any(BinaryExpr binExpr).getOp().getSpecialMethodName()\n}\n\n// ===== OPERATOR SPECIAL METHOD DETECTION =====\n\n// Identifies special methods for binary operators\npragma[nomagic]\nprivate predicate binaryOperatorSpecialMethod(\n  BinaryExpr binaryExpr, Expr subExpr, ClassValue exprClass, string methodName\n) {\n  methodName = getSpecialOperatorMethodName() and\n  subExpr = binaryExpr.getLeft() and\n  methodName = binaryExpr.getOp().getSpecialMethodName() and\n  subExpr.pointsTo().getClass() = exprClass\n}\n\n// Identifies special methods for comparison operations\npragma[nomagic]\nprivate predicate comparisonOperatorSpecialMethod(\n  Compare compareExpr, Expr subExpr, ClassValue exprClass, string methodName\n) {\n  exists(Cmpop op |\n    compareExpr.compares(subExpr, op, _) and\n    methodName = op.getSpecialMethodName()\n  ) and\n  subExpr.pointsTo().getClass() = exprClass\n}\n\n// ===== DESCRIPTOR AND ATTRIBUTE ANALYSIS =====\n\n// Determines if a descriptor type has side effects\npredicate hasSideEffectingDescriptorType(ClassValue descriptorType) {\n  descriptorType.isDescriptorType() and\n  // All descriptor accesses technically have side effects, but some represent missing calls\n  // that we want to treat as having no effect\n  not descriptorType = ClassValue::functionType() and\n  not descriptorType = ClassValue::staticmethod() and\n  not descriptorType = ClassValue::classmethod()\n}\n\n// Checks if an attribute is understood (resolved to specific classes)\npredicate isUnderstoodAttribute(Attribute attrNode, ClassValue ownerClass, ClassValue attrClass) {\n  exists(string attrName | attrNode.getName() = attrName |\n    attrNode.getObject().pointsTo().getClass() = ownerClass and\n    ownerClass.attr(attrName).getClass() = attrClass\n  )\n}\n\n// Determines if an attribute access has side effects\npredicate hasSideEffectingAttribute(Attribute attrNode) {\n  exists(ClassValue attrClass |\n    isUnderstoodAttribute(attrNode, _, attrClass) and\n    hasSideEffectingDescriptorType(attrClass)\n  )\n}\n\n// Checks if an attribute might have side effects\npredicate mightHaveSideEffectingAttribute(Attribute attrNode) {\n  not isUnderstoodAttribute(attrNode, _, _) and not attrNode.pointsTo(_)\n  or\n  hasSideEffectingAttribute(attrNode)\n}\n\n// ===== BINARY OPERATION SIDE EFFECT ANALYSIS =====\n\n// Determines if a binary operation has side effects\npredicate hasSideEffectingBinaryOperation(Expr binaryExpr) {\n  exists(Expr subExpr, ClassValue exprClass, string methodName |\n    binaryOperatorSpecialMethod(binaryExpr, subExpr, exprClass, methodName)\n    or\n    comparisonOperatorSpecialMethod(binaryExpr, subExpr, exprClass, methodName)\n  |\n    methodName = getSpecialOperatorMethodName() and\n    exprClass.hasAttribute(methodName) and\n    not exists(ClassValue declaring |\n      declaring.declaresAttribute(methodName) and\n      declaring = exprClass.getASuperType() and\n      declaring.isBuiltin() and\n      not declaring = ClassValue::object()\n    )\n  )\n}\n\n// ===== SPECIAL CONTEXT DETECTION =====\n\n// Checks if a file is a Jupyter/IPython notebook\npredicate isJupyterNotebook(File file) {\n  exists(Comment comment | comment.getLocation().getFile() = file |\n    comment.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\n// Checks if an expression is in a Jupyter/IPython notebook\npredicate isExpressionInNotebook(Expr expr) { \n  isJupyterNotebook(expr.getScope().(Module).getFile()) \n}\n\n// Gets the unittest.TestCase.assertRaises method\nFunctionValue getAssertRaisesMethod() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\n// Checks if an expression is in a test for exception raising\npredicate isInRaisesTest(Expr expr) {\n  exists(With withBlock |\n    withBlock.contains(expr) and\n    withBlock.getContextExpr() = getAssertRaisesMethod().getACall().getNode()\n  )\n}\n\n// Checks if an expression is a Python 2 print statement\npredicate isPython2PrintStatement(Expr expr) {\n  expr.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n  expr.(BinaryExpr).getOp() instanceof RShift\n  or\n  isPython2PrintStatement(expr.(Tuple).getElt(0))\n}\n\n// ===== MAIN EFFECT ANALYSIS =====\n\n// Determines if an expression has no effect\npredicate hasNoEffect(Expr expr) {\n  // Strings can be used as docstrings/comments\n  not expr instanceof StringLiteral and\n  not expr.hasSideEffects() and\n  // Check all sub-expressions for side effects\n  forall(Expr subExpr | subExpr = expr.getASubExpression*() |\n    not hasSideEffectingBinaryOperation(subExpr) and\n    not mightHaveSideEffectingAttribute(subExpr)\n  ) and\n  // Exclude special contexts where expressions are expected\n  not isExpressionInNotebook(expr) and\n  not isInRaisesTest(expr) and\n  not isPython2PrintStatement(expr)\n}\n\n// ===== MAIN QUERY =====\n\n// Main query to find statements with no effect\nfrom ExprStmt stmt\nwhere hasNoEffect(stmt.getValue())\nselect stmt, \"This statement has no effect.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Deprecated slice method\n * @description Detects the use of obsolete slice special methods (__getslice__, __setslice__, __delslice__) \n *              which are no longer recommended since Python 2.0. These should be replaced with \n *              contemporary slicing syntax via __getitem__, __setitem__, and __delitem__.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n_______________ // 补全条件\n * @id py/deprecated-slice-method\n */\n\nimport python\n\n// Query to identify deprecated slice methods in Python code\nfrom PythonFunctionValue obsoleteMethod, string methodName\nwhere\n  // Check if the method name is one of the deprecated slice methods\n  methodName = obsoleteMethod.getName() and\n  methodName in [\"__getslice__\", \"__setslice__\", \"__delslice__\"] and\n  // Verify function is a class method (not standalone)\n  obsoleteMethod.getScope().isMethod() and\n  // Exclude methods overriding parent implementations\n  not obsoleteMethod.isOverridingMethod()\n// Report the deprecated method with an appropriate warning message\nselect obsoleteMethod, methodName + \" method has been deprecated since Python 2.0.\"",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Explicit invocation of `__del__` method\n * @description The `__del__` method is a special method in Python that gets invoked by the garbage collector\n *              when an object is about to be destroyed. Explicitly calling this method is generally considered\n *              bad practice as it can lead to unexpected behavior and violates the intended lifecycle management\n *              of Python objects.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/explicit-call-to-delete\n */\n\nimport python\n\n// 定义类用于识别所有显式调用__del__方法的情况\nclass DelMethodCall extends Call {\n  // 构造函数：筛选出所有调用__del__方法的Call节点\n  DelMethodCall() { \n    // 确保被调用的方法名是\"__del__\"\n    this.getFunc().(Attribute).getName() = \"__del__\" \n  }\n\n  // 判断当前调用是否为合法的super调用场景（通常发生在子类__del__方法中调用父类__del__）\n  predicate isValidSuperInvocation() {\n    // 检查调用是否发生在某个__del__方法的作用域内\n    exists(Function parentFunction | \n      parentFunction = this.getScope() and \n      parentFunction.getName() = \"__del__\" \n    |\n      // 合法场景1: 调用者使用当前实例的self参数\n      parentFunction.getArg(0).asName().getVariable() = this.getArg(0).(Name).getVariable()\n      or\n      // 合法场景2: 调用形式为super().__del__()或super(Type, self).__del__()\n_______________ // 补全条件\n        superCall = this.getFunc().(Attribute).getObject() |\n        superCall.getFunc().(Name).getId() = \"super\"\n      )\n    )\n  }\n}\n\n// 查询所有非法的显式__del__方法调用（排除合法的super调用场景）\nfrom DelMethodCall explicitDelInvocation\nwhere not explicitDelInvocation.isValidSuperInvocation()\nselect explicitDelInvocation, \"The __del__ special method is called explicitly.\"",
    "output": "exists(Call superCall |"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks that operate on substrings of unparsed URLs are vulnerable to bypass attacks, \n *              as they don't account for the entire URL structure\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Defines regex pattern for common top-level domains used in URL validation\nprivate string commonTldPattern() { \n  result = \"com|org|edu|gov|uk|net|io\" \n}\n\n// Determines if a string literal exhibits URL-like characteristics\npredicate hasUrlCharacteristics(StringLiteral urlLiteral) {\n  exists(string textContent | \n    textContent = urlLiteral.getText() and\n    (\n      // Matches URLs with optional protocol and common TLDs\n      textContent.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + commonTldPattern() + \")(:[0-9]+)?/?\")\n      or\n      // Matches explicit HTTP/HTTPS URLs\n      textContent.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n_______________ // 补全条件\n  )\n}\n\n// Detects expressions performing incomplete URL substring sanitization\npredicate hasIncompleteSanitization(Expr sanitizationOperation, StringLiteral urlLiteral) {\n  hasUrlCharacteristics(urlLiteral) and\n  (\n    // Case 1: Substring containment check using 'in' operator\n    exists(Compare comparisonExpr |\n      comparisonExpr.compares(urlLiteral, any(In containmentOperator), _) and\n      sanitizationOperation = comparisonExpr\n    )\n    or\n    // Case 2: Unsafe startswith usage\n    exists(Call methodCall |\n      methodCall.getFunc().(Attribute).getName() = \"startswith\" and\n      methodCall.getArg(0) = urlLiteral and\n      not urlLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\") and\n      sanitizationOperation = methodCall\n    )\n    or\n    // Case 3: Unsafe endswith usage\n    exists(Call methodCall |\n      methodCall.getFunc().(Attribute).getName() = \"endswith\" and\n      methodCall.getArg(0) = urlLiteral and\n      not urlLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\") and\n      sanitizationOperation = methodCall\n    )\n  )\n}\n\n// Find expressions exhibiting incomplete URL substring sanitization patterns\nfrom Expr sanitizationOperation, StringLiteral urlLiteral\nwhere hasIncompleteSanitization(sanitizationOperation, urlLiteral)\nselect sanitizationOperation, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlLiteral,\n  urlLiteral.getText()",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Quantum Vulnerability: Symmetric Encryption with Padding\n * @description Detects symmetric encryption implementations that employ padding mechanisms.\n *              In quantum computing contexts, traditional symmetric encryption with padding\n *              may be susceptible to enhanced attacks. Quantum algorithms could potentially\n *              exploit padding oracle vulnerabilities or reduce the effective security strength\n *              of padded symmetric ciphers. This query identifies such implementations to\n *              facilitate migration towards quantum-resistant cryptographic solutions.\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n_______________ // 补全条件\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricPadding encryptionWithPadding\nselect encryptionWithPadding, \n       \"Identified symmetric encryption with padding: \" + encryptionWithPadding.getPaddingName()",
    "output": "*       cryptography"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Default Parameter Mutation Detection\n * @description Detects mutations of parameters initialized with default values. \n *              Such mutations cause unexpected behavior due to shared mutable state \n *              across function invocations.\n * @kind path-problem\n * @tags reliability\n *       maintainability\n_______________ // 补全条件\n * @sub-severity low\n * @precision high\n * @id py/modification-of-default-value\n */\n\nimport python\nimport semmle.python.functions.ModificationOfParameterWithDefault\nimport ModificationOfParameterWithDefault::Flow::PathGraph\n\nfrom\n  ModificationOfParameterWithDefault::Flow::PathNode defaultValueNode,\n  ModificationOfParameterWithDefault::Flow::PathNode mutationPointNode\nwhere \n  ModificationOfParameterWithDefault::Flow::flowPath(defaultValueNode, mutationPointNode)\nselect \n  mutationPointNode.getNode(), \n  defaultValueNode, \n  mutationPointNode, \n  \"This expression mutates a $@.\", \n  defaultValueNode.getNode(),\n  \"default value\"",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cookie creation using user-controllable data, potentially leading to Cookie Poisoning vulnerabilities.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cookie Construction from Untrusted Input\n * @description Detects cookie creation using user-controllable data, potentially leading to Cookie Poisoning vulnerabilities.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// Core Python language support and security analysis frameworks\nimport python\n\n// Specialized module for Cookie Injection vulnerability detection\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Visualization components for data flow path representation\nimport CookieInjectionFlow::PathGraph\n\n// Define untrusted input source and cookie creation sink\nfrom CookieInjectionFlow::PathNode untrustedInputSource, CookieInjectionFlow::PathNode cookieCreationSink\n\n// Verify data flow propagation from source to sink\nwhere CookieInjectionFlow::flowPath(untrustedInputSource, cookieCreationSink)\n\n// Generate security alert with vulnerability details and flow path\nselect cookieCreationSink.getNode(), \n       untrustedInputSource, \n       cookieCreationSink, \n       \"Cookie is constructed from $@.\", \n       untrustedInputSource.getNode(), \n       \"untrusted user input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-commented-out-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Counts and reports the number of lines containing commented-out code for each file",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lines of commented-out code in files\n * @description Counts and reports the number of lines containing commented-out code for each file\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// Import required CodeQL libraries for Python analysis and commented code detection\nimport python\nimport Lexical.CommentedOutCode\n\n// Select source files and their corresponding counts of commented-out code lines\nfrom File sourceFile, int commentedLineCount\n// Calculate the total number of commented lines in each file, excluding potential example code\nwhere \n    commentedLineCount = count(CommentedOutCodeLine commentedLine | \n        not commentedLine.maybeExampleCode() and \n        commentedLine.getLocation().getFile() = sourceFile)\n// Output the file paths and their commented code counts, sorted in descending order\nselect sourceFile, commentedLineCount order by commentedLineCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/explicit-return-in-init]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects non-None returns in Python `__init__` methods that cause runtime TypeErrors.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Explicit value return in `__init__` method\n * @description Detects non-None returns in Python `__init__` methods that cause runtime TypeErrors.\n *              This query identifies problematic return statements in initialization methods\n *              that would lead to TypeError exceptions at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/explicit-return-in-init\n */\n\nimport python\n\nfrom Return returnStmt, Expr returnValue\nwhere\n  // Condition 1: Return statement must be inside an __init__ method\n  returnStmt.getScope().(Function).isInitMethod() and\n  // Condition 2: Return statement must have a value (non-empty return)\n  returnStmt.getValue() = returnValue and\n  // Condition 3: Exclude returns of None value\n  not returnValue.pointsTo(Value::none_()) and\n  // Condition 4: Filter out calls to functions that never return\n  not exists(FunctionValue neverReturningFunction |\n    neverReturningFunction.getACall() = returnValue.getAFlowNode() and\n    neverReturningFunction.neverReturns()\n  ) and\n  // Condition 5: Avoid nested __init__ method calls\n  not exists(Attribute attributeAccess |\n    attributeAccess = returnValue.(Call).getFunc() and\n    attributeAccess.getName() = \"__init__\"\n  )\nselect returnStmt, \"Explicit return in __init__ method.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Catalog of framework-mode endpoints in model editor\n * @description Discovers and lists all accessible endpoints (both methods and attributes) \n *              that are available within the framework mode of the model editor.\n *              Results exclude test files and auto-generated code components.\n * @kind table\n * @id py/utils/modeleditor/framework-mode-endpoints\n * @tags modeleditor endpoints framework-mode\n */\n\n// Import ModelEditor functionality for endpoint discovery\nimport modeling.ModelEditor\n\n// Extract endpoint information using descriptive variable naming\nfrom Endpoint frameworkEndpoint\nselect \n  // Primary endpoint reference\n  frameworkEndpoint,\n  // Namespace where the endpoint is defined\n  frameworkEndpoint.getNamespace(),\n  // Class that contains the endpoint\n  frameworkEndpoint.getClass(),\n  // Name of the method or function\n  frameworkEndpoint.getFunctionName(),\n  // Parameter list for the endpoint\n  frameworkEndpoint.getParameters(),\n  // HTTP status codes supported by the endpoint\n  frameworkEndpoint.getSupportedStatus(),\n  // Source file location of the endpoint\n  frameworkEndpoint.getFileName(),\n  // Data types supported by the endpoint\n  frameworkEndpoint.getSupportedType(),\n  // Endpoint type classification (method or attribute)\n  frameworkEndpoint.getKind()",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Quantifies the total commits in the repository, excluding synthetic modifications",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commit Count Analysis\n * @description Quantifies the total commits in the repository, excluding synthetic modifications\n * @kind treemap\n * @id py/historical-number-of-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\n// Import Python language module for analysis context\nimport python\n// Import version control system utilities for commit tracking\nimport external.VCS\n\n// Define query to analyze commit history\nfrom Commit commitEntry\n// Filter out artificial commits (e.g., automated refactoring, style adjustments)\nwhere not artificialChange(commitEntry)\n// Output each valid commit with its revision identifier and unit count\nselect commitEntry.getRevisionName(), 1"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes metrics for different kinds of type annotations in Python code,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Computes metrics for different kinds of type annotations in Python code, \n *              including parameters, return types, and annotated assignments.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents built-in Python types such as int, float, str, etc.\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TAnnotatableElement =\n  TAnnotatedFunctionElement(FunctionExpr func) { exists(func.getReturns()) } or\n  TAnnotatedParameterElement(Parameter param) { exists(param.getAnnotation()) } or\n  TAnnotatedAssignmentElement(AnnAssign stmt) { exists(stmt.getAnnotation()) }\n\n// Abstract base class for all elements that can have type annotations\nabstract class AnnotatableElement extends TAnnotatableElement {\n  string toString() { result = \"AnnotatableElement\" }\n  abstract Expr getAnnotationExpr();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunctionElement extends TAnnotatedFunctionElement, AnnotatableElement {\n  FunctionExpr functionExpression;\n\n  AnnotatedFunctionElement() { this = TAnnotatedFunctionElement(functionExpression) }\n  override Expr getAnnotationExpr() { result = functionExpression.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameterElement extends TAnnotatedParameterElement, AnnotatableElement {\n  Parameter parameterVariable;\n\n  AnnotatedParameterElement() { this = TAnnotatedParameterElement(parameterVariable) }\n  override Expr getAnnotationExpr() { result = parameterVariable.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignmentElement extends TAnnotatedAssignmentElement, AnnotatableElement {\n  AnnAssign assignmentStatement;\n\n  AnnotatedAssignmentElement() { this = TAnnotatedAssignmentElement(assignmentStatement) }\n  override Expr getAnnotationExpr() { result = assignmentStatement.getAnnotation() }\n}\n\n/** Determines if an annotation is a forward declaration using string literal */\npredicate isForwardDeclaration(Expr annotationExpression) { \n  annotationExpression instanceof StringLiteral \n}\n\n/** Determines if an annotation represents a complex type construct */\npredicate isComplexType(Expr annotationExpression) {\n  (annotationExpression instanceof Subscript and not isOptionalType(annotationExpression)) or\n  annotationExpression instanceof Tuple or\n  annotationExpression instanceof List\n}\n\n/** Determines if an annotation is an Optional type annotation */\npredicate isOptionalType(Subscript annotationExpression) { \n  annotationExpression.getObject().(Name).getId() = \"Optional\" \n}\n\n/** Determines if an annotation is a simple non-built-in type identifier */\npredicate isSimpleType(Expr annotationExpression) {\n  (annotationExpression instanceof Name and not annotationExpression instanceof BuiltinType) or\n  (annotationExpression instanceof Attribute and isSimpleType(annotationExpression.(Attribute).getObject()))\n}\n\n/** Determines if an annotation is a built-in type */\npredicate isBuiltinType(Expr annotationExpression) { \n  annotationExpression instanceof BuiltinType \n}\n\n// Computes type annotation metrics for each annotation category\npredicate computeTypeAnnotationMetrics(\n  string annotationCategory, int totalAnnotations, int builtinTypeCount, \n  int forwardDeclarationCount, int simpleTypeCount, int complexTypeCount, \n  int optionalTypeCount\n) {\n  // Metrics for parameter annotations\n  annotationCategory = \"Parameter annotation\" and\n  totalAnnotations = count(AnnotatedParameterElement param) and\n  builtinTypeCount = count(AnnotatedParameterElement param | isBuiltinType(param.getAnnotationExpr())) and\n  forwardDeclarationCount = count(AnnotatedParameterElement param | isForwardDeclaration(param.getAnnotationExpr())) and\n  simpleTypeCount = count(AnnotatedParameterElement param | isSimpleType(param.getAnnotationExpr())) and\n  complexTypeCount = count(AnnotatedParameterElement param | isComplexType(param.getAnnotationExpr())) and\n  optionalTypeCount = count(AnnotatedParameterElement param | isOptionalType(param.getAnnotationExpr()))\n  or\n  // Metrics for return type annotations\n  annotationCategory = \"Return type annotation\" and\n  totalAnnotations = count(AnnotatedFunctionElement func) and\n  builtinTypeCount = count(AnnotatedFunctionElement func | isBuiltinType(func.getAnnotationExpr())) and\n  forwardDeclarationCount = count(AnnotatedFunctionElement func | isForwardDeclaration(func.getAnnotationExpr())) and\n  simpleTypeCount = count(AnnotatedFunctionElement func | isSimpleType(func.getAnnotationExpr())) and\n  complexTypeCount = count(AnnotatedFunctionElement func | isComplexType(func.getAnnotationExpr())) and\n  optionalTypeCount = count(AnnotatedFunctionElement func | isOptionalType(func.getAnnotationExpr()))\n  or\n  // Metrics for annotated assignments\n  annotationCategory = \"Annotated assignment\" and\n  totalAnnotations = count(AnnotatedAssignmentElement assign) and\n  builtinTypeCount = count(AnnotatedAssignmentElement assign | isBuiltinType(assign.getAnnotationExpr())) and\n  forwardDeclarationCount = count(AnnotatedAssignmentElement assign | isForwardDeclaration(assign.getAnnotationExpr())) and\n  simpleTypeCount = count(AnnotatedAssignmentElement assign | isSimpleType(assign.getAnnotationExpr())) and\n  complexTypeCount = count(AnnotatedAssignmentElement assign | isComplexType(assign.getAnnotationExpr())) and\n  optionalTypeCount = count(AnnotatedAssignmentElement assign | isOptionalType(assign.getAnnotationExpr()))\n}\n\n// Main query execution\nfrom \n  string annotationCategory, int totalAnnotations, int builtinTypeCount, \n  int forwardDeclarationCount, int simpleTypeCount, int complexTypeCount, \n  int optionalTypeCount\nwhere \n  computeTypeAnnotationMetrics(annotationCategory, totalAnnotations, builtinTypeCount, \n                              forwardDeclarationCount, simpleTypeCount, complexTypeCount, \n                              optionalTypeCount)\nselect \n  annotationCategory, totalAnnotations, builtinTypeCount, forwardDeclarationCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Identifies cryptographic implementations that employ elliptic curve algorithms\n *              which are either unrecognized or deemed cryptographically insecure,\n *              potentially introducing security vulnerabilities in the application.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define the collection of cryptographically secure elliptic curves\nstring trustedCurve() {\n  result = \n    \"SECP256R1\" or result = \"PRIME256V1\" or  // P-256 curves\n    result = \"SECP384R1\" or                  // P-384 curve\n    result = \"SECP521R1\" or                  // P-521 curve\n    result = \"ED25519\" or                    // Ed25519 curve\n    result = \"X25519\"                        // X25519 curve\n}\n\nfrom EllipticCurveAlgorithm curveImpl, string securityAlert, string curveName\nwhere\n  // Retrieve the curve name from the elliptic curve implementation\n  curveName = curveImpl.getCurveName() and\n  (\n    // Scenario 1: Check for unrecognized curve algorithm\n_______________ // 补全条件\n    securityAlert = \"Use of unrecognized curve algorithm.\"\n    or\n    // Scenario 2: Check for recognized but cryptographically weak curve algorithm\n    curveName != unknownAlgorithm() and\n    not curveName = trustedCurve() and\n    securityAlert = \"Use of weak curve algorithm \" + curveName + \".\"\n  )\nselect curveImpl, securityAlert",
    "output": "curveName = unknownAlgorithm() and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/todo-comment]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects comments that contain 'TODO' or 'TO DO' markers,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'To Do' comment detection\n * @description Detects comments that contain 'TODO' or 'TO DO' markers,\n *              which typically indicate incomplete functionality or pending work.\n *              These markers are useful for tracking development tasks but should\n *              be resolved before production release.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n *       external/cwe/cwe-546\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/todo-comment\n */\n\nimport python  // Import Python language module for code analysis\n\nfrom Comment commentWithTodoMarker  // Select all comment nodes for analysis\nwhere \n  // Extract comment text once for efficiency and check for TODO markers\n  exists(string commentText | \n    commentText = commentWithTodoMarker.getText() and\n    // Match both 'TODO' and 'TO DO' patterns in the comment text\n    (commentText.matches(\"%TODO%\") or commentText.matches(\"%TO DO%\"))\n  )\nselect \n  commentWithTodoMarker,  // Select the comment node containing TODO markers\n  commentWithTodoMarker.getText()  // Display the actual comment text for review"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/elliptic-curve-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies elliptic curve cryptographic implementations across codebases.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Elliptic Curve Cryptography Detection\n * @description Identifies elliptic curve cryptographic implementations across codebases.\n *              Extracts curve names and key sizes for quantum vulnerability assessment.\n *              Critical for cryptographic inventory due to ECC's susceptibility to quantum attacks.\n * @kind problem\n * @id py/quantum-readiness/cbom/elliptic-curve-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import core Python analysis module\nimport python\n\n// Import experimental cryptography analysis module\nimport experimental.cryptography.Concepts\n\n// Identify elliptic curve cryptographic implementations\nfrom EllipticCurveAlgorithm ellipticCurveAlgorithm\n\n// Format output with curve properties\nselect ellipticCurveAlgorithm,\n  \"Algorithm: \" + ellipticCurveAlgorithm.getCurveName() + \n  \" | Key Size (bits): \" + ellipticCurveAlgorithm.getCurveBitSize().toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/summarized-callable-call-sites]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies call sites where summarized callables are invoked",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Summarized callable call sites\n * @description Identifies call sites where summarized callables are invoked\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/summarized-callable-call-sites\n * @tags meta\n * @precision very-low\n */\n\n// Import Python language support\nimport python\n// Import data flow analysis modules\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\n// Import meta metrics utilities\nimport meta.MetaMetrics\n\n// Identify call sites with summarized callables\nfrom DataFlow::Node callSite, SummarizedCallable summarizedCallable, string callKind\nwhere\n  // Exclude call sites in ignored files\n  not callSite.getLocation().getFile() instanceof IgnoredFile and\n  (\n    // Handle direct callable invocations\n    (callSite = summarizedCallable.getACall() and callKind = \"Call\")\n    or\n    // Handle callback invocations\n    (callSite = summarizedCallable.getACallback() and callKind = \"Callback\")\n  )\n// Format output with call site and invocation type\nselect callSite, callKind + \" to \" + summarizedCallable"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-exception in 'except' clause\n * @description Detects exception handlers that specify non-exception types,\n *              which are ineffective at runtime since they never match actual exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Main components for exception handler analysis\nfrom ExceptFlowNode exceptHandler, Value caughtType, ClassValue actualException, \n     ControlFlowNode typeOrigin, string diagnosticMessage\nwhere\n  // Link between exception handler and its caught exception type\n  exceptHandler.handledException(caughtType, actualException, typeOrigin) and\n  (\n    // Scenario 1: Caught type is a class but not a valid exception\n    exists(ClassValue invalidExceptionClass | \n      invalidExceptionClass = caughtType and\n      not invalidExceptionClass.isLegalExceptionType() and\n      not invalidExceptionClass.failedInference(_) and\n      diagnosticMessage = \"class '\" + invalidExceptionClass.getName() + \"'\"\n_______________ // 补全条件\n    or\n    // Scenario 2: Caught type is not a class value\n    not caughtType instanceof ClassValue and\n    diagnosticMessage = \"instance of '\" + actualException.getName() + \"'\"\n  )\nselect exceptHandler.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  typeOrigin, diagnosticMessage",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Import shadowed by loop variable\n * @description Detects loop variables that share names with imported module aliases,\n *              potentially causing confusion by obscuring the imported identifier.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/import-shadowed-loop-variable\n */\n\nimport python\n\n_______________ // 补全条件\nwhere \n  // Verify the variable is defined as a loop iteration target\n  exists(For loopStatement | variableNameNode = loopStatement.getTarget()) and\n  variableNameNode.defines(loopVariable) and\n  // Identify conflicting import alias in the same scope hierarchy\n  exists(Import importStmt, Name aliasNode |\n    // Alias must originate from an import statement's 'as' clause\n    aliasNode = importStmt.getAName().getAsname() and\n    // Alias identifier must match the loop variable's name\n    aliasNode.getId() = loopVariable.getId() and\n    // Import must be accessible in the loop variable's scope\n    importStmt.getScope() = loopVariable.getScope().getScope*()\n  )\nselect variableNameNode, \"Loop variable '\" + loopVariable.getId() + \"' shadows an imported module alias.\"",
    "output": "from Variable loopVariable, Name variableNameNode"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Detects cryptographic operations that utilize elliptic curve algorithms which are either not approved \n *              or are considered cryptographically weak, potentially compromising security.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm cryptoOperation, string alertMessage, string curveIdentifier\nwhere\n  // Define the set of cryptographically strong elliptic curves\n  exists(string approvedCurve |\n    approvedCurve = [\n      \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n      \"SECP384R1\",              // P-384 curve\n      \"SECP521R1\",              // P-521 curve\n      \"ED25519\",                // Ed25519 curve\n      \"X25519\"                  // X25519 curve\n    ]\n  |\n    // Extract the curve identifier from the cryptographic operation\n    curveIdentifier = cryptoOperation.getCurveName() and\n    (\n      // Case 1: Unrecognized curve algorithm detected\n      curveIdentifier = unknownAlgorithm() and\n      alertMessage = \"Use of unrecognized curve algorithm.\"\n      or\n      // Case 2: Recognized but weak curve algorithm detected\n      curveIdentifier != unknownAlgorithm() and\n      not curveIdentifier = approvedCurve and\n_______________ // 补全条件\n    )\n  )\nselect cryptoOperation, alertMessage",
    "output": "alertMessage = \"Use of weak curve algorithm \" + curveIdentifier + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Regular expression injection\n * @description Detects when user-supplied input is directly used in regular expressions\n *              without proper escaping, enabling attackers to craft malicious regex patterns\n *              that cause exponential backtracking and denial-of-service.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/regex-injection\n * @tags security\n *       external/cwe/cwe-730\n *       external/cwe/cwe-400\n */\n\n// Core Python language imports\nimport python\n_______________ // 补全条件\nprivate import semmle.python.Concepts\n// Regex injection security dataflow analysis\nimport semmle.python.security.dataflow.RegexInjectionQuery\n// Path graph for taint flow visualization\nimport RegexInjectionFlow::PathGraph\n\n// Identify vulnerable regex patterns through dataflow analysis\nfrom\n  RegexInjectionFlow::PathNode taintedInput, RegexInjectionFlow::PathNode vulnerableRegex,\n  RegexExecution regexInstance\nwhere\n  // Verify complete taint propagation from source to sink\n  RegexInjectionFlow::flowPath(taintedInput, vulnerableRegex) and\n  // Associate sink node with its regex execution context\n  regexInstance = vulnerableRegex.getNode().(Sink).getRegexExecution()\n// Report security findings with contextual information\nselect vulnerableRegex.getNode(), taintedInput, vulnerableRegex,\n  \"This regex pattern incorporates a $@ and is executed by $@.\", \n  taintedInput.getNode(), \"user-provided value\", \n  regexInstance, regexInstance.getName()",
    "output": "// Internal Semmle Python analysis concepts"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Building cookies using user-provided input could lead to Cookie Poisoning vulnerabilities.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cookie construction with user-controlled data\n * @description Building cookies using user-provided input could lead to Cookie Poisoning vulnerabilities.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// Import Python libraries for code analysis\nimport python\n\n// Import query module for cookie injection detection\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Import path graph representation for data flow visualization\nimport CookieInjectionFlow::PathGraph\n\n// Identify data flow paths from untrusted sources to cookie creation sites\nfrom \n  // Entry point representing untrusted user input\n  CookieInjectionFlow::PathNode untrustedInputNode,\n  // Location where cookies are constructed\n  CookieInjectionFlow::PathNode cookieConstructionNode\nwhere \n  // Verify data flows from untrusted source to cookie construction\n  CookieInjectionFlow::flowPath(untrustedInputNode, cookieConstructionNode)\n// Output results with sink location, source location, flow path, \n// descriptive message, and source type classification\nselect \n  cookieConstructionNode.getNode(), \n  untrustedInputNode, \n  cookieConstructionNode, \n  \"Cookie is constructed from a $@.\", \n  untrustedInputNode.getNode(),\n  \"user-supplied input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/duplicate-key-dict-literal]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies dictionary literals containing duplicate keys where initial values are silently replaced by subsequent ones.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Duplicate key in dict literal\n * @description Identifies dictionary literals containing duplicate keys where initial values are silently replaced by subsequent ones.\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/duplicate-key-dict-literal\n */\n\nimport python\nimport semmle.python.strings\n\n/**\n * Converts dictionary keys into normalized string formats to enable accurate comparison.\n * Handles numeric types (direct value conversion) and string literals (with type-specific prefixes).\n */\npredicate keyNormalization(Dict dictionary, Expr keyExpr, string normalizedKey) {\n  keyExpr = dictionary.getAKey() and\n  (\n    // Handle numeric keys by converting their value to string representation\n    normalizedKey = keyExpr.(Num).getN()\n    or\n    // Process string literals with appropriate type prefixes\n    exists(StringLiteral strLiteral | \n      strLiteral = keyExpr and\n      (\n        // Unicode strings get 'u\"' prefix\n        normalizedKey = \"u\\\"\" + strLiteral.getText() + \"\\\"\" and strLiteral.isUnicode()\n        or\n        // Byte strings get 'b\"' prefix\n        normalizedKey = \"b\\\"\" + strLiteral.getText() + \"\\\"\" and not strLiteral.isUnicode()\n      )\n    )\n  )\n}\n\n// Identify dictionary keys that are duplicated and overwrite previous occurrences\nfrom Dict dictionary, Expr firstKey, Expr secondKey\nwhere\n  // Both keys must have identical normalized representations\n  exists(string keySignature | \n    keyNormalization(dictionary, firstKey, keySignature) and \n    keyNormalization(dictionary, secondKey, keySignature) and \n    firstKey != secondKey\n  ) and\n  // Validate the temporal sequence of key occurrences\n  (\n    // Scenario 1: Keys exist within the same basic block with first key appearing first\n    exists(BasicBlock basicBlock, int firstPosition, int secondPosition |\n      firstKey.getAFlowNode() = basicBlock.getNode(firstPosition) and\n      secondKey.getAFlowNode() = basicBlock.getNode(secondPosition) and\n      firstPosition < secondPosition\n    )\n    or\n    // Scenario 2: First key's basic block strictly dominates second key's basic block\n    firstKey.getAFlowNode().getBasicBlock().strictlyDominates(\n      secondKey.getAFlowNode().getBasicBlock()\n    )\n  )\n// Report the overwritten key with location of the overwriting duplicate\nselect firstKey, \n       \"Dictionary key \" + repr(firstKey) + \" is subsequently $@.\", \n       secondKey, \n       \"overwritten\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-of-identical-expressions]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code locations where a comparison operation is performed between identical values.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comparison of identical values\n * @description Detects code locations where a comparison operation is performed between identical values.\n *              Such comparisons usually indicate unclear programming intentions or potential logical flaws.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\nimport python  // Import Python library for analyzing Python code\nimport Expressions.RedundantComparison  // Import module for detecting redundant comparison expressions\n\n// Find redundant comparison expressions\nfrom RedundantComparison redundantValueComparison\n// Apply filtering conditions\nwhere \n  // Exclude constant comparisons\n  not redundantValueComparison.isConstant() and \n  // Exclude comparisons that might be missing self\n  not redundantValueComparison.maybeMissingSelf()\n// Output qualifying comparison expressions with warning message\nselect redundantValueComparison, \n       \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/init-calls-subclass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a parent class's `__init__` method invokes a method that is overridden by a subclass,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__init__` method calls overridden method\n * @description Detects when a parent class's `__init__` method invokes a method that is overridden by a subclass,\n *              which may lead to observing partially initialized instances.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/init-calls-subclass\n */\n\nimport python\n\nfrom\n  ClassObject parentClass, string methodIdentifier, Call methodCall, \n  FunctionObject overridingMethod, FunctionObject originalMethod\nwhere\n  // Identify the parent class's __init__ method\n  exists(FunctionObject initializerMethod |\n    parentClass.declaredAttribute(\"__init__\") = initializerMethod and\n    // Ensure the call occurs within the __init__ method's scope\n    methodCall.getScope() = initializerMethod.getFunction()\n  |\n    // Verify the call is made through a self reference\n    exists(SelfAttribute selfReference |\n      methodCall.getFunc() = selfReference and\n      // Extract the method name being called\n      selfReference.getName() = methodIdentifier and\n      // Retrieve the original method declaration in the parent class\n      originalMethod = parentClass.declaredAttribute(methodIdentifier) and\n      // Confirm that a subclass method overrides the parent method\n      overridingMethod.overrides(originalMethod)\n    )\n  )\n// Output warning with call node, overridden method name, and overriding method details\nselect methodCall, \"Call to self.$@ in __init__ method, which is overridden by $@.\", \n       originalMethod, methodIdentifier, overridingMethod, overridingMethod.descriptiveString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Redundant assignment\n * @description Identifies assignments where a variable is assigned to itself, which is typically useless and indicates a coding error.\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-563\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-assignment\n */\n\nimport python\n\n// Determines if a statement is an assignment and extracts its target and value\npredicate isAssignmentStatement(AssignStmt assignmentStmt, Expr lhs, Expr rhs) {\n  assignmentStmt.getATarget() = lhs and assignmentStmt.getValue() = rhs\n}\n\n// Recursively checks if two expressions correspond to each other, including attribute objects\npredicate expressionsMatch(Expr leftExpr, Expr rightExpr) {\n  isAssignmentStatement(_, leftExpr, rightExpr)\n  or\n  exists(Attribute leftAttr, Attribute rightAttr |\n    expressionsMatch(leftAttr, rightAttr) and\n    leftExpr = leftAttr.getObject() and\n    rightExpr = rightAttr.getObject()\n  )\n}\n\n// Determines if two expressions have the same value (either identical names or attributes)\npredicate expressionsHaveSameValue(Expr leftExpr, Expr rightExpr) {\n  namesAreIdentical(leftExpr, rightExpr) or attributesAreIdentical(leftExpr, rightExpr)\n}\n\n// Checks if a name might be undefined in an outer scope\npredicate isPotentiallyUndefinedInOuterScope(Name name) {\n  exists(SsaVariable var | var.getAUse().getNode() = name | var.maybeUndefined())\n}\n\n/*\n * Protection against false positives in projects offering Python 2/3 compatibility,\n * as they often contain assignments like:\n *\n * if PY2:\n *     bytes = str\n * else:\n *     bytes = bytes\n_______________ // 补全条件\n\n// Checks if a string corresponds to a built-in object name\npredicate isBuiltInName(string name) { exists(Value val | val = Value::named(name) and val.isBuiltin()) }\n\n// Determines if two names are identical and meet specific conditions\npredicate namesAreIdentical(Name firstName, Name secondName) {\n  expressionsMatch(firstName, secondName) and\n  firstName.getVariable() = secondName.getVariable() and\n  not isBuiltInName(firstName.getId()) and\n  not isPotentiallyUndefinedInOuterScope(secondName)\n}\n\n// Retrieves the type value of an attribute's object\nClassValue getAttributeType(Attribute attr) { attr.getObject().pointsTo().getClass() = result }\n\n// Checks if an attribute is a property access\npredicate isProperty(Attribute attr) {\n  getAttributeType(attr).lookup(attr.getName()) instanceof PropertyValue\n}\n\n// Determines if two attributes are identical and meet specific conditions\npredicate attributesAreIdentical(Attribute firstAttr, Attribute secondAttr) {\n  expressionsMatch(firstAttr, secondAttr) and\n  firstAttr.getName() = secondAttr.getName() and\n  expressionsHaveSameValue(firstAttr.getObject(), secondAttr.getObject()) and\n  exists(getAttributeType(firstAttr)) and\n  not isProperty(firstAttr)\n}\n\n// Prevents interference from magic comments in analysis\npragma[nomagic]\nComment findPyflakesMagicComment() { result.getText().toLowerCase().matches(\"%pyflakes%\") }\n\n// Gets the line number of a file containing a Pyflakes comment\nint getPyflakesCommentLine(File f) {\n  findPyflakesMagicComment().getLocation().hasLocationInfo(f.getAbsolutePath(), result, _, _, _)\n}\n\n// Checks if an assignment statement is marked with a Pyflakes comment\npredicate hasPyflakesComment(AssignStmt assignmentStmt) {\n  exists(Location loc |\n    assignmentStmt.getLocation() = loc and\n    loc.getStartLine() = getPyflakesCommentLine(loc.getFile())\n  )\n}\n\n// Checks if the left-hand side attribute expression has side effects\npredicate leftHandSideHasSideEffects(Attribute lhsAttr) {\n  exists(ClassValue cls, ClassValue superType |\n    lhsAttr.getObject().pointsTo().getClass() = cls and\n    superType = cls.getASuperType() and\n    not superType.isBuiltin()\n  |\n    superType.declaresAttribute(\"__setattr__\")\n  )\n}\n\n// Main query: Finds self-assignments without Pyflakes comments and without side effects\nfrom AssignStmt assignmentStmt, Expr lhs, Expr rhs\nwhere\n  isAssignmentStatement(assignmentStmt, lhs, rhs) and\n  expressionsHaveSameValue(lhs, rhs) and\n  not hasPyflakesComment(assignmentStmt) and\n  not leftHandSideHasSideEffects(lhs)\nselect assignmentStmt, \"This assignment assigns a variable to itself.\"",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * 评估指向关系数据结构的压缩性能：通过测量不同上下文深度下的\n * 唯一事实数量与总关系规模，计算数据压缩的有效性。\n * \n * 该查询计算以下性能指标：\n * - 唯一事实数量：不同(控制流节点, 目标对象, 对象类)组合的计数\n * - 总关系规模：包含上下文和源节点信息的完整关系数量\n * - 压缩效率：唯一事实数量占总关系规模的百分比\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 声明查询输出变量：唯一事实计数、关系总数、上下文深度和压缩效率\nfrom int uniqueFactsCount, int totalRelationCount, int ctxDepth, float compressionEfficiency\nwhere\n  // 基础条件：确保存在指向关系并确定上下文深度\n  exists(ControlFlowNode cfNode, Object targetObject, ClassObject objClass, PointsToContext ptContext |\n    PointsTo::points_to(cfNode, ptContext, targetObject, objClass, _) and\n    ctxDepth = ptContext.getDepth()\n  ) and\n  // 计算唯一事实数量：统计不同(控制流节点, 目标对象, 对象类)三元组的数量\n  uniqueFactsCount =\n    strictcount(ControlFlowNode cfNode, Object targetObject, ClassObject objClass |\n      // 筛选特定上下文深度的指向关系\n      exists(PointsToContext ptContext |\n        PointsTo::points_to(cfNode, ptContext, targetObject, objClass, _) and\n        ptContext.getDepth() = ctxDepth\n      )\n    ) and\n  // 计算关系总规模：统计所有(控制流节点, 目标对象, 对象类, 上下文, 源节点)五元组的数量\n  totalRelationCount =\n    strictcount(ControlFlowNode cfNode, Object targetObject, ClassObject objClass, \n      PointsToContext ptContext, ControlFlowNode sourceNode |\n      // 筛选特定上下文深度的完整指向关系\n      PointsTo::points_to(cfNode, ptContext, targetObject, objClass, sourceNode) and\n      ptContext.getDepth() = ctxDepth\n    ) and\n  // 计算压缩效率：唯一事实数量占总关系规模的百分比\n  compressionEfficiency = 100.0 * uniqueFactsCount / totalRelationCount\n// 输出结果：上下文深度、唯一事实数量、关系总规模和压缩效率\nselect ctxDepth, uniqueFactsCount, totalRelationCount, compressionEfficiency"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Decompression Bomb Vulnerability\n * @description Detects potential decompression bomb attacks where uncontrolled input\n *              flows into decompression APIs without proper compression rate checks\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.8\n * @precision high\n * @id py/decompression-bomb\n * @tags security\n *       experimental\n *       external/cwe/cwe-409\n */\n\n// Core Python analysis framework\nimport python\n// Specialized decompression bomb detection capabilities\nimport experimental.semmle.python.security.DecompressionBomb\n// Path graph utilities for visualizing data flows\nimport BombsFlow::PathGraph\n\n_______________ // 补全条件\nfrom BombsFlow::PathNode untrustedSource, BombsFlow::PathNode decompressionSink\n// Verify complete data flow path exists from source to sink\nwhere BombsFlow::flowPath(untrustedSource, decompressionSink)\n// Report security finding with flow context\nselect decompressionSink.getNode(), \n       untrustedSource, \n       decompressionSink, \n       \"This uncontrolled decompression operation originates from $@.\", \n       untrustedSource.getNode(),\n       \"untrusted user input that could cause excessive resource consumption\"",
    "output": "// Identify vulnerable data flow paths"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/utils/modeleditor/framework-mode-endpoints]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Catalogs accessible endpoints (methods and attributes) within the model editor's framework mode.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Framework-mode endpoint catalog for model editor\n * @description Catalogs accessible endpoints (methods and attributes) within the model editor's framework mode.\n *              Filters out test code and generated artifacts from the results.\n * @kind table\n * @id py/utils/modeleditor/framework-mode-endpoints\n * @tags modeleditor endpoints framework-mode\n */\n\n// Import ModelEditor capabilities for endpoint analysis\nimport modeling.ModelEditor\n\n// Fetch framework endpoint information with improved variable naming\nfrom Endpoint frameworkEndpoint\nselect \n  // Core endpoint reference\n  frameworkEndpoint,\n  // Namespace containing the endpoint\n  frameworkEndpoint.getNamespace(),\n  // Parent class defining the endpoint\n  frameworkEndpoint.getClass(),\n  // Method/function name of the endpoint\n  frameworkEndpoint.getFunctionName(),\n  // Parameter signature of the endpoint\n  frameworkEndpoint.getParameters(),\n  // Supported HTTP status codes\n  frameworkEndpoint.getSupportedStatus(),\n  // Source file containing endpoint definition\n  frameworkEndpoint.getFileName(),\n  // Supported data types for the endpoint\n  frameworkEndpoint.getSupportedType(),\n  // Endpoint classification (method/attribute)\n  frameworkEndpoint.getKind()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Membership test with a non-container\n * @description A membership test, such as 'item in sequence', with a non-container \n *              on the right hand side will raise a 'TypeError'.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n// Identifies Compare nodes containing In/NotIn operations where the specified node \n// serves as the right-hand operand in membership testing\npredicate isRightOperandInMembershipTest(ControlFlowNode rhsNode, Compare membershipTest) {\n  exists(Cmpop op, int i | \n    membershipTest.getOp(i) = op and \n    membershipTest.getComparator(i) = rhsNode.getNode() and \n    (op instanceof In or op instanceof NotIn)\n  )\n}\n\nfrom \n  ControlFlowNode nonContainerRhsNode, \n  Compare membershipTest, \n  Value pointedValue, \n  ClassValue valueClass, \n  ControlFlowNode sourceNode\nwhere\n  // Establish relationship between membership test and its right operand\n  isRightOperandInMembershipTest(nonContainerRhsNode, membershipTest) and\n  \n  // Track value flow and class information\n  nonContainerRhsNode.pointsTo(_, pointedValue, sourceNode) and\n  pointedValue.getClass() = valueClass and\n  \n  // Exclude cases with failed type inference\n  not Types::failedInference(valueClass, _) and\n  \n  // Verify absence of container protocol methods\n  not valueClass.hasAttribute(\"__contains__\") and\n  not valueClass.hasAttribute(\"__iter__\") and\n  not valueClass.hasAttribute(\"__getitem__\") and\n_______________ // 补全条件\n  // Exclude special container-like types\n  not valueClass = ClassValue::nonetype() and\n  not valueClass = Value::named(\"types.MappingProxyType\")\nselect \n  membershipTest, \n  \"This test may raise an Exception as the $@ may be of non-container class $@.\", \n  sourceNode, \"target\", valueClass, valueClass.getName()",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/constant-conditional-expression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The condition is always true or always false",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Constant used in conditional context\n * @description The condition is always true or always false\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/constant-conditional-expression\n */\n\nimport python\n\n// Determine if an expression is used in a conditional test context\npredicate is_condition(Expr conditionExpr) {\n  // Check if the expression is the test part of an if statement\n  exists(If ifStmt | ifStmt.getTest() = conditionExpr)\n  or\n  // Check if the expression is the test part of a conditional expression\n  exists(IfExp conditionalExpr | conditionalExpr.getTest() = conditionExpr)\n}\n\n// Identify specific built-in names that should be treated as constants\npredicate effective_constant(Name nameNode) {\n  // Find global built-in constants that haven't been redefined in the code\n  exists(GlobalVariable globalVar | \n    globalVar = nameNode.getVariable() and \n    not exists(NameNode definitionNode | definitionNode.defines(globalVar)) |\n    globalVar.getId() = \"True\" or \n    globalVar.getId() = \"False\" or \n    globalVar.getId() = \"NotImplemented\"\n  )\n}\n\n// Detect conditions that result in unreachable code blocks\npredicate test_makes_code_unreachable(Expr conditionExpr) {\n  // Check if conditions in if statements create unreachable branches\n  exists(If ifStmt | \n    ifStmt.getTest() = conditionExpr and \n    (ifStmt.getStmt(0).isUnreachable() or \n     ifStmt.getOrelse(0).isUnreachable())\n  )\n  or\n  // Check if conditions in while loops create unreachable bodies\n  exists(While whileStmt | \n    whileStmt.getTest() = conditionExpr and \n    whileStmt.getStmt(0).isUnreachable()\n  )\n}\n\n// Identify all constant expressions used in conditional contexts\nfrom Expr conditionExpr\nwhere\n  // Verify the expression is used in a conditional context\n  is_condition(conditionExpr) and\n  // Determine if the expression is a constant or effectively constant\n  (conditionExpr.isConstant() or effective_constant(conditionExpr)) and\n  // Filter out conditions that make code unreachable (handled by a separate query)\n  not test_makes_code_unreachable(conditionExpr)\n// Report the findings\nselect conditionExpr, \"Testing a constant will always give the same result.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak elliptic curve\n * @description Finds uses of cryptography algorithms that are unapproved or otherwise weak.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 定义安全曲线算法列表\nstring getSecureCurve() {\n  result =\n    [\n      \"SECP256R1\", \"PRIME256V1\",  // P-256 curves\n      \"SECP384R1\",               // P-384 curve\n      \"SECP521R1\",               // P-521 curve\n      \"ED25519\",                 // Ed25519 curve\n      \"X25519\"                   // X25519 curve\n    ]\n}\n\n// 从椭圆曲线算法实例中提取信息并检测弱曲线\nfrom EllipticCurveAlgorithm algo, string alertMsg, string curveName\nwhere\n  // 获取当前使用的曲线名称\n  curveName = algo.getCurveName() and\n  (\n    // 情况1：检测未识别的曲线算法\n    curveName = unknownAlgorithm() and\n_______________ // 补全条件\n    or\n    // 情况2：检测弱曲线算法\n    curveName != unknownAlgorithm() and\n    not curveName = getSecureCurve() and\n    alertMsg = \"Use of weak curve algorithm \" + curveName + \".\"\n  )\nselect algo, alertMsg",
    "output": "alertMsg = \"Use of unrecognized curve algorithm.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Recent contributors count per module\n * @description Counts distinct contributors who made changes in the last 180 days\n * @kind treemap\n * @id py/historical-number-of-recent-authors\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Select each module that has lines of code metrics\nfrom Module moduleEntity\nwhere exists(moduleEntity.getMetrics().getNumberOfLinesOfCode())\nselect moduleEntity,\n  count(Author codeAuthor |\n    // Find commits by this author that affected the module\n_______________ // 补全条件\n      commitRecord = codeAuthor.getACommit() and\n      moduleEntity.getFile() = commitRecord.getAnAffectedFile() and\n      commitRecord.daysToNow() <= 180 and\n      not artificialChange(commitRecord)\n    )\n  )",
    "output": "exists(Commit commitRecord |"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/key-exchange]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Finds all potential usage of key exchange using the supported libraries.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Key Exchange Algorithms\n * @description Finds all potential usage of key exchange using the supported libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/key-exchange\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// 导入Python库，用于分析Python代码\nimport python\n\n// 导入实验性的加密概念库，用于处理加密相关的概念和算法\nimport experimental.cryptography.Concepts\n\n// 从KeyExchangeAlgorithm类中选择算法alg\nfrom KeyExchangeAlgorithm alg\n\n// 查询语句：选择算法alg，并返回一个字符串，表示使用了哪个算法\nselect alg, \"Use of algorithm \" + alg.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/possible-timing-attack-sensitive-info]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects non-constant-time verification routines for secret values,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Timing attack against secret\n * @description Detects non-constant-time verification routines for secret values,\n *              potentially enabling timing attacks that expose sensitive information.\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/possible-timing-attack-sensitive-info\n * @tags security\n *       external/cwe/cwe-208\n *       experimental\n */\n\n// Import core Python language analysis modules\nimport python\n// Import data flow analysis framework\nimport semmle.python.dataflow.new.DataFlow\n// Import taint propagation capabilities\nimport semmle.python.dataflow.new.TaintTracking\n// Import experimental timing attack detection utilities\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * Configuration for tracking data flow from secret origins to non-constant-time comparisons.\n * This setup identifies potential timing attack vulnerabilities in code.\n */\nprivate module SecretComparisonConfig implements DataFlow::ConfigSig {\n  // Define origins: nodes representing secret sources\n  predicate isSource(DataFlow::Node secretOrigin) { secretOrigin instanceof SecretSource }\n\n  // Define targets: nodes representing non-constant-time comparison operations\n  predicate isSink(DataFlow::Node comparisonTarget) { comparisonTarget instanceof NonConstantTimeComparisonSink }\n\n  // Enable differential observation mode for all scenarios\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Establish global taint tracking using the secret comparison configuration\nmodule SecretComparisonFlow = TaintTracking::Global<SecretComparisonConfig>;\n\n// Import path visualization module for flow paths\nimport SecretComparisonFlow::PathGraph\n\n// Primary query to detect timing attack vulnerabilities\nfrom\n  SecretComparisonFlow::PathNode sourceNode,  // Origin of the secret data\n  SecretComparisonFlow::PathNode sinkNode     // Target comparison operation\nwhere \n  // Verify existence of flow path from secret origin to comparison target\n  SecretComparisonFlow::flowPath(sourceNode, sinkNode)\nselect \n  sinkNode.getNode(),      // Location where vulnerability manifests\n  sourceNode,              // Origin of the flow\n  sinkNode,                // Termination point of the flow\n  \"Timing attack against $@ verification.\", // Security alert\n  sourceNode.getNode(),    // Reference point for alert\n  \"client-provided secret\" // Description of the sensitive source"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Importing value of mutable attribute\n * @description Direct import of mutable attribute values prevents observing global state changes locally.\n * @kind problem\n_______________ // 补全条件\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity high\n * @precision medium\n * @id py/import-of-mutable-attribute\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom ImportMember importedMember, ModuleValue originalModule, AttrNode attributeModification, string attributeName\nwhere\n  // Verify module name consistency between import and source\n  originalModule.importedAs(importedMember.getModule().(ImportExpr).getImportedModuleName()) and\n  // Ensure imported member name matches attribute name\n  importedMember.getName() = attributeName and\n  // Confirm attribute is a store operation\n  attributeModification.isStore() and\n  // Attribute modification must occur within function scope\n  exists(Function func | attributeModification.getScope() = func) and\n  // Imported variable must have module-level scope (non-function)\n  not exists(Function func | importedMember.getScope() = func) and\n  // Verify attribute references the imported module\n  attributeModification.getObject(attributeName).pointsTo(originalModule) and\n  // Ensure import and modification occur in different modules\n  importedMember.getEnclosingModule() != attributeModification.getScope().getEnclosingModule() and\n  // Exclude modifications within test code\n  not exists(TestScope test | attributeModification.getScope().getScope*() = test)\nselect importedMember,\n  \"Importing the value of '\" + attributeName +\n    \"' from $@ means that any change made to $@ will be not be observed locally.\", originalModule,\n  \"module \" + originalModule.getName(), attributeModification, originalModule.getName() + \".\" + attributeName",
    "output": "* @tags reliability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/hash-unhashable-value]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Hashing an object which is not hashable will result in a TypeError at runtime.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unhashable object hashed\n * @description Hashing an object which is not hashable will result in a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/hash-unhashable-value\n */\n\nimport python\n\n/**\n * Identifies classes representing numpy array types.\n * Matches classes inheriting from numpy.ndarray or numpy.core.ndarray.\n */\npredicate numpy_array_type(ClassValue arrayClass) {\n  exists(ModuleValue numpyModule | \n    numpyModule.getName() = \"numpy\" or \n    numpyModule.getName() = \"numpy.core\" |\n    arrayClass.getASuperType() = numpyModule.attr(\"ndarray\")\n  )\n}\n\n/**\n * Determines if a value implements custom indexing behavior.\n * True for classes with custom __getitem__ method or numpy arrays.\n */\npredicate has_custom_getitem(Value targetValue) {\n  targetValue.getClass().lookup(\"__getitem__\") instanceof PythonFunctionValue\n  or\n  numpy_array_type(targetValue.getClass())\n}\n\n/**\n * Locates control flow nodes passed directly to hash().\n */\npredicate explicitly_hashed(ControlFlowNode node) {\n  exists(CallNode callNode, GlobalVariable globalVar |\n    callNode.getArg(0) = node and \n    callNode.getFunction().(NameNode).uses(globalVar) and \n    globalVar.getId() = \"hash\"\n  )\n}\n\n/**\n * Checks if a subscript operation uses an unhashable index.\n * Requires the target object to lack custom indexing behavior.\n */\npredicate unhashable_subscript(ControlFlowNode indexNode, ClassValue unhashableClass, ControlFlowNode originNode) {\n  is_unhashable(indexNode, unhashableClass, originNode) and\n  exists(SubscriptNode subscriptOp | subscriptOp.getIndex() = indexNode |\n    exists(Value targetValue |\n      subscriptOp.getObject().pointsTo(targetValue) and\n      not has_custom_getitem(targetValue)\n    )\n  )\n}\n\n/**\n * Verifies if an object is unhashable.\n * Applies to new-style classes without __hash__ or with __hash__ = None.\n */\npredicate is_unhashable(ControlFlowNode node, ClassValue targetClass, ControlFlowNode originNode) {\n  exists(Value objValue | node.pointsTo(objValue, originNode) and objValue.getClass() = targetClass |\n    (not targetClass.hasAttribute(\"__hash__\") and \n     not targetClass.failedInference(_) and \n     targetClass.isNewStyle())\n    or\n    targetClass.lookup(\"__hash__\") = Value::named(\"None\")\n  )\n}\n\n/**\n * Detects control flow nodes within try blocks catching TypeError.\n * Used to filter out cases where TypeError is explicitly handled.\n */\npredicate typeerror_is_caught(ControlFlowNode node) {\n  exists(Try tryBlock |\n    tryBlock.getBody().contains(node.getNode()) and\n    tryBlock.getAHandler().getType().pointsTo(ClassValue::typeError())\n  )\n}\n\n// Main query identifying unhandled unhashable operations\nfrom ControlFlowNode node, ClassValue unhashableClass, ControlFlowNode originNode\nwhere\n  not typeerror_is_caught(node) and\n  (\n    explicitly_hashed(node) and \n    is_unhashable(node, unhashableClass, originNode)\n    or\n    unhashable_subscript(node, unhashableClass, originNode)\n  )\nselect node.getNode(), \"This $@ of $@ is unhashable.\", originNode, \"instance\", unhashableClass, unhashableClass.getQualifiedName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-protocol]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code that uses deprecated SSL/TLS protocol versions, which can expose connections to known security vulnerabilities.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of insecure SSL/TLS version\n * @description Identifies code that uses deprecated SSL/TLS protocol versions, which can expose connections to known security vulnerabilities.\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n/* Represents nodes that configure deprecated SSL/TLS protocol versions */\nclass InsecureSSLConfig extends DataFlow::Node {\n  InsecureSSLConfig() {\n    /* Case 1: Creating vulnerable connection with security context */\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    /* Case 2: Creating vulnerable connection without security context */\n    unsafe_connection_creation_without_context(this, _)\n    or\n    /* Case 3: Creating insecure security context */\n    unsafe_context_creation(this, _)\n  }\n\n  /* Retrieves the function node associated with this configuration */\n  DataFlow::Node getAssociatedFunction() { \n    result = this.(DataFlow::CallCfgNode).getFunction() \n  }\n}\n\n/* Represents nodes that can be identified by name (function calls or attribute references) */\nclass NamedNode extends DataFlow::Node {\n  NamedNode() {\n    /* Case 1: Node is a function from protocol configuration */\n    this = any(InsecureSSLConfig insecureConfig).getAssociatedFunction()\n    or\n    /* Case 2: Node is an attribute reference of another identifiable node */\n    this = any(NamedNode attributeNode).(DataFlow::AttrRef).getObject()\n  }\n}\n\n/* Constructs the fully qualified name for a named node */\nstring getQualifiedName(NamedNode namedNode) {\n  /* Case 1: Direct function name */\n  result = namedNode.asExpr().(Name).getId()\n  or\n  /* Case 2: Attribute access chain */\n  exists(DataFlow::AttrRef attributeRef | \n    attributeRef = namedNode and\n    result = getQualifiedName(attributeRef.getObject()) + \".\" + attributeRef.getAttributeName()\n  )\n}\n\n/* Helper functions for generating descriptive text */\n\n/* Generates descriptive text for SSL configuration */\nstring getConfigurationDescription(InsecureSSLConfig configNode) {\n  /* Case 1: Function call configuration */\n  exists(DataFlow::CallCfgNode functionCall | \n    functionCall = configNode and\n    result = \"call to \" + getQualifiedName(functionCall.getFunction())\n  )\n  or\n  /* Case 2: Context modification (non-call, non-context creation) */\n  not configNode instanceof DataFlow::CallCfgNode and\n  not configNode instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n/* Determines appropriate verb based on explicit configuration flag */\nstring getVerbForConfiguration(boolean isExplicit) {\n  isExplicit = true and result = \"specified\"\n  or\n  isExplicit = false and result = \"allowed\"\n}\n\n/* Query to identify usage of deprecated SSL/TLS protocol versions */\nfrom\n  DataFlow::Node vulnerableNode, string insecureProtocol, \n  InsecureSSLConfig configNode, boolean isExplicit\nwhere\n  /* Case 1: Insecure connection with security context */\n  (\n    unsafe_connection_creation_with_context(vulnerableNode, insecureProtocol, configNode, isExplicit)\n  )\n  or\n  /* Case 2: Insecure connection without security context */\n  (\n    unsafe_connection_creation_without_context(vulnerableNode, insecureProtocol) and\n    configNode = vulnerableNode and\n    isExplicit = true\n  )\n  or\n  /* Case 3: Insecure security context creation */\n  (\n    unsafe_context_creation(configNode, insecureProtocol) and\n    vulnerableNode = configNode and\n    isExplicit = true\n  )\nselect vulnerableNode,\n  \"Insecure SSL/TLS protocol version \" + insecureProtocol + \" \" + getVerbForConfiguration(isExplicit) + \" by $@.\",\n  configNode, getConfigurationDescription(configNode)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/utils/modeleditor/framework-mode-endpoints]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Catalogs all discoverable endpoints operating within the Model Editor's framework mode,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Model Editor Framework Endpoint Discovery\n * @description Catalogs all discoverable endpoints operating within the Model Editor's framework mode,\n *              systematically filtering out test implementations and auto-generated code artifacts.\n * @kind table\n * @id py/utils/modeleditor/framework-mode-endpoints\n * @tags modeleditor endpoints framework-mode\n */\n\nimport modeling.ModelEditor\n\nfrom Endpoint frameworkEndpoint\nselect \n  frameworkEndpoint,                     // Core endpoint reference\n  frameworkEndpoint.getNamespace(),      // Namespace containing the endpoint\n  frameworkEndpoint.getClass(),          // Parent class defining the endpoint\n  frameworkEndpoint.getFunctionName(),   // Method/function name of the endpoint\n  frameworkEndpoint.getParameters(),     // Parameter signature of the endpoint\n  frameworkEndpoint.getSupportedStatus(), // Supported HTTP status codes\n  frameworkEndpoint.getFileName(),       // Source file containing endpoint definition\n  frameworkEndpoint.getSupportedType(),  // Supported data types for the endpoint\n  frameworkEndpoint.getKind()            // Endpoint classification (method/attribute)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/equals-hash-mismatch]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects classes violating object model by defining equality without hashability (or vice-versa)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent equality and hashing\n * @description Detects classes violating object model by defining equality without hashability (or vice-versa)\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-581\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/equals-hash-mismatch\n */\n\nimport python\n\n// Helper to check if a class implements equality comparison methods\nCallableValue classDefinesEquality(ClassValue cls, string methodName) {\n  // Standard equality check for all Python versions\n  methodName = \"__eq__\" and\n  result = cls.declaredAttribute(methodName)\n  or\n  // Legacy comparison method for Python 2\n  major_version() = 2 and\n  methodName = \"__cmp__\" and\n  result = cls.declaredAttribute(methodName)\n}\n\n// Helper to check if a class implements a specific method\nCallableValue classHasMethod(ClassValue cls, string methodName) {\n  // Check equality methods via dedicated helper\n  result = classDefinesEquality(cls, methodName)\n  or\n  // Check hash method implementation\n  methodName = \"__hash__\" and\n  result = cls.declaredAttribute(\"__hash__\")\n}\n\n// Determine which required method is missing in a class\nstring missingMethod(ClassValue cls) {\n  // Case 1: Missing equality methods\n  not exists(classDefinesEquality(cls, _)) and\n  (\n    // Python 3 requires __eq__\n    major_version() = 3 and\n    result = \"__eq__\"\n    or\n    // Python 2 accepts either __eq__ or __cmp__\n    major_version() = 2 and\n    result = \"__eq__ or __cmp__\"\n  )\n  or\n  // Case 2: Missing __hash__ method (Python 2 only)\n  major_version() = 2 and\n  result = \"__hash__\" and\n  not cls.declaresAttribute(\"__hash__\")\n}\n\n/** Classes explicitly marked as unhashable */\npredicate isUnhashable(ClassValue cls) {\n  // Explicit __hash__ = None assignment\n  cls.lookup(\"__hash__\") = Value::named(\"None\")\n  or\n  // __hash__ method that never returns\n  cls.lookup(\"__hash__\").(CallableValue).neverReturns()\n}\n\n// Detect classes violating the hash contract\npredicate violatesHashContract(ClassValue cls, string existingMethod, string absentMethod, Value method) {\n  // Exclude explicitly unhashable classes\n  not isUnhashable(cls) and\n  // Identify the missing required method\n  absentMethod = missingMethod(cls) and\n  // Get the existing method implementation\n  method = classHasMethod(cls, existingMethod) and\n  // Exclude classes with analysis failures\n  not cls.failedInference(_)\n}\n\n// Main query: Identify classes with hash contract violations\nfrom ClassValue c, string existingMethod, string absentMethod, CallableValue method\nwhere\n  violatesHashContract(c, existingMethod, absentMethod, method) and\n  exists(c.getScope()) // Ensure class is from source code\nselect method, \"Class $@ implements \" + existingMethod + \" but does not define \" + absentMethod + \".\", c,\n  c.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Modification of dictionary returned by locals()\n * @description Detects code that modifies the dictionary from locals(), which has no effect on local variables.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/modification-of-locals\n */\n\nimport python\n\n// Identifies control flow nodes referencing locals() call results\npredicate referencesLocalsCall(ControlFlowNode cfNode) { \n    cfNode.pointsTo(_, _, Value::named(\"locals\").getACall()) \n}\n\n// Detects dictionary subscript operations (assignment/deletion) on locals() results\npredicate isDictionaryModification(ControlFlowNode modNode) {\n    exists(SubscriptNode subNode |\n        subNode = modNode and\n        referencesLocalsCall(subNode.getObject()) and\n        (subNode.isStore() or subNode.isDelete())\n    )\n}\n\n// Detects mutating method calls (pop/update/etc.) on locals() results\npredicate isMethodCallModification(ControlFlowNode modNode) {\n    exists(CallNode callNode, AttrNode attrNode, string method |\n        callNode = modNode and\n        attrNode = callNode.getFunction() and\n        referencesLocalsCall(attrNode.getObject(method)) and\n        method in [\"pop\", \"popitem\", \"update\", \"clear\"]\n    )\n_______________ // 补全条件\n\nfrom AstNode syntaxNode, ControlFlowNode modNode\nwhere\n    // Combines detection of both modification types\n    (isDictionaryModification(modNode) or isMethodCallModification(modNode)) and\n    // Maps control flow node to AST node\n    syntaxNode = modNode.getNode() and\n    // Excludes module-level operations (locals() ≡ globals() there)\n    not syntaxNode.getScope() instanceof ModuleScope\n// Selects problematic nodes with warning message\nselect syntaxNode, \"Modification of the locals() dictionary will have no effect on the local variables.\"",
    "output": "}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/catch-base-exception]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers catching 'BaseException' without re-raising,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Exception block catches 'BaseException'\n * @description Identifies exception handlers catching 'BaseException' without re-raising,\n *              which can interfere with system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\nfrom ExceptStmt exceptBlock\nwhere\n  /* Identify handlers catching BaseException or using bare except */\n  (\n    exceptBlock.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n    or\n    not exists(exceptBlock.getType())\n  )\n  and\n  /* Confirm handler doesn't re-raise the exception */\n  exceptBlock.getAFlowNode().getBasicBlock().reachesExit()\nselect exceptBlock, \"Except block directly handles BaseException.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/equals-hash-mismatch]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Defining equality for a class without also defining hashability (or vice-versa) violates the object model.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent equality and hashing\n * @description Defining equality for a class without also defining hashability (or vice-versa) violates the object model.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-581\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/equals-hash-mismatch\n */\n\nimport python\n\n// Identifies equality comparison methods within a class\nCallableValue getEqualityMethod(ClassValue cls, string methodName) {\n  // Check for __eq__ method or Python 2's __cmp__\n  (\n    methodName = \"__eq__\"\n    or\n    major_version() = 2 and methodName = \"__cmp__\"\n  ) and\n  result = cls.declaredAttribute(methodName)\n}\n\n// Retrieves implemented methods from a class (either equality methods or __hash__)\nCallableValue getClassMethod(ClassValue cls, string methodName) {\n  // Return equality methods or __hash__ implementation\n  result = getEqualityMethod(cls, methodName)\n  or\n  result = cls.declaredAttribute(\"__hash__\") and methodName = \"__hash__\"\n}\n\n// Determines which method is missing in a class to satisfy the hash contract\nstring getMissingMethodName(ClassValue cls) {\n  // Case 1: Equality methods are missing\n  not exists(getEqualityMethod(cls, _)) and\n  (\n    result = \"__eq__\" and major_version() = 3\n    or\n    major_version() = 2 and result = \"__eq__ or __cmp__\"\n  )\n  or\n  // Case 2: __hash__ method is missing (Python 2 specific)\n  not cls.declaresAttribute(result) and result = \"__hash__\" and major_version() = 2\n}\n\n/** Checks if a class is intentionally designed to be unhashable */\npredicate isIntentionallyUnhashable(ClassValue cls) {\n  // Class is unhashable if __hash__ is explicitly set to None or never returns\n  cls.lookup(\"__hash__\") = Value::named(\"None\")\n  or\n  cls.lookup(\"__hash__\").(CallableValue).neverReturns()\n}\n\n// Detects classes that violate the hash contract by not implementing required methods\npredicate violatesHashContract(ClassValue cls, string existingMethod, string missingMethod, Value methodImpl) {\n  // Verify the class isn't intentionally unhashable and has missing methods\n  not isIntentionallyUnhashable(cls) and\n  missingMethod = getMissingMethodName(cls) and\n  methodImpl = getClassMethod(cls, existingMethod) and\n  not cls.failedInference(_) // Exclude classes with inference failures\n}\n\n// Main query that identifies classes with hash contract violations\nfrom ClassValue cls, string existingMethod, string missingMethod, CallableValue methodImpl\nwhere\n  violatesHashContract(cls, existingMethod, missingMethod, methodImpl) and\n  exists(cls.getScope()) // Ensure class is from source code\nselect methodImpl, \"Class $@ implements \" + existingMethod + \" but does not define \" + missingMethod + \".\", cls,\n  cls.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Syntax error\n * @description Syntax errors cause failures at runtime and prevent analysis of the code.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// 导入Python语言分析模块，提供语法错误检测功能\nimport python\n\n// 查询所有非编码类型的语法错误\nfrom SyntaxError syntaxIssue\nwhere \n    // 排除编码相关的错误，只关注真正的语法问题\n    not syntaxIssue instanceof EncodingError\n_______________ // 补全条件\nselect syntaxIssue, syntaxIssue.getMessage() + \" (in Python \" + major_version() + \").\"",
    "output": "// 返回语法错误及其详细信息，包含当前Python主版本信息"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-lines-added]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Number of added lines per file, across the revision history in the database.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Added lines per file\n * @description Number of added lines per file, across the revision history in the database.\n * @kind treemap\n * @id py/historical-lines-added\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\nfrom Module targetModule, int totalAddedLines\nwhere\n  // Calculate cumulative line additions across all commits for each module\n  totalAddedLines =\n    sum(Commit versionCommit, int addedLineCount |\n      // Retrieve line additions from the most recent commit for the module's file\n      addedLineCount = versionCommit.getRecentAdditionsForFile(targetModule.getFile()) and\n      // Exclude commits that are artificial or automated changes\n      not artificialChange(versionCommit)\n    |\n      // Aggregate the line counts across all qualifying commits\n      addedLineCount\n    ) and\n  // Verify that the module has valid lines of code metrics available\n  exists(targetModule.getMetrics().getNumberOfLinesOfCode())\nselect targetModule, totalAddedLines order by totalAddedLines desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable 'except' block\n * @description Identifies situations where a specific exception handler is positioned after a general one,\n *              causing it to be unreachable because the general handler will always intercept the exception first.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Extracts the exception type handled by an except clause\nClassValue getHandledExceptionType(ExceptStmt exceptClause) { \n  exceptClause.getType().pointsTo(result) \n}\n\n// Determines if an exception handler is unreachable due to handler ordering\npredicate hasUnreachableHandler(ExceptStmt precedingHandler, ClassValue superTypeException, \n                                ExceptStmt subsequentHandler, ClassValue subTypeException) {\n  exists(int precedingIndex, int subsequentIndex, Try tryBlock |\n    // Both handlers belong to the same try statement\n    precedingHandler = tryBlock.getHandler(precedingIndex) and\n    subsequentHandler = tryBlock.getHandler(subsequentIndex) and\n    // Preceding handler appears before subsequent handler in source code\n_______________ // 补全条件\n    // Extract exception types for both handlers\n    superTypeException = getHandledExceptionType(precedingHandler) and\n    subTypeException = getHandledExceptionType(subsequentHandler) and\n    // Preceding handler catches a superclass of subsequent handler's exception\n    superTypeException = subTypeException.getASuperType()\n  )\n}\n\n// Main query identifying unreachable exception handlers\nfrom ExceptStmt precedingHandler, ClassValue superTypeException, \n     ExceptStmt subsequentHandler, ClassValue subTypeException\n// Check if handler ordering creates unreachable exception block\nwhere hasUnreachableHandler(precedingHandler, superTypeException, subsequentHandler, subTypeException)\n// Generate result with unreachable block and warning message\nselect subsequentHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  subTypeException, subTypeException.getName(), precedingHandler, \"except block\", superTypeException, superTypeException.getName()",
    "output": "precedingIndex < subsequentIndex and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python类定义与源文件关联\n * @description 识别所有Python类定义，并建立类与其源定义文件之间的映射关系\n * @kind source-link\n * @id py/class-source-links\n * @metricType reftype\n */\n\nimport python\n\n// 定义Python类及其对应的源文件\nfrom Class pythonClass, File definingFile\n_______________ // 补全条件\nselect pythonClass, definingFile",
    "output": "where definingFile = pythonClass.getLocation().getFile()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/sql-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Building a SQL query from user-controlled sources is vulnerable to insertion of",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name SQL query built from user-controlled sources\n * @description Building a SQL query from user-controlled sources is vulnerable to insertion of\n *              malicious SQL code by the user.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 8.8\n * @precision high\n * @id py/sql-injection\n * @tags security\n *       external/cwe/cwe-089\n */\n\n// 导入Python库，用于处理Python代码的解析和分析\nimport python\n\n// 导入与SQL注入相关的数据流分析模块\nimport semmle.python.security.dataflow.SqlInjectionQuery\n\n// 导入路径图模块，用于表示数据流路径\nimport SqlInjectionFlow::PathGraph\n\n// 定义查询，查找从源节点到汇节点的数据流路径\nfrom SqlInjectionFlow::PathNode source, SqlInjectionFlow::PathNode sink\nwhere SqlInjectionFlow::flowPath(source, sink) // 条件：存在从源节点到汇节点的路径\nselect sink.getNode(), source, sink, \"This SQL query depends on a $@.\", source.getNode(),\n  \"user-provided value\" // 选择结果：汇节点、源节点、路径信息以及描述信息"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inconsistent-mro]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent method resolution order\n * @description Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n// 检测目标类是否存在无效的方法解析顺序（MRO）\n// 当继承列表中某个基类（rightBase）的左侧基类（leftBase）是其不当超类型时触发\npredicate hasInvalidMRO(ClassObject targetClass, ClassObject leftBase, ClassObject rightBase) {\n  // 验证目标类是新式类\n  targetClass.isNewStyle() and\n  // 查找继承列表中rightBase左侧的基类\n  exists(int position | \n    position > 0 and \n    targetClass.getBaseType(position) = rightBase and \n    leftBase = targetClass.getBaseType(position - 1)\n  ) and\n  // 验证左侧基类是右侧基类的不当超类型\n  leftBase = rightBase.getAnImproperSuperType()\n}\n\n// 查询所有存在无效MRO的类并生成诊断信息\nfrom ClassObject targetClass, ClassObject leftBase, ClassObject rightBase\nwhere hasInvalidMRO(targetClass, leftBase, rightBase)\nselect targetClass,\n  \"Construction of class \" + targetClass.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", leftBase,\n  leftBase.getName(), rightBase, rightBase.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies super() function calls within old-style Python classes, which do not support this mechanism.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description Identifies super() function calls within old-style Python classes, which do not support this mechanism.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n// This predicate identifies calls to the super() function within old-style classes.\n// In Python, old-style classes are defined as those that do not inherit from 'object'.\n// These classes lack support for the super() mechanism, which can result in runtime errors.\npredicate superCallInOldStyleClass(Call superInvocation) {\n  exists(Function containingFunction, ClassObject hostClass |\n    // Verify the call targets the built-in 'super' function\n    superInvocation.getFunc().(Name).getId() = \"super\" and\n    \n    // Ensure the super() call is located within a function or method\n    superInvocation.getScope() = containingFunction and\n    \n    // Confirm the enclosing function is a method belonging to a class\n    containingFunction.getScope() = hostClass.getPyClass() and\n    \n    // Verify that class analysis was completed successfully and the class is old-style\n    not hostClass.failedInference() and\n    not hostClass.isNewStyle()\n  )\n}\n\n// Primary query that detects all super() calls in old-style classes that will cause issues\nfrom Call invalidSuperCall\nwhere superCallInOldStyleClass(invalidSuperCall)\nselect invalidSuperCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-block-mode]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects symmetric encryption operations utilizing weak, deprecated, or unauthorized block cipher modes",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak block mode\n * @description Detects symmetric encryption operations utilizing weak, deprecated, or unauthorized block cipher modes\n * @id py/weak-block-mode\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Helper predicate to determine if a cryptographic artifact is located within the cryptography/hazmat module\npredicate isCryptographyHazmatPath(CryptographicArtifact cryptoArtifact) {\n  cryptoArtifact.asExpr()\n    .getLocation()\n    .getFile()\n    .getAbsolutePath()\n    .toString()\n    .matches(\"%cryptography/hazmat/%\")\n}\n\n// Helper predicate to evaluate block cipher modes for security vulnerabilities\npredicate analyzeWeakBlockModes(CryptographicArtifact cryptoArtifact, string alertMessage) {\n  cryptoArtifact instanceof BlockMode and\n  // ECB mode is only permitted within KeyWrapOperation contexts\n  (cryptoArtifact.(BlockMode).getBlockModeName() = \"ECB\" implies \n    not cryptoArtifact instanceof KeyWrapOperation) and\n  exists(string modeName | modeName = cryptoArtifact.(BlockMode).getBlockModeName() |\n    // Only CBC, CTS, and XTS modes are authorized for use\n    // Reference: Microsoft.Security.Cryptography.10002\n    not modeName = [\"CBC\", \"CTS\", \"XTS\"] and\n    if modeName = unknownAlgorithm()\n    then alertMessage = \"Use of unrecognized block mode algorithm.\"\n    else\n      if modeName in [\"GCM\", \"CCM\"]\n      then\n        alertMessage =\n          \"Use of block mode algorithm \" + modeName +\n            \" requires special crypto board approval/review.\"\n      else alertMessage = \"Use of unapproved block mode algorithm or API \" + modeName + \".\"\n  )\n}\n\n// Helper predicate to identify symmetric ciphers lacking explicit block mode specification\npredicate analyzeUnspecifiedBlockMode(CryptographicArtifact cryptoArtifact, string alertMessage) {\n  cryptoArtifact instanceof SymmetricCipher and\n  not cryptoArtifact.(SymmetricCipher).hasBlockMode() and\n  alertMessage = \"Cipher has unspecified block mode algorithm.\"\n}\n\n// Main query selecting cryptographic operations and corresponding security alert messages\nfrom CryptographicArtifact cryptoArtifact, string alertMessage\nwhere\n  // Exclude false positives originating from cryptography/hazmat paths\n  // (e.g., ECB usage within keywrap operations)\n  not isCryptographyHazmatPath(cryptoArtifact) and\n  (\n    // Evaluate block cipher modes for potential weaknesses\n    analyzeWeakBlockModes(cryptoArtifact, alertMessage)\n    or\n    // Detect ciphers without explicitly defined block modes\n    analyzeUnspecifiedBlockMode(cryptoArtifact, alertMessage)\n  )\nselect cryptoArtifact, alertMessage"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Comparison using is when operands support `__eq__`\n * @description Comparison using 'is' when equivalence is not the same as identity\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/comparison-using-is\n */\n\nimport python\n\n/** Holds if the comparison `comp` uses `is` or `is not` (represented as `op`) to compare its `left` and `right` arguments. */\npredicate comparison_using_is(Compare comp, ControlFlowNode left, Cmpop op, ControlFlowNode right) {\n  exists(CompareNode compareFlowNode | compareFlowNode = comp.getAFlowNode() |\n    compareFlowNode.operands(left, op, right) and\n    (op instanceof Is or op instanceof IsNot)\n  )\n}\n\n/**\n * @brief Determines if the expression `e` is a value that is interned in CPython.\n * @param e The expression to check.\n * @return True if the expression is an interned value in CPython, false otherwise.\n */\nprivate predicate cpython_interned_value(Expr e) {\n  // Check for empty or single-character ASCII string literals\n  exists(string text | text = e.(StringLiteral).getText() |\n    text.length() = 0\n    or\n    text.length() = 1 and text.regexpMatch(\"[U+0000-U+00ff]\")\n  )\n  // Check for integer literals in the range [-5, 256]\n  or\n  exists(int intValue | intValue = e.(IntegerLiteral).getN().toInt() | -5 <= intValue and intValue <= 256)\n  // Check for empty tuples\n  or\n  exists(Tuple tupleNode | tupleNode = e and not exists(tupleNode.getAnElt()))\n}\n\n/**\n * @brief Determines if the expression `e` is a literal that is not interned.\n * @param e The expression to check.\n * @return True if the expression is a non-interned literal, false otherwise.\n */\npredicate uninterned_literal(Expr e) {\n  (\n    e instanceof StringLiteral  // String literal\n    or\n    e instanceof IntegerLiteral  // Integer literal\n    or\n    e instanceof FloatLiteral  // Float literal\n    or\n    e instanceof Dict  // Dictionary literal\n    or\n    e instanceof List  // List literal\n    or\n    e instanceof Tuple  // Tuple literal\n  ) and\n  not cpython_interned_value(e)  // Not interned by CPython\n}\n\nfrom Compare comp, Cmpop op, string alt\nwhere\n  exists(ControlFlowNode leftOperand, ControlFlowNode rightOperand |\n    comparison_using_is(comp, leftOperand, op, rightOperand) and\n    (\n      op instanceof Is and alt = \"==\"  // 'is' operator detected\n      or\n      op instanceof IsNot and alt = \"!=\"  // 'is not' operator detected\n    ) and\n    (\n      uninterned_literal(leftOperand.getNode())  // Left operand is non-interned literal\n      or\n      uninterned_literal(rightOperand.getNode())  // Right operand is non-interned literal\n    )\n  )\nselect comp,\n_______________ // 补全条件\n    \"' when equivalence is not the same as identity. Use '\" + alt + \"' instead.\"",
    "output": "\"Values compared using '\" + op.getSymbol() +"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/return-or-yield-outside-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query detects instances where 'return', 'yield', or 'yield from' statements are erroneously placed outside of function definitions, leading to a 'SyntaxError' at runtime.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Improper usage of 'return' or 'yield' statements outside function scope\n * @description This query detects instances where 'return', 'yield', or 'yield from' statements are erroneously placed outside of function definitions, leading to a 'SyntaxError' at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/return-or-yield-outside-function\n */\n\nimport python\n\n// Identify all statement nodes that violate function scope rules and their types\nfrom AstNode stmtNode, string stmtType\nwhere \n  // Verify the statement is not within any function scope\n  not exists(Function funcDef | stmtNode.getScope() = funcDef.getScope()) and\n  (\n    // Detect return statements\n    stmtNode instanceof Return and stmtType = \"return\"\n    or\n    // Detect yield statements\n    stmtNode instanceof Yield and stmtType = \"yield\"\n    or\n    // Detect yield from statements\n    stmtNode instanceof YieldFrom and stmtType = \"yield from\"\n  )\n// Output results: violating statement nodes with corresponding error messages\nselect stmtNode, \"'\" + stmtType + \"' is used outside a function.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary delete statement in function\n * @description Using a 'delete' statement to delete a local variable is\n *              unnecessary, because the variable is deleted automatically when\n *              the function exits.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/unnecessary-delete\n */\n\nimport python\n\n/**\n * Determines whether the specified AST node is located within a loop structure.\n * Recursively checks if the node's parent is a While/For loop or if the node\n * is nested within another node that is inside a loop.\n */\npredicate isInsideLoop(AstNode node) {\n  // Base case: Direct parent is a loop structure\n  node.getParentNode() instanceof While\n  or\n  node.getParentNode() instanceof For\n  or\n  // Recursive case: Node is a child of a loop-enclosed node\n  exists(AstNode loopParent | \n    isInsideLoop(loopParent) and \n    node = loopParent.getAChildNode()\n  )\n}\n\n// Identify unnecessary delete statements within functions\nfrom Delete deleteStatement, Expr target, Function function\nwhere\n  // Position condition: Delete is the final statement in the function\n  function.getLastStatement() = deleteStatement\n  and\n  // Target condition: Delete operation targets a specific expression\n  target = deleteStatement.getATarget()\n  and\n  // Scope condition: Target expression is within function's scope\n  function.containsInScope(target)\n  and\n  // Exclusion condition 1: Target is not subscript access (e.g., list[0])\n  not target instanceof Subscript\n  and\n  // Exclusion condition 2: Target is not attribute access (e.g., obj.attr)\n  not target instanceof Attribute\n  and\n  // Loop condition: Delete statement is not inside any loop\n  not isInsideLoop(deleteStatement)\n  and\n_______________ // 补全条件\n  not exists(FunctionValue sysExcInfo |\n    sysExcInfo = Value::named(\"sys.exc_info\") and\n    sysExcInfo.getACall().getScope() = function\n  )\nselect deleteStatement, \"Unnecessary deletion of local variable $@ in function $@.\", target, target.toString(), function,\n  function.getName()",
    "output": "// Exception condition: No sys.exc_info() calls in function context"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python 模块传出耦合分析\n * @description 通过量化每个 Python 模块对外部模块的依赖数量，评估模块间的耦合程度和系统架构质量。\n * @kind 树状图\n * @id py/efferent-coupling-per-file\n * @treemap.warnOn 高值警告\n * @metricType 文件\n * @metricAggregate 平均值 最大值\n * @tags 可测试性\n *       模块化\n */\n\nimport python // 导入Python语言分析所需的基础库\n\n// 遍历所有Python模块，收集其度量指标数据\n// 这些数据将用于分析模块之间的依赖关系和耦合程度\nfrom ModuleMetrics modStats\n\n_______________ // 补全条件\n// 传出耦合度表示一个模块依赖的外部模块数量\n// 高耦合度值通常意味着模块独立性较差，可能影响系统的可维护性\nselect modStats, modStats.getEfferentCoupling() as couplingCount\n\n// 根据传出耦合度进行降序排序\n// 这样可以优先展示耦合度较高的模块，便于架构优化\norder by couplingCount desc",
    "output": "// 获取每个模块的传出耦合度指标"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 检测子类方法是否被超类属性遮蔽的情况\n */\n\n/* 定位在超类构造函数中定义的属性 */\nimport python\n\n// 定义谓词 isMethodOverriddenByBaseAttribute，用于判断子类方法是否被超类属性遮蔽\npredicate isMethodOverriddenByBaseAttribute(\n  ClassObject derivedClass, ClassObject baseClass, Assign attributeDef, FunctionObject overriddenMethod\n) {\n  // 确认继承关系：derivedClass 继承自 baseClass\n  derivedClass.getASuperType() = baseClass and\n  // 子类声明了 overriddenMethod 作为其属性\n  derivedClass.declaredAttribute(_) = overriddenMethod and\n  // 检查超类构造函数中是否存在同名属性赋值\n  exists(FunctionObject constructorMethod, Attribute targetAttribute |\n    // 超类定义了 __init__ 方法\n    baseClass.declaredAttribute(\"__init__\") = constructorMethod and\n    // 属性赋值的目标是 targetAttribute\n    targetAttribute = attributeDef.getATarget() and\n    // 属性赋值对象是 self\n    targetAttribute.getObject().(Name).getId() = \"self\" and\n    // 属性名称与子类方法名称相同\n    targetAttribute.getName() = overriddenMethod.getName() and\n    // 赋值操作发生在超类的构造函数中\n    attributeDef.getScope() = constructorMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  /*\n   * 排除超类中也定义了同名方法的情况\n   * 这种情况下，我们认为是有意为之的设计\n   */\n  // 确保超类没有定义同名属性\n  not baseClass.hasAttribute(overriddenMethod.getName())\n}\n\n// 从子类、超类、属性赋值和被遮蔽的方法中查询\nfrom ClassObject derivedClass, ClassObject baseClass, Assign attributeDef, FunctionObject overriddenMethod\n// 应用谓词进行筛选\nwhere isMethodOverriddenByBaseAttribute(derivedClass, baseClass, attributeDef, overriddenMethod)\n// 选择被遮蔽方法的位置、错误信息、属性赋值位置和属性类型\nselect overriddenMethod.getOrigin(),\n  \"Method \" + overriddenMethod.getName() + \" is shadowed by an $@ in super class '\" + baseClass.getName() +\n    \"'.\", attributeDef, \"attribute\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/efferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the number of distinct external classes that each class depends on.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class External Dependency Analysis\n * @description Calculates the number of distinct external classes that each class depends on.\n *              This metric helps identify highly coupled classes that may be harder to maintain and test.\n * @kind treemap\n * @id py/efferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags testability\n *       modularity\n */\n\nimport python\n\n// For each class in the codebase, determine how many external classes it references\nfrom ClassMetrics targetClass\nwhere exists(targetClass.getEfferentCoupling())\nselect targetClass, \n       targetClass.getEfferentCoupling() as outboundCoupling \norder by outboundCoupling desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-input]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies calls to the built-in 'input' function in Python 2, which poses a security risk by executing arbitrary code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unsafe 'input' function usage in Python 2\n * @description Identifies calls to the built-in 'input' function in Python 2, which poses a security risk by executing arbitrary code.\n * @kind problem\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/use-of-input\n */\n\nimport python  // Import the Python analysis library\nimport semmle.python.dataflow.new.DataFlow  // Import data flow analysis framework\nimport semmle.python.ApiGraphs  // Import API graph analysis tools\n\n// Identify potentially dangerous function calls in Python 2 code\nfrom DataFlow::CallCfgNode riskyInputCall\nwhere\n  // Restrict analysis to Python 2 environments\n  major_version() = 2 and\n  \n  // Detect invocations of the 'input' built-in function\n  riskyInputCall = API::builtin(\"input\").getACall() and\n  \n  // Filter out calls to the safer 'raw_input' alternative\n  riskyInputCall != API::builtin(\"raw_input\").getACall()\n  \nselect riskyInputCall, \"Use of the unsafe built-in 'input' function detected in Python 2 code.\"  // Report the security issue with descriptive message"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name An assert statement has a side-effect\n * @description Identifies assert statements that include expressions with side effects,\n *              leading to different behaviors between normal execution and optimized builds.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/side-effect-in-assert\n */\n\nimport python\n\n// Predicate to identify expressions containing function calls with known side effects\npredicate exprHasSideEffectFunction(Expr expr) {\n  // Check if the expression is an attribute or name reference to a side-effect function\n  exists(string functionName | \n    (functionName = expr.(Attribute).getName() or functionName = expr.(Name).getId()) and\n    functionName in [\n        \"print\", \"write\", \"append\", \"pop\", \"remove\", \"discard\", \"delete\", \"close\", \"open\", \"exit\"\n      ]\n  )\n_______________ // 补全条件\n\n// Predicate to determine if an expression may produce side effects\npredicate expressionMayHaveSideEffect(Expr expr) {\n  // Case 1: Yield expressions (excluding those in comprehensions)\n  (expr instanceof Yield and not exists(Comp c | c.contains(expr))) or\n  // Case 2: YieldFrom expressions\n  expr instanceof YieldFrom or\n  // Case 3: Function calls with side effects\n  (expr instanceof Call and \n    (exprHasSideEffectFunction(expr.(Call).getFunc()) or\n     // Case 4: Subprocess calls (merged into the function call case)\n     expr.getAFlowNode() = Value::named(\"subprocess.call\").getACall() or\n     expr.getAFlowNode() = Value::named(\"subprocess.check_call\").getACall() or\n     expr.getAFlowNode() = Value::named(\"subprocess.check_output\").getACall())\n  )\n}\n\n// Main query to find assert statements containing expressions with side effects\nfrom Assert assertion, Expr sideEffectExpr\nwhere expressionMayHaveSideEffect(sideEffectExpr) and assertion.contains(sideEffectExpr)\nselect assertion, \"This 'assert' statement contains a $@ which may produce side effects.\", sideEffectExpr, \"expression\"",
    "output": "}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/init-calls-subclass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calling a method from `__init__` that is overridden by a subclass may result in a partially",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__init__` method calls overridden method\n * @description Calling a method from `__init__` that is overridden by a subclass may result in a partially\n *              initialized instance being observed.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/init-calls-subclass\n */\n\nimport python\n\n// 查找基类__init__方法中调用被子类重写方法的情况\nfrom\n  ClassObject baseClass, string calledMethodName, Call initMethodCall, \n  FunctionObject overridingMethod, FunctionObject overriddenMethod\nwhere\n  // 条件1: 确保调用发生在基类的__init__方法中，且通过self属性访问\n  exists(FunctionObject initMethod, SelfAttribute selfAttr |\n    baseClass.declaredAttribute(\"__init__\") = initMethod and\n    initMethodCall.getScope() = initMethod.getFunction() and\n    initMethodCall.getFunc() = selfAttr and\n    selfAttr.getName() = calledMethodName\n  ) and\n  // 条件2: 获取基类中声明的方法定义\n  overriddenMethod = baseClass.declaredAttribute(calledMethodName) and\n  // 条件3: 确认子类方法重写了基类方法\n  overridingMethod.overrides(overriddenMethod)\n// 输出调用位置及警告信息\nselect initMethodCall, \"Call to self.$@ in __init__ method, which is overridden by $@.\", overriddenMethod, calledMethodName,\n  overridingMethod, overridingMethod.descriptiveString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-parameters-without-default-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the count of function parameters that lack default value assignments.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of parameters without defaults\n * @description Calculates the count of function parameters that lack default value assignments.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // 导入Python模块以进行代码静态分析\n\n// 定义查询：获取所有Python函数并计算其无默认值参数的数量\nfrom FunctionMetrics functionObj\n// 选择函数及其无默认值参数数量，并按数量降序排序\nselect functionObj, \n       functionObj.getNumberOfParametersWithoutDefault() as paramCountWithoutDefault \norder by paramCountWithoutDefault desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comment-density-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes the percentage of comment lines relative to the total lines in Python source files.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python source file comment density analysis\n * @description Computes the percentage of comment lines relative to the total lines in Python source files.\n *              Note that this analysis specifically focuses on regular comments and excludes docstrings,\n *              which are treated as a distinct documentation element.\n * @kind treemap\n * @id py/comment-density-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\nfrom Module pythonFile\nwhere pythonFile.getMetrics().getNumberOfLines() > 0\nselect pythonFile,\n       100.0 * pythonFile.getMetrics().getNumberOfLinesOfComments() / pythonFile.getMetrics().getNumberOfLines() as commentRatio\norder by commentRatio desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lack-of-cohesion-hitz-montazeri]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Evaluates the lack of cohesion within classes using Hitz and Montazeri's methodology.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class Cohesion Deficiency (HM Method)\n * @description Evaluates the lack of cohesion within classes using Hitz and Montazeri's methodology.\n * @kind treemap\n * @id py/lack-of-cohesion-hitz-montazeri\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n */\n\nimport python  // Import Python module for code analysis capabilities\n\n// Query to analyze class cohesion metrics\n// Results are sorted in descending order of cohesion deficiency\nfrom ClassMetrics clsMetric\n\n// Select class and its cohesion metric\nselect \n    clsMetric, \n    clsMetric.getLackOfCohesionHM() as cohesionMetric \n\n// Order by highest cohesion deficiency first\norder by \n    cohesionMetric desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type inference fails for 'object'\n * @description Type inference fails for 'object' which reduces recall for many queries.\n * @kind problem\n * @problem.severity info\n * @id py/type-inference-failure\n * @deprecated\n */\n\n// 导入Python库，用于处理Python代码的查询\nimport python\n\n// 从ControlFlowNode和Object类中选择数据\nfrom ControlFlowNode f, Object o\nwhere\n_______________ // 补全条件\n  f.refersTo(o) and\n  // 并且f没有通过其他方式引用o\n  not f.refersTo(o, _, _)\n// 选择对象o，并返回信息“Type inference fails for 'object'.”\nselect o, \"Type inference fails for 'object'.\"",
    "output": "// 过滤条件：f引用了o"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/local-shadows-builtin]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects local variables that share names with built-in objects.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Local Variable Shadowing Built-in Object\n * @description Detects local variables that share names with built-in objects.\n *              This shadowing makes the built-in object inaccessible within the current scope,\n *              potentially reducing code clarity and maintainability.\n * @kind problem\n * @tags maintainability\n *       readability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/local-shadows-builtin\n */\n\nimport python\nimport semmle.python.types.Builtins\n\n// Determines if a built-in object name is in the safe list, allowing it to be shadowed without issues\npredicate isSafeShadowingName(string builtinObjectName) {\n  builtinObjectName in [\n      /* Built-in names that are rarely used and unlikely to cause confusion when shadowed */\n      \"iter\", \"next\", \"input\", \"file\", \"apply\", \"slice\", \"buffer\", \"coerce\", \"intern\", \"exit\",\n      \"quit\", \"license\",\n      /* Common names that are difficult to avoid using due to their brevity or common usage */\n      \"dir\", \"id\", \"max\", \"min\", \"sum\", \"cmp\", \"chr\", \"ord\", \"bytes\", \"_\",\n    ]\n}\n\n// Checks if a name node represents a local variable that shadows a built-in object\npredicate localVarShadowsBuiltin(Name variableNameNode, string builtinObjectName, Function functionScope, int lineNumber) {\n  not isSafeShadowingName(builtinObjectName) and\n  exists(LocalVariable localVariable |\n    variableNameNode.defines(localVariable) and\n    localVariable.getId() = builtinObjectName and\n    exists(Builtin::builtin(localVariable.getId()))\n  ) and\n  variableNameNode.getScope() = functionScope and\n  variableNameNode.getLocation().getStartLine() = lineNumber\n}\n\n// Identifies the first occurrence of a variable shadowing a built-in within a given scope\npredicate isFirstShadowingOccurrence(Name variableNameNode, string builtinObjectName) {\n  exists(int firstOccurrenceLine, Function functionScope |\n    localVarShadowsBuiltin(variableNameNode, builtinObjectName, functionScope, firstOccurrenceLine) and\n    firstOccurrenceLine = min(int line | localVarShadowsBuiltin(_, builtinObjectName, functionScope, line))\n  )\n}\n\n// Main query: Detects all local variables that shadow built-in objects\nfrom Name variableNameNode, string builtinObjectName\nwhere isFirstShadowingOccurrence(variableNameNode, builtinObjectName)\nselect variableNameNode, \"Local variable '\" + builtinObjectName + \"' shadows a built-in object.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-url-substring-sanitization]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Defines a regex pattern capturing commonly used top-level domains\nprivate string getTopLevelDomainPattern() { \n  result = \"com|org|edu|gov|uk|net|io\" \n}\n\n// Determines if a string literal exhibits URL-like characteristics\npredicate showsUrlCharacteristics(StringLiteral urlStrLiteral) {\n  exists(string strContent | strContent = urlStrLiteral.getText() |\n    // Matches URLs that include common TLDs\n    strContent.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + getTopLevelDomainPattern() +\n        \")(:[0-9]+)?/?\")\n    or\n    // Matches HTTP/HTTPS URLs with any TLD\n    strContent.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Identifies expressions that perform inadequate URL sanitization\npredicate performsIncompleteUrlSanitization(Expr sanitizationOp, StringLiteral urlStrLiteral) {\n  showsUrlCharacteristics(urlStrLiteral) and\n  (\n    // Identifies comparison-based checks\n    sanitizationOp.(Compare).compares(urlStrLiteral, any(In i), _)\n    or\n    // Identifies risky prefix validations\n    isRiskyPrefixValidation(sanitizationOp, urlStrLiteral)\n    or\n    // Identifies risky suffix validations\n    isRiskySuffixValidation(sanitizationOp, urlStrLiteral)\n  )\n}\n\n// Detects potentially unsafe startswith operations on URL strings\npredicate isRiskyPrefixValidation(Call sanitizationOp, StringLiteral urlStrLiteral) {\n  sanitizationOp.getFunc().(Attribute).getName() = \"startswith\" and\n  sanitizationOp.getArg(0) = urlStrLiteral and\n  // Excludes URLs with properly formatted protocol prefixes\n  not urlStrLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n}\n\n// Detects potentially unsafe endswith operations on URL strings\npredicate isRiskySuffixValidation(Call sanitizationOp, StringLiteral urlStrLiteral) {\n  sanitizationOp.getFunc().(Attribute).getName() = \"endswith\" and\n  sanitizationOp.getArg(0) = urlStrLiteral and\n  // Excludes properly formatted domain endings\n  not urlStrLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n}\n\n// Main query: Locates expressions performing incomplete URL substring sanitization\nfrom Expr sanitizationOp, StringLiteral urlStrLiteral\nwhere performsIncompleteUrlSanitization(sanitizationOp, urlStrLiteral)\nselect sanitizationOp, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlStrLiteral,\n  urlStrLiteral.getText()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/catch-base-exception]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handling blocks that catch BaseException or all exceptions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Except block handles 'BaseException'\n * @description Identifies exception handling blocks that catch BaseException or all exceptions\n *              without re-raising them, potentially mis-handling system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n/**\n * Checks if an exception handler catches BaseException or all exceptions.\n * This predicate evaluates two possible scenarios:\n * 1. The handler explicitly captures BaseException through type specification\n * 2. The handler uses a bare except clause which implicitly catches all exceptions\n */\npredicate handlesBaseException(ExceptStmt exceptionBlock) {\n  // Scenario 1: Explicit BaseException capture\n  exceptionBlock.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  // Scenario 2: Bare except clause (catch-all)\n  not exists(exceptionBlock.getType())\n}\n\n/**\n * Verifies if an exception handler fails to re-raise the caught exception.\n * This is determined by checking if the control flow within the handler\n * can reach an exit point without encountering a re-raise operation.\n */\npredicate failsToReraise(ExceptStmt exceptionBlock) { \n  exceptionBlock.getAFlowNode().getBasicBlock().reachesExit() \n}\n\n// Main query: Identify problematic exception handlers\nfrom ExceptStmt exceptionBlock\nwhere\n  handlesBaseException(exceptionBlock) and  // Catches BaseException or all exceptions\n  failsToReraise(exceptionBlock)           // Lacks re-raise mechanism\nselect exceptionBlock, \"Except block directly handles BaseException.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unnecessary-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using a 'delete' statement to delete a local variable is",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unnecessary delete statement in function\n * @description Using a 'delete' statement to delete a local variable is\n *              unnecessary, because the variable is deleted automatically when\n *              the function exits.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/unnecessary-delete\n */\n\nimport python\n\n/**\n * Check if the given AST node is inside a loop (while or for).\n * Recursively checks the parent nodes until a loop is found or the root is reached.\n */\npredicate isInsideLoop(AstNode node) {\n  // Direct parent is a loop\n  node.getParentNode() instanceof While\n  or\n  node.getParentNode() instanceof For\n  or\n  // Nested inside another node within a loop\n  exists(AstNode loopParent | \n    isInsideLoop(loopParent) and \n    node = loopParent.getAChildNode()\n  )\n}\n\n// Identify unnecessary delete statements within functions\nfrom Delete deleteStmt, Expr targetExpr, Function func\nwhere\n  // Core conditions for unnecessary deletion\n  func.getLastStatement() = deleteStmt and\n  targetExpr = deleteStmt.getATarget() and\n  func.containsInScope(targetExpr) and\n  \n  // Exclude complex deletion targets (subscripts/attributes)\n  not (\n    targetExpr instanceof Subscript or\n    targetExpr instanceof Attribute\n  ) and\n  \n  // Exclude deletions within loops\n  not isInsideLoop(deleteStmt) and\n  \n  // Exclude functions calling sys.exc_info\n  not exists(FunctionValue excInfoCall |\n    excInfoCall = Value::named(\"sys.exc_info\") and\n    excInfoCall.getACall().getScope() = func\n  )\nselect deleteStmt, \"Unnecessary deletion of local variable $@ in function $@.\", targetExpr, targetExpr.toString(), func,\n  func.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of re-commits for each file\n_______________ // 补全条件\n * @kind treemap\n * @id py/historical-number-of-re-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max */\n\nimport python\nimport external.VCS\n\n/** Determines if two commits affect the same file within 5-day window */\npredicate commitsWithinRange(Commit baseCommit, Commit followCommit) {\n  baseCommit.getAnAffectedFile() = followCommit.getAnAffectedFile() and\n  baseCommit != followCommit and\n  exists(int dayDelta |\n    dayDelta = baseCommit.getDate().daysTo(followCommit.getDate()) and\n    dayDelta >= 0 and\n    dayDelta < 5\n  )\n}\n\n/** Calculates re-commit count for a given file */\nint getRecommitCount(File targetFile) {\n  result = count(Commit currentCommit |\n    targetFile = currentCommit.getAnAffectedFile() and\n    exists(Commit priorCommit | commitsWithinRange(priorCommit, currentCommit))\n  )\n}\n\nfrom Module analyzedModule\nwhere exists(analyzedModule.getMetrics().getNumberOfLinesOfCode())\nselect analyzedModule, getRecommitCount(analyzedModule.getFile())",
    "output": "* @description Counts commits to files modified within 5 days of previous changes"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 分析指向关系的深度分布特征：\n * - 边界计数：在最浅深度层级上出现的唯一指向关系数量\n * - 总出现次数：在特定深度层级上的所有指向关系总数\n * - 效率比率：边界计数占总出现次数的比例，表示该深度层级的效率\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 获取指定控制流节点、对象值和类对象的上下文深度\nint getContextDepth(ControlFlowNode node, Object obj, ClassObject clsObj) {\n  // 当存在一个指向上下文，使得节点在该上下文中指向对象并关联类对象时，返回该上下文的深度\n  exists(PointsToContext context |\n    PointsTo::points_to(node, context, obj, clsObj, _) and\n    result = context.getDepth()\n  )\n}\n\n// 获取指定控制流节点、对象值和类对象的最浅上下文深度\nint getMinimumContextDepth(ControlFlowNode node, Object obj, ClassObject clsObj) {\n  // 返回所有可能深度的最小值\n  result = min(int depth | depth = getContextDepth(node, obj, clsObj))\n}\n\n// 分析各深度层级的指向关系特征\nfrom int boundaryCount, int totalOccurrences, int currentDepth, float efficiencyRatio\nwhere\n  // 计算边界计数：最浅深度等于当前深度层级的唯一指向关系数量\n  boundaryCount = strictcount(ControlFlowNode node, Object obj, ClassObject clsObj |\n    currentDepth = getMinimumContextDepth(node, obj, clsObj)\n  ) and\n  // 计算总出现次数：深度等于当前深度层级的所有指向关系数量\n_______________ // 补全条件\n                          PointsToContext context, ControlFlowNode origin |\n    PointsTo::points_to(node, context, obj, clsObj, origin) and\n    currentDepth = context.getDepth()\n  ) and\n  // 计算效率比率：边界计数占总出现次数的百分比\n  totalOccurrences > 0 and  // 避免除以零\n  efficiencyRatio = 100.0 * boundaryCount / totalOccurrences\n// 输出深度层级、边界计数、总出现次数和效率比率\nselect currentDepth, boundaryCount, totalOccurrences, efficiencyRatio",
    "output": "totalOccurrences = strictcount(ControlFlowNode node, Object obj, ClassObject clsObj,"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Identifies cryptographic implementations that generate asymmetric keys",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak key generation key size (< 2048 bits)\n * @description\n * Identifies cryptographic implementations that generate asymmetric keys\n * with insufficient bit length, which may be vulnerable to brute-force attacks.\n * Keys smaller than 2048 bits are considered weak for most asymmetric algorithms.\n * @id py/weak-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify asymmetric key generation operations with weak key sizes\nfrom AsymmetricKeyGen keyGeneration, DataFlow::Node keySizeSource, int keySizeBits, string algorithmName\nwhere\n  // Extract key size from configuration source\n  keySizeBits = keyGeneration.getKeySizeInBits(keySizeSource) and\n  // Retrieve algorithm identification\n  algorithmName = keyGeneration.getAlgorithm().getName() and\n  // Validate key strength against security threshold\n  keySizeBits < 2048 and\n  // Exclude elliptic curve algorithms (use different security models)\n  not isEllipticCurveAlgorithm(algorithmName, _)\n// Report findings with contextual information\nselect keyGeneration,\n  \"Weak asymmetric key size (\" + keySizeBits.toString() + \" bits) for algorithm \" +\n    algorithmName + \" configured at $@\", keySizeSource, keySizeSource.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-small-key-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Key Derivation Functions (KDF) that generate keys",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insufficient KDF Derived Key Length\n * @description Identifies Key Derivation Functions (KDF) that generate keys \n *              shorter than 128 bits (16 bytes), which is cryptographically weak.\n * @assumption When key length is unspecified (None/missing), it defaults to the \n *             underlying hash function's output length. Standard hash functions \n *             (SHA256/384/512) are considered to provide adequate length.\n * @kind problem\n * @id py/kdf-small-key-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\n// Detect cryptographic key derivation operations with inadequate key lengths\nfrom KeyDerivationOperation kdfOperation, string alertMessage, DataFlow::Node keySizeSource\nwhere\n  // Obtain the source of the key size parameter configuration\n  keySizeSource = kdfOperation.getDerivedKeySizeSrc() and\n  \n  // Exclude operations that rely on default hash length (None values)\n  not keySizeSource.asExpr() instanceof None and\n  (\n    // Case 1: Key length is explicitly set to an insufficient value\n    exists(int derivedKeyLength |\n      derivedKeyLength = keySizeSource.asExpr().(IntegerLiteral).getValue() and\n      derivedKeyLength < 16 and\n      alertMessage = \"Insufficient derived key length. \"\n    )\n    or\n    // Case 2: Key length cannot be determined through static analysis\n    not exists(keySizeSource.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Derived key size is not statically verifiable. \"\n  )\nselect kdfOperation, alertMessage + \"Keys must be at least 16 bytes (128 bits). Configured key size: $@\",\n  keySizeSource.asExpr(), keySizeSource.asExpr().toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 类实例化参数数量不匹配\n * @description 识别 Python 类实例化过程中传递给 `__init__` 方法的参数数量与定义不符的情况。\n *              当创建类实例时提供的参数个数与构造函数签名不匹配时，\n *              将在运行时引发 TypeError 异常。本查询捕获两种典型场景：\n *              1. 实际参数数量超过构造函数期望的参数数量\n *              2. 实际参数数量少于构造函数期望的参数数量\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstanceCall, ClassValue targetClass, \n     string errorMessage, string errorPrefix, \n     int expectedArgCount, FunctionValue classInitializer\nwhere\n  // 获取目标类的初始化方法（即构造函数）\n  classInitializer = get_function_or_initializer(targetClass) and\n  \n  // 检查参数数量不匹配的两种情况\n  (\n    // 情况1：参数数量过多\n    too_many_args(classInstanceCall, targetClass, expectedArgCount) and\n_______________ // 补全条件\n    errorPrefix = \"no more than \"\n  )\n  or\n  (\n    // 情况2：参数数量过少\n    too_few_args(classInstanceCall, targetClass, expectedArgCount) and\n    errorMessage = \"too few arguments\" and\n    errorPrefix = \"no fewer than \"\n  )\nselect classInstanceCall, \n       \"Call to $@ with \" + errorMessage + \"; should be \" + errorPrefix + expectedArgCount.toString() + \".\", \n       classInitializer,\n       // 输出调用点、错误描述及初始化方法的完全限定名\n       classInitializer.getQualifiedName()",
    "output": "errorMessage = \"too many arguments\" and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Functions with names starting with uppercase letters reduce code readability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed function\n * @description Functions with names starting with uppercase letters reduce code readability.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python  // Import Python library for analyzing Python source code\n\n// Predicate to check if a function name starts with an uppercase letter\npredicate isMisnamedFunction(Function targetFunction) {\n  exists(string firstLetter |\n    firstLetter = targetFunction.getName().prefix(1) and  // Extract the first character of the function name\n    not firstLetter = firstLetter.toLowerCase()  // Verify that the character is not lowercase\n  )\n}\n\n// Select all functions that meet our criteria\nfrom Function targetFunction\nwhere\n  targetFunction.inSource() and  // Ensure the function is defined in source code\n  isMisnamedFunction(targetFunction) and  // Check if the function name starts with uppercase\n  not exists(Function duplicateFunction |\n    duplicateFunction != targetFunction and  // Exclude other functions with the same name\n    duplicateFunction.getLocation().getFile() = targetFunction.getLocation().getFile() and  // In the same file\n    isMisnamedFunction(duplicateFunction)  // And also starts with uppercase\n  )\nselect targetFunction, \"Function names should start in lowercase.\"  // Report the function with a recommendation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Except block handles 'BaseException'\n * @description Identifies exception handling blocks that catch BaseException or all exceptions\n *              without re-raising them, potentially mis-handling system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n_______________ // 补全条件\n// Main query: Find exception blocks that catch BaseException or all exceptions\n// and do not re-raise them\nfrom ExceptStmt handler\nwhere\n  // Check if handler catches BaseException or all exceptions\n  (handler.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n   or\n   not exists(handler.getType()))\n  and\n  // Verify handler lacks re-raise by checking if its basic block reaches exit\n  handler.getAFlowNode().getBasicBlock().reachesExit()\nselect handler, \"Except block directly handles BaseException.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Improper LDAP Authentication\n * @description Detects LDAP bind operations that are performed without proper authentication credentials,\n *              which could lead to unauthorized access to directory services.\n * @kind problem\n * @problem.severity warning\n * @id py/improper-ldap-auth\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\n\n/**\n * Holds if the specified LDAP bind operation uses insecure authentication.\n * This occurs when:\n *   - No password parameter is provided\n *   - Password is explicitly set to None\n *   - Password is an empty string\n */\npredicate hasInsecureAuth(LdapBind bindOp) {\n  // Case 1: Missing password parameter\n  not exists(bindOp.getPassword())\n  or\n  // Case 2: Password is None (no authentication)\n  exists(None noneVal |\n    DataFlow::localFlow(DataFlow::exprNode(noneVal), bindOp.getPassword())\n  )\n  or\n  // Case 3: Password is empty string (equivalent to no password)\n  exists(StringLiteral emptyStr |\n    emptyStr.getText() = \"\" and\n    DataFlow::localFlow(DataFlow::exprNode(emptyStr), bindOp.getPassword())\n  )\n}\n_______________ // 补全条件\nfrom LdapBind ldapOperation\nwhere hasInsecureAuth(ldapOperation)\nselect ldapOperation, \"The following LDAP bind operation is executed without authentication.\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects and evaluates alert suppression mechanisms in Python source code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Detects and evaluates alert suppression mechanisms in Python source code.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing utilities\nprivate import semmle.python.Comment as PythonComment\n\n/**\n * Represents a single-line Python comment with location tracking capabilities.\n * Provides methods to retrieve location information and comment text.\n */\nclass SingleLineComment instanceof PythonComment::Comment {\n  /**\n   * Retrieves location information for the comment.\n   * @param sourceFile - Path to the source file containing the comment\n   * @param beginLine - Starting line number of the comment\n   * @param beginColumn - Starting column number of the comment\n   * @param concludeLine - Ending line number of the comment\n   * @param concludeColumn - Ending column number of the comment\n   */\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginColumn, int concludeLine, int concludeColumn\n  ) {\n    // Delegate location retrieval to parent class implementation\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginColumn, concludeLine, concludeColumn)\n  }\n\n  /**\n   * Retrieves the textual content of the comment.\n   * @returns The raw text content of the comment\n   */\n  string getText() { result = super.getContents() }\n\n  /**\n   * Provides a string representation of the comment.\n   * @returns String representation of the comment\n   */\n  string toString() { result = super.toString() }\n}\n\n/**\n * Represents a Python AST node with location tracking capabilities.\n * Provides methods to retrieve location information for AST nodes.\n */\nclass AstNode instanceof PythonComment::AstNode {\n  /**\n   * Retrieves location information for the AST node.\n   * @param sourceFile - Path to the source file containing the node\n   * @param beginLine - Starting line number of the node\n   * @param beginColumn - Starting column number of the node\n   * @param concludeLine - Ending line number of the node\n   * @param concludeColumn - Ending column number of the node\n   */\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginColumn, int concludeLine, int concludeColumn\n  ) {\n    // Delegate location retrieval to parent class implementation\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginColumn, concludeLine, concludeColumn)\n  }\n\n  /**\n   * Provides a string representation of the AST node.\n   * @returns String representation of the AST node\n   */\n  string toString() { result = super.toString() }\n}\n\n// Establish suppression relationships between AST nodes and comments\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A suppression comment using the 'noqa' directive. This directive is recognized\n * by both pylint and pyflakes linters, and should be respected by LGTM alerts.\n */\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  /**\n   * Initializes a NoqaSuppressionComment by identifying the noqa pattern.\n   * Matches case-insensitive 'noqa' with optional suffix.\n   */\n  NoqaSuppressionComment() {\n    // Identify comments containing the noqa directive\n    super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  /**\n   * Retrieves the annotation identifier for this suppression.\n   * @returns The string \"lgtm\" as the annotation identifier\n   */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /**\n   * Defines the code range affected by this suppression.\n   * @param sourceFile - Path to the source file\n   * @param beginLine - Starting line of the affected range\n   * @param beginColumn - Starting column of the affected range\n   * @param concludeLine - Ending line of the affected range\n   * @param concludeColumn - Ending column of the affected range\n   */\n  override predicate covers(\n    string sourceFile, int beginLine, int beginColumn, int concludeLine, int concludeColumn\n  ) {\n    // Extract comment location and verify it starts at column 1\n    this.hasLocationInfo(sourceFile, beginLine, _, concludeLine, concludeColumn) and\n    beginColumn = 1\n  }\n}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-padding]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Identifies asymmetric encryption padding schemes that are either cryptographically",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Identifies asymmetric encryption padding schemes that are either cryptographically\n * weak or not recognized as secure by established security standards. The query\n * exclusively permits robust padding methods (OAEP, KEM, PSS) and flags all others\n * as potential security vulnerabilities.\n * \n * Focuses on padding implementations vulnerable to cryptographic attacks in\n * asymmetric encryption contexts.\n * \n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricPadding insecurePadding, string paddingName\nwhere\n  // Extract the padding algorithm identifier from the implementation\n  paddingName = insecurePadding.getPaddingName()\n  // Identify padding schemes that are not in the approved secure list\n  and not paddingName = [\"OAEP\", \"KEM\", \"PSS\"]\nselect insecurePadding, \"Detected unapproved, weak, or unknown asymmetric padding algorithm: \" + paddingName"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/print-during-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects print statements at module scope that are not guarded by `if __name__ == '__main__'`.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of a print statement at module level\n * @description Detects print statements at module scope that are not guarded by `if __name__ == '__main__'`.\n *              Such statements will produce output when the module is imported, which is often unintended.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/print-during-import\n */\n\nimport python\n\n// Predicate to identify if statements checking if __name__ == '__main__'\npredicate isMainNameCheck(If ifNode) {\n  exists(Name nameNode, StringLiteral mainLiteral, Compare comparisonNode |\n    ifNode.getTest() = comparisonNode and // Get the condition of the if statement\n    comparisonNode.getLeft() = nameNode and // Left operand is __name__\n    comparisonNode.getAComparator() = mainLiteral and // Right operand is \"__main__\"\n    nameNode.getId() = \"__name__\" and // Confirm left operand is __name__\n    mainLiteral.getText() = \"__main__\" // Confirm right operand is \"__main__\"\n  )\n}\n\n// Predicate to identify print statements (both Python 2 print statements and Python 3 print function calls)\npredicate isPrintStatement(Stmt statement) {\n  statement instanceof Print // Python 2 print statement\n  or\n  exists(ExprStmt exprStatement, Call callNode, Name funcNameNode |\n    exprStatement = statement and // Statement is an expression statement\n    callNode = exprStatement.getValue() and // Get the call part of the expression\n    funcNameNode = callNode.getFunc() and // Get the function name being called\n    funcNameNode.getId() = \"print\" // Confirm function name is print\n  )\n}\n\n// Find print statements that execute during import\nfrom Stmt printStatement\nwhere\n  // Verify it's a print statement\n  isPrintStatement(printStatement)\n  and\n  // Check if the statement is in a module used as an imported module\n  // TODO: Need to discuss how we would like to handle ModuleObject.getKind in the glorious future\n  exists(ModuleValue moduleValue | \n    moduleValue.getScope() = printStatement.getScope() and \n    moduleValue.isUsedAsModule()\n  )\n  and\n  // Ensure the print statement is not inside an if __name__ == '__main__' block\n  not exists(If ifNode | \n    isMainNameCheck(ifNode) and \n    ifNode.getASubStatement().getASubStatement*() = printStatement\n  )\nselect printStatement, \"Print statement may execute during import.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects data flow paths where untrusted user inputs are propagated",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted Data Propagation to Cookie Construction\n * @description Detects data flow paths where untrusted user inputs are propagated\n *              into cookie value assignments, potentially enabling injection\n *              attacks that compromise cookie integrity.\n * @id py/untrusted-cookie-injection\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 8.7\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\nfrom \n  CookieInjectionFlow::PathNode untrustedSourceNode, \n  CookieInjectionFlow::PathNode cookieSinkNode\nwhere \n  CookieInjectionFlow::flowPath(untrustedSourceNode, cookieSinkNode)\nselect \n  cookieSinkNode.getNode(), \n  untrustedSourceNode, \n  cookieSinkNode, \n  \"Cookie value constructed from $@.\", \n  untrustedSourceNode.getNode(), \n  \"untrusted user input\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Framework-mode endpoint catalog for model editor\n * @description Identifies accessible endpoints (methods and attributes) available in the model editor's framework mode. \n *              Excludes test and generated code artifacts from results.\n * @kind table\n * @id py/utils/modeleditor/framework-mode-endpoints\n * @tags modeleditor endpoints framework-mode\n */\n_______________ // 补全条件\n// Import ModelEditor capabilities for endpoint analysis\nimport modeling.ModelEditor\n\n// Obtain framework-mode endpoint metadata\nfrom Endpoint frameworkEndpoint\nselect \n  // Endpoint identification and classification\n  frameworkEndpoint,\n  frameworkEndpoint.getKind(),\n  frameworkEndpoint.getFunctionName(),\n  \n  // Endpoint structural context\n  frameworkEndpoint.getClass(),\n  frameworkEndpoint.getNamespace(),\n  \n  // Endpoint functional specifications\n  frameworkEndpoint.getParameters(),\n  frameworkEndpoint.getSupportedType(),\n  frameworkEndpoint.getSupportedStatus(),\n  \n  // Source code location\n  frameworkEndpoint.getFileName()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Small KDF derived key length.\n_______________ // 补全条件\n * @assumption If the key length is not explicitly provided (e.g., it is None or otherwise not specified) assumes the length is derived from the hash length.\n * @kind problem\n * @id py/kdf-small-key-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\n// Identify Key Derivation Function operations with insufficient key sizes\nfrom KeyDerivationOperation kdfOp, string diagnosticMsg, DataFlow::Node keySizeSource\nwhere\n  // Retrieve the source of derived key size configuration\n  keySizeSource = kdfOp.getDerivedKeySizeSrc() and\n  // Exclude cases where key size is explicitly set to None (handled by hash-length assumption)\n  not keySizeSource.asExpr() instanceof None and\n  (\n    // Case 1: Explicit integer literal value below 16 bytes\n    keySizeSource.asExpr() instanceof IntegerLiteral and\n    keySizeSource.asExpr().(IntegerLiteral).getValue() < 16 and\n    diagnosticMsg = \"Derived key size is too small. \"\n    or\n    // Case 2: Non-integer key size (cannot statically verify minimum length)\n    not keySizeSource.asExpr() instanceof IntegerLiteral and\n    diagnosticMsg = \"Derived key size is not a statically verifiable size. \"\n  )\nselect kdfOp, diagnosticMsg + \"Derived key size must be a minimum of 16 (bytes). Derived Key Size Config: $@\",\n  keySizeSource.asExpr(), keySizeSource.asExpr().toString()",
    "output": "* @description KDF derived keys should be a minimum of 128 bits (16 bytes)."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Summarized callable call sites\n * @description Identifies call sites associated with summarized callables\n * @kind problem\n_______________ // 补全条件\n * @id py/meta/summarized-callable-call-sites\n * @tags meta\n * @precision very-low\n */\n\n// Import Python language core library\nimport python\n// Import data flow analysis modules\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\n// Import meta metrics analysis module\nimport meta.MetaMetrics\n\n// Define analysis variables: invocation point, target callable, and call type\nfrom DataFlow::Node invocationPoint, SummarizedCallable targetCallable, string callType\nwhere\n  // Direct invocation scenario: invocation point matches callable's call site\n  (invocationPoint = targetCallable.getACall() and callType = \"Call\")\n  or\n  // Callback invocation scenario: invocation point matches callable's callback site\n  (invocationPoint = targetCallable.getACallback() and callType = \"Callback\")\n  and\n  // Exclude invocation points located in ignored files\n  not invocationPoint.getLocation().getFile() instanceof IgnoredFile\n// Output invocation point with formatted call type and target callable information\nselect invocationPoint, callType + \" to \" + targetCallable",
    "output": "* @problem.severity recommendation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-exception in 'except' clause\n * @description Identifies exception handlers that specify non-exception types,\n *              which are ineffective at runtime as they never match actual exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Core variables for exception handler analysis\nfrom ExceptFlowNode handlerNode, Value caughtType, ClassValue exceptionClass, \n     ControlFlowNode sourceNode, string typeDesc\nwhere\n_______________ // 补全条件\n  handlerNode.handledException(caughtType, exceptionClass, sourceNode) and\n  (\n    // Check for non-exception class type\n    exists(ClassValue invalidType | \n      invalidType = caughtType and\n      not invalidType.isLegalExceptionType() and\n      not invalidType.failedInference(_) and\n      typeDesc = \"class '\" + invalidType.getName() + \"'\"\n    )\n    or\n    // Handle non-class value cases\n    not caughtType instanceof ClassValue and\n    typeDesc = \"instance of '\" + exceptionClass.getName() + \"'\"\n  )\nselect handlerNode.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  sourceNode, typeDesc",
    "output": "// Establish relationship between handler and exception source"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/encoding-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies potential encoding issues in Python code that may cause runtime exceptions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Encoding error detection\n * @description Identifies potential encoding issues in Python code that may cause runtime exceptions\n *              or interfere with static analysis. This query targets cases where improper encoding\n *              handling could lead to data corruption or execution failures.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/encoding-error\n */\n\nimport python\n\n// Identify all encoding-related issues in the codebase\n// Each issue represents a location where encoding errors might occur\nfrom EncodingError encodingIssue\nselect encodingIssue, encodingIssue.getMessage()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Timing attack against Hash\n * @description 在验证消息哈希值时，必须采用恒定时间算法。\n *              若不使用恒定时间算法，攻击者可能利用执行时间差异\n *              来伪造有效的哈希值，从而绕过身份验证机制。\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/timing-attack-against-hash\n * @tags security\n *       external/cwe/cwe-208\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * 哈希时序攻击安全分析配置\n * 设定数据流分析的起点（加密操作）和终点（非恒定时间比较）\n */\nprivate module HashTimingSecurityConfig implements DataFlow::ConfigSig {\n  /**\n   * 起点定义：加密操作生成的数据节点\n   * 涵盖哈希函数调用等可能生成加密值的操作\n   */\n  predicate isSource(DataFlow::Node cryptoSource) { \n    cryptoSource instanceof ProduceCryptoCall \n  }\n\n  /**\n   * 终点定义：非恒定时间比较操作节点\n_______________ // 补全条件\n   */\n  predicate isSink(DataFlow::Node timingVulnerableSink) { \n    timingVulnerableSink instanceof NonConstantTimeComparisonSink \n  }\n}\n\n/**\n * 全局污点传播跟踪模块\n * 监控从加密操作到非恒定时间比较的数据流传播路径\n */\nmodule HashTimingVulnerabilityFlow = TaintTracking::Global<HashTimingSecurityConfig>;\n\n// 导入路径图用于路径分析\nimport HashTimingVulnerabilityFlow::PathGraph\n\n/**\n * 核心查询：识别哈希验证中的时序攻击风险路径\n * 检测从加密操作到非恒定时间比较的数据流，\n * 且该比较操作涉及用户可控制的输入\n */\nfrom HashTimingVulnerabilityFlow::PathNode cryptoOriginPath, HashTimingVulnerabilityFlow::PathNode vulnerableComparisonPath\nwhere\n  // 要求1：存在从加密操作到比较操作的数据流路径\n  HashTimingVulnerabilityFlow::flowPath(cryptoOriginPath, vulnerableComparisonPath) and\n  // 要求2：比较操作包含用户输入，增加攻击可能性\n  vulnerableComparisonPath.getNode().(NonConstantTimeComparisonSink).includesUserInput()\nselect \n  // 输出格式：终点节点、起点节点、路径节点、描述信息、消息类型\n  vulnerableComparisonPath.getNode(), \n  cryptoOriginPath, \n  vulnerableComparisonPath, \n  \"Timing attack against $@ validation.\",\n  cryptoOriginPath.getNode().(ProduceCryptoCall).getResultType(), \n  \"message\"",
    "output": "* 这些操作可能因执行时间差异而泄露敏感信息"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Potentially unsafe 'input' function usage in Python 2\n * @description Detects usage of the built-in 'input' function in Python 2 code.\n *              In Python 2, 'input()' evaluates user input as Python code, creating a code injection vulnerability.\n *              Unlike the safe 'raw_input()' which returns a string, 'input()' can execute arbitrary code.\n * @kind problem\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/use-of-input\n */\n\nimport python  // Import the Python library for analyzing Python code\nimport semmle.python.dataflow.new.DataFlow  // Import data flow analysis library\nimport semmle.python.ApiGraphs  // Import API graph analysis library\n\n// Select call configuration nodes representing function calls\nfrom DataFlow::CallCfgNode dangerousInputUsage\nwhere\n  // Restrict analysis to Python 2 code\n  major_version() = 2\n  and\n  // Identify calls to the unsafe 'input' function\n_______________ // 补全条件\n  and\n  // Exclude calls to the safe 'raw_input' function\n  dangerousInputUsage != API::builtin(\"raw_input\").getACall()\nselect dangerousInputUsage, \"The unsafe built-in function 'input' is used in Python 2, which can lead to code injection.\"",
    "output": "dangerousInputUsage = API::builtin(\"input\").getACall()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-parameters-without-default-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python functions by counting parameters that lack default values, which can signal increased complexity.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of parameters without defaults\n * @description Identifies Python functions by counting parameters that lack default values, which can signal increased complexity.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // 导入Python分析模块，提供对Python源代码的静态分析能力\n\n// 此查询用于识别Python函数中需要显式传入的参数数量\n// 较多的无默认值参数通常意味着函数复杂度较高，可能影响可测试性\nfrom FunctionMetrics targetFunction\n// 计算每个函数中未设置默认值的参数数量（即调用时必须提供的参数）\nselect targetFunction, \n       targetFunction.getNumberOfParametersWithoutDefault() as requiredParamCount \n// 按必需参数数量降序排列，以便优先识别可能复杂度过高的函数\norder by requiredParamCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'super' in old style class\n * @description Detects incorrect usage of super() in legacy class definitions that lack proper inheritance support.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * Locates super() function calls within methods of old-style classes.\n * \n * This predicate identifies super() invocations that will cause runtime errors\n * since old-style classes lack proper inheritance mechanisms required by super().\n */\npredicate superCallInOldClass(Call superCall) {\n  // Ensure the call targets the built-in super function\n  superCall.getFunc().(Name).getId() = \"super\" and\n  // Validate the call context is within a method of an old-style class\n  exists(Function methodDef |\n    // The super call must be inside a method\n    superCall.getScope() = methodDef and\n    // The method must be inside an old-style class\n    exists(ClassObject parentClass |\n      methodDef.getScope() = parentClass.getPyClass() and\n      // Verify the class type was properly determined\n      not parentClass.failedInference() and\n      // Confirm the class follows old-style conventions (not inheriting from object)\n      not parentClass.isNewStyle()\n    )\n  )\n}\n\n// Main query to identify problematic super() calls in old-style classes\nfrom Call problematicSuperCall\n// Apply filter to find super() calls specifically within old-style classes\nwhere superCallInOldClass(problematicSuperCall)\n_______________ // 补全条件\nselect problematicSuperCall, \"'super()' will not work in old-style classes.\"",
    "output": "// Generate alert with descriptive message"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/improper-ldap-auth]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects LDAP bind operations lacking proper authentication credentials",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Improper LDAP Authentication\n * @description Detects LDAP bind operations lacking proper authentication credentials\n * @kind problem\n * @problem.severity warning\n * @id py/improper-ldap-auth\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\n// Import necessary modules for LDAP analysis and data flow tracking\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\n\n/**\n * Identifies LDAP bind operations with authentication weaknesses by checking:\n * 1. Absence of password parameter\n * 2. Password derived from None literal\n * 3. Password using empty string literal\n */\npredicate hasInsecureAuth(LdapBind ldapBind) {\n  // Case 1: Missing password parameter\n  not exists(ldapBind.getPassword())\n  or\n  // Case 2: Password parameter is None\n  exists(None noneNode |\n    DataFlow::localFlow(DataFlow::exprNode(noneNode), ldapBind.getPassword())\n  )\n  or\n  // Case 3: Password parameter is empty string\n  exists(StringLiteral emptyStrNode |\n    emptyStrNode.getText() = \"\" and\n    DataFlow::localFlow(DataFlow::exprNode(emptyStrNode), ldapBind.getPassword())\n  )\n}\n\n// Identify all LDAP bind operations with insecure authentication patterns\nfrom LdapBind ldapBind\nwhere hasInsecureAuth(ldapBind)\nselect ldapBind, \"The following LDAP bind operation is executed without authentication.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak cryptographic key usage\n * @description Identifies cryptographic keys with inadequate bit length that are susceptible to brute-force attacks.\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/weak-crypto-key\n * @tags security\n *       external/cwe/cwe-326\n */\n\nimport python\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.filters.Tests\n\nfrom Cryptography::PublicKey::KeyGeneration cryptoKeyGeneration, int actualKeyLength, DataFlow::Node keyLengthSource\nwhere\n  // Extract key bit length from generation context and source node\n_______________ // 补全条件\n  and\n  // Validate key length against minimum security requirements\n  actualKeyLength < cryptoKeyGeneration.minimumSecureKeySize()\n  and\n  // Exclude test code from security analysis scope\n  not keyLengthSource.getScope().getScope*() instanceof TestScope\nselect cryptoKeyGeneration,\n  \"Creation of $@ key uses \" + actualKeyLength.toString() + \" bits, which is below \" +\n    cryptoKeyGeneration.minimumSecureKeySize() + \" and considered breakable.\", \n  keyLengthSource, cryptoKeyGeneration.getName()",
    "output": "actualKeyLength = cryptoKeyGeneration.getKeySizeWithOrigin(keyLengthSource)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak key generation key size (< 2048 bits)\n * @description\n_______________ // 补全条件\n * insufficient key sizes (below 2048 bits), which are vulnerable to brute-force attacks.\n * @id py/weak-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify asymmetric key generation operations with weak cryptographic parameters\nfrom AsymmetricKeyGen keyGeneration, DataFlow::Node keyConfigNode, int keySizeBits, string algorithmName\nwhere\n  // Extract cryptographic configuration details\n  keySizeBits = keyGeneration.getKeySizeInBits(keyConfigNode) and\n  algorithmName = keyGeneration.getAlgorithm().getName() and\n  // Apply security constraints: validate key strength and exclude elliptic curve algorithms\n  keySizeBits < 2048 and\n  not isEllipticCurveAlgorithm(algorithmName, _)\n// Report findings with contextual information about the vulnerable configuration\nselect keyGeneration,\n  \"Weak asymmetric key size (\" + keySizeBits.toString() + \" bits) for algorithm \" +\n    algorithmName + \" configured at $@\", keyConfigNode, keyConfigNode.toString()",
    "output": "* Detects asymmetric cryptographic key generation operations using"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unguarded next in generator\n * @description Detects unguarded next() calls in generators that may cause unintended iteration termination.\n * @kind problem\n * @tags maintainability\n *       portability\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unguarded-next-in-generator\n */\n\nimport python\nprivate import semmle.python.ApiGraphs\n\n// API nodes for built-in functions and exceptions\nAPI::Node builtinIterFunction() { result = API::builtin(\"iter\") }\nAPI::Node builtinNextFunction() { result = API::builtin(\"next\") }\nAPI::Node builtinStopIterationException() { result = API::builtin(\"StopIteration\") }\n\n// Identifies iter() calls with specified sequence argument\npredicate iterCallWithSequence(CallNode iterCallNode, EssaVariable sequenceVar) {\n  iterCallNode = builtinIterFunction().getACall().asCfgNode() and\n  iterCallNode.getArg(0) = sequenceVar.getAUse()\n}\n\n// Identifies next() calls with specified iterator argument\npredicate nextCallWithIterator(CallNode nextCallNode, ControlFlowNode iteratorNode) {\n  nextCallNode = builtinNextFunction().getACall().asCfgNode() and\n  nextCallNode.getArg(0) = iteratorNode\n}\n\n// Checks if next() call provides a default value\npredicate nextCallHasDefault(CallNode nextCallNode) {\n  exists(nextCallNode.getArg(1)) or exists(nextCallNode.getArgByName(\"default\"))\n}\n\n// Checks if sequence is guarded and non-empty\npredicate isSequenceGuarded(EssaVariable sequenceVar) {\n  sequenceVar.getDefinition() instanceof EssaEdgeRefinement\n}\n\n/**\n * Holds if iterator is guaranteed non-exhausted.\n * Common pattern: next(iter(x)) where x is known non-empty.\n */\npredicate isIteratorNonExhausted(EssaVariable iteratorVar) {\n  exists(EssaVariable sequenceVar |\n_______________ // 补全条件\n    isSequenceGuarded(sequenceVar)\n  )\n}\n\n// Checks if StopIteration exception is handled in scope\npredicate isStopIterationCaught(CallNode nextCallNode) {\n  exists(Try tryStmt |\n    tryStmt.containsInScope(nextCallNode.getNode()) and\n    tryStmt.getAHandler().getType() = builtinStopIterationException().getAValueReachableFromSource().asExpr()\n  )\n}\n\n// Find unguarded next() calls in generators without default value or exception handling\nfrom CallNode nextCallNode, ControlFlowNode iteratorNode\nwhere\n  // Verify next() call with iterator argument\n  nextCallWithIterator(nextCallNode, iteratorNode) and\n  // Ensure no default value provided\n  not nextCallHasDefault(nextCallNode) and\n  // Confirm iterator might be exhausted\n  not exists(EssaVariable iteratorVar |\n    iteratorNode = iteratorVar.getAUse() and\n    isIteratorNonExhausted(iteratorVar)\n  ) and\n  // Restrict to generator functions\n  nextCallNode.getNode().getScope().(Function).isGenerator() and\n  // Exclude comprehensions\n  not exists(Comp comprehension | comprehension.contains(nextCallNode.getNode())) and\n  // Verify no StopIteration handling\n  not isStopIterationCaught(nextCallNode) and\n  // PEP 479 resolves this in Python 3.7+\n  // Only alert for Python 2 since minor version is unknown\n  major_version() = 2\nselect nextCallNode, \"Call to 'next()' in a generator.\"",
    "output": "iterCallWithSequence(iteratorVar.getDefinition().(AssignmentDefinition).getValue(), sequenceVar) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raise-not-implemented]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies raise statements that incorrectly use 'NotImplemented'",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name NotImplemented is not an Exception\n * @description Identifies raise statements that incorrectly use 'NotImplemented'\n *              instead of 'NotImplementedError', which leads to runtime type errors.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom Expr incorrectNotImplementedUsage\nwhere \n  // Find raise statements that misuse NotImplemented instead of NotImplementedError\n  use_of_not_implemented_in_raise(_, incorrectNotImplementedUsage)\nselect \n  incorrectNotImplementedUsage, \n  \"NotImplemented is not an Exception. Did you mean NotImplementedError?\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unnecessary-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query identifies unnecessary 'delete' statements that remove local variables.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unnecessary delete statement in function\n * @description This query identifies unnecessary 'delete' statements that remove local variables.\n *              Such deletions are redundant because local variables are automatically cleaned up\n *              when the function scope exits. The query excludes cases where deletion might be\n *              necessary, such as within loops or when dealing with sys.exc_info() calls.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/unnecessary-delete\n */\n\nimport python\n\n// Predicate to determine if an AST node is inside a loop structure\npredicate isWithinLoopContext(AstNode astNode) {\n  // Check if the node is directly inside a while or for loop\n  astNode.getParentNode() instanceof While\n  or\n  astNode.getParentNode() instanceof For\n  // Check if the node is nested inside another node that is within a loop\n  or\n  exists(AstNode predecessorNode | \n    isWithinLoopContext(predecessorNode) and \n    astNode = predecessorNode.getAChildNode()\n  )\n}\n\n// Main query to identify unnecessary delete statements\nfrom Delete deleteStmt, Expr targetExpr, Function containingFunction\nwhere\n  // Position check: The delete statement is the last statement in the function\n  containingFunction.getLastStatement() = deleteStmt and\n  // Target check: The target expression is being deleted\n  targetExpr = deleteStmt.getATarget() and\n  // Scope check: The target is in the function's scope\n  containingFunction.containsInScope(targetExpr) and\n  // Type exclusions: Exclude certain types of deletions that might be necessary\n  not targetExpr instanceof Subscript and  // e.g., del list[index]\n  not targetExpr instanceof Attribute and  // e.g., del obj.attribute\n  // Context exclusions: Exclude deletions in certain contexts\n  not isWithinLoopContext(deleteStmt) and  // Exclude deletions within loops\n  // Special case: Exclude functions that call sys.exc_info() (which may need explicit deletion)\n  not exists(FunctionValue excInfoFunc |\n    excInfoFunc = Value::named(\"sys.exc_info\") and\n    excInfoFunc.getACall().getScope() = containingFunction\n  )\nselect deleteStmt, \"Unnecessary deletion of local variable $@ in function $@.\", \n  targetExpr, targetExpr.toString(), containingFunction, containingFunction.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of co-committed files\n * @description Measures the average number of files that are modified together whenever a specific file is changed in a commit\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Helper function: Calculates the total number of files affected by a specific commit\nint countAffectedFilesInCommit(Commit revision) { \n    result = count(revision.getAnAffectedFile()) \n}\n\n// Main analysis: Analyzes patterns of co-modification across various modules\nfrom Module targetModule\n// Filtering condition: Only consider modules that have available lines of code metrics\n_______________ // 补全条件\nselect targetModule,\n  // Calculate the average count of files modified together with files in this module\n  avg(Commit commit, int coModifiedFilesCount |\n    // Condition: The commit affects a file within the target module\n    commit.getAnAffectedFile() = targetModule.getFile() and \n    // Compute the number of additional files modified in the same commit\n    coModifiedFilesCount = countAffectedFilesInCommit(commit) - 1\n  |\n    coModifiedFilesCount\n  )",
    "output": "where exists(targetModule.getMetrics().getNumberOfLinesOfCode())"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @name Mostly duplicate class\n * @description \n * More than 80% of the methods in this class are duplicated in another class. \n * Create a common supertype to improve code sharing.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-class\n */\n\nimport python\n\n// 声明查询变量：\n// - `c`: 当前分析的类\n// - `other`: 可能包含重复代码的对比类\n// - `message`: 描述重复问题的诊断消息\nfrom \n    Class c, \n    Class other, \n    string message\nwhere \n    // 无过滤条件（原始查询逻辑）\n    none()\nselect \n    c, \n    message, \n    other, \n    other.getName()",
    "output": "* @deprecated"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/paramiko-missing-host-key-validation]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Accepting unknown host keys can allow man-in-the-middle attacks.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Accepting unknown SSH host keys when using Paramiko\n * @description Accepting unknown host keys can allow man-in-the-middle attacks.\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/paramiko-missing-host-key-validation\n * @tags security\n *       external/cwe/cwe-295\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Identify unsafe Paramiko host key policies\nprivate API::Node getUnsafeParamikoPolicy(string policyName) {\n  // Match either client module policies or direct module policies\n  policyName in [\"AutoAddPolicy\", \"WarningPolicy\"] and\n  (\n    result = API::moduleImport(\"paramiko\").getMember(\"client\").getMember(policyName)\n    or\n    result = API::moduleImport(\"paramiko\").getMember(policyName)\n  )\n}\n\n// Retrieve Paramiko SSHClient instance sources\nprivate API::Node getParamikoSshClientInstance() {\n  // Handle both client.SSHClient and direct SSHClient access patterns\n  result = API::moduleImport(\"paramiko\").getMember(\"client\").getMember(\"SSHClient\").getReturn()\n  or\n  result = API::moduleImport(\"paramiko\").getMember(\"SSHClient\").getReturn()\n}\n\n// Detect unsafe policy configurations\nfrom DataFlow::CallCfgNode cfgNode, DataFlow::Node policyArg, string policyName\nwhere\n  // Reference: Paramiko SSHClient.set_missing_host_key_policy documentation\n  // Identify calls to set_missing_host_key_policy method\n  cfgNode = getParamikoSshClientInstance().getMember(\"set_missing_host_key_policy\").getACall() and\n  // Capture policy argument (position 0 or named 'policy')\n  policyArg in [cfgNode.getArg(0), cfgNode.getArgByName(\"policy\")] and\n  // Check if argument resolves to unsafe policy\n  (\n    policyArg = getUnsafeParamikoPolicy(policyName).getAValueReachableFromSource()\n    or\n    policyArg = getUnsafeParamikoPolicy(policyName).getReturn().getAValueReachableFromSource()\n  )\nselect cfgNode, \"Setting missing host key policy to \" + policyName + \" may be unsafe.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/property-in-old-style-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects property descriptors used within legacy class definitions that are incompatible with Python 2.1+.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Property in old-style class\n * @description Detects property descriptors used within legacy class definitions that are incompatible with Python 2.1+.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/property-in-old-style-class\n */\n\nimport python\n\n// Identify property descriptors that are problematic when used in legacy class definitions\nfrom PropertyObject propertyObj, ClassObject legacyClass\n// The following conditions must be satisfied:\n// - The property is explicitly declared as an attribute within the class\n// - The class type inference completed successfully (ensuring accurate analysis)\n// - The class follows the legacy pattern (not inheriting from 'object' or built-in types)\nwhere \n  propertyObj = legacyClass.declaredAttribute(_) and\n  not legacyClass.failedInference() and\n  not legacyClass.isNewStyle()\n// Generate alert with detailed explanation about the compatibility issue\nselect propertyObj,\n  \"Property '\" + propertyObj.getName() + \"' is incompatible with class '\" + \n  legacyClass.getName() + \"' because it is defined as an old-style class. \" +\n  \"Property descriptors require new-style classes to function correctly.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-named-class-argument]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a named argument is used in a class instantiation",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Wrong name for an argument in a class instantiation\n * @description Detects when a named argument is used in a class instantiation\n *              that does not match any parameter of the class's __init__ method.\n *              This results in a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\n// Import required CodeQL modules for Python analysis and call arguments handling\nimport python\nimport Expressions.CallArgs\n\n// This query identifies class instantiations using invalid keyword argument names\n// that don't correspond to any parameter in the class's __init__ method\nfrom Call instantiationCall, ClassValue instantiatedClass, string invalidArgName, FunctionValue classInitializer\nwhere\n  // Check for presence of an invalid keyword argument in the instantiation\n  illegally_named_parameter(instantiationCall, instantiatedClass, invalidArgName) and\n  // Retrieve the class's initialization method (__init__)\n  classInitializer = get_function_or_initializer(instantiatedClass)\nselect instantiationCall, \n  \"Keyword argument '\" + invalidArgName + \"' is not a supported parameter name of $@.\", \n  classInitializer,\n  // Include the qualified name of the initialization method\n  classInitializer.getQualifiedName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects and examines alert suppression techniques in Python code,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression analysis\n * @description Detects and examines alert suppression techniques in Python code,\n *              with a focus on 'noqa' style suppression comments that are frequently\n *              utilized to silence linter warnings.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression utilities for examining suppression mechanisms\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing utilities to extract and handle code comments\nprivate import semmle.python.Comment as PythonComment\n\n/**\n * Represents a single-line Python comment with improved location tracking functionality.\n * This class builds upon the base Comment class to offer more precise location details.\n */\nclass SingleLineComment instanceof PythonComment::Comment {\n  /**\n   * Obtains comprehensive location information for the comment.\n   * @param filePath - The path to the file containing the comment\n   * @param startLine - The starting line number of the comment\n   * @param startColumn - The starting column number of the comment\n   * @param finishLine - The ending line number of the comment\n   * @param finishColumn - The ending column number of the comment\n   */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startColumn, int finishLine, int finishColumn\n  ) {\n    // Inherit location details from parent class\n    super.getLocation().hasLocationInfo(filePath, startLine, startColumn, finishLine, finishColumn)\n  }\n\n  /**\n   * Retrieves the text content of the comment, without the comment marker.\n   * @returns The textual content of the comment\n   */\n  string getText() { result = super.getContents() }\n\n  /**\n   * Provides a string representation of the comment.\n   * @returns A string representation of the comment\n   */\n  string toString() { result = super.toString() }\n}\n\n/**\n * Represents a Python AST node with detailed location tracking capabilities.\n * This class extends the base AstNode class to provide thorough location information.\n */\nclass AstNode instanceof PythonComment::AstNode {\n  /**\n   * Obtains comprehensive location information for the AST node.\n   * @param filePath - The path to the file containing the node\n   * @param startLine - The starting line number of the node\n   * @param startColumn - The starting column number of the node\n   * @param finishLine - The ending line number of the node\n   * @param finishColumn - The ending column number of the node\n   */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startColumn, int finishLine, int finishColumn\n  ) {\n    // Inherit location details from parent class\n    super.getLocation().hasLocationInfo(filePath, startLine, startColumn, finishLine, finishColumn)\n  }\n\n  /**\n   * Provides a string representation of the AST node.\n   * @returns A string representation of the node\n   */\n  string toString() { result = super.toString() }\n}\n\n// Establish suppression relationships between AST nodes and comments using the AlertSuppression framework\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * Represents a 'noqa' suppression comment, which is a widely recognized mechanism\n * for disabling linter warnings in Python code. Both pylint and pyflakes respect\n * this convention, making it a standard for suppression in the Python ecosystem.\n */\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  /**\n   * Constructs a NoqaSuppressionComment by identifying comments that match the noqa pattern.\n   * The pattern is case-insensitive and allows for optional suffixes after the noqa keyword.\n   */\n  NoqaSuppressionComment() {\n    // Match case-insensitive noqa with optional suffix (without colon)\n    super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  /**\n   * Retrieves the annotation identifier for this suppression comment.\n   * @returns The string \"lgtm\" as the annotation identifier\n   */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /**\n   * Specifies the code range covered by this suppression comment.\n   * A noqa comment typically covers the entire line where it appears.\n   * @param filePath - The path to the file containing the suppression\n   * @param startLine - The starting line number of the covered range\n   * @param startColumn - The starting column number of the covered range\n   * @param finishLine - The ending line number of the covered range\n   * @param finishColumn - The ending column number of the covered range\n   */\n  override predicate covers(\n    string filePath, int startLine, int startColumn, int finishLine, int finishColumn\n  ) {\n    // Get comment location and verify it starts at column 1 (beginning of line)\n    this.hasLocationInfo(filePath, startLine, _, finishLine, finishColumn) and\n    startColumn = 1\n  }\n}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/syntax-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects syntax errors in Python code that lead to runtime failures and hinder code analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Syntax error\n * @description Detects syntax errors in Python code that lead to runtime failures and hinder code analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// 导入Python语言分析模块，用于检测代码中的语法错误\nimport python\n\n// 查询所有非编码相关的语法错误\nfrom SyntaxError syntaxIssue\nwhere not syntaxIssue instanceof EncodingError\n// 返回语法错误及其描述信息，并附带当前Python主版本号\nselect syntaxIssue, syntaxIssue.getMessage() + \" (in Python \" + major_version() + \").\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Deprecated slice method\n * @description Identifies usage of deprecated slicing special methods which have been obsolete since Python 2.0.\n * @kind problem\n_______________ // 补全条件\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/deprecated-slice-method\n */\n\nimport python\n\n// 谓词函数：验证输入的方法名是否属于已弃用的切片方法集合\npredicate is_deprecated_slice_method(string methodName) {\n  // 方法名必须是以下三种已弃用的切片方法之一\n  methodName = \"__getslice__\" or methodName = \"__setslice__\" or methodName = \"__delslice__\"\n}\n\n// 查询源：从Python函数值中筛选目标\nfrom PythonFunctionValue funcObj, string methodName\nwhere\n  // 条件1：函数名与方法名匹配，且该方法名是已弃用的切片方法\n  funcObj.getName() = methodName and\n  is_deprecated_slice_method(methodName) and\n  // 条件2：函数必须是一个类方法\n  funcObj.getScope().isMethod() and\n  // 条件3：函数不能是重写父类的方法\n  not funcObj.isOverridingMethod()\n// 输出结果：显示函数对象和相应的弃用警告信息\nselect funcObj, methodName + \" method has been deprecated since Python 2.0.\"",
    "output": "* @tags maintainability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'exec' used\n * @description Detects usage of the 'exec' statement or function which can lead to arbitrary code execution.\n * @kind problem\n * @tags security\n_______________ // 补全条件\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec\n */\n\n// Import Python library for code parsing and analysis\nimport python\n\n// Creates a version-specific warning message for exec usage\nstring constructExecWarningMessage() {\n  // Python 2 uses exec as a statement\n  major_version() = 2 and result = \"The 'exec' statement is used.\"\n  // Python 3 uses exec as a function\n  or\n  major_version() = 3 and result = \"The 'exec' function is used.\"\n}\n\n// Identifies calls to the exec function that may execute arbitrary code\npredicate isExecFunctionInvocation(Call execCall) {\n  // Verify the function call references a global variable named 'exec'\n  exists(GlobalVariable referencedExecVar | \n    referencedExecVar = execCall.getFunc().(Name).getVariable() and \n    referencedExecVar.getId() = \"exec\"\n  )\n}\n\n// Main query to locate and report all potentially dangerous exec usages\nfrom AstNode dangerousExecNode\n// Check if the node represents either an exec function call or an exec statement\nwhere \n  isExecFunctionInvocation(dangerousExecNode) \n  or \n  dangerousExecNode instanceof Exec\n// Report the exec usage with an appropriate version-specific warning message\nselect dangerousExecNode, constructExecWarningMessage()",
    "output": "*       correctness"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/catch-base-exception]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers that capture 'BaseException' without re-raising,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Exception block catches 'BaseException'\n * @description Identifies exception handlers that capture 'BaseException' without re-raising,\n *              potentially interfering with system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\nfrom ExceptStmt exceptionHandler\nwhere\n  /* Check if handler catches BaseException or uses bare except clause */\n  (\n    exceptionHandler.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n    or\n    not exists(exceptionHandler.getType())\n  )\n  and\n  /* Verify handler doesn't re-raise the caught exception */\n  exceptionHandler.getAFlowNode().getBasicBlock().reachesExit()\nselect exceptionHandler, \"Except block directly handles BaseException.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description General consistency check to be run on any and all code. Should never produce any results.\n * @id py/consistency-check\n */\n\nimport python\nimport analysis.DefinitionTracking\n\n// Predicate to detect uniqueness violations in method results\npredicate uniqueness_error(int countVal, string methodName, string issueDesc) {\n  // Check if method is in the monitored list\n  methodName in [\n      \"toString\", \"getLocation\", \"getNode\", \"getDefinition\", \"getEntryNode\", \"getOrigin\",\n      \"getAnInferredType\"\n    ] and\n  // Define issue description based on result count\n  (\n    countVal = 0 and issueDesc = \"no results for \" + methodName + \"()\"\n    or\n    countVal in [2 .. 10] and issueDesc = countVal.toString() + \" results for \" + methodName + \"()\"\n  )\n}\n\n// AST consistency validation\npredicate ast_consistency(string className, string issueDesc, string details) {\n  exists(AstNode astNode | className = astNode.getAQlClass() |\n    // Check toString uniqueness\n    uniqueness_error(count(astNode.toString()), \"toString\", issueDesc) and\n    details = \"at \" + astNode.getLocation().toString()\n    or\n    // Check location uniqueness\n    uniqueness_error(strictcount(astNode.getLocation()), \"getLocation\", issueDesc) and\n    details = astNode.getLocation().toString()\n    or\n    // Validate location existence\n    not exists(astNode.getLocation()) and\n    not astNode.(Module).isPackage() and\n    issueDesc = \"no location\" and\n    details = astNode.toString()\n  )\n}\n\n// Location consistency validation\npredicate location_consistency(string className, string issueDesc, string details) {\n  exists(Location loc | className = loc.getAQlClass() |\n    // Check toString uniqueness\n    uniqueness_error(count(loc.toString()), \"toString\", issueDesc) and \n    details = \"at \" + loc.toString()\n    or\n    // Validate toString existence\n    not exists(loc.toString()) and\n    issueDesc = \"no toString\" and\n    (\n      exists(AstNode astNode | astNode.getLocation() = loc |\n        details = \"a location of a \" + astNode.getAQlClass()\n      )\n      or\n      not exists(AstNode astNode | astNode.getLocation() = loc) and\n      details = \"a location\"\n    )\n    or\n    // Check line order consistency\n    loc.getEndLine() < loc.getStartLine() and\n    issueDesc = \"end line before start line\" and\n    details = \"at \" + loc.toString()\n    or\n    // Check column order consistency\n    loc.getEndLine() = loc.getStartLine() and\n    loc.getEndColumn() < loc.getStartColumn() and\n    issueDesc = \"end column before start column\" and\n    details = \"at \" + loc.toString()\n  )\n}\n\n// Control flow graph consistency validation\npredicate cfg_consistency(string className, string issueDesc, string details) {\n  exists(ControlFlowNode cfgNode | className = cfgNode.getAQlClass() |\n    // Check node mapping uniqueness\n    uniqueness_error(count(cfgNode.getNode()), \"getNode\", issueDesc) and\n    details = \"at \" + cfgNode.getLocation().toString()\n    or\n    // Validate location existence\n    not exists(cfgNode.getLocation()) and\n    not exists(Module pkg | pkg.isPackage() | pkg.getEntryNode() = cfgNode or pkg.getAnExitNode() = cfgNode) and\n    issueDesc = \"no location\" and\n    details = cfgNode.toString()\n    or\n    // Check attribute node value uniqueness\n    uniqueness_error(count(cfgNode.(AttrNode).getObject()), \"getValue\", issueDesc) and\n    details = \"at \" + cfgNode.getLocation().toString()\n  )\n}\n\n// Scope consistency validation\npredicate scope_consistency(string className, string issueDesc, string details) {\n  exists(Scope scope | className = scope.getAQlClass() |\n    // Check entry node uniqueness\n    uniqueness_error(count(scope.getEntryNode()), \"getEntryNode\", issueDesc) and\n    details = \"at \" + scope.getLocation().toString()\n    or\n    // Check toString uniqueness\n    uniqueness_error(count(scope.toString()), \"toString\", issueDesc) and\n    details = \"at \" + scope.getLocation().toString()\n    or\n    // Check location uniqueness\n    uniqueness_error(strictcount(scope.getLocation()), \"getLocation\", issueDesc) and\n    details = \"at \" + scope.getLocation().toString()\n    or\n    // Validate location existence\n    not exists(scope.getLocation()) and\n    issueDesc = \"no location\" and\n    details = scope.toString() and\n    not scope.(Module).isPackage()\n  )\n}\n\n// Helper function to describe built-in objects\nstring best_description_builtin_object(Object builtinObj) {\n  builtinObj.isBuiltin() and\n  (\n    result = builtinObj.toString()\n    or\n    not exists(builtinObj.toString()) and py_cobjectnames(builtinObj, result)\n    or\n    not exists(builtinObj.toString()) and\n    not py_cobjectnames(builtinObj, _) and\n    result = \"builtin object of type \" + builtinObj.getAnInferredType().toString()\n    or\n    not exists(builtinObj.toString()) and\n    not py_cobjectnames(builtinObj, _) and\n    not exists(builtinObj.getAnInferredType().toString()) and\n    result = \"builtin object\"\n  )\n}\n\n// Private predicate for introspected built-in objects\nprivate predicate introspected_builtin_object(Object builtinObj) {\n  /* Only check objects from the extractor, missing data for objects generated \n   * from C source code analysis is OK as it will be ignored if it doesn't \n   * match up with the introspected form. */\n  py_cobject_sources(builtinObj, 0)\n}\n\n// Built-in object consistency validation\npredicate builtin_object_consistency(string className, string issueDesc, string details) {\n  exists(Object builtinObj |\n    className = builtinObj.getAQlClass() and\n    details = best_description_builtin_object(builtinObj) and\n    introspected_builtin_object(builtinObj)\n  |\n    // Validate type/name existence\n    not exists(builtinObj.getAnInferredType()) and\n    not py_cobjectnames(builtinObj, _) and\n    issueDesc = \"neither name nor type\"\n    or\n    // Check name uniqueness\n    uniqueness_error(count(string name | py_cobjectnames(builtinObj, name)), \"name\", issueDesc)\n    or\n    not exists(builtinObj.getAnInferredType()) and issueDesc = \"no results for getAnInferredType\"\n    or\n    not exists(builtinObj.toString()) and\n    issueDesc = \"no toString\" and\n    not exists(string name | name.matches(\"\\\\_semmle%\") | py_special_objects(builtinObj, name)) and\n    not builtinObj = unknownValue()\n  )\n}\n\n// Source object consistency validation\npredicate source_object_consistency(string className, string issueDesc, string details) {\n  exists(Object srcObj | className = srcObj.getAQlClass() and not srcObj.isBuiltin() |\n    // Check origin uniqueness\n    uniqueness_error(count(srcObj.getOrigin()), \"getOrigin\", issueDesc) and\n    details = \"at \" + srcObj.getOrigin().getLocation().toString()\n    or\n    // Validate location existence\n    not exists(srcObj.getOrigin().getLocation()) and \n    issueDesc = \"no location\" and \n    details = \"??\"\n    or\n    not exists(srcObj.toString()) and\n    issueDesc = \"no toString\" and\n    details = \"at \" + srcObj.getOrigin().getLocation().toString()\n    or\n    // Check toString multiplicity\n    strictcount(srcObj.toString()) > 1 and \n    issueDesc = \"multiple toStrings()\" and \n    details = srcObj.toString()\n  )\n}\n\n// SSA consistency validation\npredicate ssa_consistency(string className, string issueDesc, string details) {\n  /* Zero or one definitions of each SSA variable */\n  exists(SsaVariable ssaVar | className = ssaVar.getAQlClass() |\n    // Check definition uniqueness\n    uniqueness_error(strictcount(ssaVar.getDefinition()), \"getDefinition\", issueDesc) and\n    details = ssaVar.getId()\n  )\n  or\n  /* Dominance criterion: Definition must dominate all uses */\n  exists(SsaVariable ssaVar, ControlFlowNode defNode, ControlFlowNode useNode |\n    defNode = ssaVar.getDefinition() and \n    useNode = ssaVar.getAUse()\n  |\n    // Validate dominance relationship\n    not defNode.strictlyDominates(useNode) and\n    not defNode = useNode and\n    not (exists(ssaVar.getAPhiInput()) and defNode = useNode) and\n    className = ssaVar.getAQlClass() and\n    issueDesc = \"a definition which does not dominate a use at \" + useNode.getLocation() and\n    details = ssaVar.getId() + \" at \" + ssaVar.getLocation()\n  )\n  or\n  /* Minimality of phi nodes */\n  exists(SsaVariable ssaVar |\n    strictcount(ssaVar.getAPhiInput()) = 1 and\n    ssaVar.getAPhiInput()\n        .getDefinition()\n        .getBasicBlock()\n        .strictlyDominates(ssaVar.getDefinition().getBasicBlock())\n  |\n    className = ssaVar.getAQlClass() and\n    issueDesc = \"a definition which is dominated by the definition of an incoming phi edge\" and\n    details = ssaVar.getId() + \" at \" + ssaVar.getLocation()\n  )\n}\n\n// Function object consistency validation\npredicate function_object_consistency(string className, string issueDesc, string details) {\n  exists(FunctionObject funcObj | className = funcObj.getAQlClass() |\n    details = funcObj.getName() and\n    (\n      // Validate descriptive string existence\n      not exists(funcObj.descriptiveString()) and \n      issueDesc = \"no descriptiveString()\"\n      or\n      exists(int cnt | cnt = strictcount(funcObj.descriptiveString()) and cnt > 1 |\n        issueDesc = cnt + \" descriptiveString()s\"\n      )\n    )\n    or\n    not exists(funcObj.getName()) and \n    details = \"?\" and \n    issueDesc = \"no name\"\n  )\n}\n\n// Predicate to detect objects with multiple origins\npredicate multiple_origins_per_object(Object obj) {\n  not obj.isC() and\n  not obj instanceof ModuleObject and\n  exists(ControlFlowNode useNode, Context ctx |\n    strictcount(ControlFlowNode orig | useNode.refersTo(ctx, obj, _, orig)) > 1\n  )\n}\n\n// Predicate to detect intermediate origins\npredicate intermediate_origins(ControlFlowNode useNode, ControlFlowNode interNode, Object obj) {\n  exists(ControlFlowNode origNode, Context ctx | not interNode = origNode |\n    useNode.refersTo(ctx, obj, _, interNode) and\n    interNode.refersTo(ctx, obj, _, origNode) and\n    not strictcount(Object val | interNode.(AttrNode).getObject().refersTo(val)) > 1\n  )\n}\n\n// Points-to consistency validation\npredicate points_to_consistency(string className, string issueDesc, string details) {\n  exists(Object obj |\n    multiple_origins_per_object(obj) and\n    className = obj.getAQlClass() and\n    issueDesc = \"multiple origins for an object\" and\n    details = obj.toString()\n  )\n  or\n  exists(ControlFlowNode useNode, ControlFlowNode interNode |\n    intermediate_origins(useNode, interNode, _) and\n    className = useNode.getAQlClass() and\n    issueDesc = \"has intermediate origin \" + interNode and\n    details = useNode.toString()\n  )\n}\n\n// Jump-to-definition consistency validation\npredicate jump_to_definition_consistency(string className, string issueDesc, string details) {\n  issueDesc = \"multiple (jump-to) definitions\" and\n  exists(Expr expr |\n    strictcount(getUniqueDefinition(expr)) > 1 and\n    className = expr.getAQlClass() and\n    details = expr.toString()\n  )\n}\n\n// File consistency validation\npredicate file_consistency(string className, string issueDesc, string details) {\n  exists(File file, Folder folder |\n    className = file.getAQlClass() and\n    issueDesc = \"has same name as a folder\" and\n    details = file.getAbsolutePath() and\n    details = folder.getAbsolutePath()\n  )\n  or\n  exists(Container container |\n    className = container.getAQlClass() and\n    uniqueness_error(count(container.toString()), \"toString\", issueDesc) and\n    details = \"file \" + container.getAbsolutePath()\n  )\n}\n\n// Class value consistency validation\npredicate class_value_consistency(string className, string issueDesc, string details) {\n  exists(ClassValue classVal, ClassValue superType, string attr |\n    details = classVal.getName() and\n    superType = classVal.getASuperType() and\n    exists(superType.lookup(attr)) and\n    not classVal.failedInference(_) and\n    not exists(classVal.lookup(attr)) and\n    className = classVal.getAQlClass() and\n    issueDesc = \"no attribute '\" + attr + \"', but super type '\" + superType.getName() + \"' does.\"\n  )\n}\n\n// Main query combining all consistency checks\nfrom string className, string issueDesc, string details\nwhere\n  ast_consistency(className, issueDesc, details) or\n  location_consistency(className, issueDesc, details) or\n  scope_consistency(className, issueDesc, details) or\n  cfg_consistency(className, issueDesc, details) or\n  ssa_consistency(className, issueDesc, details) or\n  builtin_object_consistency(className, issueDesc, details) or\n  source_object_consistency(className, issueDesc, details) or\n  function_object_consistency(className, issueDesc, details) or\n  points_to_consistency(className, issueDesc, details) or\n  jump_to_definition_consistency(className, issueDesc, details) or\n  file_consistency(className, issueDesc, details) or\n  class_value_consistency(className, issueDesc, details)\nselect className + \" \" + details + \" has \" + issueDesc",
    "output": "* @name Consistency check"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak elliptic curve cryptography\n * @description Identifies cryptographic operations that use elliptic curve algorithms which are\n *              either unrecognized or classified as weak according to security best practices.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm cryptoOperation, string alertMessage, string curveName\nwhere\n_______________ // 补全条件\n  curveName = cryptoOperation.getCurveName()\n  and\n  (\n    // Case 1: The curve algorithm is not recognized by the system\n    curveName = unknownAlgorithm()\n    and\n    alertMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: The curve algorithm is recognized but not in the approved secure list\n    curveName != unknownAlgorithm()\n    and\n    not curveName in [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ]\n    and\n    alertMessage = \"Use of weak curve algorithm \" + curveName + \".\"\n  )\nselect cryptoOperation, alertMessage",
    "output": "// Extract the curve identifier from the elliptic curve cryptographic operation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python functions that do not adhere to PEP8 naming standards, specifically those beginning with uppercase letters.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Function Naming Convention Violation\n * @description Detects Python functions that do not adhere to PEP8 naming standards, specifically those beginning with uppercase letters.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n * @convention PEP8\n */\n\nimport python  // Import Python analysis module for code inspection capabilities\n\n// Helper predicate to determine if a function's name begins with an uppercase letter\npredicate hasCapitalizedName(Function func) {\n  exists(string initialCharacter |\n    initialCharacter = func.getName().prefix(1) and  // Extract the initial character of the function name\n    not initialCharacter = initialCharacter.toLowerCase()  // Confirm the character is uppercase\n  )\n}\n\n// Main query for identifying functions that violate PEP8 naming conventions\nfrom Function nonCompliantFunction\nwhere\n  // Basic conditions: function is in source code and violates naming convention\n  nonCompliantFunction.inSource() and\n  hasCapitalizedName(nonCompliantFunction)\n  \n  // Additional condition: exclude files with multiple violations to reduce noise\n  and not exists(Function otherFunction |\n    otherFunction != nonCompliantFunction and\n    otherFunction.getLocation().getFile() = nonCompliantFunction.getLocation().getFile() and\n    hasCapitalizedName(otherFunction)\n  )\nselect nonCompliantFunction, \"Function names should start with lowercase letters according to PEP8.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Comparison using is when operands support `__eq__`\n * @description Detects 'is' comparisons where equivalence differs from identity\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/comparison-using-is\n */\n\nimport python\n\n/** Identifies comparisons using 'is'/'is not' operators between operands */\npredicate comparison_using_is(Compare cmpNode, ControlFlowNode leftOp, Cmpop op, ControlFlowNode rightOp) {\n  exists(CompareNode flowCmp | flowCmp = cmpNode.getAFlowNode() |\n    flowCmp.operands(leftOp, op, rightOp) and\n    (op instanceof Is or op instanceof IsNot)\n  )\n}\n\n/**\n * @brief Checks if expression represents a CPython-interned value\n * @param expr Expression to evaluate\n * @return True for interned values in CPython\n */\nprivate predicate cpython_interned_value(Expr expr) {\n  // Empty/single-character ASCII strings\n  exists(string strVal | strVal = expr.(StringLiteral).getText() |\n    strVal.length() = 0\n    or\n    strVal.length() = 1 and strVal.regexpMatch(\"[U+0000-U+00ff]\")\n  )\n  // Integers in [-5, 256] range\n  or\n  exists(int intVal | intVal = expr.(IntegerLiteral).getN().toInt() | -5 <= intVal and intVal <= 256)\n  // Empty tuples\n  or\n  exists(Tuple t | t = expr and not exists(t.getAnElt()))\n}\n\n/**\n * @brief Identifies non-interned literal values\n * @param expr Expression to evaluate\n * @return True for non-interned literals\n */\npredicate uninterned_literal(Expr expr) {\n  (\n    expr instanceof StringLiteral\n    or\n    expr instanceof IntegerLiteral\n    or\n    expr instanceof FloatLiteral\n    or\n    expr instanceof Dict\n    or\n    expr instanceof List\n    or\n    expr instanceof Tuple\n  ) and\n  not cpython_interned_value(expr)\n}\n\nfrom Compare cmpNode, Cmpop op, string altOp\nwhere\n  // Map operators to their equivalence alternatives\n  (\n    op instanceof Is and altOp = \"==\"\n    or\n_______________ // 补全条件\n  ) and\n  exists(ControlFlowNode leftOp, ControlFlowNode rightOp |\n    comparison_using_is(cmpNode, leftOp, op, rightOp) and\n    (\n      uninterned_literal(leftOp.getNode())\n      or\n      uninterned_literal(rightOp.getNode())\n    )\n  )\nselect cmpNode,\n  \"Values compared using '\" + op.getSymbol() +\n    \"' when equivalence is not the same as identity. Use '\" + altOp + \"' instead.\"",
    "output": "op instanceof IsNot and altOp = \"!=\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/classic-model/hash-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all cryptographic operations utilizing hash algorithms or password hashing algorithms",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cryptographic Hash Algorithm Detection\n * @description Identifies all cryptographic operations utilizing hash algorithms or password hashing algorithms\n *              across supported cryptography libraries. This detection targets quantum-vulnerable\n *              cryptographic primitives in classical CBOM models.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/hash-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import core Python analysis modules and Semmle cryptography concepts\nimport python\nimport semmle.python.Concepts\n\n// Define source variables with semantic clarity\nfrom Cryptography::CryptographicOperation cryptoOperation, Cryptography::CryptographicAlgorithm cryptoAlgorithm\nwhere\n  // Establish algorithm-operation relationship\n  cryptoAlgorithm = cryptoOperation.getAlgorithm()\n  and (\n    // Identify hash-based cryptographic algorithms\n    cryptoAlgorithm instanceof Cryptography::HashingAlgorithm\n    or cryptoAlgorithm instanceof Cryptography::PasswordHashingAlgorithm\n  )\n// Report operations with algorithm identification\nselect cryptoOperation, \"Detected cryptographic hash algorithm: \" + cryptoOperation.getAlgorithm().getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * 查询特定类及其继承关系\n * 通过类名和可选文件路径精确定位目标类\n */\n\nimport python\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n\n// 判断类是否为特定目标类的谓词\npredicate isDesiredClass(Class targetCls) {\n  // 匹配指定的类名\n  targetCls.getName() = \"YourClassName\"\n  // 可选：通过文件路径进一步限定\n  // and targetCls.getLocation().getFile().getAbsolutePath().matches(\"%/folder/file.py\")\n}\n\n// 查找目标类的所有父类（包括直接和间接父类）\nquery predicate findAncestorClasses(Class targetCls, Class ancestorCls) {\n  isDesiredClass(targetCls) and\n  ancestorCls = getADirectSuperclass+(targetCls)\n}\n\n// 查找目标类的所有子类（包括直接和间接子类）\nquery predicate findDescendantClasses(Class targetCls, Class descendantCls) {\n  isDesiredClass(targetCls) and\n  descendantCls = getADirectSubclass+(targetCls)\n}\n\n// 输出所有匹配的目标类\nfrom Class targetCls\nwhere isDesiredClass(targetCls)\nselect targetCls"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak cryptographic hash algorithms\n * @description Detects usage of deprecated or insecure cryptographic hash functions\n *              that should not be used in security-sensitive applications.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import Python language support and cryptographic analysis utilities\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify hash functions using weak or deprecated cryptographic algorithms\nfrom HashAlgorithm hashFunc, string algoName, string warningMsg\nwhere\n  // Retrieve the algorithm name from the hash function operation\n  algoName = hashFunc.getHashName() and\n  \n  // Exclude approved secure hash algorithms from detection\n  not algoName = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  \n  // Determine appropriate warning message based on algorithm recognition status\n  (\n    // Handle identified but unapproved algorithms\n    algoName != \"\" and\n    warningMsg = \"Use of unapproved hash algorithm or API \" + algoName + \".\"\n  )\n  or\n  (\n_______________ // 补全条件\n    algoName = \"\" and\n    warningMsg = \"Use of unrecognized hash algorithm.\"\n  )\nselect hashFunc, warningMsg",
    "output": "// Handle cases where algorithm cannot be identified"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/percent-format/unsupported-character]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects format strings containing unsupported or invalid conversion specifiers",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unsupported format character\n * @description Detects format strings containing unsupported or invalid conversion specifiers\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/percent-format/unsupported-character\n */\n\n// Import core Python analysis capabilities\nimport python\n// Import string processing utilities for format string validation\nimport semmle.python.strings\n\n// Query definition: Identify expressions with invalid format specifiers\nfrom Expr problematicFormatExpr, int specifierErrorPosition\n// Validation condition: Determine the location of invalid conversion specifiers\nwhere specifierErrorPosition = illegal_conversion_specifier(problematicFormatExpr)\n// Result output: Report the problematic expression with detailed error context\nselect problematicFormatExpr, \"Invalid conversion specifier at index \" + specifierErrorPosition + \" of \" + repr(problematicFormatExpr) + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/signature-mismatch]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies methods in child classes that override parent class methods",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Signature mismatch in overriding method\n * @description Identifies methods in child classes that override parent class methods\n *              with incompatible parameter signatures, potentially causing runtime\n *              errors during method invocation.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom FunctionValue superclassMethod, PythonFunctionValue subclassMethod\nwhere\n  // Establish inheritance relationship between methods\n  subclassMethod.overrides(superclassMethod) and\n  \n  // Filter out special methods and constructors to focus on business logic\n  not subclassMethod.getScope().isSpecialMethod() and\n  subclassMethod.getName() != \"__init__\" and\n  subclassMethod.isNormalMethod() and\n  \n  // Verify that the superclass method is not directly called\n  not exists(superclassMethod.getACall()) and\n  \n  // Ensure no other subclass method overriding the same superclass method is being used\n  not exists(FunctionValue otherSubclassMethod |\n    otherSubclassMethod.overrides(superclassMethod) and\n    exists(otherSubclassMethod.getACall())\n  ) and\n  \n  // Detect parameter signature incompatibility\n  (\n    // Case 1: Subclass method requires more minimum parameters than superclass can accept\n    subclassMethod.minParameters() > superclassMethod.maxParameters()\n    or\n    // Case 2: Subclass method accepts fewer maximum parameters than superclass requires\n    subclassMethod.maxParameters() < superclassMethod.minParameters()\n  )\n\nselect subclassMethod, \"Overriding method '\" + subclassMethod.getName() + \"' has signature mismatch with $@.\",\n  superclassMethod, \"overridden method\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unsafe usage of v1 version of Azure Storage client-side encryption.\n * @description Using version v1 of Azure Storage client-side encryption is insecure, and may enable an attacker to decrypt encrypted data\n * @kind path-problem\n * @tags security\n *       experimental\n *       cryptography\n *       external/cwe/cwe-327\n * @id py/azure-storage/unsafe-client-side-encryption-in-use\n * @problem.severity error\n * @precision medium\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Azure Storage client initialization patterns\nAPI::Node blobServiceClientNode(boolean isDirect) {\n  // Direct BlobServiceClient instantiation\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getReturn()\n  or\n  // BlobServiceClient from connection string\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getMember(\"from_connection_string\")\n        .getReturn()\n}\n\nAPI::CallNode containerClientTransition() {\n  // Transition from BlobServiceClient to ContainerClient\n  result = blobServiceClientNode(_).getMember(\"get_container_client\").getACall()\n  or\n  // Transition from BlobClient to ContainerClient\n  result = blobClientNode(_).getMember(\"_get_container_client\").getACall()\n}\n\nAPI::Node containerClientNode(boolean isDirect) {\n  // ContainerClient obtained through transition\n  isDirect = false and\n  result = containerClientTransition().getReturn()\n  or\n  // Direct ContainerClient instantiation\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getReturn()\n  or\n  // ContainerClient from connection string or URL\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getMember([\"from_connection_string\", \"from_container_url\"])\n        .getReturn()\n}\n\nAPI::CallNode blobClientTransition() {\n  // Transition from BlobServiceClient or ContainerClient to BlobClient\n  result = [blobServiceClientNode(_), containerClientNode(_)]\n        .getMember(\"get_blob_client\")\n        .getACall()\n}\n\nAPI::Node blobClientNode(boolean isDirect) {\n  // BlobClient obtained through transition\n  isDirect = false and\n  result = blobClientTransition().getReturn()\n  or\n  // Direct BlobClient instantiation\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getReturn()\n  or\n  // BlobClient from connection string or URL\n  isDirect = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getMember([\"from_connection_string\", \"from_blob_url\"])\n        .getReturn()\n}\n\n// Unified representation of Azure Storage client types\nAPI::Node anyStorageClient(boolean isDirect) {\n  result in [blobServiceClientNode(isDirect), containerClientNode(isDirect), blobClientNode(isDirect)]\n}\n\n// Encryption state definitions\nnewtype TEncryptionFlowState =\n  MkV1EncryptionState() or\n  MkNoEncryptionState()\n\n// Data flow configuration with encryption state tracking\nprivate module EncryptionFlowConfig implements DataFlow::StateConfigSig {\n  class FlowState = TEncryptionFlowState;\n\n  // Source nodes: uninitialized clients (no encryption configured)\n  predicate isSource(DataFlow::Node node, FlowState state) {\n    state = MkNoEncryptionState() and\n    node = anyStorageClient(true).asSource()\n  }\n\n  // Barrier nodes: clients explicitly configured with v2 encryption\n  predicate isBarrier(DataFlow::Node node, FlowState state) {\n    exists(state) and\n    exists(DataFlow::AttrWrite encryptionAttr |\n_______________ // 补全条件\n      encryptionAttr.accesses(node, \"encryption_version\") and\n      encryptionAttr.getValue().asExpr().(StringLiteral).getText() in [\"'2.0'\", \"2.0\"]\n    )\n    or\n    // Barrier for state transition when encryption is configured\n    isAdditionalFlowStep(_, MkNoEncryptionState(), node, MkV1EncryptionState()) and\n    state = MkNoEncryptionState()\n  }\n\n  // Flow transitions between client objects\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(DataFlow::MethodCallNode transitionCall |\n      transitionCall in [containerClientTransition(), blobClientTransition()] and\n      node1 = transitionCall.getObject() and\n      node2 = transitionCall\n    )\n  }\n\n  // State transition when encryption configuration is applied\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    node1 = node2.(DataFlow::PostUpdateNode).getPreUpdateNode() and\n    state1 = MkNoEncryptionState() and\n    state2 = MkV1EncryptionState() and\n    exists(DataFlow::AttrWrite encryptionAttr |\n      node1 = anyStorageClient(_).getAValueReachableFromSource() and\n      encryptionAttr.accesses(node1, [\"key_encryption_key\", \"key_resolver_function\"])\n    )\n  }\n\n  // Sink nodes: v1 encrypted blob upload operations\n  predicate isSink(DataFlow::Node node, FlowState state) {\n    state = MkV1EncryptionState() and\n    exists(DataFlow::MethodCallNode uploadCall |\n      uploadCall = blobClientNode(_).getMember(\"upload_blob\").getACall() and\n      node = uploadCall.getObject()\n    )\n  }\n\n  // No restrictions on incremental mode\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global data flow analysis with encryption state tracking\nmodule EncryptionDataFlow = DataFlow::GlobalWithState<EncryptionFlowConfig>;\n\nimport EncryptionDataFlow::PathGraph\n\n// Query: Identify unsafe v1 encryption usage paths\nfrom EncryptionDataFlow::PathNode sourceNode, EncryptionDataFlow::PathNode sinkNode\nwhere EncryptionDataFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode, sourceNode, sinkNode, \"Unsafe usage of v1 version of Azure Storage client-side encryption\"",
    "output": "node = anyStorageClient(_).getAValueReachableFromSource() and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commented-out-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code blocks containing commented-out source code, which",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commented-out code\n * @description Detects code blocks containing commented-out source code, which\n *              negatively impacts code readability and maintainability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code\n */\n\n// Import Python language support for code analysis\nimport python\n\n// Import lexical analysis utilities for commented code detection\nimport Lexical.CommentedOutCode\n\n// Identify commented-out code blocks, excluding potential examples\nfrom CommentedOutCodeBlock commentedOutBlock\nwhere not commentedOutBlock.maybeExampleCode()\n// Report the location of problematic commented code\nselect commentedOutBlock, \"This comment appears to contain commented-out code.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Generates information about alert suppressions in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import CodeQL alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing module\nprivate import semmle.python.Comment as P\n\n// Represents AST nodes with location tracking capabilities\nclass AstNode instanceof P::AstNode {\n  // Verify node location matches specified coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Provide string representation of the AST node\n  string toString() { result = super.toString() }\n}\n\n// Represents single-line comments with location tracking\nclass SingleLineComment instanceof P::Comment {\n  // Verify comment location matches specified coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Retrieve the textual content of the comment\n  string getText() { result = super.getContents() }\n\n  // Provide string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships using AS template\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Represents noqa-style suppression comments\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Initialize by matching noqa comment pattern\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Return suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define code coverage scope for this suppression\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Extract and validate location details from comment\n    exists(int cmtStartLine, int cmtEndLine, int cmtEndCol |\n      this.hasLocationInfo(filePath, cmtStartLine, _, cmtEndLine, cmtEndCol) and\n      // Enforce line-start position and match boundaries\n      startLine = cmtStartLine and\n      endLine = cmtEndLine and\n      startCol = 1 and\n      endCol = cmtEndCol\n    )\n  }\n}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-number-class-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测类实例化调用时传递的参数数量与构造函数(__init__方法)期望的参数数量不符的情况。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 类实例化参数数量不匹配\n * @description 检测类实例化调用时传递的参数数量与构造函数(__init__方法)期望的参数数量不符的情况。\n *               这种不匹配会导致运行时抛出TypeError异常，影响程序的健壮性。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call instantiationCall, ClassValue targetClassType, string argumentErrorType, string argumentConstraintPrefix, int expectedArgCount, FunctionValue classConstructor\nwhere\n  // 获取目标类的构造函数（通常是__init__方法）\n  classConstructor = get_function_or_initializer(targetClassType) and\n  (\n    // 处理参数数量不匹配的两种情况：过多或过少\n    (\n      too_many_args(instantiationCall, targetClassType, expectedArgCount) and\n      argumentErrorType = \"too many arguments\" and\n      argumentConstraintPrefix = \"no more than \"\n    )\n    or\n    (\n      too_few_args(instantiationCall, targetClassType, expectedArgCount) and\n      argumentErrorType = \"too few arguments\" and\n      argumentConstraintPrefix = \"no fewer than \"\n    )\n  )\nselect instantiationCall, \"Call to $@ with \" + argumentErrorType + \"; should be \" + argumentConstraintPrefix + expectedArgCount.toString() + \".\", classConstructor,\n  // 输出调用点、错误消息及构造函数的完全限定名\n  classConstructor.getQualifiedName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unnecessary-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies redundant 'delete' operations on local variables",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unnecessary delete statement in function\n * @description Identifies redundant 'delete' operations on local variables\n *              that are automatically cleaned up when the function exits.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/unnecessary-delete\n */\n\nimport python\n\n// Recursively determines if a node is contained within any loop structure\npredicate isInsideLoop(AstNode currentNode) {\n  // Case 1: Direct child of a While or For loop\n  currentNode.getParentNode() instanceof While\n  or\n  currentNode.getParentNode() instanceof For\n  // Case 2: Descendant of a node already inside a loop\n  or\n  exists(AstNode parentInLoop | \n    isInsideLoop(parentInLoop) and \n    currentNode = parentInLoop.getAChildNode()\n  )\n}\n\n// Query to detect unnecessary delete statements at function termination\nfrom Delete delStatement, Expr deletedExpr, Function enclosingFunc\nwhere\n  // Position verification: delete is the final statement in the function\n  enclosingFunc.getLastStatement() = delStatement and\n  // Target identification: expression being deleted\n  deletedExpr = delStatement.getATarget() and\n  // Scope validation: expression is within function's scope\n  enclosingFunc.containsInScope(deletedExpr) and\n  // Exclusion 1: Skip subscript operations (e.g., del list[0])\n  not deletedExpr instanceof Subscript and\n  // Exclusion 2: Skip attribute access (e.g., del obj.attr)\n  not deletedExpr instanceof Attribute and\n  // Exclusion 3: Skip deletes within loop constructs\n  not isInsideLoop(delStatement) and\n  // Exclusion 4: Skip functions calling sys.exc_info (may need cleanup)\n  not exists(FunctionValue excInfoCall |\n    excInfoCall = Value::named(\"sys.exc_info\") and\n    excInfoCall.getACall().getScope() = enclosingFunc\n  )\nselect delStatement, \n  \"Unnecessary deletion of local variable $@ in function $@.\", \n  deletedExpr, deletedExpr.toString(), \n  enclosingFunc, enclosingFunc.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak elliptic curve\n * @description Identifies the use of cryptographic elliptic curve algorithms that are either unapproved or considered weak.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n_______________ // 补全条件\nwhere\n  // Case 1: The curve identifier is an unknown algorithm\n  (\n    curveIdentifier = cryptoOperation.getCurveName() and\n    curveIdentifier = unknownAlgorithm() and\n    alertMessage = \"Use of unrecognized curve algorithm.\"\n  )\n  or\n  // Case 2: The curve identifier is known but not in the approved list\n  (\n    curveIdentifier != unknownAlgorithm() and\n    curveIdentifier = cryptoOperation.getCurveName() and\n    not curveIdentifier =\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    alertMessage = \"Use of weak curve algorithm \" + curveIdentifier + \".\"\n  )\nselect cryptoOperation, alertMessage",
    "output": "from EllipticCurveAlgorithm cryptoOperation, string alertMessage, string curveIdentifier"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary 'else' clause in loop\n * @description An 'else' clause in a 'for' or 'while' statement that does not contain a 'break' is redundant.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-else\n */\n_______________ // 补全条件\nimport python  # 导入python库，用于分析Python代码\n\nfrom Stmt loop, StmtList body, StmtList clause, string kind  # 定义变量：loop表示循环语句，body表示循环体，clause表示else子句，kind表示循环类型（for或while）\nwhere\n  (\n    exists(For f | f = loop | clause = f.getOrelse() and body = f.getBody() and kind = \"for\")  # 检查是否存在一个for循环，其else子句和循环体满足条件，且类型为\"for\"\n    or\n    exists(While w | w = loop | clause = w.getOrelse() and body = w.getBody() and kind = \"while\")  # 检查是否存在一个while循环，其else子句和循环体满足条件，且类型为\"while\"\n  ) and\n  not exists(Break b | body.contains(b))  # 检查循环体内是否不存在break语句\nselect loop,  # 选择符合条件的循环语句\n  \"This '\" + kind + \"' statement has a redundant 'else' as no 'break' is present in the body.\"  # 输出警告信息，指出该循环语句存在冗余的else子句，因为循环体内没有break语句",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file access during archive extraction (\"Zip Slip\")\n * @description Detects unsafe archive extraction where malicious file paths containing '..' \n *              can circumvent directory restrictions, leading to unauthorized \n *              file system access.\n * @kind path-problem\n * @id py/zipslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.semmle.python.security.ZipSlip\nimport ZipSlipFlow::PathGraph\n\n// Identify vulnerable data flow paths from archive entries to file operations\n_______________ // 补全条件\nwhere \n  // Trace the complete flow path from source to sink\n  ZipSlipFlow::flowPath(taintedEntryNode, fileOpNode)\n\n// Generate vulnerability report with full path context\nselect \n  taintedEntryNode.getNode(), \n  taintedEntryNode, \n  fileOpNode,\n  \"This unsanitized archive entry (potentially containing '..') flows to a $@.\", \n  fileOpNode.getNode(),\n  \"file system operation\"",
    "output": "from ZipSlipFlow::PathNode taintedEntryNode, ZipSlipFlow::PathNode fileOpNode"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mostly-duplicate-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies modules with substantial code duplication. Refactoring these modules enhances maintainability and reduces technical debt.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Significant code duplication detector\n * @description Identifies modules with substantial code duplication. Refactoring these modules enhances maintainability and reduces technical debt.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-file\n */\n\nimport python\n\nfrom \n  Module primaryModule,\n  Module replicaModule,\n  string notificationMsg\nwhere \n  // This query has been intentionally disabled\n  none()\nselect \n  primaryModule,\n  notificationMsg,\n  replicaModule,\n  replicaModule.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-of-identical-expressions]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects comparisons where both operands are identical, which may indicate unclear intent.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Identical Value Comparison\n * @description Detects comparisons where both operands are identical, which may indicate unclear intent.\n * @kind problem\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\nimport python  // Import Python module for analyzing Python source code\nimport Expressions.RedundantComparison  // Import library for detecting redundant comparisons\n\n// Identify redundant comparisons from the RedundantComparison class\nfrom RedundantComparison redundantComparison\n// Apply filters: exclude constant comparisons and those potentially missing 'self'\nwhere \n  not redundantComparison.isConstant() and \n  not redundantComparison.maybeMissingSelf()\n// Select matching comparisons and generate appropriate warning message\nselect \n  redundantComparison, \n  \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mixed-tuple-returns]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects functions returning tuples with varying sizes, which may indicate design inconsistencies.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent tuple return lengths\n * @description Detects functions returning tuples with varying sizes, which may indicate design inconsistencies.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       quality\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mixed-tuple-returns\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n/**\n * Determines if a function returns a tuple with specific element count.\n * @param targetFunc - The function under analysis\n * @param tupleLength - The expected tuple length\n * @param returnedTuple - The tuple expression being returned\n */\npredicate returns_tuple_of_size(Function targetFunc, int tupleLength, Tuple returnedTuple) {\n  exists(Return retStmt, DataFlow::Node retFlowNode |\n    // Verify return statement belongs to target function\n    retStmt.getScope() = targetFunc and\n    // Map return value to data flow node\n    retFlowNode.asExpr() = retStmt.getValue() and\n    // Track data flow from tuple source to return node\n    exists(DataFlow::LocalSourceNode tupleSrc |\n      tupleSrc.asExpr() = returnedTuple and\n      tupleSrc.flowsTo(retFlowNode)\n    )\n  |\n    // Calculate tuple element count\n    tupleLength = count(int idx | exists(returnedTuple.getElt(idx)))\n  )\n}\n\nfrom Function targetFunc, int firstSize, int secondSize, AstNode firstTuple, AstNode secondTuple\nwhere\n  // Identify distinct tuple return sizes from same function\n  returns_tuple_of_size(targetFunc, firstSize, firstTuple) and\n  returns_tuple_of_size(targetFunc, secondSize, secondTuple) and\n  // Ensure size variation exists\n  firstSize < secondSize and\n  // Exclude functions with explicit return type hints\n  not exists(targetFunc.getDefinition().(FunctionExpr).getReturns())\nselect \n  targetFunc, \n  targetFunc.getQualifiedName() + \" returns $@ and $@.\", \n  firstTuple, \"tuple of size \" + firstSize, \n  secondTuple, \"tuple of size \" + secondSize"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commented-out-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code segments that have been commented out, which can reduce code readability and maintainability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commented-out code\n * @description Identifies code segments that have been commented out, which can reduce code readability and maintainability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code */\n\n// Import Python language analysis library for static code analysis\nimport python\n\n// Import Lexical module containing CommentedOutCode class for detecting commented-out code\nimport Lexical.CommentedOutCode\n\n// Query to find commented-out code blocks, excluding potential examples to minimize false positives\nfrom CommentedOutCodeBlock commentedBlock\nwhere not commentedBlock.maybeExampleCode()\n// Output the identified commented code blocks with an informative message\nselect commentedBlock, \"This comment appears to contain commented-out code.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Indirect imports per file\n * @description Computes the cumulative count of modules imported by each file, encompassing\n *              both immediate imports (via import statements) and indirect imports (modules\n *              imported by dependencies of the file).\n * @kind treemap\n * @id py/transitive-imports-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg max\n * @tags modularity\n */\n\n_______________ // 补全条件\nimport python\n\n// For each initial module and its corresponding aggregate import count\nfrom ModuleValue initialModule, int aggregateImportCount\n// Calculate the aggregate import count by counting all transitively imported modules\nwhere aggregateImportCount = \n       count(ModuleValue accessibleModule | \n             accessibleModule = initialModule.getAnImportedModule+() and \n             accessibleModule != initialModule)\n// Select the file scope of the initial module and its computed aggregate import count\nselect initialModule.getScope(), aggregateImportCount",
    "output": "// Import the Python library for code analysis"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-exception in 'except' clause\n * @description Identifies exception handlers that use non-exception types,\n *              which are ineffective as they never match actual exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Variables for analyzing exception handling constructs\nfrom ExceptFlowNode exceptNode, Value caughtType, ClassValue exceptionBase, \n     ControlFlowNode sourceNode, string typeInfo\nwhere\n  // Verify the handler processes a specific exception type from the source\n  exceptNode.handledException(caughtType, exceptionBase, sourceNode) and\n  (\n    // Case 1: Type is a class but not a valid exception\n    exists(ClassValue invalidType | \n      invalidType = caughtType and\n      not invalidType.isLegalExceptionType() and\n      not invalidType.failedInference(_) and\n      typeInfo = \"class '\" + invalidType.getName() + \"'\"\n    )\n_______________ // 补全条件\n    // Case 2: Type is not a class value\n    not caughtType instanceof ClassValue and\n    typeInfo = \"instance of '\" + exceptionBase.getName() + \"'\"\n  )\nselect exceptNode.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  sourceNode, typeInfo",
    "output": "or"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comment-density-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the ratio of comment lines to total lines in Python source files.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python source code comment density evaluation\n * @description Calculates the ratio of comment lines to total lines in Python source files.\n *              This analysis focuses exclusively on standard comments, deliberately excluding\n *              docstrings which are considered separate documentation components.\n * @kind treemap\n * @id py/comment-density-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\nfrom Module sourceModule\nwhere sourceModule.getMetrics().getNumberOfLines() > 0\nselect sourceModule,\n       (100.0 * sourceModule.getMetrics().getNumberOfLinesOfComments()) / sourceModule.getMetrics().getNumberOfLines() as commentDensity\norder by commentDensity desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/print-during-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies print statements in module scope that aren't protected by",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Print statement at module level without main guard\n * @description Identifies print statements in module scope that aren't protected by \n *              `if __name__ == '__main__'` guards. These statements execute during \n *              module import, which is typically unintended behavior.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/print-during-import\n */\n\nimport python\n\n// Checks if an If statement implements the standard Python main guard pattern\npredicate isMainGuard(If guardStmt) {\n  exists(Name nameVar, StringLiteral mainLiteral, Compare comparison |\n    guardStmt.getTest() = comparison and\n    comparison.getLeft() = nameVar and\n    comparison.getAComparator() = mainLiteral and\n    nameVar.getId() = \"__name__\" and\n    mainLiteral.getText() = \"__main__\"\n  )\n}\n\n// Detects both Python 2 print statements and Python 3 print function calls\npredicate isPrintStatement(Stmt stmt) {\n  stmt instanceof Print\n  or\n  exists(ExprStmt exprStmt, Call callNode, Name funcName |\n    exprStmt = stmt and\n    callNode = exprStmt.getValue() and\n    funcName = callNode.getFunc() and\n    funcName.getId() = \"print\"\n  )\n}\n\n// Find print statements that execute during module import\nfrom Stmt printStmt\nwhere\n  isPrintStatement(printStmt) and\n  // Verify the statement is in a module scope used for imports\n  exists(ModuleValue moduleVal | \n    moduleVal.getScope() = printStmt.getScope() and \n    moduleVal.isUsedAsModule()\n  ) and\n  // Ensure the print is not protected by a main guard\n  not exists(If guardStmt | \n    isMainGuard(guardStmt) and \n    guardStmt.getASubStatement().getASubStatement*() = printStmt\n  )\nselect printStmt, \"Print statement may execute during import.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable 'except' block\n * @description Identifies exception handlers that are shadowed by preceding broader handlers,\n *              making them unreachable as exceptions are caught by the earlier handler.\n * @kind problem\n * @tags reliability\n_______________ // 补全条件\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Extracts the exception type handled by an except clause\nClassValue getHandledExceptionType(ExceptStmt exceptClause) { \n  exceptClause.getType().pointsTo(result) \n}\n\n// Detects shadowed exception handlers where a broader handler precedes a narrower one\npredicate isShadowedExceptionHandler(ExceptStmt priorHandler, ClassValue generalException, \n                                     ExceptStmt subsequentHandler, ClassValue specificException) {\n  exists(int priorIndex, int subsequentIndex, Try tryBlock |\n    // Both handlers belong to the same try block\n    priorHandler = tryBlock.getHandler(priorIndex) and\n    subsequentHandler = tryBlock.getHandler(subsequentIndex) and\n    // Source order: prior handler appears before subsequent handler\n    priorIndex < subsequentIndex and\n    // Retrieve exception types for both handlers\n    generalException = getHandledExceptionType(priorHandler) and\n    specificException = getHandledExceptionType(subsequentHandler) and\n    // Prior handler catches a superclass of subsequent handler's exception\n    generalException = specificException.getASuperType()\n  )\n}\n\n// Main query identifying all unreachable exception handlers\nfrom ExceptStmt priorHandler, ClassValue generalException, \n     ExceptStmt subsequentHandler, ClassValue specificException\nwhere isShadowedExceptionHandler(priorHandler, generalException, subsequentHandler, specificException)\nselect subsequentHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  specificException, specificException.getName(), priorHandler, \"except block\", generalException, generalException.getName()",
    "output": "*       maintainability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies functions with names starting with an uppercase letter, which can reduce code readability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed function\n * @description Identifies functions with names starting with an uppercase letter, which can reduce code readability.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python\n\n// Define a predicate to determine if a function's name begins with an uppercase letter\npredicate hasUppercaseStart(Function fn) {\n  exists(string initialChar |\n    initialChar = fn.getName().prefix(1) and  // Extract the first character of the function name\n    initialChar = initialChar.toUpperCase()  // Verify if the first character is uppercase\n  )\n}\n\n// Identify functions that match our criteria\nfrom Function candidateFn\nwhere\n  // Ensure the function is present in the source code\n  candidateFn.inSource() and\n  // Function name starts with an uppercase letter\n  hasUppercaseStart(candidateFn) and\n  // Ensure this is the only function with an uppercase-starting name in its file\n  not exists(Function similarFn |\n    similarFn != candidateFn and  // Exclude other functions with the same name\n    similarFn.getLocation().getFile() = candidateFn.getLocation().getFile() and  // Located in the same file\n    hasUppercaseStart(similarFn)  // And also starts with an uppercase letter\n  )\nselect candidateFn, \"Function names should start in lowercase.\"  // Report these functions with a recommendation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides a comprehensive analysis of type annotation usage in Python code,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Provides a comprehensive analysis of type annotation usage in Python code,\n *              categorizing and quantifying parameter annotations, return types, and\n *              annotated assignments. This query generates metrics on built-in types,\n *              forward declarations, simple types, complex types, and optional types.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents Python built-in types (e.g., int, str, bool)\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TypeAnnotatableElement =\n  TTypeAnnotatableFunctionElement(FunctionExpr functionExpr) { exists(functionExpr.getReturns()) } or\n  TTypeAnnotatableParameterElement(Parameter parameter) { exists(parameter.getAnnotation()) } or\n  TTypeAnnotatableAssignmentElement(AnnAssign assignment) { exists(assignment.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class TypeAnnotationElement extends TypeAnnotatableElement {\n  string toString() { result = \"TypeAnnotationElement\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass FunctionTypeAnnotationElement extends TTypeAnnotatableFunctionElement, TypeAnnotationElement {\n  FunctionExpr functionExpr;\n\n  FunctionTypeAnnotationElement() { this = TTypeAnnotatableFunctionElement(functionExpr) }\n  override Expr getAnnotation() { result = functionExpr.getReturns() }\n}\n\n// Parameters with type annotations\nclass ParameterTypeAnnotationElement extends TTypeAnnotatableParameterElement, TypeAnnotationElement {\n  Parameter parameter;\n\n  ParameterTypeAnnotationElement() { this = TTypeAnnotatableParameterElement(parameter) }\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AssignmentTypeAnnotationElement extends TTypeAnnotatableAssignmentElement, TypeAnnotationElement {\n  AnnAssign assignment;\n\n  AssignmentTypeAnnotationElement() { this = TTypeAnnotatableAssignmentElement(assignment) }\n  override Expr getAnnotation() { result = assignment.getAnnotation() }\n}\n\n/** Determines if `typeAnnotation` is a forward-declared type (string literal). */\npredicate is_forward_declaration(Expr typeAnnotation) { typeAnnotation instanceof StringLiteral }\n\n/** Determines if `typeAnnotation` is a complex type that may be difficult to analyze. */\npredicate is_complex_type(Expr typeAnnotation) {\n  (typeAnnotation instanceof Subscript and not is_optional_type(typeAnnotation)) or\n  typeAnnotation instanceof Tuple or\n  typeAnnotation instanceof List\n}\n\n/** Determines if `typeAnnotation` is an Optional type (e.g., Optional[...]). */\npredicate is_optional_type(Subscript typeAnnotation) { typeAnnotation.getObject().(Name).getId() = \"Optional\" }\n\n/** Determines if `typeAnnotation` is a simple type (non-built-in identifier or attribute chain). */\npredicate is_simple_type(Expr typeAnnotation) {\n  (typeAnnotation instanceof Name and not typeAnnotation instanceof BuiltinType) or\n  is_simple_type(typeAnnotation.(Attribute).getObject())\n}\n\n/** Determines if `typeAnnotation` is a built-in type. */\npredicate is_builtin_type(Expr typeAnnotation) { typeAnnotation instanceof BuiltinType }\n\n// Computes metrics for parameter type annotations\npredicate parameter_annotation_metrics(\n  int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  totalCount = count(ParameterTypeAnnotationElement annotatedParameter) and\n  builtinCount = count(ParameterTypeAnnotationElement annotatedParameter | is_builtin_type(annotatedParameter.getAnnotation())) and\n  forwardDeclCount = count(ParameterTypeAnnotationElement annotatedParameter | is_forward_declaration(annotatedParameter.getAnnotation())) and\n  simpleTypeCount = count(ParameterTypeAnnotationElement annotatedParameter | is_simple_type(annotatedParameter.getAnnotation())) and\n  complexTypeCount = count(ParameterTypeAnnotationElement annotatedParameter | is_complex_type(annotatedParameter.getAnnotation())) and\n  optionalTypeCount = count(ParameterTypeAnnotationElement annotatedParameter | is_optional_type(annotatedParameter.getAnnotation()))\n}\n\n// Computes metrics for return type annotations\npredicate return_type_annotation_metrics(\n  int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  totalCount = count(FunctionTypeAnnotationElement annotatedFunction) and\n  builtinCount = count(FunctionTypeAnnotationElement annotatedFunction | is_builtin_type(annotatedFunction.getAnnotation())) and\n  forwardDeclCount = count(FunctionTypeAnnotationElement annotatedFunction | is_forward_declaration(annotatedFunction.getAnnotation())) and\n  simpleTypeCount = count(FunctionTypeAnnotationElement annotatedFunction | is_simple_type(annotatedFunction.getAnnotation())) and\n  complexTypeCount = count(FunctionTypeAnnotationElement annotatedFunction | is_complex_type(annotatedFunction.getAnnotation())) and\n  optionalTypeCount = count(FunctionTypeAnnotationElement annotatedFunction | is_optional_type(annotatedFunction.getAnnotation()))\n}\n\n// Computes metrics for annotated assignments\npredicate assignment_annotation_metrics(\n  int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  totalCount = count(AssignmentTypeAnnotationElement annotatedAssignment) and\n  builtinCount = count(AssignmentTypeAnnotationElement annotatedAssignment | is_builtin_type(annotatedAssignment.getAnnotation())) and\n  forwardDeclCount = count(AssignmentTypeAnnotationElement annotatedAssignment | is_forward_declaration(annotatedAssignment.getAnnotation())) and\n  simpleTypeCount = count(AssignmentTypeAnnotationElement annotatedAssignment | is_simple_type(annotatedAssignment.getAnnotation())) and\n  complexTypeCount = count(AssignmentTypeAnnotationElement annotatedAssignment | is_complex_type(annotatedAssignment.getAnnotation())) and\n  optionalTypeCount = count(AssignmentTypeAnnotationElement annotatedAssignment | is_optional_type(annotatedAssignment.getAnnotation()))\n}\n\n// Combines metrics for all categories of type annotations\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  (\n    category = \"Parameter annotation\" and\n    parameter_annotation_metrics(totalCount, builtinCount, forwardDeclCount, \n                              simpleTypeCount, complexTypeCount, optionalTypeCount)\n  )\n  or\n  // Return type annotation metrics\n  (\n    category = \"Return type annotation\" and\n    return_type_annotation_metrics(totalCount, builtinCount, forwardDeclCount, \n                              simpleTypeCount, complexTypeCount, optionalTypeCount)\n  )\n  or\n  // Annotated assignment metrics\n  (\n    category = \"Annotated assignment\" and\n    assignment_annotation_metrics(totalCount, builtinCount, forwardDeclCount, \n                               simpleTypeCount, complexTypeCount, optionalTypeCount)\n  )\n}\n\n// Query execution and results output\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                       simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using '\\b' to escape the backspace character in a regular expression is confusing",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Backspace escape in regular expression\n * @description Using '\\b' to escape the backspace character in a regular expression is confusing\n *              since it could be mistaken for a word boundary assertion.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int escapePosition\nwhere\n  // 验证指定位置存在转义字符\n  regexPattern.escapingChar(escapePosition) and\n  // 验证转义字符后紧跟字符'b'\n  regexPattern.getChar(escapePosition + 1) = \"b\" and\n  // 确认转义序列位于字符集边界内\n  exists(int charSetStart, int charSetEnd | \n    charSetStart < escapePosition and \n    charSetEnd > escapePosition | \n    regexPattern.charSet(charSetStart, charSetEnd)\n  )\nselect regexPattern, \"Backspace escape in regular expression at offset \" + escapePosition + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Identify classes implementing descriptor protocol that contain mutation operations\npredicate containsDescriptorMutation(ClassObject descriptorClass, SelfAttributeStore mutationOperation) {\n  // Verify target class implements descriptor protocol\n  descriptorClass.isDescriptorType() and\n  // Find descriptor protocol methods (__get__/__set__/__delete__)\n  exists(PyFunctionObject descriptorMethod, string protocolMethodName |\n    // Retrieve descriptor protocol method implementation\n    descriptorClass.lookupAttribute(protocolMethodName) = descriptorMethod and\n    // Match descriptor protocol method names\n    (protocolMethodName = \"__get__\" or protocolMethodName = \"__set__\" or protocolMethodName = \"__delete__\") and\n    // Locate member functions called by descriptor methods\n    exists(PyFunctionObject memberFunction |\n      // Called function is a member of target class\n      descriptorClass.lookupAttribute(_) = memberFunction and\n      // Descriptor method directly/indirectly invokes member function\n      descriptorMethod.getACallee*() = memberFunction and\n      // Exclude initialization method (__init__)\n      not memberFunction.getName() = \"__init__\" and\n_______________ // 补全条件\n      mutationOperation.getScope() = memberFunction.getFunction()\n    )\n  )\n}\n\n// Find classes with descriptor mutations and corresponding operations\nfrom ClassObject descriptorClass, SelfAttributeStore mutationOperation\nwhere containsDescriptorMutation(descriptorClass, mutationOperation)\n// Output mutation location, warning message, related class and its name\nselect mutationOperation,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorClass, descriptorClass.getName()",
    "output": "// Mutation occurs within member function scope"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Classes per file\n * @description Analyzes and counts the number of classes defined in each source file\n * @kind treemap\n * @id py/classes-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python\n\n// Identify each Python source file and calculate the number of class definitions it contains\nfrom Module sourceFile, int classDefinitionCount\n\n// For each Python module, count all class definitions that are directly enclosed within it\nwhere classDefinitionCount = count(Class classEntity | classEntity.getEnclosingModule() = sourceFile)\n\n_______________ // 补全条件\n// sorted in descending order based on the number of classes\nselect sourceFile, classDefinitionCount order by classDefinitionCount desc",
    "output": "// Present the analysis results: display each source file along with its class count,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 评估指向关系图的压缩效率指标：量化唯一事实数量与关系总规模，\n * 分析上下文深度对压缩比率的影响。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n_______________ // 补全条件\n// 定义查询输出指标：唯一事实计数、关系总规模、上下文深度和压缩效率\nfrom int uniqueFactsCount, int totalRelationsSize, int ctxDepth, float compressionRate\nwhere\n  // 唯一事实计数：统计不同(控制流节点, 指向对象, 目标类)组合的数量\n  uniqueFactsCount =\n    strictcount(ControlFlowNode flowNode, Object pointedObject, ClassObject targetClass |\n      exists(PointsToContext analysisContext |\n        // 验证在分析上下文中，控制流节点指向对象，且该对象是目标类的实例\n        PointsTo::points_to(flowNode, analysisContext, pointedObject, targetClass, _) and\n        ctxDepth = analysisContext.getDepth()\n      )\n    ) and\n  // 关系总规模：统计所有(控制流节点, 指向对象, 目标类, 分析上下文, 源节点)组合的数量\n  totalRelationsSize =\n    strictcount(ControlFlowNode flowNode, Object pointedObject, ClassObject targetClass, \n      PointsToContext analysisContext, ControlFlowNode originNode |\n      // 验证在分析上下文中，控制流节点指向对象，且该对象是目标类的实例，并记录源节点\n      PointsTo::points_to(flowNode, analysisContext, pointedObject, targetClass, originNode) and\n      ctxDepth = analysisContext.getDepth()\n    ) and\n  // 压缩效率计算：唯一事实数量与关系总规模的百分比比率\n  compressionRate = 100.0 * uniqueFactsCount / totalRelationsSize\n// 输出分析结果：上下文深度、唯一事实计数、关系总规模和压缩效率\nselect ctxDepth, uniqueFactsCount, totalRelationsSize, compressionRate",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Wildcard Import Usage\n * @description Detects Python source files containing wildcard imports ('from ... import *').\n *              This practice can lead to namespace pollution and make code harder to understand.\n * @kind problem\n * @tags maintainability\n_______________ // 补全条件\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// Import the Python analysis module to enable code inspection capabilities\nimport python\n\n// Find all import statements that use the wildcard ('*') syntax\n// The ImportStar class represents these statements in the Python abstract syntax tree\nfrom ImportStar wildcardImport\n\n// Create an alert for each identified wildcard import\n// Each alert provides the import location and explains why this pattern is discouraged\nselect wildcardImport, \"Wildcard imports ('from ... import *') can clutter namespaces and negatively impact code maintainability.\"",
    "output": "* @problem.severity recommendation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__init__` method is a generator\n * @description `__init__` 方法是一个生成器。\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/init-method-is-generator\n */\n\nimport python\n\nfrom Function f\nwhere\n  // 检查函数是否是类的初始化方法（即 __init__ 方法）\n  f.isInitMethod() and\n_______________ // 补全条件\n  (exists(Yield y | y.getScope() = f) or exists(YieldFrom y | y.getScope() = f))\nselect f, \"__init__ method is a generator.\"",
    "output": "// 检查函数体内是否存在 yield 或 yield from 语句，表示该函数是生成器"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/full-ssrf]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects HTTP requests where the entire URL is controlled by external input, enabling SSRF attacks",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Complete server-side request forgery vulnerability\n * @description Detects HTTP requests where the entire URL is controlled by external input, enabling SSRF attacks\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision high\n * @id py/full-ssrf\n * @tags security\n *       external/cwe/cwe-918\n */\n\n// Import required Python analysis modules\nimport python\n// Import SSRF detection framework\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\n// Import path tracking for SSRF flows\nimport FullServerSideRequestForgeryFlow::PathGraph\n\n// Identify complete SSRF vulnerability paths through tainted data flow\nfrom\n  // Source of untrusted user input\n  FullServerSideRequestForgeryFlow::PathNode untrustedInputSource,\n  // Sink where tainted data reaches HTTP request\n  FullServerSideRequestForgeryFlow::PathNode httpRequestSink,\n  // Vulnerable HTTP client request\n  Http::Client::Request vulnerableRequest\nwhere\n  // Establish data flow path from source to sink\n  FullServerSideRequestForgeryFlow::flowPath(untrustedInputSource, httpRequestSink) and\n  // Map sink node to actual HTTP request\n  vulnerableRequest = httpRequestSink.getNode().(Sink).getRequest() and\n  // Verify complete user control over request URL\n  fullyControlledRequest(vulnerableRequest)\nselect\n  // Report vulnerable request and flow path\n  vulnerableRequest, untrustedInputSource, httpRequestSink,\n  // Generate vulnerability description\n  \"Complete URL controlled by $@.\", untrustedInputSource.getNode(),\n  \"untrusted user input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/classic-model/hash-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all instances where cryptographic hash algorithms are utilized within the codebase,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Hash Algorithms\n * @description Identifies all instances where cryptographic hash algorithms are utilized within the codebase,\n *              including both standard hashing algorithms and password-specific hashing algorithms.\n *              This detection is performed across all supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/hash-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import necessary Python and Semmle libraries for cryptographic analysis\nimport python\nimport semmle.python.Concepts\n\n// Define variables for cryptographic operations and algorithms\nfrom Cryptography::CryptographicOperation cryptographicOperation, Cryptography::CryptographicAlgorithm cryptographicAlgorithm\nwhere\n  // Establish relationship between operation and its algorithm\n  cryptographicAlgorithm = cryptographicOperation.getAlgorithm() and\n  (\n    // Check if the algorithm is a standard hashing algorithm\n    cryptographicAlgorithm instanceof Cryptography::HashingAlgorithm or\n    // Check if the algorithm is a password-specific hashing algorithm\n    cryptographicAlgorithm instanceof Cryptography::PasswordHashingAlgorithm\n  )\n// Select the cryptographic operation and provide a descriptive message about the algorithm used\nselect cryptographicOperation, \"Use of algorithm \" + cryptographicOperation.getAlgorithm().getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Test methods count\n * @description Computes the quantity of test functions contained in each Python module\n * @kind treemap\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg sum max\n * @id py/tests-in-files\n */\n\n_______________ // 补全条件\nimport python\n// Import utilities for test detection and filtering\nimport semmle.python.filters.Tests\n\n// Main query for counting test methods per module\nfrom Module pythonModule, int testMethodCount\nwhere \n  // Determine the precise count of test methods within each module\n  testMethodCount = strictcount(Test testCase | \n    testCase.getEnclosingModule() = pythonModule\n  )\n// Output module file path along with its test count, ordered by count in descending order\nselect pythonModule.getFile(), testMethodCount order by testMethodCount desc",
    "output": "// Import Python language analysis capabilities"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mutable-descriptor]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Enhanced predicate to detect descriptor mutation within accessor methods\npredicate mutates_descriptor(ClassObject descriptorClass, SelfAttributeStore attrStore) {\n  // Verify the class implements the descriptor protocol\n  descriptorClass.isDescriptorType() and\n  // Identify accessor methods (__get__/__set__/__delete__)\n  exists(PyFunctionObject descriptorAccessor |\n    exists(string accessorMethodName |\n      // Check standard descriptor method names\n      (accessorMethodName = \"__get__\" or \n       accessorMethodName = \"__set__\" or \n       accessorMethodName = \"__delete__\") and\n      // Ensure the class contains this accessor method\n      descriptorClass.lookupAttribute(accessorMethodName) = descriptorAccessor\n    ) and\n    // Locate mutation methods called by accessors\n    exists(PyFunctionObject mutationMethod |\n      // Verify mutation method belongs to the descriptor class\n      descriptorClass.lookupAttribute(_) = mutationMethod and\n      // Confirm mutation method is invoked by the accessor\n      descriptorAccessor.getACallee*() = mutationMethod and\n      // Exclude initialization methods from mutation analysis\n      not mutationMethod.getName() = \"__init__\" and\n      // Ensure attribute mutation occurs within mutation method's scope\n      attrStore.getScope() = mutationMethod.getFunction()\n    )\n  )\n}\n\n// Query for descriptor mutations\nfrom ClassObject descriptorClass, SelfAttributeStore attrStore\nwhere mutates_descriptor(descriptorClass, attrStore)\nselect attrStore,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorClass, descriptorClass.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Symmetric Encryption Algorithms Detection\n * @description Identifies all occurrences of symmetric encryption algorithm usage \n *              within Python codebases through supported cryptographic libraries.\n *              This detection helps assess quantum readiness by flagging potentially\n *              vulnerable cryptographic implementations.\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-encryption-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricEncryptionAlgorithm symmetricAlgorithm\nselect symmetricAlgorithm, \n       \"Use of algorithm \" + symmetricAlgorithm.getEncryptionName()",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies cookie creation using untrusted user input,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cookie Construction from User-Supplied Input\n * @description Identifies cookie creation using untrusted user input,\n *              potentially enabling Cookie Poisoning attacks.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// Import core Python analysis libraries\nimport python\n\n// Import specialized modules for cookie injection detection\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Import path graph representation for data flow tracking\nimport CookieInjectionFlow::PathGraph\n\n// Define path nodes representing tainted input sources and cookie construction sinks\nfrom CookieInjectionFlow::PathNode taintedSource, \n     CookieInjectionFlow::PathNode cookieSink\n// Verify data flows from untrusted source to cookie construction\nwhere CookieInjectionFlow::flowPath(taintedSource, cookieSink)\n// Report findings with sink location, source node, path details, and contextual message\nselect cookieSink.getNode(), \n       taintedSource, \n       cookieSink, \n       \"Cookie is constructed from a $@.\", \n       taintedSource.getNode(),\n       \"user-supplied input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/member-test-non-container]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects membership tests (e.g., 'item in sequence') where the right-hand side is not a container type, which may raise TypeError.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Membership test with a non-container\n * @description Detects membership tests (e.g., 'item in sequence') where the right-hand side is not a container type, which may raise TypeError.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python  // Provides core Python language analysis capabilities\nimport semmle.python.pointsto.PointsTo  // Enables points-to analysis for value tracking\n\n// Identifies comparison operations containing In/NotIn operators with specified right-hand side\npredicate isMembershipTestRhs(ControlFlowNode rhsNode, Compare comparison) {\n  exists(Cmpop operator, int operandIndex |\n    comparison.getOp(operandIndex) = operator and\n    comparison.getComparator(operandIndex) = rhsNode.getNode() and\n    (operator instanceof In or operator instanceof NotIn)\n  )\n}\n\n// Analyzes membership tests where RHS may be non-container\nfrom ControlFlowNode nonContainerNode, Compare comparison, Value targetValue, ClassValue targetClass, ControlFlowNode sourceNode\nwhere\n  isMembershipTestRhs(nonContainerNode, comparison) and  // Confirm RHS is part of membership test\n  nonContainerNode.pointsTo(_, targetValue, sourceNode) and  // Track value flow to RHS\n  targetValue.getClass() = targetClass and  // Extract class of RHS value\n  // Exclude cases with type inference failures\n  not Types::failedInference(targetClass, _) and\n  // Verify absence of container protocol methods\n  not targetClass.hasAttribute(\"__contains__\") and\n  not targetClass.hasAttribute(\"__iter__\") and\n  not targetClass.hasAttribute(\"__getitem__\") and\n  // Exclude special cases with non-standard container behavior\n  not targetClass = ClassValue::nonetype() and\n  not targetClass = Value::named(\"types.MappingProxyType\")\nselect comparison, \"Membership test may fail as the $@ belongs to non-container class $@.\", sourceNode,\n  \"target\", targetClass, targetClass.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unknown-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别在非对称加密密钥生成过程中使用无法静态确定密钥长度的操作",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 非对称密钥生成中的未知密钥大小\n * @description 识别在非对称加密密钥生成过程中使用无法静态确定密钥长度的操作\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 检测非对称密钥生成操作中密钥大小无法静态确认的情况\nfrom AsymmetricKeyGen cryptoKeyGen, DataFlow::Node keyConfigNode, string cryptoAlgorithm\nwhere\n  // 获取密钥配置源节点\n  keyConfigNode = cryptoKeyGen.getKeyConfigSrc() and\n  // 获取所使用的加密算法名称\n  cryptoAlgorithm = cryptoKeyGen.getAlgorithm().getName() and\n  // 确认密钥生成操作没有静态验证的密钥大小参数\n  not cryptoKeyGen.hasKeySize(keyConfigNode)\nselect cryptoKeyGen,\n  // 生成问题报告，包含算法信息和配置源\n  \"用于算法 \" + cryptoAlgorithm.toString() + \" 的密钥生成使用了无法静态验证的密钥大小，在配置源 $@\", keyConfigNode, keyConfigNode.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/dependency-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：外部依赖源链接",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name 外部依赖源链接\n * @kind source-link\n * @metricType externalDependency\n * @id py/dependency-source-links\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/**\n * 查询目标：为外部依赖生成源链接信息\n * \n * 背景说明：\n * - 外部依赖实体表示为'/file/path<|>dependency'格式\n * - 路径部分是相对于源代码存档根目录的字符串\n * - 这些路径需要通过File实体建立版本关联\n * \n * 功能描述：\n * - 识别代码文件与外部依赖之间的关系\n * - 生成仪表板数据库可用的源链接信息\n * - 输出中的File实体可通过ExternalEntity.getASourceLink()恢复源链接\n * \n * 实现逻辑：\n * 1. 遍历所有Python代码文件\n * 2. 查找每个文件引用的外部包\n * 3. 为文件-包对生成依赖标识符\n * 4. 输出依赖标识符和源文件\n */\n\nfrom File codeFile, string dependencyId\nwhere\n  exists(PackageObject externalPackage, AstNode importStatement |\n    // 确认从当前文件的导入语句到外部包存在依赖关系\n    dependency(importStatement, externalPackage) and\n    // 验证导入语句位于当前处理的源文件中\n    importStatement.getLocation().getFile() = codeFile and\n    // 生成源文件和依赖包的唯一标识符\n    dependencyId = munge(codeFile, externalPackage)\n  )\nselect dependencyId, codeFile"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A module imports itself",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description A module imports itself\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n/**\n * Identifies self-import scenarios where a module imports its own code\n * \n * This predicate detects circular import patterns where a module attempts to import itself.\n * Such imports are anti-patterns that introduce unnecessary complexity and potential circular\n * dependencies without providing functional benefits. The analysis handles both absolute and\n * relative imports by matching the longest possible module name.\n * \n * Parameters:\n * - selfImportStmt: The import statement performing the self-import\n * - targetModule: The module value representing the imported module\n */\npredicate isSelfImport(ImportingStmt selfImportStmt, ModuleValue targetModule) {\n  // Verify the containing module matches the imported module's scope\n  selfImportStmt.getEnclosingModule() = targetModule.getScope() and\n  // Resolve module ambiguity by selecting the longest matching module name\n  targetModule = \n    max(string moduleName, ModuleValue candidate |\n      // Extract imported module name from the statement\n      moduleName = selfImportStmt.getAnImportedModuleName() and\n      // Ensure candidate module corresponds to the imported name\n      candidate.importedAs(moduleName)\n    |\n      // Prioritize longer module names to handle relative imports correctly\n      candidate order by moduleName.length() desc\n    )\n}\n\n// Detect all self-import instances across the codebase\n// \n// This query identifies modules that import themselves through any import mechanism.\n// Each finding provides context about the specific import statement and the affected module,\n// helping developers eliminate unnecessary circular dependencies.\nfrom ImportingStmt selfImportStmt, ModuleValue targetModule\nwhere isSelfImport(selfImportStmt, targetModule)\nselect selfImportStmt, \"The module '\" + targetModule.getName() + \"' imports itself.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'super' in old style class\n * @description Identifies improper usage of super() calls within legacy Python classes\n *              that do not support new-style inheritance mechanisms.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * Locates super() function calls that are problematic because they occur\n * within methods of old-style classes, which lack proper inheritance support.\n * \n * Such calls will result in runtime errors since old-style classes do not\n * implement the MRO (Method Resolution Order) required by super().\n */\npredicate superCallInOldClass(Call superCallExpr) {\n  exists(Function methodContext, ClassObject parentClass |\n    // The super() call must be inside a method definition\n    superCallExpr.getScope() = methodContext and\n    // The method must be defined within a class\n    methodContext.getScope() = parentClass.getPyClass() and\n    // The class type must be successfully inferred by the analysis\n    not parentClass.failedInference() and\n    // The class must be an old-style class (not inheriting from 'object')\n    not parentClass.isNewStyle() and\n    // The call must be to the built-in 'super' function\n    superCallExpr.getFunc().(Name).getId() = \"super\"\n  )\n}\n\n// Main query to find all problematic super() calls\n_______________ // 补全条件\n// Apply our predicate to filter for super() calls in old-style classes\nwhere superCallInOldClass(problematicCall)\n// Generate the alert with an appropriate error message\nselect problematicCall, \"'super()' will not work in old-style classes.\"",
    "output": "from Call problematicCall"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-parameters-without-default-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates how many function parameters lack default value assignments.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Count of non-default parameters\n * @description Calculates how many function parameters lack default value assignments.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // 导入Python模块，用于支持Python代码的静态分析功能\n\n// 获取所有函数作为分析对象\nfrom FunctionMetrics func\n// 选择函数及其无默认值的参数计数\nselect func, \n       func.getNumberOfParametersWithoutDefault() as nonDefaultParamCount \n// 按无默认值参数数量降序排序\norder by nonDefaultParamCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Nested loops with same variable\n * @description Identifies nested for loops that utilize identical iteration variables,\n *              potentially causing code confusion and introducing bugs.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\n// Query to detect problematic nested loop patterns with shared iteration variables\n_______________ // 补全条件\nwhere \n  // Verify inner loop is directly nested within outer loop's body\n  outerForLoop.getBody().contains(innerForLoop) and\n  // Confirm both loops target the same variable for iteration\n  innerForLoop.getTarget().defines(reusedVariable) and\n  outerForLoop.getTarget().defines(reusedVariable) and\n  // Ensure the variable is referenced in outer scope beyond the inner loop\n  exists(Name variableReference | \n    variableReference.uses(reusedVariable) and \n    outerForLoop.contains(variableReference) and \n    not innerForLoop.contains(variableReference)\n  )\nselect innerForLoop, \n  \"Nested for loop reuses iteration variable '\" + reusedVariable.getId() + \"' from enclosing $@.\", \n  outerForLoop, \"for loop\"",
    "output": "from For innerForLoop, For outerForLoop, Variable reusedVariable"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/syntax-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python code containing syntax errors that cause runtime failures and impede static analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python Syntax Error Detection\n * @description Identifies Python code containing syntax errors that cause runtime failures and impede static analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error */\n\nimport python\n\n// Retrieve syntax errors while excluding encoding-related issues\nfrom SyntaxError syntaxErr\nwhere not (syntaxErr instanceof EncodingError)\n\n// Generate error message with Python version context\nselect syntaxErr, \n       syntaxErr.getMessage() + \" (in Python \" + major_version() + \").\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unhashable object hashed\n * @description Hashing an object which is not hashable will result in a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/hash-unhashable-value\n */\n\nimport python\n\n/*\n * This analysis identifies unhashable objects used in hashing contexts.\n * It assumes indexing operations require hashable keys except for sequences (which use integer indices)\n * and numpy arrays (which may use non-hashable list indices).\n */\n\n// Identifies numpy array types by checking inheritance from numpy.ndarray\npredicate numpy_array_type(ClassValue numpyArrayType) {\n  exists(ModuleValue numpyMod | \n    numpyMod.getName() = \"numpy\" or numpyMod.getName() = \"numpy.core\" |\n    numpyArrayType.getASuperType() = numpyMod.attr(\"ndarray\")\n  )\n}\n\n// Determines if a value implements custom indexing behavior via __getitem__\npredicate has_custom_getitem(Value value) {\n  value.getClass().lookup(\"__getitem__\") instanceof PythonFunctionValue\n  or\n  numpy_array_type(value.getClass())\n}\n\n// Detects explicit hash() function calls on values\npredicate explicitly_hashed(ControlFlowNode cfNode) {\n  exists(CallNode hashCallNode, GlobalVariable hashGlobalVar |\n    hashCallNode.getArg(0) = cfNode and \n    hashCallNode.getFunction().(NameNode).uses(hashGlobalVar) and \n    hashGlobalVar.getId() = \"hash\"\n  )\n}\n\n// Identifies subscript operations using unhashable indices\npredicate unhashable_subscript(ControlFlowNode indexCfNode, ClassValue unhashableCls, ControlFlowNode originCfNode) {\n  is_unhashable(indexCfNode, unhashableCls, originCfNode) and\n  exists(SubscriptNode subscriptNode | subscriptNode.getIndex() = indexCfNode |\n    exists(Value targetVal |\n      subscriptNode.getObject().pointsTo(targetVal) and\n      not has_custom_getitem(targetVal)\n    )\n  )\n}\n\n// Checks if an object is unhashable by examining its __hash__ implementation\npredicate is_unhashable(ControlFlowNode cfNode, ClassValue targetCls, ControlFlowNode originCfNode) {\n  exists(Value value | \n    cfNode.pointsTo(value, originCfNode) and \n_______________ // 补全条件\n    (\n      not targetCls.hasAttribute(\"__hash__\") and \n      not targetCls.failedInference(_) and \n      targetCls.isNewStyle()\n    )\n    or\n    targetCls.lookup(\"__hash__\") = Value::named(\"None\")\n  )\n}\n\n/**\n * Identifies nodes within try blocks that catch TypeError exceptions.\n * Used to filter false positives where TypeError is intentionally handled.\n * Example:\n *   try:\n *       ... node ...\n *   except TypeError:\n *       ...\n */\npredicate typeerror_is_caught(ControlFlowNode cfNode) {\n  exists(Try tryStmt |\n    tryStmt.getBody().contains(cfNode.getNode()) and\n    tryStmt.getAHandler().getType().pointsTo(ClassValue::typeError())\n  )\n}\n\n// Main query finding unhandled unhashable object usage\nfrom ControlFlowNode problemCfNode, ClassValue problemCls, ControlFlowNode originCfNode\nwhere\n  not typeerror_is_caught(problemCfNode) and\n  (\n    explicitly_hashed(problemCfNode) and is_unhashable(problemCfNode, problemCls, originCfNode)\n    or\n    unhashable_subscript(problemCfNode, problemCls, originCfNode)\n  )\nselect problemCfNode.getNode(), \"This $@ of $@ is unhashable.\", originCfNode, \"instance\", problemCls, problemCls.getQualifiedName()",
    "output": "value.getClass() = targetCls |"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/shell-command-constructed-from-input]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Building shell commands using strings from external sources",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unsafe shell command constructed from library input\n * @description Building shell commands using strings from external sources\n *              can lead to command injection vulnerabilities.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.3\n * @precision medium\n * @id py/shell-command-constructed-from-input\n * @tags correctness\n *       security\n *       external/cwe/cwe-078\n *       external/cwe/cwe-088\n *       external/cwe/cwe-073\n */\n\n// Core Python language support\nimport python\n\n// Security analysis module for shell command injection detection\nimport semmle.python.security.dataflow.UnsafeShellCommandConstructionQuery\n\n// Data flow path tracking infrastructure\nimport UnsafeShellCommandConstructionFlow::PathGraph\n\n// Identify vulnerable command construction patterns\nfrom\n  UnsafeShellCommandConstructionFlow::PathNode inputSource,    // External input origin\n  UnsafeShellCommandConstructionFlow::PathNode executionSink,   // Command execution point\n  Sink sinkInfo                                                // Detailed sink metadata\nwhere\n  // Verify data flow path from input to command execution\n  UnsafeShellCommandConstructionFlow::flowPath(inputSource, executionSink) and\n  // Map execution node to sink details\n  sinkInfo = executionSink.getNode()\nselect \n  // Vulnerability context: string construction details\n  sinkInfo.getStringConstruction(), \n  inputSource, \n  executionSink,\n  // Security impact description with contextual placeholders\n  \"This \" + sinkInfo.describe() + \n  \" which depends on $@ is later used in a $@.\", \n  inputSource.getNode(), \"library input\", \n  sinkInfo.getCommandExecution(), \"shell command\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Summarized callable invocation sites\n * @description Identifies code locations where summarized callables are invoked\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/summarized-callable-call-sites\n * @tags meta\n * @precision very-low\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\nimport meta.MetaMetrics\n\n// Identify invocation sites and their corresponding summarized callables\nfrom DataFlow::Node invocationSite, SummarizedCallable summarizedFunc, string invocationType\nwhere\n  // Filter out invocation sites in ignored files\n  not invocationSite.getLocation().getFile() instanceof IgnoredFile\n_______________ // 补全条件\n    // Direct invocation case\n    (invocationSite = summarizedFunc.getACall() and invocationType = \"Call\")\n    or\n    // Callback invocation case\n    (invocationSite = summarizedFunc.getACallback() and invocationType = \"Callback\")\n  )\n// Format output with invocation details\nselect invocationSite, invocationType + \" to \" + summarizedFunc",
    "output": "and ("
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/iter-returns-non-iterator]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes returned by `__iter__` methods that fail to implement",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__iter__` method returns non-iterator type\n * @description Identifies classes returned by `__iter__` methods that fail to implement \n *              the iterator protocol, which would trigger TypeErrors in iteration contexts\n *              such as for-loops.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iter-returns-non-iterator\n */\n\nimport python\n\nfrom ClassValue containerClass, FunctionValue iteratorMethod, ClassValue returnType\nwhere\n  // Locate the __iter__ method within the container class\n  iteratorMethod = containerClass.lookup(\"__iter__\") and\n  // Extract the inferred return type from the __iter__ method\n  returnType = iteratorMethod.getAnInferredReturnType() and\n  // Confirm the return type violates iterator protocol requirements\n  not returnType.isIterator()\nselect \n  returnType,\n  \"Class \" + returnType.getName() + \n    \" is returned as an iterator (by $@) but doesn't implement the iterator protocol.\",\n  iteratorMethod, iteratorMethod.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/partial-ssrf]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects HTTP requests where URL elements are tainted by untrusted user input,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Partial server-side request forgery\n * @description Detects HTTP requests where URL elements are tainted by untrusted user input,\n *              which could lead to server-side request forgery vulnerabilities\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision medium\n * @id py/partial-ssrf\n * @tags security\n *       external/cwe/cwe-918\n */\n\n// Import Python language support\nimport python\n// Import SSRF security analysis framework\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\n// Import partial SSRF data flow path analysis\nimport PartialServerSideRequestForgeryFlow::PathGraph\n\n// Define the core vulnerability pattern: HTTP requests with user-controlled URL components\nfrom\n  Http::Client::Request targetRequest,                          // Target HTTP request for analysis\n  PartialServerSideRequestForgeryFlow::PathNode taintedSource,  // Entry point of untrusted data\n  PartialServerSideRequestForgeryFlow::PathNode vulnerableSink  // Point where data is used in request\nwhere\n  // Verify data flow path exists from source to sink\n  PartialServerSideRequestForgeryFlow::flowPath(taintedSource, vulnerableSink) and\n  // Establish relationship between HTTP request and sink node\n  targetRequest = vulnerableSink.getNode().(Sink).getRequest() and\n  // Filter out requests with entirely controlled URLs to focus on partial SSRF\n  not fullyControlledRequest(targetRequest)\nselect targetRequest, taintedSource, vulnerableSink, \"URL component in this request originates from $@.\", taintedSource.getNode(),\n  \"user-provided input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects paths where cookies are constructed using untrusted user input,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Construction of a cookie using user-supplied input\n * @description Detects paths where cookies are constructed using untrusted user input,\n *              potentially enabling Cookie Poisoning attacks.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// Core Python analysis libraries\nimport python\n\n// Specialized data flow tracking for cookie injection vulnerabilities\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Path visualization components for data flow results\nimport CookieInjectionFlow::PathGraph\n\n// Identify dangerous data flow paths from untrusted sources to cookie creation points\nfrom CookieInjectionFlow::PathNode maliciousInputSource, CookieInjectionFlow::PathNode cookieCreationSink\n// Establish data flow connection between tainted source and sensitive sink\nwhere CookieInjectionFlow::flowPath(maliciousInputSource, cookieCreationSink)\n// Report findings with path context and vulnerability description\nselect cookieCreationSink.getNode(), \n       maliciousInputSource, \n       cookieCreationSink, \n       \"Cookie is constructed from a $@.\", \n       maliciousInputSource.getNode(),\n       \"user-supplied input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/command-line-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using externally controlled strings in a command line may allow a malicious",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Uncontrolled command line\n * @description Using externally controlled strings in a command line may allow a malicious\n *              user to change the meaning of the command.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/command-line-injection\n * @tags correctness\n *       security\n *       external/cwe/cwe-078\n *       external/cwe/cwe-088\n */\n\n// Import Python analysis libraries\nimport python\n\n// Import security dataflow analysis for command injection detection\nimport semmle.python.security.dataflow.CommandInjectionQuery\n\n// Import path graph representation for command injection flows\nimport CommandInjectionFlow::PathGraph\n\n// Identify untrusted sources and dangerous sinks in command execution\nfrom CommandInjectionFlow::PathNode untrustedSource, CommandInjectionFlow::PathNode dangerousSink\n// Verify data flow exists from untrusted source to dangerous sink\nwhere CommandInjectionFlow::flowPath(untrustedSource, dangerousSink)\n// Report results with flow path and vulnerability description\nselect dangerousSink.getNode(), untrustedSource, dangerousSink, \n       \"This command line depends on a $@.\", untrustedSource.getNode(),\n       \"user-provided value\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 低效正则表达式检测（ReDoS）\n * @description 识别可能导致指数级时间复杂度的正则表达式模式。\n *              这些模式在处理特定构造的输入时，会触发灾难性回溯，\n *              从而引发严重的性能问题和潜在的拒绝服务攻击。\n_______________ // 补全条件\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/redos\n * @tags security\n *       external/cwe/cwe-1333\n *       external/cwe/cwe-730\n *       external/cwe/cwe-400\n */\n\n// 导入Python正则表达式树视图模块，用于分析正则表达式结构\nprivate import semmle.python.regexp.RegexTreeView::RegexTreeView as TreeView\n// 导入指数回溯检测模块，并使用TreeView作为参数实例化\nimport codeql.regex.nfa.ExponentialBackTracking::Make<TreeView>\n\n// 定义查询变量：存在风险的正则表达式项、触发问题的重复模式、回溯状态和上下文信息\nfrom TreeView::RegExpTerm vulnerableRegexTerm, string triggerPattern, State backtrackState, string contextInfo\nwhere\n  // 检查当前正则表达式项是否存在导致指数级回溯的潜在风险\n  hasReDoSResult(vulnerableRegexTerm, triggerPattern, backtrackState, contextInfo) and\n  // 排除详细模式（VERBOSE）的正则表达式，因为它们通常包含格式化空格和注释\n  not vulnerableRegexTerm.getRegex().getAMode() = \"VERBOSE\"\nselect vulnerableRegexTerm,\n  // 构建详细的警告消息，指出风险点和潜在影响\n  \"正则表达式的这部分可能在包含大量'\" + triggerPattern + \"'重复的字符串\" + contextInfo +\n    \"上导致指数级回溯问题，从而引发性能瓶颈或拒绝服务攻击。\"",
    "output": "* @kind problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/command-line-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Execution of commands incorporating user-controlled input enables",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Command Line Injection\n * @description Execution of commands incorporating user-controlled input enables\n *              attackers to manipulate command behavior via malicious inputs.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/command-line-injection\n * @tags correctness\n *       security\n *       external/cwe/cwe-078\n *       external/cwe/cwe-088\n */\n\n// Import Python analysis framework\nimport python\n\n// Import specialized security dataflow library for command injection detection\nimport semmle.python.security.dataflow.CommandInjectionQuery\n\n// Import path graph representation for taint flow visualization\nimport CommandInjectionFlow::PathGraph\n\n// Define tainted source and command execution sink nodes\nfrom CommandInjectionFlow::PathNode taintedSource, CommandInjectionFlow::PathNode executionSink\n// Ensure data flows from tainted source to command execution sink\nwhere CommandInjectionFlow::flowPath(taintedSource, executionSink)\n// Report command execution point with taint path details\nselect executionSink.getNode(), taintedSource, executionSink, \n       \"This command execution depends on a $@.\", taintedSource.getNode(),\n       // Identify the source of untrusted input\n       \"user-provided value\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of re-commits for each file\n * @description Counts commits to files modified within 5 days of previous changes\n * @kind treemap\n * @id py/historical-number-of-re-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max */\n\nimport python\nimport external.VCS\n\n/**\n * Determines if two commits modify the same file within a 5-day timeframe\n * @param firstCommit - The initial commit that modified a file\n * @param secondCommit - A subsequent commit that modified the same file\n */\npredicate isCommitInRecommitWindow(Commit firstCommit, Commit secondCommit) {\n  // Both commits must target the same file and be distinct commits\n  firstCommit.getAnAffectedFile() = secondCommit.getAnAffectedFile() and\n  firstCommit != secondCommit and\n  \n  // Calculate the temporal distance between commits\n  exists(int timeDelta |\n    timeDelta = firstCommit.getDate().daysTo(secondCommit.getDate()) and\n    // Verify the time difference falls within the 5-day window (0 to 4 days)\n    timeDelta >= 0 and\n    timeDelta < 5\n  )\n}\n\n/**\n * Calculates the frequency of re-commits for a specific file within 5 days\n * of a prior modification\n * @param targetFile - The file to analyze for re-commit patterns\n */\n_______________ // 补全条件\n  // Count all commits to the file that have a preceding commit within 5 days\n  result = count(Commit currentCommit |\n    targetFile = currentCommit.getAnAffectedFile() and\n    exists(Commit previousCommit | \n      isCommitInRecommitWindow(previousCommit, currentCommit)\n    )\n  )\n}\n\n// Query to find modules with measurable code and their re-commit frequencies\nfrom Module analyzedModule\nwhere exists(analyzedModule.getMetrics().getNumberOfLinesOfCode())\nselect analyzedModule, calculateRecommitFrequency(analyzedModule.getFile())",
    "output": "int calculateRecommitFrequency(File targetFile) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n// 检测目标类是否存在无效方法解析顺序(MRO)\n// 无效MRO发生在继承链中，右侧基类的不当超类型出现在其左侧位置\npredicate hasInvalidMRO(ClassObject targetClass, ClassObject precedingBase, ClassObject followingBase) {\n  // 验证目标类采用新式类定义\n  targetClass.isNewStyle() and\n  \n  // 定位继承列表中相邻的基类对\n  exists(int index | \n    index > 0 and \n    // 获取右侧基类及其直接左侧基类\n    followingBase = targetClass.getBaseType(index) and \n    precedingBase = targetClass.getBaseType(index - 1)\n  ) and\n  \n  // 确认左侧基类是右侧基类的不当超类型\n  precedingBase = followingBase.getAnImproperSuperType()\n}\n\n// 识别所有具有无效方法解析顺序的类，并提供详细诊断信息\nfrom ClassObject targetClass, ClassObject precedingBase, ClassObject followingBase\nwhere hasInvalidMRO(targetClass, precedingBase, followingBase)\nselect targetClass,\n  \"Construction of class \" + targetClass.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", precedingBase,\n  precedingBase.getName(), followingBase, followingBase.getName()",
    "output": "* @name Inconsistent method resolution order"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Lack of Cohesion in Methods (CK)\n * @description Computes the Chidamber-Kemerer Lack of Cohesion in Methods (LCOM) metric.\n *              This metric quantifies the degree of dissimilarity between methods in a class,\n *              where higher values suggest lower cohesion. Classes with high LCOM scores\n *              may benefit from refactoring to improve design quality and maintainability.\n * @kind treemap\n * @id py/lack-of-cohesion-chidamber-kemerer\n * @treemap.warnOn highValues\n_______________ // 补全条件\n * @metricAggregate avg max\n */\n\nimport python\n\n// Identify classes and compute their LCOM metric to evaluate method cohesion\n// Results are sorted by descending LCOM scores to prioritize classes with poor cohesion\nfrom ClassMetrics evaluatedClass\nselect evaluatedClass,\n       evaluatedClass.getLackOfCohesionCK() as cohesionValue\norder by cohesionValue desc",
    "output": "* @metricType reftype"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/useless-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects exception handlers using non-exception types, rendering them ineffective for catching actual exceptions.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-exception in 'except' clause\n * @description Detects exception handlers using non-exception types, rendering them ineffective for catching actual exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\nfrom ExceptFlowNode exceptionHandlerNode, \n     Value exceptionType, \n     ClassValue exceptionClassValue, \n     ControlFlowNode typeOriginNode, \n     string typeInfoDescription\nwhere\n  // Establish exception handling context\n  exceptionHandlerNode.handledException(exceptionType, exceptionClassValue, typeOriginNode) and\n  (\n    // Case 1: Exception type is a non-inheriting class\n    exists(ClassValue invalidExceptionClass | \n      invalidExceptionClass = exceptionType and\n      not invalidExceptionClass.isLegalExceptionType() and\n      not invalidExceptionClass.failedInference(_) and\n      typeInfoDescription = \"class '\" + invalidExceptionClass.getName() + \"'\"\n    )\n    or\n    // Case 2: Exception type is a non-class instance\n    not exceptionType instanceof ClassValue and\n    typeInfoDescription = \"instance of '\" + exceptionClassValue.getName() + \"'\"\n  )\nselect exceptionHandlerNode.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  typeOriginNode, \n  typeInfoDescription"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/redos]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别可能导致指数级时间复杂度的正则表达式模式。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 低效正则表达式检测（ReDoS）\n * @description 识别可能导致指数级时间复杂度的正则表达式模式。\n *              这些模式在处理特定构造的输入时，会触发灾难性回溯，\n *              从而引发严重的性能问题和潜在的拒绝服务攻击。\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/redos\n * @tags security\n *       external/cwe/cwe-1333\n *       external/cwe/cwe-730\n *       external/cwe/cwe-400\n */\n\n// 导入Python正则表达式树视图模块，用于分析正则表达式结构\nprivate import semmle.python.regexp.RegexTreeView::RegexTreeView as TreeView\n// 导入指数回溯检测模块，并使用TreeView作为参数实例化\nimport codeql.regex.nfa.ExponentialBackTracking::Make<TreeView>\n\n// 定义查询变量：存在风险的正则表达式项、触发问题的重复模式、回溯状态和上下文信息\nfrom TreeView::RegExpTerm vulnerableRegexTerm, string triggerPattern, State backtrackState, string contextInfo\nwhere\n  // 检查当前正则表达式项是否存在导致指数级回溯的潜在风险\n  hasReDoSResult(vulnerableRegexTerm, triggerPattern, backtrackState, contextInfo) and\n  // 排除详细模式（VERBOSE）的正则表达式，因为它们通常包含格式化空格和注释\n  not vulnerableRegexTerm.getRegex().getAMode() = \"VERBOSE\"\nselect vulnerableRegexTerm,\n  // 构建详细的警告消息，指出风险点和潜在影响\n  \"正则表达式的这部分可能在包含大量'\" + triggerPattern + \"'重复的字符串\" + contextInfo +\n    \"上导致指数级回溯问题，从而引发性能瓶颈或拒绝服务攻击。\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-small-salt-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Key Derivation Function (KDF) salts must be at least 128 bits (16 bytes) in length.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insufficient KDF Salt Size\n * @description Key Derivation Function (KDF) salts must be at least 128 bits (16 bytes) in length.\n *\n * This rule identifies security vulnerabilities where the salt size used in key derivation\n * functions is less than the required 128 bits, or when the salt size cannot be statically\n * determined during code analysis. Insufficient salt size can weaken cryptographic security\n * by making the derived keys more susceptible to brute-force attacks.\n * @kind problem\n * @id py/kdf-small-salt-size\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// 查询定义：检测密钥派生函数中盐值大小不足的情况\nfrom KeyDerivationOperation kdfOperation, DataFlow::Node saltSizeParam, API::CallNode urandomInvocation, string securityAlert\nwhere\n  // 基本条件：密钥派生操作需要盐值\n  kdfOperation.requiresSalt() and\n  \n  // 盐值配置源条件：确保使用os.urandom作为盐值源\n  urandomInvocation = kdfOperation.getSaltConfigSrc() and\n  urandomInvocation = API::moduleImport(\"os\").getMember(\"urandom\").getACall() and\n  \n  // 获取盐值大小参数的最终来源\n  saltSizeParam = CryptoUtils::getUltimateSrcFromApiNode(urandomInvocation.getParameter(0, \"size\")) and\n  \n  // 安全检查条件：盐值大小不足或无法静态验证\n  (\n    // 情况1：盐值大小不是静态可验证的（动态确定）\n    not exists(saltSizeParam.asExpr().(IntegerLiteral).getValue()) and\n    securityAlert = \"Salt config is not a statically verifiable size. \"\n    or\n    // 情况2：盐值大小不够大（小于16字节）\n    saltSizeParam.asExpr().(IntegerLiteral).getValue() < 16 and\n    securityAlert = \"Salt config is insufficiently large. \"\n  )\nselect kdfOperation,  // 选择存在安全问题的密钥派生操作\n  securityAlert + \"Salt size must be a minimum of 16 (bytes). os.urandom Config: $@, Size Config: $@\",  // 构建安全警报消息\n  urandomInvocation, urandomInvocation.toString(),  // 显示urandom调用及其字符串表示\n  saltSizeParam, saltSizeParam.toString()  // 显示盐值大小参数及其字符串表示"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Call graph\n * @description Identifies and represents edges in the call graph, connecting invocation points to their callable targets.\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/call-graph\n_______________ // 补全条件\n * @precision very-low\n */\n\n// Import Python language support\nimport python\n// Import internal data flow analysis utilities\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n// Import meta metrics utilities\nimport meta.MetaMetrics\n\n// Select all valid call graph edges between call locations and their target functions\nfrom DataFlowCall callLocation, DataFlowCallable targetFunction\nwhere\n  // Ensure both the call location and target function are not in ignored files\n  not (\n    callLocation.getLocation().getFile() instanceof IgnoredFile or\n    targetFunction.getScope().getLocation().getFile() instanceof IgnoredFile\n  )\n  // Verify that the target function is a valid callable for this specific call location\n  and targetFunction = viableCallable(callLocation)\nselect callLocation, \"Call to $@\", targetFunction.getScope(), targetFunction.toString()",
    "output": "* @tags meta"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-number-class-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测类实例化调用时传递的参数数量与构造函数（__init__方法）定义不匹配的情况。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 类实例化参数数量不匹配\n * @description 检测类实例化调用时传递的参数数量与构造函数（__init__方法）定义不匹配的情况。\n *              这种不匹配会导致运行时TypeError异常，影响代码的健壮性和可靠性。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstantiation, ClassValue instantiatedClass, string errorType, string constraintDescription, int expectedArgCount, FunctionValue classInitializer\nwhere\n  // 获取目标类的初始化方法（通常是__init__）\n  classInitializer = get_function_or_initializer(instantiatedClass) and\n  (\n    // 检查参数数量超过上限的情况\n    too_many_args(classInstantiation, instantiatedClass, expectedArgCount) and\n    errorType = \"too many arguments\" and\n    constraintDescription = \"no more than \"\n    or\n    // 检查参数数量低于下限的情况\n    too_few_args(classInstantiation, instantiatedClass, expectedArgCount) and\n    errorType = \"too few arguments\" and\n    constraintDescription = \"no fewer than \"\n  )\nselect classInstantiation, \"Call to $@ with \" + errorType + \"; should be \" + constraintDescription + expectedArgCount.toString() + \".\", classInitializer,\n  // 输出调用点、错误描述及初始化方法的完全限定名称\n  classInitializer.getQualifiedName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-using-is]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies comparisons using 'is' or 'is not' where equivalence comparison would be more appropriate",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comparison using is when operands support `__eq__`\n * @description Identifies comparisons using 'is' or 'is not' where equivalence comparison would be more appropriate\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/comparison-using-is\n */\n\nimport python\n\n/** Holds if comparison `comp` uses `is`/`is not` (represented by `op`) between `leftOperand` and `rightOperand`. */\npredicate comparison_using_is(Compare comp, ControlFlowNode leftOperand, Cmpop op, ControlFlowNode rightOperand) {\n  exists(CompareNode fcomp | fcomp = comp.getAFlowNode() |\n    fcomp.operands(leftOperand, op, rightOperand) and\n    (op instanceof Is or op instanceof IsNot)\n  )\n}\n\n/**\n * @brief Determines if expression represents a CPython-interned value.\n * @param expr Expression to evaluate.\n * @return true if expression represents an interned value (small integers, short strings, empty tuples).\n */\nprivate predicate cpython_interned_value(Expr expr) {\n  // Check for empty or single ASCII character strings\n  exists(string text | text = expr.(StringLiteral).getText() |\n    text.length() = 0\n    or\n    text.length() = 1 and text.regexpMatch(\"[U+0000-U+00ff]\")\n  )\n  // Check for integers in the interning range (-5 to 256)\n  or\n  exists(int i | i = expr.(IntegerLiteral).getN().toInt() | -5 <= i and i <= 256)\n  // Check for empty tuples\n  or\n  exists(Tuple t | t = expr and not exists(t.getAnElt()))\n}\n\n/**\n * @brief Identifies expressions that are literals but not interned by CPython.\n * @param expr Expression to evaluate.\n * @return true if expression is a non-interned literal (strings, integers, floats, containers).\n */\npredicate uninterned_literal(Expr expr) {\n  (\n    expr instanceof StringLiteral  // String literals\n    or\n    expr instanceof IntegerLiteral  // Integer literals\n    or\n    expr instanceof FloatLiteral  // Floating-point literals\n    or\n    expr instanceof Dict  // Dictionary literals\n    or\n    expr instanceof List  // List literals\n    or\n    expr instanceof Tuple  // Tuple literals\n  ) and\n  not cpython_interned_value(expr)  // Exclude interned values\n}\n\nfrom Compare comp, Cmpop op, string recommendedOperator\nwhere\n  exists(ControlFlowNode leftNode, ControlFlowNode rightNode |\n    comparison_using_is(comp, leftNode, op, rightNode) and\n    (\n      op instanceof Is and recommendedOperator = \"==\"  // 'is' should be '=='\n      or\n      op instanceof IsNot and recommendedOperator = \"!=\"  // 'is not' should be '!='\n    )\n  |\n    uninterned_literal(leftNode.getNode())  // Left operand is non-interned literal\n    or\n    uninterned_literal(rightNode.getNode())  // Right operand is non-interned literal\n  )\nselect comp,\n  \"Values compared using '\" + op.getSymbol() +\n    \"' when equivalence is not the same as identity. Use '\" + recommendedOperator + \"' instead.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：本查询通过计算高价值分析结果在总体分析结果中的占比，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 指向关系分析质量评估\n * @description 本查询通过计算高价值分析结果在总体分析结果中的占比，\n * 评估指向关系分析的精确度和信息密度。该指标有助于量化分析引擎性能，\n * 特别是在过滤掉低价值节点（如参数、名称常量和不可变字面量）后的分析质量。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 判断控制流节点是否为低价值节点（即分析价值不高的节点）\npredicate isTrivialNode(ControlFlowNode flowNode) {\n  // 如果节点是以下类型之一，则认为其分析价值有限：函数参数、名称常量或不可变字面量\n  flowNode.getNode() instanceof Parameter\n  or\n  flowNode instanceof NameConstantNode\n  or\n  flowNode.getNode() instanceof ImmutableLiteral\n}\n\n// 计算指向关系分析的质量指标\nfrom \n  int highValueAnalysisCount,      // 高价值分析结果的总数\n  int sourceHighValueCount,        // 源文件中的高价值分析结果数量\n  int overallAnalysisCount,        // 所有指向关系分析结果的总数\n  float analysisQualityMetric     // 分析质量指标评分\nwhere\n  // 计算高价值分析结果总数（排除低价值节点）\n  highValueAnalysisCount =\n    strictcount(ControlFlowNode flowNode, Object targetObject, ClassObject targetClass |\n      flowNode.refersTo(targetObject, targetClass, _) and not isTrivialNode(flowNode)\n    ) and\n  // 计算源文件中的高价值分析结果数量\n  sourceHighValueCount =\n    strictcount(ControlFlowNode flowNode, Object targetObject, ClassObject targetClass |\n      flowNode.refersTo(targetObject, targetClass, _) and\n      not isTrivialNode(flowNode) and\n      exists(flowNode.getScope().getEnclosingModule().getFile().getRelativePath())\n    ) and\n  // 计算所有指向关系分析结果的总数\n  overallAnalysisCount =\n    strictcount(ControlFlowNode flowNode, PointsToContext context, Object targetObject, \n      ClassObject targetClass, ControlFlowNode originalFlowNode | \n      PointsTo::points_to(flowNode, context, targetObject, targetClass, originalFlowNode)\n    ) and\n  // 计算分析质量指标：源文件高价值分析结果占总体分析结果的百分比\n  analysisQualityMetric = 100.0 * sourceHighValueCount / overallAnalysisCount\nselect highValueAnalysisCount, sourceHighValueCount, overallAnalysisCount, analysisQualityMetric"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-star-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using import * prevents some analysis",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' used\n * @description Using import * prevents some analysis\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// 导入Python模块，用于分析Python代码\nimport python\n\n// 从ImportStar类中选择实例i\nfrom ImportStar i\n// 查询语句：选择i并输出警告信息，指出使用'from ... import *'会污染命名空间。\nselect i, \"Using 'from ... import *' pollutes the namespace.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称密钥生成中使用未知密钥大小\n * @description 识别在非对称加密密钥生成过程中使用无法通过静态分析验证的密钥长度的安全风险\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n_______________ // 补全条件\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 检测非对称密钥生成操作中密钥大小无法静态验证的实例\nfrom AsymmetricKeyGen keyGenerationOperation, DataFlow::Node configSourceNode, string algorithmIdentifier\nwhere\n  // 提取密钥配置的源节点信息\n  configSourceNode = keyGenerationOperation.getKeyConfigSrc() and\n  // 获取当前密钥生成操作所使用的加密算法标识\n  algorithmIdentifier = keyGenerationOperation.getAlgorithm().getName() and\n  // 验证该密钥生成操作是否缺乏静态可验证的密钥大小配置\n  not keyGenerationOperation.hasKeySize(configSourceNode)\nselect keyGenerationOperation,\n  // 生成安全警告，标识算法名称及配置源位置\n  \"算法 \" + algorithmIdentifier.toString() + \" 的密钥生成使用了无法静态验证的密钥大小，配置源位于 $@\", configSourceNode, configSourceNode.toString()",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Exception block catches 'BaseException'\n * @description Identifies exception handlers that catch BaseException without re-raising,\n *              potentially causing improper handling of system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Determine if an exception handler fails to re-raise the caught exception\npredicate doesNotReraise(ExceptStmt exceptionHandler) { \n  // Check if control flow from the handler reaches program exit\n  exceptionHandler.getAFlowNode().getBasicBlock().reachesExit() \n}\n\n// Detect handlers that catch BaseException or use bare except clauses\npredicate catchesBaseException(ExceptStmt exceptionHandler) {\n  // Verify explicit BaseException handling\n  exceptionHandler.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  // Identify bare except clauses (catching all exceptions)\n  not exists(exceptionHandler.getType())\n}\n\n// Primary query: Locate handlers that catch BaseException without re-raising\nfrom ExceptStmt exceptionHandler\nwhere\n_______________ // 补全条件\n  doesNotReraise(exceptionHandler)          // Condition: Doesn't re-raise\nselect exceptionHandler, \"Except block directly handles BaseException.\" // Output with description",
    "output": "catchesBaseException(exceptionHandler) and // Condition: Catches BaseException"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete Task Marker Comment\n * @description Identifies comments containing 'TODO' or 'TO DO' markers. These markers typically\n_______________ // 补全条件\n *              Accumulation of such markers may indicate technical debt and maintenance challenges.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n *       external/cwe/cwe-546\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/todo-comment\n */\n\nimport python\n\nfrom Comment incompleteComment\nwhere \n  // Check for presence of either 'TODO' or 'TO DO' markers in comment text\n  incompleteComment.getText().matches(\"%(TODO|TO DO)%\")\nselect \n  incompleteComment,  // The comment node containing the marker\n  incompleteComment.getText()  // Full text content of the comment",
    "output": "*              represent unfinished code sections or pending features that require attention."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects super() calls in old-style classes where they are unsupported.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description Detects super() calls in old-style classes where they are unsupported.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n// Identifies invocations of super() within old-style class contexts\npredicate superInvocationInOldStyleClass(Call superInvocation) {\n  exists(Function parentFunction, ClassObject parentClass |\n    // Check if the call is to the 'super' built-in function\n    superInvocation.getFunc().(Name).getId() = \"super\" and\n    // Ensure the super call is within a function/method\n    superInvocation.getScope() = parentFunction and\n    // Verify the function is a member of a class\n    parentFunction.getScope() = parentClass.getPyClass() and\n    // Confirm the class was successfully analyzed\n    not parentClass.failedInference() and\n    // Identify old-style classes (those not inheriting from object or other new-style classes)\n    not parentClass.isNewStyle()\n  )\n}\n\n// Query to find all problematic super() calls in old-style classes\nfrom Call invalidSuperCall\nwhere superInvocationInOldStyleClass(invalidSuperCall)\nselect invalidSuperCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name SQL query built from user-controlled sources\n * @description Constructing SQL queries using user-controlled input enables attackers\n *              to inject malicious SQL code, creating SQL injection vulnerabilities.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 8.8\n_______________ // 补全条件\n * @id py/sql-injection\n * @tags security\n *       external/cwe/cwe-089\n */\n\n// Import Python analysis library for code parsing and processing\nimport python\n\n// Import specialized SQL injection data flow tracking module\nimport semmle.python.security.dataflow.SqlInjectionQuery\n\n// Import path graph module for visualizing data flow trajectories\nimport SqlInjectionFlow::PathGraph\n\n// Identify tainted data flow paths from user input to SQL construction points\nfrom \n  SqlInjectionFlow::PathNode taintedSource, \n  SqlInjectionFlow::PathNode sqlSink\nwhere \n  SqlInjectionFlow::flowPath(taintedSource, sqlSink)  // Validate data flow existence\nselect \n  sqlSink.getNode(),          // Target SQL construction point\n  taintedSource,              // Origin of tainted data\n  sqlSink,                    // Termination point of flow\n  \"This SQL query depends on a $@.\",  // Vulnerability description template\n  taintedSource.getNode(),    // Source node for placeholder substitution\n  \"user-provided value\"       // Label for tainted data origin",
    "output": "* @precision high"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/asymmetric-padding-schemes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies cryptographic implementations using asymmetric padding schemes",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Asymmetric Padding Schemes\n * @description Identifies cryptographic implementations using asymmetric padding schemes\n *              that may be vulnerable to quantum computing attacks.\n * @kind problem\n * @id py/quantum-readiness/cbom/asymmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify asymmetric padding schemes vulnerable to quantum attacks\nfrom AsymmetricPadding vulnerablePadding\n\n// Generate security alert with padding scheme details\nselect vulnerablePadding,\n       \"Vulnerable asymmetric padding scheme detected: \" \n       + vulnerablePadding.getPaddingName() \n       + \" (quantum-susceptible)\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'import *' may pollute namespace\n * @description Detects 'import *' statements that could pollute the namespace\n *              when the imported module lacks '__all__' definition. This practice\n *              can lead to unintended name conflicts and reduced code maintainability.\n * @kind problem\n * @tags maintainability\n *       modularity\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/polluting-import\n */\n\n_______________ // 补全条件\nimport python\n\n// Predicate to determine if a module properly defines '__all__' attribute\n// This is crucial for controlling what gets exported via 'import *' statements\npredicate moduleProperlyDefinesAll(ModuleValue sourceModule) {\n  // Built-in modules are considered safe as they typically have controlled exports\n  sourceModule.isBuiltin()\n  or\n  // Check if '__all__' is explicitly defined in the module's import-time scope\n  sourceModule.getScope().(ImportTimeScope).definesName(\"__all__\")\n  or\n  // Check if '__all__' is defined in the module's initialization file\n  sourceModule.getScope().getInitModule().(ImportTimeScope).definesName(\"__all__\")\n}\n\n// Main query to identify problematic 'import *' statements\n// These statements can pollute the namespace by importing all names from a module\n// that doesn't explicitly specify which names should be exported\nfrom ImportStar starImport, ModuleValue sourceModule\nwhere \n  // Verify that the star import is from the specific module\n  sourceModule.importedAs(starImport.getImportedModuleName()) and\n  // Ensure the module doesn't properly define '__all__'\n  not moduleProperlyDefinesAll(sourceModule) and\n  // Exclude modules that are absent (not found)\n  not sourceModule.isAbsent()\nselect starImport,\n  \"Import pollutes the enclosing namespace, as the imported module $@ does not define '__all__'.\",\n  sourceModule, sourceModule.getName()",
    "output": "// Import Python analysis library for code examination and AST traversal"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Complete server-side request forgery vulnerability\n * @description Detects HTTP requests where attackers fully control target URLs via user input,\n *              enabling SSRF attacks against internal systems\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision high\n * @id py/full-ssrf\n * @tags security\n *       external/cwe/cwe-918\n */\n\n// Core Python analysis framework\nimport python\n// SSRF vulnerability detection capabilities\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\n// Path tracking for vulnerability propagation\nimport FullServerSideRequestForgeryFlow::PathGraph\n\nfrom\n  // Entry point for attacker-controlled data\n  FullServerSideRequestForgeryFlow::PathNode maliciousInputSource,\n  // Destination point for vulnerable HTTP requests\n  FullServerSideRequestForgeryFlow::PathNode vulnerableRequestSink,\n  // Target HTTP client operation being exploited\n_______________ // 补全条件\nwhere\n  // Verify the entire URL is controlled by untrusted input\n  fullyControlledRequest(targetHttpRequest) and\n  // Map the sink to its corresponding HTTP request\n  targetHttpRequest = vulnerableRequestSink.getNode().(Sink).getRequest() and\n  // Confirm data flow path from source to sink exists\n  FullServerSideRequestForgeryFlow::flowPath(maliciousInputSource, vulnerableRequestSink)\nselect\n  // Vulnerability details with propagation path\n  targetHttpRequest, maliciousInputSource, vulnerableRequestSink,\n  // Attack impact description\n  \"Complete URL controlled by $@.\", maliciousInputSource.getNode(),\n  \"untrusted user input\"",
    "output": "Http::Client::Request targetHttpRequest"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/statement-nesting-depth-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates and displays the maximum nesting depth of statements within each function.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Statement nesting depth\n * @description Calculates and displays the maximum nesting depth of statements within each function.\n *              Higher values indicate more complex control flow structures.\n * @kind treemap\n * @id py/statement-nesting-depth-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags maintainability\n *       complexity\n */\n\nimport python\n\n// Select all Python functions and compute their statement nesting depth\n// Results are presented in descending order of nesting depth to highlight\n// functions with the most complex control flow structures\nfrom FunctionMetrics analyzedFunction\nselect analyzedFunction, analyzedFunction.getStatementNestingDepth() as nestingDepth \norder by nestingDepth desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Raising a tuple in Python 2\n * @description In Python 2, raising a tuple results in only the first element being raised as an exception,\n *              while all other elements are silently discarded. This can lead to unexpected behavior.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple */\n_______________ // 补全条件\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// This query identifies raise statements that use tuple expressions as exceptions\n// In Python 2, this behavior causes only the first tuple element to be raised,\n// which differs from Python 3 where this would be a type error\nfrom Raise raiseStatement, DataFlow::LocalSourceNode tupleSourceNode\nwhere\n  // Limit the analysis scope to Python 2 codebases only\n  major_version() = 2 and\n  // Confirm the source node represents a tuple expression\n  tupleSourceNode.asExpr() instanceof Tuple and\n  // Establish data flow connection between the tuple and the raised exception\n  exists(DataFlow::Node exceptionDestNode |\n    exceptionDestNode.asExpr() = raiseStatement.getException() and\n    tupleSourceNode.flowsTo(exceptionDestNode)\n  )\n/* Important: This behavior is specific to Python 2. In Python 3, raising a tuple\n   results in a TypeError, which is covered by the IllegalRaise query */\nselect raiseStatement,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleSourceNode, \"tuple\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/init-calls-subclass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when `__init__` methods invoke functions that could be overridden by subclasses,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__init__` method calls overridden method\n * @description Detects when `__init__` methods invoke functions that could be overridden by subclasses,\n *              potentially exposing partially initialized objects.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/init-calls-subclass\n */\n\nimport python\n\nfrom\n  ClassObject superClass, string methodName, Call selfCall,\n  FunctionObject subclassMethod, FunctionObject superclassMethod\nwhere\n  // Identify the superclass and its initialization method\n  exists(FunctionObject initMethod, SelfAttribute selfAttribute |\n    // Locate the __init__ method in the superclass\n    superClass.declaredAttribute(\"__init__\") = initMethod and\n    \n    // Find method calls on self within the __init__ method\n    selfCall.getScope() = initMethod.getFunction() and\n    selfCall.getFunc() = selfAttribute and\n    \n    // Extract the name of the method being called\n    selfAttribute.getName() = methodName and\n    \n    // Verify the method exists in the superclass\n    superclassMethod = superClass.declaredAttribute(methodName) and\n    \n    // Confirm the method is overridden by a subclass\n    subclassMethod.overrides(superclassMethod)\n  )\n// Generate alert with details about the problematic call\nselect selfCall, \"Call to self.$@ in __init__ method, which is overridden by $@.\", \n  superclassMethod, methodName, subclassMethod, subclassMethod.descriptiveString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：使用 super() 访问继承的方法在旧式类中是不被支持的。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description 使用 super() 访问继承的方法在旧式类中是不被支持的。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n// 定义一个谓词函数，用于检测在旧式类中使用了 super()\npredicate uses_of_super_in_old_style_class(Call s) {\n  // 存在一个函数 f 和一个类对象 c，使得以下条件成立：\n  exists(Function f, ClassObject c |\n    // 调用 s 的作用域是函数 f\n    s.getScope() = f and\n    // 函数 f 的作用域是类对象 c 的 Python 类\n    f.getScope() = c.getPyClass() and\n    // 类对象 c 没有失败的类型推断\n    not c.failedInference() and\n    // 类对象 c 不是新式类\n    not c.isNewStyle() and\n    // 调用的函数名是 \"super\"\n    s.getFunc().(Name).getId() = \"super\"\n  )\n}\n\n// 从所有调用点开始查询\nfrom Call c\n// 条件是调用点满足在旧式类中使用了 super()\nwhere uses_of_super_in_old_style_class(c)\n// 选择这些调用点，并给出错误信息\nselect c, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commented-out-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code segments that have been deactivated through commenting.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commented-out code\n * @description Detects code segments that have been deactivated through commenting.\n *              Commented-out code can reduce readability and maintainability,\n *              as it often becomes outdated and may confuse developers about\n *              the intended functionality of the codebase.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code */\n\n// Import necessary modules for Python code analysis\nimport python\nimport Lexical.CommentedOutCode\n\n// Identify all commented-out code blocks in the codebase\nfrom CommentedOutCodeBlock commentedOutCode\n// Exclude blocks that are likely example code to reduce false positives\nwhere not commentedOutCode.maybeExampleCode()\n// Report the identified commented-out code blocks with a descriptive message\nselect commentedOutCode, \"This comment appears to contain commented-out code.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects instances where a tuple is raised as an exception in Python 2.\n *              This behavior leads to only the first element being raised as an exception,\n *              while all other elements are silently discarded, potentially causing unexpected runtime behavior.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// This query identifies raise statements where the exception being raised originates from a tuple expression.\n// In Python 2, this causes only the first element of the tuple to be raised as an exception, while\n// discarding all other elements, which can lead to unexpected behavior.\nfrom Raise exceptionRaise, DataFlow::LocalSourceNode originatingTuple\nwhere\n  // Constraint: This issue is specific to Python 2 environments\n  major_version() = 2 and\n  // The source must be a tuple expression\n  originatingTuple.asExpr() instanceof Tuple and\n  // Verify data flow from the tuple to the raised exception\n  exists(DataFlow::Node exceptionNode |\n    exceptionNode.asExpr() = exceptionRaise.getException() and\n    originatingTuple.flowsTo(exceptionNode)\n  )\n/* Note: In Python 3, raising a tuple results in a type error, which is handled by the IllegalRaise query.\n   Therefore, this query is specifically targeted at Python 2 codebases. */\nselect exceptionRaise,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  originatingTuple, \"tuple\"",
    "output": "* @name Raising a tuple in Python 2"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-randomness]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies security-sensitive operations that employ",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak cryptographic randomness vulnerability\n * @description Identifies security-sensitive operations that employ \n *              cryptographically weak pseudo-random number generators,\n *              potentially enabling attackers to predict generated values.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// Core Python language analysis infrastructure\nimport python\n\n// Data flow analysis framework for security vulnerability detection\nimport semmle.python.dataflow.new.DataFlow\nimport InsecureRandomness::Flow::PathGraph\n\n// Security analysis components for detecting weak random number generation\nimport experimental.semmle.python.security.InsecureRandomness\n\n// Query that traces data flow from weak random sources to security-critical sinks\nfrom InsecureRandomness::Flow::PathNode weakRandomSource, \n     InsecureRandomness::Flow::PathNode securityCriticalSink\nwhere \n  // Establish data flow path between source and sink\n  InsecureRandomness::Flow::flowPath(weakRandomSource, securityCriticalSink)\nselect \n  // Primary result: the vulnerable sink location\n  securityCriticalSink.getNode(), \n  // Source node in the data flow path\n  weakRandomSource, \n  // Sink node in the data flow path\n  securityCriticalSink, \n  // Warning message with source reference\n  \"Cryptographically insecure $@ used in security-sensitive context.\",\n  // Reference to the source node for message formatting\n  weakRandomSource.getNode(), \n  // Label for the source node\n  \"random value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-low-iteration-count]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies key derivation functions with insufficient iteration counts.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use iteration count at least 100k to prevent brute force attacks\n * @description Identifies key derivation functions with insufficient iteration counts.\n * When deriving cryptographic keys from user inputs (such as passwords), it's critical to use\n * a high iteration count (at least 100,000 iterations) to effectively resist brute force attacks.\n *\n * This query detects two potential security issues:\n * 1. Constant iteration count values below the recommended threshold of 100,000\n * 2. Iteration counts that cannot be statically determined at analysis time\n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import standard Python analysis library\nimport python\n// Import experimental cryptography concepts for key derivation operations\nimport experimental.cryptography.Concepts\n// Import utility functions for cryptography analysis, aliased as CryptoUtils\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Define security threshold for iteration count\nint getMinIterationCount() { result = 100000 }\n\n// Select key derivation operations with insufficient iteration counts\nfrom KeyDerivationOperation kdfOperation, string alertMessage, DataFlow::Node iterationCountSource\nwhere\n  // Focus only on operations that require iteration configuration\n  kdfOperation.requiresIteration() and\n  // Identify the source node that configures the iteration count\n  iterationCountSource = kdfOperation.getIterationSizeSrc() and\n  // Evaluate iteration count against security requirements\n  (\n    // Case 1: Iteration count is a constant below the security threshold\n    exists(IntegerLiteral lit |\n      lit = iterationCountSource.asExpr() and\n      lit.getValue() < getMinIterationCount() and\n      alertMessage = \"Insufficient iteration count detected. \"\n    )\n    or\n    // Case 2: Iteration count cannot be statically verified\n    not iterationCountSource.asExpr() instanceof IntegerLiteral and\n    alertMessage = \"Iteration count cannot be statically verified. \"\n  )\nselect \n  // Report the key derivation operation with appropriate warning message\n  kdfOperation, alertMessage + \"Minimum required iteration count is 100000. Configuration source: $@\",\n  iterationCountSource.asExpr(), iterationCountSource.asExpr().toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-number-class-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测类实例化时传入参数数量与构造函数（__init__方法）定义不匹配的情况。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 错误的类实例化参数数量\n * @description 检测类实例化时传入参数数量与构造函数（__init__方法）定义不匹配的情况。\n *              这类问题会在运行时导致TypeError异常，影响程序可靠性。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call instantiationCall, ClassValue targetClass, string errorDescription, string constraintMessage, int expectedCount, FunctionValue constructorFunction\nwhere\n  // 获取目标类的构造函数（通常是__init__方法）\n  constructorFunction = get_function_or_initializer(targetClass) and\n  (\n    // 处理参数数量超过上限的情况\n    too_many_args(instantiationCall, targetClass, expectedCount) and\n    errorDescription = \"too many arguments\" and\n    constraintMessage = \"no more than \"\n    or\n    // 处理参数数量低于下限的情况\n    too_few_args(instantiationCall, targetClass, expectedCount) and\n    errorDescription = \"too few arguments\" and\n    constraintMessage = \"no fewer than \"\n  )\nselect instantiationCall, \"Call to $@ with \" + errorDescription + \"; should be \" + constraintMessage + expectedCount.toString() + \".\", constructorFunction,\n  // 输出调用点、错误消息及构造函数的完全限定名\n  constructorFunction.getQualifiedName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/syntax-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python syntax errors that cause runtime failures and impede proper code analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Syntax error\n * @description Identifies Python syntax errors that cause runtime failures and impede proper code analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import the Python module which provides essential classes and predicates for analyzing Python source code\nimport python\n\n// Query to identify syntax errors in Python code that could lead to runtime failures\n// This query specifically excludes encoding-related errors as they require different handling approaches\nfrom SyntaxError syntaxErrorInstance\nwhere \n    // Exclude encoding errors to focus on genuine syntax issues in the code structure\n    not syntaxErrorInstance instanceof EncodingError\nselect \n    // The syntax error instance that was detected\n    syntaxErrorInstance, \n    // Detailed error message including the specific syntax issue and Python version context\n    syntaxErrorInstance.getMessage() + \" (in Python \" + major_version() + \").\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Model Editor Framework-Mode Endpoint Inventory\n_______________ // 补全条件\n *              within the model editor's framework mode. This query systematically excludes \n *              test files and auto-generated code artifacts to focus on production endpoints.\n *              The results provide a detailed view of the framework's API surface area.\n * @kind table\n * @id py/utils/modeleditor/framework-mode-endpoints\n * @tags modeleditor endpoints framework-mode api-inventory\n */\n\nimport modeling.ModelEditor\n\nfrom Endpoint editorEndpoint\nselect \n  // Core endpoint reference\n  editorEndpoint,  \n  \n  // Structural hierarchy\n  editorEndpoint.getNamespace(),  // Namespace context\n  editorEndpoint.getClass(),      // Parent class definition\n  \n  // Functional signature\n  editorEndpoint.getFunctionName(),  // Method identifier\n  editorEndpoint.getParameters(),    // Parameter signature\n  editorEndpoint.getSupportedStatus(),  // HTTP response codes\n  \n  // Location and typing\n  editorEndpoint.getFileName(),      // Source file location\n  editorEndpoint.getSupportedType(), // Data type specifications\n  editorEndpoint.getKind()           // Endpoint classification",
    "output": "* @description Comprehensive inventory of all accessible endpoints (methods and attributes)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-ordering]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Class defines one or more ordering method but does not define all 4 ordering comparison methods",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incomplete ordering\n * @description Class defines one or more ordering method but does not define all 4 ordering comparison methods\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/incomplete-ordering\n */\n\nimport python\n\n// 检查类是否应用了total_ordering装饰器\npredicate uses_total_ordering(Class targetClass) {\n  exists(Attribute attr | attr = targetClass.getADecorator() | attr.getName() = \"total_ordering\") // 检查装饰器属性\n  or\n  exists(Name nameNode | nameNode = targetClass.getADecorator() | nameNode.getId() = \"total_ordering\") // 检查装饰器名称\n}\n\n// 根据索引获取比较方法的名称\nstring get_ordering_method_name(int index) {\n  result = \"__lt__\" and index = 1 // 小于\n  or\n  result = \"__le__\" and index = 2 // 小于等于\n  or\n  result = \"__gt__\" and index = 3 // 大于\n  or\n  result = \"__ge__\" and index = 4 // 大于等于\n}\n\n// 检查类或其父类是否重写了指定的比较方法\npredicate has_ordering_method(ClassValue targetCls, string methodName) {\n  methodName = get_ordering_method_name(_) and ( // 确保是有效的比较方法名\n    targetCls.declaresAttribute(methodName) // 类自身声明了该方法\n    or\n    exists(ClassValue superClass | superClass = targetCls.getASuperType() and not superClass = Value::named(\"object\") | // 父类声明了该方法\n      superClass.declaresAttribute(methodName)\n    )\n  )\n}\n\n// 获取类未实现的比较方法名称\nstring missing_ordering_method(ClassValue targetCls, int index) {\n  not targetCls = Value::named(\"object\") and // 排除object类\n  not has_ordering_method(targetCls, result) and // 确保类及其父类未实现该方法\n  result = get_ordering_method_name(index) // 获取对应索引的比较方法名\n}\n\n// 构建包含所有未实现比较方法的字符串\nstring get_missing_methods_string(ClassValue targetCls, int index) {\n  // 初始化空字符串并检查是否有未实现的方法\n  index = 0 and result = \"\" and exists(missing_ordering_method(targetCls, _))\n  or\n  // 递归构建结果字符串\n  exists(string prefix, int prevIndex | index = prevIndex + 1 and prefix = get_missing_methods_string(targetCls, prevIndex) |\n    // 如果前缀为空，直接添加当前方法名\n    prefix = \"\" and result = missing_ordering_method(targetCls, index)\n    or\n    // 如果当前方法已实现，继续递归\n    result = prefix and not exists(missing_ordering_method(targetCls, index)) and index < 5\n    or\n    // 如果前缀不为空，添加连接符和当前方法名\n    prefix != \"\" and result = prefix + \" or \" + missing_ordering_method(targetCls, index)\n  )\n}\n\n// 获取类声明的比较方法\nValue get_declared_ordering_method(ClassValue targetCls, string methodName) {\n  /* 仅当类自身声明了比较方法时才返回，避免将父类实现的方法归咎于当前类 */\n  methodName = get_ordering_method_name(_) and result = targetCls.declaredAttribute(methodName)\n}\n\n// 查询未完整实现所有比较方法的类\nfrom ClassValue targetCls, Value orderingMethod, string methodName\nwhere\n  not targetCls.failedInference(_) and // 确保类推理成功\n  not uses_total_ordering(targetCls.getScope()) and // 排除使用total_ordering装饰器的类\n  orderingMethod = get_declared_ordering_method(targetCls, methodName) and // 获取类声明的比较方法\n  exists(missing_ordering_method(targetCls, _)) // 确保有未实现的比较方法\nselect targetCls,\n  \"Class \" + targetCls.getName() + \" implements $@, but does not implement \" + // 报告类名和已实现的比较方法\n    get_missing_methods_string(targetCls, 4) + \".\", orderingMethod, methodName // 列出缺失的比较方法"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-star-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using import * prevents some analysis",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' used\n * @description Using import * prevents some analysis\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// 导入Python分析库，提供对Python代码结构的解析支持\nimport python\n\n// 定义变量表示所有星号通配符导入语句\nfrom ImportStar starImportStmt\n\n// 报告所有通配符导入实例，说明其污染命名空间的危害\nselect starImportStmt, \"Using 'from ... import *' pollutes the namespace.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Counts of various kinds of type annotations in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Counts of various kinds of type annotations in Python code.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents built-in Python types like int, float, str, etc.\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type definition for elements that can have type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr function) { exists(function.getReturns()) } or \n  TAnnotatedParameter(Parameter parameter) { exists(parameter.getAnnotation()) } or \n  TAnnotatedAssignment(AnnAssign assignment) { exists(assignment.getAnnotation()) }\n\n// Abstract base class for all elements that can have type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Represents functions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr functionExpr;\n  AnnotatedFunction() { this = TAnnotatedFunction(functionExpr) }\n  override Expr getAnnotation() { result = functionExpr.getReturns() }\n}\n\n// Represents parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter parameter;\n  AnnotatedParameter() { this = TAnnotatedParameter(parameter) }\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\n// Represents assignments with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assignmentStmt;\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assignmentStmt) }\n  override Expr getAnnotation() { result = assignmentStmt.getAnnotation() }\n}\n\n// Helper predicates to classify type annotations\n\n/** Determines if an expression is a forward-declared type (string literal) */\npredicate isForwardDeclaration(Expr expr) { expr instanceof StringLiteral }\n\n/** Determines if an expression represents a complex type structure */\npredicate isComplexType(Expr expr) {\n  expr instanceof Subscript and not isOptionalType(expr)\n  or\n  expr instanceof Tuple\n  or\n  expr instanceof List\n}\n\n/** Determines if an expression is an Optional type */\npredicate isOptionalType(Subscript expr) { expr.getObject().(Name).getId() = \"Optional\" }\n\n/** Determines if an expression is a simple user-defined type */\npredicate isSimpleType(Expr expr) {\n  expr instanceof Name and not expr instanceof BuiltinType\n  or\n  isSimpleType(expr.(Attribute).getObject())\n}\n\n/** Determines if an expression is a built-in type */\npredicate isBuiltinType(Expr expr) { expr instanceof BuiltinType }\n\n// Computes type annotation metrics for different categories\npredicate computeTypeMetrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Metrics for parameter annotations\n  category = \"Parameter annotation\" and\n  totalCount = count(AnnotatedParameter annotatedParam) and\n  builtinCount = count(AnnotatedParameter annotatedParam | isBuiltinType(annotatedParam.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedParameter annotatedParam | isForwardDeclaration(annotatedParam.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedParameter annotatedParam | isSimpleType(annotatedParam.getAnnotation())) and\n  complexTypeCount = count(AnnotatedParameter annotatedParam | isComplexType(annotatedParam.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedParameter annotatedParam | isOptionalType(annotatedParam.getAnnotation()))\n  or\n  // Metrics for return type annotations\n  category = \"Return type annotation\" and\n  totalCount = count(AnnotatedFunction annotatedFunc) and\n  builtinCount = count(AnnotatedFunction annotatedFunc | isBuiltinType(annotatedFunc.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedFunction annotatedFunc | isForwardDeclaration(annotatedFunc.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedFunction annotatedFunc | isSimpleType(annotatedFunc.getAnnotation())) and\n  complexTypeCount = count(AnnotatedFunction annotatedFunc | isComplexType(annotatedFunc.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedFunction annotatedFunc | isOptionalType(annotatedFunc.getAnnotation()))\n  or\n  // Metrics for annotated assignments\n  category = \"Annotated assignment\" and\n  totalCount = count(AnnotatedAssignment annotatedAssign) and\n  builtinCount = count(AnnotatedAssignment annotatedAssign | isBuiltinType(annotatedAssign.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedAssignment annotatedAssign | isForwardDeclaration(annotatedAssign.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedAssignment annotatedAssign | isSimpleType(annotatedAssign.getAnnotation())) and\n  complexTypeCount = count(AnnotatedAssignment annotatedAssign | isComplexType(annotatedAssign.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedAssignment annotatedAssign | isOptionalType(annotatedAssign.getAnnotation()))\n}\n\n// Query execution and result selection\nfrom\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  computeTypeMetrics(category, totalCount, builtinCount, forwardDeclCount, \n                    simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description Detects when malicious tar archives overwrite files outside target directory due to unvalidated extraction paths\n * @kind path-problem\n * @id py/tarslip-extended\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport TarSlipFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.internal.Attributes\nimport semmle.python.dataflow.new.BarrierGuards\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n/**\n * Identifies tarfile opening methods:\n *  - `tarfile.open()`\n *  - `tarfile.TarFile()`\n *  - Subclasses' `open` methods\n */\nAPI::Node tarfileOpenMethod() {\n  result in [\n      API::moduleImport(\"tarfile\").getMember([\"open\", \"TarFile\"]),\n      API::moduleImport(\"tarfile\").getMember(\"TarFile\").getASubclass().getMember(\"open\")\n    ]\n}\n\n/**\n_______________ // 补全条件\n */\nclass TarfileExtractionCall extends API::CallNode {\n  TarfileExtractionCall() {\n    this = tarfileOpenMethod().getACall()\n    or\n    exists(API::Node contextlibClosing, Node tarCall |\n      contextlibClosing = API::moduleImport(\"contextlib\").getMember(\"closing\") and\n      this = contextlibClosing.getACall() and\n      tarCall = this.getArg(0) and\n      tarCall = tarfileOpenMethod().getACall()\n    )\n  }\n}\n\n/**\n * Enhanced taint tracking configuration for TarSlip vulnerability detection\n */\nprivate module TarSlipConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { \n    source = tarfileOpenMethod().getACall() \n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(TarfileExtractionCall tarfileCall |\n      // Handle extractall() without members parameter\n      exists(MethodCallNode extractallCall |\n        extractallCall = tarfileCall.getReturn().getMember(\"extractall\").getACall() and\n        not extractallCall.getArgByName(\"members\") instanceof Node and\n        sink = extractallCall.getObject()\n      )\n      or\n      // Handle extractall() with members parameter\n      exists(MethodCallNode extractallCall, Node membersArg |\n        extractallCall = tarfileCall.getReturn().getMember(\"extractall\").getACall() and\n        membersArg = extractallCall.getArgByName(\"members\") and\n        (\n          membersArg.asCfgNode() instanceof NameConstantNode or\n          membersArg.asCfgNode() instanceof ListNode\n        ) and\n        sink = extractallCall.getObject()\n      )\n      or\n      // Handle extractall() with dynamic members\n      exists(MethodCallNode extractallCall, MethodCallNode getmembersCall |\n        extractallCall = tarfileCall.getReturn().getMember(\"extractall\").getACall() and\n        getmembersCall = extractallCall.getArgByName(\"members\") and\n        getmembersCall.getMethodName() = \"getmembers\" and\n        sink = getmembersCall.getObject()\n      )\n      or\n      // Handle extract() method\n      exists(MethodCallNode extractCall |\n        extractCall = tarfileCall.getReturn().getMember(\"extract\").getACall() and\n        sink = extractCall.getArg(0)\n      )\n      or\n      // Handle _extract_member() method\n      exists(MethodCallNode extractMemberCall, AttrRead nameAttr |\n        extractMemberCall = tarfileCall.getReturn().getMember(\"_extract_member\").getACall() and\n        nameAttr = extractMemberCall.getArg(1).(AttrRead) and\n        nameAttr.accesses(sink, \"name\")\n      )\n    ) and\n    not sink.getScope().getLocation().getFile().inStdlib()\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) {\n    // Flow through getmembers() method calls\n    exists(MethodCallNode getmembersCall |\n      getmembersCall.calls(nodeFrom, \"getmembers\") and\n      nodeTo = getmembersCall and\n      nodeFrom instanceof TarfileExtractionCall\n    )\n    or\n    // Flow through contextlib.closing wrapper\n    exists(API::CallNode contextlibClosingCall |\n      contextlibClosingCall = API::moduleImport(\"contextlib\").getMember(\"closing\").getACall() and\n      nodeTo = contextlibClosingCall and\n      nodeFrom = contextlibClosingCall.getArg(0) and\n      nodeFrom = tarfileOpenMethod().getReturn().getAValueReachableFromSource()\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n/** Global taint tracking for enhanced TarSlip vulnerability detection */\nmodule TarSlipFlow = TaintTracking::Global<TarSlipConfig>;\n\nfrom TarSlipFlow::PathNode source, TarSlipFlow::PathNode sink\nwhere TarSlipFlow::flowPath(source, sink)\nselect sink, source, sink, \"Extraction of tarfile from $@ to potentially unsafe location $@.\",\n  source.getNode(), source.getNode().toString(), sink.getNode(), sink.getNode().toString()",
    "output": "* Handles direct tarfile calls and contextlib.closing wrappers"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-exec]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of the 'exec' statement or function which can lead to arbitrary code execution.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'exec' used\n * @description Detects usage of the 'exec' statement or function which can lead to arbitrary code execution.\n * @kind problem\n * @tags security\n *       correctness\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec\n */\n\n// Import the Python library for code parsing and security analysis\nimport python\n\n// Generate a version-specific warning message based on the Python version being used\n// This helps developers understand which form of 'exec' (statement or function) is being detected\nstring createVersionSpecificExecWarning() {\n  // For Python 2, 'exec' is a statement that can execute arbitrary code\n  major_version() = 2 and result = \"The 'exec' statement is used.\"\n  // For Python 3, 'exec' is a function that can execute arbitrary code\n  or\n  major_version() = 3 and result = \"The 'exec' function is used.\"\n}\n\n// Identify function calls to the built-in 'exec' function which can execute arbitrary code\n// This is a security risk as it allows dynamic code execution\npredicate representsUnsafeExecFunctionCall(Call execFunctionCall) {\n  // Check if the function call references the global variable named 'exec'\n  // This ensures we're detecting the actual built-in 'exec' function, not a user-defined function with the same name\n  exists(GlobalVariable globalExecVariable | \n    globalExecVariable = execFunctionCall.getFunc().(Name).getVariable() and \n    globalExecVariable.getId() = \"exec\"\n  )\n}\n\n// Main query to find all instances of potentially dangerous 'exec' usage\n// Both exec statements (Python 2) and exec function calls (Python 2 and 3) are detected\nfrom AstNode dangerousExecUsage\n// Check if the node represents either an exec function call or an exec statement\n// This covers both forms of 'exec' usage across different Python versions\nwhere \n  representsUnsafeExecFunctionCall(dangerousExecUsage) \n  or \n  dangerousExecUsage instanceof Exec\n// Report the exec usage with an appropriate version-specific warning message\n// This helps developers identify and remediate the security risk\nselect dangerousExecUsage, createVersionSpecificExecWarning()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/symmetric-padding-schemes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all potential implementations of padding schemes used with symmetric encryption algorithms.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Symmetric Padding Schemes Detection\n * @description Identifies all potential implementations of padding schemes used with symmetric encryption algorithms.\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify all symmetric padding scheme implementations in the codebase\nfrom SymmetricPadding symPaddingScheme\n\n// Generate results with algorithm identification\nselect symPaddingScheme,\n  \"Symmetric algorithm detected: \" + symPaddingScheme.getPaddingName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 基类中的属性冲突\n * @description 检测继承自多个基类的类，其中多个基类定义了相同名称的属性。这种冲突可能导致由于属性解析歧义而产生意外行为。\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n/**\n * 判断函数实现是否为空（仅包含pass语句或文档字符串）\n */\npredicate is_empty_implementation(PyFunctionObject func) {\n  not exists(Stmt stmt | stmt.getScope() = func.getFunction() |\n    not stmt instanceof Pass and \n    not stmt.(ExprStmt).getValue() = func.getFunction().getDocString()\n  )\n}\n\n/**\n * 检查函数是否显式调用super()进行方法解析\n */\npredicate invokes_super(FunctionObject func) {\n  exists(Call superCall, Call methodCall, Attribute attr, GlobalVariable superVar |\n    methodCall.getScope() = func.getFunction() and\n    methodCall.getFunc() = attr and\n    attr.getObject() = superCall and\n    attr.getName() = func.getName() and\n    superCall.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/**\n * 识别冲突检测中豁免的属性名称\n */\npredicate is_exempt_attribute(string attrName) {\n  /*\n   * 根据Python的socketserver模块文档，process_request方法被豁免：\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   */\n  attrName = \"process_request\"\n}\n\nfrom\n  ClassObject childClass, \n  ClassObject baseClass1, \n  ClassObject baseClass2, \n  string attributeName, \n  int baseIndex1, \n  int baseIndex2, \n  Object attributeInBase1, \n  Object attributeInBase2\nwhere\n  // 建立继承关系：派生类继承自两个不同的基类（按继承顺序）\n  childClass.getBaseType(baseIndex1) = baseClass1 and\n  childClass.getBaseType(baseIndex2) = baseClass2 and\n  baseIndex1 < baseIndex2 and\n  \n  // 在两个基类中定位相同名称的属性（确保是不同对象）\n  attributeInBase1 != attributeInBase2 and\n  attributeInBase1 = baseClass1.lookupAttribute(attributeName) and\n  attributeInBase2 = baseClass2.lookupAttribute(attributeName) and\n  \n  // 排除特殊方法（双下划线包围的方法）和已知豁免属性\n  not attributeName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  not is_exempt_attribute(attributeName) and\n  \n  // 排除已通过super()调用处理方法解析的情况\n  not invokes_super(attributeInBase1) and\n  \n  // 忽略第二个基类中的空实现（通常不会造成实际冲突）\n_______________ // 补全条件\n  \n  // 确保两个属性间不存在覆盖关系\n  not attributeInBase1.overrides(attributeInBase2) and\n  not attributeInBase2.overrides(attributeInBase1) and\n  \n  // 确保派生类没有显式声明该属性（否则冲突会被解决）\n  not childClass.declaresAttribute(attributeName)\nselect childClass, \n  \"Base classes have conflicting values for attribute '\" + attributeName + \"': $@ and $@.\", \n  attributeInBase1, attributeInBase1.toString(), \n  attributeInBase2, attributeInBase2.toString()",
    "output": "not is_empty_implementation(attributeInBase2) and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python 类源码位置追踪\n * @description 检索 Python 项目中所有已定义类的源文件路径，支持代码导航和依赖关系分析\n * @kind source-link\n * @id py/class-source-links\n * @metricType reftype\n */\n\nimport python\n_______________ // 补全条件\n// 从代码库中提取所有 Python 类定义及其位置信息\nfrom Class cls, Location loc\n// 确保类定义具有可获取的源位置信息\nwhere loc = cls.getLocation()\n// 输出类对象及其对应的源文件完整路径，用于代码导航和依赖分析\nselect cls, loc.getFile()",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/efferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the count of external classes that each class references.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Outgoing class dependencies\n * @description Measures the count of external classes that each class references.\n * @kind treemap\n * @id py/efferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags testability\n *       modularity\n */\n\nimport python\n\n// 检索所有类的度量数据，计算每个类的外向耦合值（依赖的外部类数量）\nfrom ClassMetrics classMetric\nselect classMetric, classMetric.getEfferentCoupling() as externalDependencyCount order by externalDependencyCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-misconfiguration-with-credentials]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Disabling or weakening SOP protection may make the application",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cors misconfiguration with credentials\n * @description Disabling or weakening SOP protection may make the application\n *              vulnerable to a CORS attack.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n// 检查中间件是否为CORS中间件\npredicate isCorsMiddleware(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n// 检查CORS中间件是否启用了凭证支持\npredicate credentialsAllowed(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getCredentialsAllowed().asExpr() instanceof True\n}\n\n// 检查来源配置是否包含通配符或null值\npredicate containsWildcardOrigin(DataFlow::Node originNode) {\n  // 处理列表形式的来源配置\n  exists(List originList | \n    originList = originNode.asExpr() and\n    exists(StringLiteral literal |\n      literal = originList.getASubExpression() and\n      literal.getText() in [\"*\", \"null\"]\n    )\n  )\n  // 处理字符串形式的来源配置\n  or\n  exists(StringLiteral literal |\n    literal = originNode.asExpr() and\n    literal.getText() in [\"*\", \"null\"]\n  )\n}\n\n// 查询存在安全风险的CORS配置\nfrom Http::Server::CorsMiddleware corsMiddleware\nwhere\n  // 验证中间件类型\n  isCorsMiddleware(corsMiddleware) and\n  // 验证凭证启用状态\n  credentialsAllowed(corsMiddleware) and\n  // 验证来源配置安全性\n  containsWildcardOrigin(corsMiddleware.getOrigins().getALocalSource())\nselect corsMiddleware,\n  \"This CORS middleware uses a vulnerable configuration that allows arbitrary websites to make authenticated cross-site requests\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/flask-debug]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：当 Flask 应用程序在调试模式下运行时，攻击者可能利用 Werkzeug 调试器执行任意代码，构成严重安全风险。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Flask 应用在调试模式下运行\n * @description 当 Flask 应用程序在调试模式下运行时，攻击者可能利用 Werkzeug 调试器执行任意代码，构成严重安全风险。\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/flask-debug\n * @tags security\n *       external/cwe/cwe-215\n *       external/cwe/cwe-489\n */\n\nimport python  // Python 代码分析的基础库\nimport semmle.python.dataflow.new.DataFlow  // 提供数据流分析能力\nimport semmle.python.ApiGraphs  // API 调用图分析支持\nimport semmle.python.frameworks.Flask  // Flask 框架特定分析\n\n// 查找所有以调试模式运行的 Flask 应用\nfrom API::CallNode flaskAppRunCall, ImmutableLiteral debugParamValue\nwhere\n  // 检查 debug 参数是否显式设置为 true\n  debugParamValue.booleanValue() = true and\n  // 确认是 Flask 应用实例的 run 方法调用\n  flaskAppRunCall = Flask::FlaskApp::instance().getMember(\"run\").getACall() and\n  // 获取 debug 参数的值\n  debugParamValue = flaskAppRunCall.getParameter(2, \"debug\").getAValueReachingSink().asExpr()\nselect flaskAppRunCall,\n  // 报告发现的安全问题\n  \"检测到 Flask 应用以调试模式运行。这可能导致攻击者通过调试器执行任意代码。\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/unmatchable-dollar]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Regular expressions containing a dollar '$' in the middle cannot be matched, whatever the input.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unmatchable dollar in regular expression\n * @description Regular expressions containing a dollar '$' in the middle cannot be matched, whatever the input.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/regex/unmatchable-dollar\n */\n\nimport python\nimport semmle.python.regex\n\n// Enhanced predicate to detect unmatchable dollar signs\npredicate unmatchable_dollar(RegExp regex, int position) {\n  // Verify regex mode excludes MULTILINE and VERBOSE\n  not (regex.getAMode() = \"MULTILINE\" or regex.getAMode() = \"VERBOSE\") and\n  // Check for '$' character at specified position\n  regex.specialCharacter(position, position + 1, \"$\") and\n  // Ensure '$' is not the last element in the pattern\n  not regex.lastItem(position, position + 1)\n}\n\n// Query for regex patterns with problematic dollar signs\nfrom RegExp regex, int offset\nwhere unmatchable_dollar(regex, offset)\nselect regex,\n  \"This regular expression includes an unmatchable dollar at offset \" + offset.toString() + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Cyclomatic complexity of functions\n * @description This analysis calculates the cyclomatic complexity metric for Python functions.\n *              Cyclomatic complexity measures the number of linearly independent paths through\n *              a function's code, providing insight into its decision logic. Functions with\n *              higher complexity scores typically contain more branching points, potentially\n *              requiring more comprehensive testing efforts and possibly impacting code maintainability.\n * @kind treemap\n * @id py/cyclomatic-complexity-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max sum\n * @tags testability\n *       complexity\n *       maintainability\n */\n\nimport python\n\n// For each Python function, determine its cyclomatic complexity score\nfrom Function func, int complexityValue\n// Retrieve the cyclomatic complexity metric for the function\nwhere complexityValue = func.getMetrics().getCyclomaticComplexity()\n_______________ // 补全条件\nselect func, complexityValue order by complexityValue desc",
    "output": "// Output the function along with its complexity, sorted by highest complexity first"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/ldap-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies potential LDAP injection vulnerabilities where untrusted user input",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name LDAP query constructed from untrusted input sources\n * @description Identifies potential LDAP injection vulnerabilities where untrusted user input\n *              is incorporated into LDAP queries without adequate sanitization, enabling\n *              attackers to execute unauthorized LDAP operations.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.8\n * @precision high\n * @id py/ldap-injection\n * @tags security\n *       external/cwe/cwe-090\n */\n\n// Essential security analysis modules for detecting LDAP injection vulnerabilities\nimport python\nimport semmle.python.security.dataflow.LdapInjectionQuery\nimport LdapInjectionFlow::PathGraph\n\nfrom LdapInjectionFlow::PathNode originNode, LdapInjectionFlow::PathNode targetNode, string paramType\nwhere\n  // Verify data flow to the Distinguished Name (DN) parameter\n  exists(string dnParam |\n    dnParam = \"DN\" and\n    LdapInjectionDnFlow::flowPath(originNode.asPathNode1(), targetNode.asPathNode1()) and \n    paramType = dnParam\n  )\n  or\n  // Verify data flow to the filter parameter\n  exists(string filterParam |\n    filterParam = \"filter\" and\n    LdapInjectionFilterFlow::flowPath(originNode.asPathNode2(), targetNode.asPathNode2()) and \n    paramType = filterParam\n  )\nselect targetNode.getNode(), originNode, targetNode,\n  \"LDAP query parameter (\" + paramType + \") is influenced by a $@.\", originNode.getNode(),\n  \"user-provided value\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during a tarball extraction from a user controlled source\n * @description 检测从用户控制的源提取tar文件时，未验证目标路径是否在目标目录内的情况。\n *             此漏洞可能被攻击者利用进行目录遍历攻击，特别是当tar文件源自不可信来源时。\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// 查询目标：识别从不可信输入源到危险解包函数的数据流路径\nfrom \n_______________ // 补全条件\n  UnsafeUnpackFlow::PathNode maliciousInputSource,\n  // 数据流终点：表示存在漏洞的解包操作点\n  UnsafeUnpackFlow::PathNode vulnerableExtraction\nwhere \n  // 验证从输入源到解包操作存在完整的数据流路径，表明存在潜在安全风险\n  UnsafeUnpackFlow::flowPath(maliciousInputSource, vulnerableExtraction)\n// 输出漏洞信息，包括漏洞位置、数据流路径和风险描述\nselect vulnerableExtraction.getNode(), maliciousInputSource, vulnerableExtraction,\n  \"不安全的解包操作：从不可信远程源获取的恶意tar文件可能导致目录遍历攻击\"",
    "output": "// 数据流起点：表示用户控制的或不可信的输入源"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/statement-nesting-depth-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This analysis calculates the maximum nesting depth of statements within each function.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Statement nesting depth\n * @description This analysis calculates the maximum nesting depth of statements within each function.\n *              Higher nesting levels often indicate increased complexity and can reduce code readability.\n * @kind treemap\n * @id py/statement-nesting-depth-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags maintainability\n *       complexity\n */\n\nimport python\n\n// Select functions to analyze their statement nesting depth\nfrom FunctionMetrics analyzedFunction\n// Compute the highest nesting depth per function and present results in descending order\nselect analyzedFunction, analyzedFunction.getStatementNestingDepth() as depthValue order by depthValue desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jump-to-definition]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Enhanced helper query for navigating from expression usage to their corresponding definition locations in Python source code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Navigate to Definitions\n * @description Enhanced helper query for navigating from expression usage to their corresponding definition locations in Python source code.\n * @kind definitions\n * @id py/jump-to-definition */\n\n// Import the core Python library for static analysis of Python source code\nimport python\n\n// Import the definition tracking module to enable tracing of variable, function, and class definitions\nimport analysis.DefinitionTracking\n\n// This query establishes a mapping between expressions in Python code and their definitions\nfrom NiceLocationExpr sourceExpr, Definition targetDef, string defCategory\n// Resolve the definition associated with the source expression\nwhere \n  targetDef = definitionOf(sourceExpr, defCategory)\n// Return the source expression, its definition, and the definition category for navigation\nselect sourceExpr, targetDef, defCategory"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unknown-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测非对称密钥生成操作中使用了无法静态验证的密钥大小的情况",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 未知密钥生成密钥大小\n * @description 检测非对称密钥生成操作中使用了无法静态验证的密钥大小的情况\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找非对称密钥生成操作，其中密钥大小无法静态验证\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node configurationSource, string algorithmName\nwhere\n  // 确保密钥生成操作没有静态验证的密钥大小\n  not keyGenOperation.hasKeySize(configurationSource) and\n  // 获取密钥配置源和算法名称\n  configurationSource = keyGenOperation.getKeyConfigSrc() and\n  algorithmName = keyGenOperation.getAlgorithm().getName()\nselect keyGenOperation,\n  // 报告问题，指出算法和配置源信息\n  \"用于算法 \" + algorithmName.toString() + \" 的密钥生成使用了无法静态验证的密钥大小，在配置源 $@\", configurationSource, configurationSource.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-missing-self]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects comparisons between identical values that may indicate",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Possible absence of 'self' in comparison operations\n * @description Detects comparisons between identical values that may indicate \n *              a missing 'self' reference in object-oriented Python code.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-missing-self\n */\n\nimport python  // Core Python static analysis capabilities\nimport Expressions.RedundantComparison  // Identifies potentially problematic comparisons\n\nfrom RedundantComparison suspectComparison\nwhere suspectComparison.maybeMissingSelf()\nselect suspectComparison, \"Identical value comparison; potential missing 'self' reference.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name JWT missing secret or public key verification\n * @description The application does not verify the JWT payload with a cryptographic secret or public key.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-missing-verification\n * @tags security\n *       experimental\n *       external/cwe/cwe-347\n */\n\n// 引入Python代码分析的基础库及安全概念相关模块\nimport python\nimport experimental.semmle.python.Concepts\n\n_______________ // 补全条件\nfrom JwtDecoding unverifiedJwtDecode\n// 筛选条件：JWT解码操作缺乏密钥或公钥验证机制\nwhere not unverifiedJwtDecode.verifiesSignature()\n// 输出未经验证的JWT有效载荷及其安全风险描述\nselect unverifiedJwtDecode.getPayload(), \"is not verified with a cryptographic secret or public key.\"",
    "output": "// 识别所有JWT解码操作中未使用密钥或公钥进行签名验证的情况"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-use-with]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies 'try-finally' blocks that exclusively close a resource.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Should use a 'with' statement\n * @description Identifies 'try-finally' blocks that exclusively close a resource. \n *              These patterns can be simplified using Python's 'with' statement \n *              for enhanced readability and automatic resource management.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/should-use-with\n */\n\nimport python\n\n// Determines if a method call targets a 'close' operation\npredicate is_close_method_call(Call closeCall) { \n    exists(Attribute closeAttr | \n        closeCall.getFunc() = closeAttr and \n        closeAttr.getName() = \"close\"\n    ) \n}\n\n// Verifies that a finally block contains only a single close operation\npredicate is_sole_close_in_finally(Try tryBlock, Call closeCall) {\n    exists(ExprStmt closeStmt |\n        tryBlock.getAFinalstmt() = closeStmt and \n        closeStmt.getValue() = closeCall and \n        strictcount(tryBlock.getAFinalstmt()) = 1\n    )\n}\n\n// Checks if a control flow node references a context manager instance\npredicate refers_to_context_manager(ControlFlowNode objectFlowNode, ClassValue contextManagerClass) {\n    forex(Value targetValue | \n        objectFlowNode.pointsTo(targetValue) | \n        targetValue.getClass() = contextManagerClass\n    ) and\n    contextManagerClass.isContextManager()\n}\n\n// Locates try-finally blocks with sole close operations on context managers\nfrom Call closeCall, Try tryBlock, ClassValue contextManagerClass\nwhere\n    is_sole_close_in_finally(tryBlock, closeCall) and\n    is_close_method_call(closeCall) and\n    exists(ControlFlowNode objectFlowNode | \n        objectFlowNode = closeCall.getFunc().getAFlowNode().(AttrNode).getObject() and\n        refers_to_context_manager(objectFlowNode, contextManagerClass)\n    )\nselect closeCall,\n    \"Instance of context-manager class $@ is closed in a finally block. Consider using 'with' statement.\",\n    contextManagerClass, contextManagerClass.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/symmetric-padding-schemes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies symmetric encryption implementations employing padding mechanisms.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Quantum-Vulnerable Symmetric Encryption with Padding\n * @description Identifies symmetric encryption implementations employing padding mechanisms.\n *              Padding schemes in symmetric encryption can introduce security weaknesses\n *              that are particularly susceptible to exploitation in quantum computing environments. \n *              Conventional symmetric ciphers with padding may become inadequate against quantum attacks,\n *              requiring detection and replacement with quantum-resistant alternatives.\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricPadding vulnerableCipher\nselect vulnerableCipher, \n       \"Identified symmetric encryption with padding: \" + vulnerableCipher.getPaddingName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode detection\n * @description Identifies symmetric encryption operations using insecure, deprecated, or unapproved block modes\n * @id py/weak-block-mode\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Helper predicate to identify artifacts in cryptography/hazmat paths\n// These paths are excluded to minimize false positives (e.g., ECB in keywrap contexts)\npredicate isExcludedHazmatArtifact(CryptographicArtifact cryptoArtifact) {\n  cryptoArtifact.asExpr()\n    .getLocation()\n    .getFile()\n    .getAbsolutePath()\n    .toString()\n    .matches(\"%cryptography/hazmat/%\")\n}\n\n// Helper predicate to evaluate block modes for security vulnerabilities\npredicate assessBlockModeWeakness(CryptographicArtifact cryptoArtifact, string warningMessage) {\n  cryptoArtifact instanceof BlockMode and\n  // ECB mode is only allowed in KeyWrapOperation contexts\n  (cryptoArtifact.(BlockMode).getBlockModeName() = \"ECB\" implies \n    not cryptoArtifact instanceof KeyWrapOperation) and\n  exists(string modeName | modeName = cryptoArtifact.(BlockMode).getBlockModeName() |\n    // Only CBC, CTS, and XTS are considered secure modes\n    // Reference: Microsoft.Security.Cryptography.10002\n    not modeName = [\"CBC\", \"CTS\", \"XTS\"] and\n    (\n      modeName = unknownAlgorithm() and\n      warningMessage = \"Use of unrecognized block mode algorithm.\"\n      or\n      modeName in [\"GCM\", \"CCM\"] and\n_______________ // 补全条件\n        \" requires special crypto board approval/review.\"\n      or\n      not modeName = unknownAlgorithm() and not modeName in [\"GCM\", \"CCM\"] and\n      warningMessage = \"Use of unapproved block mode algorithm or API \" + modeName + \".\"\n    )\n  )\n}\n\n// Helper predicate to detect ciphers without explicitly specified block modes\npredicate detectUnspecifiedBlockMode(CryptographicArtifact cryptoArtifact, string warningMessage) {\n  cryptoArtifact instanceof SymmetricCipher and\n  not cryptoArtifact.(SymmetricCipher).hasBlockMode() and\n  warningMessage = \"Cipher has unspecified block mode algorithm.\"\n}\n\n// Main query to identify cryptographic artifacts with security issues\nfrom CryptographicArtifact cryptoArtifact, string warningMessage\nwhere\n  // Exclude artifacts in cryptography/hazmat paths to reduce false positives\n  // (e.g., ECB usage inside keywrap operations)\n  not isExcludedHazmatArtifact(cryptoArtifact) and\n  (\n    // Evaluate weak or unapproved block modes\n    assessBlockModeWeakness(cryptoArtifact, warningMessage)\n    or\n    // Detect ciphers without specified block mode\n    detectUnspecifiedBlockMode(cryptoArtifact, warningMessage)\n  )\nselect cryptoArtifact, warningMessage",
    "output": "warningMessage = \"Use of block mode algorithm \" + modeName +"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Analyzes and identifies alert suppression mechanisms in Python codebases,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Analyzes and identifies alert suppression mechanisms in Python codebases, \n *              providing detailed information about how warnings and alerts are being suppressed.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL alert suppression utilities for handling suppression logic\nprivate import codeql.util.suppression.AlertSuppression as SuppressionUtils\n// Import Python comment processing utilities for analyzing code comments\nprivate import semmle.python.Comment as PyComment\n\n// Represents enhanced AST nodes with comprehensive location tracking capabilities\nclass EnhancedAstNode instanceof PyComment::AstNode {\n  // Check if node corresponds to specific file location coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Generate human-readable string representation of the AST node\n  string toString() { result = super.toString() }\n}\n\n// Represents single-line comments with precise location tracking and text extraction\nclass TrackedSingleLineComment instanceof PyComment::Comment {\n  // Verify if comment matches specified location coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Extract the textual content from the comment\n  string getText() { result = super.getContents() }\n\n  // Provide descriptive string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Apply suppression relationship generation using SuppressionUtils template\nimport SuppressionUtils::Make<EnhancedAstNode, TrackedSingleLineComment>\n\n/**\n * A noqa-style suppression comment. Both pylint and pyflakes respect this convention,\n * making it a standard mechanism for suppressing warnings in Python codebases.\n */\n// Represents suppression comments following the noqa convention\nclass NoqaStyleSuppressionComment extends SuppressionComment instanceof TrackedSingleLineComment {\n  // Constructor that identifies noqa comment patterns with case-insensitive matching\n  NoqaStyleSuppressionComment() {\n    TrackedSingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Return the standardized suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define the scope of code coverage for this suppression annotation\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Ensure comment location matches and enforce line-start positioning\n    this.hasLocationInfo(filePath, startLine, _, endLine, endCol) and\n    startCol = 1\n  }\n}"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Importing value of mutable attribute\n * @description Direct import of mutable attribute values prevents observing global state changes locally.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity high\n * @precision medium\n * @id py/import-of-mutable-attribute\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom ImportMember importedMember, ModuleValue moduleValue, AttrNode attributeStore, string attributeName\nwhere\n  // Verify module matching between imported and target module\n  moduleValue.importedAs(importedMember.getModule().(ImportExpr).getImportedModuleName()) and\n  // Ensure imported member name matches attribute name\n  importedMember.getName() = attributeName and\n  // Attribute modification must occur within function scope\n  attributeStore.getScope() instanceof Function and\n  // Imported variable must have extended lifetime (non-function scope)\n  not importedMember.getScope() instanceof Function and\n  // Confirm attribute is a store operation\n  attributeStore.isStore() and\n  // Verify attribute references the imported module\n_______________ // 补全条件\n  // Ensure import and modification occur in different modules\n  not importedMember.getEnclosingModule() = attributeStore.getScope().getEnclosingModule() and\n  // Exclude modifications within test code\n  not attributeStore.getScope().getScope*() instanceof TestScope\nselect importedMember,\n  \"Importing the value of '\" + attributeName +\n    \"' from $@ means that any change made to $@ will be not be observed locally.\", moduleValue,\n  \"module \" + moduleValue.getName(), attributeStore, moduleValue.getName() + \".\" + attributeStore.getName()",
    "output": "attributeStore.getObject(attributeName).pointsTo(moduleValue) and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name C-style condition\n * @description Identifies redundant parentheses around expressions in control flow statements.\n *              Such parentheses are unnecessary in Python and reduce code readability.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/c-style-parentheses\n */\n\nimport python  // 导入Python语言库，用于分析Python代码\n\nfrom Expr parenthesizedExpression, Location expressionLocation, string statementType, string expressionRole  // 从表达式、位置、语句类型和表达式角色中选择数据\nwhere\n  // 验证表达式被括号包围且不是元组\n  parenthesizedExpression.isParenthesized() and\n  not parenthesizedExpression instanceof Tuple and\n  \n  // 确保表达式位于同一行内\n  expressionLocation = parenthesizedExpression.getLocation() and\n  expressionLocation.getStartLine() = expressionLocation.getEndLine() and\n  \n  // 排除需要括号的表达式类型\n  not parenthesizedExpression instanceof Yield and\n  not parenthesizedExpression instanceof YieldFrom and\n  not parenthesizedExpression instanceof GeneratorExp and\n  \n  // 检查表达式是否在特定语句中使用\n  (\n    // 处理if语句的条件表达式\n    exists(If ifStatement | \n      ifStatement.getTest() = parenthesizedExpression and \n      statementType = \"if\" and \n      expressionRole = \"condition\"\n    )\n    \n    or\n    \n    // 处理while语句的条件表达式\n    exists(While whileStatement | \n      whileStatement.getTest() = parenthesizedExpression and \n      statementType = \"while\" and \n      expressionRole = \"condition\"\n    )\n    \n    or\n    \n    // 处理return语句的返回值\n    exists(Return returnStatement | \n      returnStatement.getValue() = parenthesizedExpression and \n      statementType = \"return\" and \n      expressionRole = \"value\"\n    )\n    \n    or\n    \n    // 处理没有消息的assert语句的测试部分\n    exists(Assert assertStatement | \n      assertStatement.getTest() = parenthesizedExpression and \n      not exists(assertStatement.getMsg()) and\n_______________ // 补全条件\n      expressionRole = \"test\"\n    )\n  )\n\n// 选择表达式并生成描述信息\nselect parenthesizedExpression, \"Parenthesized \" + expressionRole + \" in '\" + statementType + \"' statement.\"",
    "output": "statementType = \"assert\" and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raises-tuple]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code that raises a tuple in Python 2, which results in only the first element being raised",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Tuple raising in Python 2\n * @description Detects code that raises a tuple in Python 2, which results in only the first element being raised\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// Detect raise statements involving tuples in Python 2\nfrom Raise raiseExpression, DataFlow::LocalSourceNode tupleSource\nwhere\n  // Ensure we're analyzing Python 2 code\n  major_version() = 2 and\n  // Verify the source is a tuple expression\n  tupleSource.asExpr() instanceof Tuple and\n  // Check data flow from tuple to the exception being raised\n  exists(DataFlow::Node exceptionTarget | \n    exceptionTarget.asExpr() = raiseExpression.getException() and\n    tupleSource.flowsTo(exceptionTarget)\n  )\n/* Note: In Python 3, raising a tuple is a type error and is handled by the IllegalRaise query. */\nselect raiseExpression,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleSource, \"tuple\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/unmatchable-caret]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Regular expressions containing a caret '^' in the middle cannot be matched, whatever the input.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unmatchable caret in regular expression\n * @description Regular expressions containing a caret '^' in the middle cannot be matched, whatever the input.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/regex/unmatchable-caret\n */\n\nimport python\nimport semmle.python.regex\n\n/**\n * Identifies regex patterns with invalid mid-string caret positions:\n * - Pattern lacks MULTILINE/VERBOSE modes (which allow mid-string anchors)\n * - Contains literal '^' at specified position\n * - Caret isn't at pattern start (where it functions as valid anchor)\n */\npredicate has_unmatchable_caret(RegExp regex, int caretPos) {\n  // Verify regex doesn't use modes that permit mid-string anchors\n  not regex.getAMode() = \"MULTILINE\" and\n  not regex.getAMode() = \"VERBOSE\" and\n  \n  // Confirm caret exists at exact position\n  regex.specialCharacter(caretPos, caretPos + 1, \"^\") and\n  \n  // Exclude valid start-of-pattern anchors\n  not regex.firstItem(caretPos, caretPos + 1)\n}\n\n// Locate regex patterns containing invalid mid-string carets\nfrom RegExp badRegex, int caretLoc\nwhere has_unmatchable_caret(badRegex, caretLoc)\nselect badRegex,\n  \"This regular expression includes an unmatchable caret at offset \" + caretLoc.toString() + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/log-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies security vulnerabilities where untrusted user inputs",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Log Injection Vulnerability\n * @description Identifies security vulnerabilities where untrusted user inputs\n *              are directly written to logs without sanitization, potentially\n *              enabling log tampering, forgery, or injection attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.8\n * @precision medium\n * @id py/log-injection\n * @tags security\n *       external/cwe/cwe-117\n */\n\nimport python\nimport semmle.python.security.dataflow.LogInjectionQuery\nimport LogInjectionFlow::PathGraph\n\nfrom LogInjectionFlow::PathNode maliciousSource, \n     LogInjectionFlow::PathNode vulnerableSink\nwhere LogInjectionFlow::flowPath(maliciousSource, vulnerableSink)\nselect vulnerableSink.getNode(), \n       maliciousSource, \n       vulnerableSink,\n       \"This log entry incorporates a $@.\", \n       maliciousSource.getNode(),\n       \"user-provided value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comment-ratio-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes the percentage of comment lines relative to the total lines in a Python module.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python file comment density analysis\n * @description Computes the percentage of comment lines relative to the total lines in a Python module.\n *              Note that docstrings are not counted as comments and are evaluated separately.\n * @kind treemap\n * @id py/comment-ratio-per-file\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg max\n * @tags maintainability\n *       documentation\n */\n\nimport python\n\nfrom Module pyModule\nwhere pyModule.getMetrics().getNumberOfLines() > 0\nselect pyModule, \n       (100.0 * pyModule.getMetrics().getNumberOfLinesOfComments()) / pyModule.getMetrics().getNumberOfLines() as commentRatio\norder by commentRatio desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 类继承层次结构分析\n * 此查询旨在识别特定类及其在继承体系中的完整父类和子类关系\n */\n\nimport python\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n\n_______________ // 补全条件\npredicate isAnalysisTarget(Class targetClass) {\n  // 检查类名是否与预设目标匹配\n  targetClass.getName() = \"YourClassName\"\n  // 可选条件：验证类是否位于特定文件路径\n  // and targetClass.getLocation().getFile().getAbsolutePath().matches(\"%/folder/file.py\")\n}\n\n// 获取目标类的所有祖先类（包括直接和间接继承关系）\nquery predicate retrieveAncestorClasses(Class childClass, Class parentClass) {\n  isAnalysisTarget(childClass) and\n  parentClass = getADirectSuperclass+(childClass)\n}\n\n// 获取目标类的所有后代类（包括直接和间接派生关系）\nquery predicate retrieveDescendantClasses(Class parentClass, Class childClass) {\n  isAnalysisTarget(parentClass) and\n  childClass = getADirectSubclass+(parentClass)\n}\n\n// 检索并输出所有满足目标条件的类\nfrom Class targetClass\nwhere isAnalysisTarget(targetClass)\nselect targetClass",
    "output": "// 确定类是否为当前分析的目标类"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "import python\n\n/**\n * @name Explicit returns mixed with implicit (fall through) returns\n * @description Identifies functions that combine both explicit return statements and implicit returns.\n *              This pattern often indicates a logic error since implicit returns always evaluate to 'None',\n *              potentially causing unexpected behavior when different return types are expected.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mixed-returns\n */\n\n// Detects functions that have at least one return statement with a non-None value\npredicate containsExplicitNonNoneReturn(Function func) {\n  exists(Return retStmt |\n    retStmt.getScope() = func and\n    exists(Expr retValue | \n      retValue = retStmt.getValue() and \n      not retValue instanceof None\n    )\n  )\n}\n\n// Checks if a function contains any implicit return paths (either fallthrough or empty returns)\npredicate containsImplicitReturnPath(Function func) {\n  // Check for reachable fallthrough nodes\n  exists(ControlFlowNode fallThruNode |\n    fallThruNode = func.getFallthroughNode() and \n    not fallThruNode.unlikelyReachable()\n  )\n  // Also check for return statements without values\n_______________ // 补全条件\n  exists(Return retStmt | \n    retStmt.getScope() = func and \n    not exists(retStmt.getValue())\n  )\n}\n\n// Main query to identify functions with both explicit non-None returns and implicit returns\nfrom Function targetFunction\nwhere containsExplicitNonNoneReturn(targetFunction) and containsImplicitReturnPath(targetFunction)\nselect targetFunction,\n  \"Mixing implicit and explicit returns may indicate an error as implicit returns always return None.\"",
    "output": "or"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of insecure SSL/TLS version\n * @description Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n/* Represents protocol configuration nodes that may use insecure SSL/TLS versions */\nclass InsecureProtocolConfig extends DataFlow::Node {\n  InsecureProtocolConfig() {\n    /* Case 1: Creating insecure connection with context */\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    /* Case 2: Creating insecure connection without context */\n    unsafe_connection_creation_without_context(this, _)\n    or\n    /* Case 3: Creating insecure context */\n    unsafe_context_creation(this, _)\n  }\n\n  /* Retrieves the function node associated with this configuration */\n  DataFlow::Node getAssociatedFunction() { result = this.(DataFlow::CallCfgNode).getFunction() }\n}\n\n/* Represents nodes that can be named (function calls or attribute references) */\nclass NamedNode extends DataFlow::Node {\n  NamedNode() {\n    /* Case 1: Node is a function in protocol configuration */\n    this = any(InsecureProtocolConfig ipc).getAssociatedFunction()\n    or\n    /* Case 2: Node is an attribute reference of another named node */\n    this = any(NamedNode attr).(DataFlow::AttrRef).getObject()\n  }\n}\n\n/* Retrieves the fully qualified name of a named node */\nstring getFullyQualifiedName(NamedNode node) {\n  /* Case 1: Direct function name */\n  result = node.asExpr().(Name).getId()\n  or\n  /* Case 2: Attribute access chain */\n  exists(DataFlow::AttrRef attrRef | attrRef = node |\n    result = getFullyQualifiedName(attrRef.getObject()) + \".\" + attrRef.getAttributeName()\n  )\n}\n\n/* Retrieves descriptive name for protocol configuration */\nstring getProtocolConfigDescription(InsecureProtocolConfig configNode) {\n  /* Case 1: Function call configuration */\n  result = \"call to \" + getFullyQualifiedName(configNode.(DataFlow::CallCfgNode).getFunction())\n  or\n  /* Case 2: Context modification (non-call, non-context creation) */\n  not configNode instanceof DataFlow::CallCfgNode and\n  not configNode instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n/* Retrieves appropriate verb based on specificity flag */\nstring getSpecificityVerb(boolean isSpecific) {\n  isSpecific = true and result = \"specified\"\n  or\n  isSpecific = false and result = \"allowed\"\n}\n\n/* Query detecting insecure SSL/TLS version usage */\nfrom\n  DataFlow::Node insecureConnNode, string insecureProtoVer, \n_______________ // 补全条件\nwhere\n  /* Case 1: Insecure connection creation with context */\n  (\n    unsafe_connection_creation_with_context(insecureConnNode, insecureProtoVer, protoConfigNode, isSpecificVer)\n  )\n  or\n  /* Case 2: Insecure connection creation without context */\n  (\n    unsafe_connection_creation_without_context(insecureConnNode, insecureProtoVer) and\n    protoConfigNode = insecureConnNode and\n    isSpecificVer = true\n  )\n  or\n  /* Case 3: Insecure context creation */\n  (\n    unsafe_context_creation(protoConfigNode, insecureProtoVer) and\n    insecureConnNode = protoConfigNode and\n    isSpecificVer = true\n  )\nselect insecureConnNode,\n  \"Insecure SSL/TLS protocol version \" + insecureProtoVer + \" \" + getSpecificityVerb(isSpecificVer) + \" by $@.\",\n  protoConfigNode, getProtocolConfigDescription(protoConfigNode)",
    "output": "InsecureProtocolConfig protoConfigNode, boolean isSpecificVer"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-commented-out-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects and measures the number of lines that contain commented-out code within source files",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lines of commented-out code in files\n * @description Detects and measures the number of lines that contain commented-out code within source files\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// Import necessary CodeQL libraries for Python code analysis and commented code identification\nimport python\nimport Lexical.CommentedOutCode\n\n// Query to identify source files containing commented-out code and calculate the count of such lines\nfrom File sourceFile, int commentedOutLinesCount\nwhere \n    // Calculate the total number of commented-out code lines in each file, excluding potential example code\n    commentedOutLinesCount = count(CommentedOutCodeLine commentedLine | \n        // Filter out lines that could be example code\n        not commentedLine.maybeExampleCode() and \n        // Ensure the commented line is associated with the current source file\n        commentedLine.getLocation().getFile() = sourceFile)\n// Output results displaying each source file along with its respective count of commented-out code lines, sorted in descending order\nselect sourceFile, commentedOutLinesCount order by commentedOutLinesCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies functions with uppercase initial characters that reduce code readability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed function\n * @description Identifies functions with uppercase initial characters that reduce code readability.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python\n\n// Predicate to check if a function name starts with an uppercase letter\npredicate starts_with_uppercase(Function targetFunction) {\n  exists(string initialChar |\n    initialChar = targetFunction.getName().prefix(1) and  // Extract first character of function name\n    initialChar != initialChar.toLowerCase()  // Verify character remains uppercase when converted\n  )\n}\n\n// Identify source functions with uppercase names that are unique in their file\nfrom Function targetFunction\nwhere\n  targetFunction.inSource() and  // Ensure function exists in source code\n  starts_with_uppercase(targetFunction) and  // Check for uppercase initial character\n  not exists(Function otherFunction |\n    otherFunction != targetFunction and  // Exclude the same function instance\n    otherFunction.getLocation().getFile() = targetFunction.getLocation().getFile() and  // Same file constraint\n    starts_with_uppercase(otherFunction)  // Other function also has uppercase name\n  )\nselect targetFunction, \"Function names should start in lowercase.\"  // Report findings with recommendation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-commented-out-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides a quantitative analysis of commented-out code lines across source files",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lines of commented-out code in files\n * @description Provides a quantitative analysis of commented-out code lines across source files\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// Import necessary CodeQL libraries for Python source code analysis and commented code detection\nimport python\nimport Lexical.CommentedOutCode\n\n// Define variables to represent source files and their respective commented code line counts\nfrom File targetFile, int totalCommentedLines\n// Compute the count of non-example commented code lines for each source file\nwhere \n    totalCommentedLines = count(CommentedOutCodeLine codeLine | \n        not codeLine.maybeExampleCode() and \n        codeLine.getLocation().getFile() = targetFile)\n// Generate results displaying file paths along with their commented code metrics, ordered by volume\nselect targetFile, totalCommentedLines order by totalCommentedLines desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Quantum-Vulnerable Symmetric Encryption with Padding\n * @description Detects symmetric encryption implementations utilizing padding mechanisms.\n *              Padding schemes in symmetric encryption can introduce security vulnerabilities\n *              that are particularly exploitable in quantum computing environments. Traditional\n *              symmetric ciphers with padding may become insufficient against quantum attacks,\n *              requiring identification and replacement with quantum-resistant alternatives.\n * @kind problem\n_______________ // 补全条件\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricPadding paddedSymmetricCipher\nselect paddedSymmetricCipher, \n       \"Detected symmetric encryption using padding: \" + paddedSymmetricCipher.getPaddingName()",
    "output": "* @id py/quantum-readiness/cbom/symmetric-padding-schemes"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name CSRF protection weakened or disabled\n * @description Disabling or weakening CSRF protection may make the application\n *              vulnerable to a Cross-Site Request Forgery (CSRF) attack.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/csrf-protection-disabled\n * @tags security\n *       external/cwe/cwe-352\n */\n\nimport python\nimport semmle.python.Concepts\n\n// Identifies production environment CSRF configurations\n// Filters out test-related files using path pattern analysis\npredicate isProductionCsrfConfig(Http::Server::CsrfProtectionSetting csrfSetting) {\n_______________ // 补全条件\n}\n\n// Detects configurations with insufficient CSRF protection\n// Evaluates three critical conditions:\n// 1. CSRF verification is disabled\n// 2. No local CSRF protection mechanisms exist\n// 3. Configuration applies to production environment\npredicate isCsrfProtectionInadequate(Http::Server::CsrfProtectionSetting csrfSetting) {\n  csrfSetting.getVerificationSetting() = false and\n  not exists(Http::Server::CsrfLocalProtectionSetting localProtection | \n    localProtection.csrfEnabled()\n  ) and\n  isProductionCsrfConfig(csrfSetting)\n}\n\n// Primary query to identify vulnerable CSRF configurations\n// Performs comprehensive analysis by:\n// 1. Confirming current configuration has inadequate protection\n// 2. Ensuring no secure configurations exist in production\nfrom Http::Server::CsrfProtectionSetting vulnerableConfig\nwhere\n  // Current configuration must be vulnerable\n  isCsrfProtectionInadequate(vulnerableConfig) and\n  // Production environment must lack secure alternatives\n  not exists(Http::Server::CsrfProtectionSetting secureConfig |\n    isProductionCsrfConfig(secureConfig) and\n    not isCsrfProtectionInadequate(secureConfig)\n  )\nselect vulnerableConfig, \"Potential CSRF vulnerability due to forgery protection being disabled or weakened.\"",
    "output": "not csrfSetting.getLocation().getFile().getAbsolutePath().matches(\"%test%\")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Method override signature incompatibility\n * @description Detects inheritance scenarios where a child class method overrides a parent class method\n *              with incompatible parameter counts, potentially causing runtime errors during method resolution.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Identify overridden method pairs with signature incompatibilities\nfrom FunctionValue parentMethod, PythonFunctionValue childMethod\nwhere\n_______________ // 补全条件\n  childMethod.overrides(parentMethod) and\n  \n  // Filter to standard instance methods (exclude special methods and constructors)\n  childMethod.isNormalMethod() and\n  not childMethod.getScope().isSpecialMethod() and\n  childMethod.getName() != \"__init__\" and\n  \n  // Exclude cases where parent method is directly invoked\n  not exists(parentMethod.getACall()) and\n  \n  // Ensure no sibling overriding methods are being called\n  not exists(FunctionValue siblingOverride |\n    siblingOverride.overrides(parentMethod) and\n    exists(siblingOverride.getACall())\n  ) and\n  \n  // Detect parameter count incompatibility scenarios\n  (\n    // Case 1: Child method requires more parameters than parent can provide\n    childMethod.minParameters() > parentMethod.maxParameters()\n    or\n    // Case 2: Child method accepts fewer parameters than parent requires\n    childMethod.maxParameters() < parentMethod.minParameters()\n  )\nselect childMethod, \"Overriding method '\" + childMethod.getName() + \"' has signature mismatch with $@.\",\n  parentMethod, \"overridden method\"",
    "output": "// Verify override relationship between methods"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称加密密钥大小不可静态验证\n * @description 检测非对称加密算法密钥生成过程中，密钥大小参数无法通过静态分析确定的代码模式\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找非对称密钥生成操作及其配置源\nfrom AsymmetricKeyGen asymmetricKeyGeneration, DataFlow::Node keyConfigSource\nwhere\n  // 确定密钥配置源\n  keyConfigSource = asymmetricKeyGeneration.getKeyConfigSrc()\n  and\n  // 检查密钥大小是否无法静态验证\n  not asymmetricKeyGeneration.hasKeySize(keyConfigSource)\nselect asymmetricKeyGeneration,\n_______________ // 补全条件\n  \"算法 \" + asymmetricKeyGeneration.getAlgorithm().getName() + \" 的密钥生成使用了无法静态验证的密钥大小，配置源位于 $@\", keyConfigSource, keyConfigSource.toString()",
    "output": "// 构建包含算法名称和配置源的诊断信息"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-hashes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of cryptographic hash functions that are either",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak cryptographic hash algorithms\n * @description Detects usage of cryptographic hash functions that are either\n *              deprecated or considered insecure for security-sensitive contexts.\n *              This query identifies hash algorithms that are not part of the\n *              approved strong algorithm set (SHA256, SHA384, SHA512) or cannot\n *              be recognized by the analysis.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import required Python modules and cryptographic analysis components\nimport python\nimport experimental.cryptography.Concepts\n\n// Find cryptographic hash operations utilizing weak or non-approved algorithms\nfrom HashAlgorithm cryptoHashOperation, string hashAlgorithmName, string securityAlert\nwhere\n  // Retrieve the name of the hash algorithm being used\n  hashAlgorithmName = cryptoHashOperation.getHashName() and\n  // Filter out strong, approved hash algorithms from our detection\n  not hashAlgorithmName = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // Construct appropriate security alert based on algorithm recognition\n  (\n    // Handle recognized but unapproved algorithms\n    hashAlgorithmName != \"\" and\n    securityAlert = \"Use of unapproved hash algorithm or API \" + hashAlgorithmName + \".\"\n    or\n    // Handle unrecognized algorithms\n    hashAlgorithmName = \"\" and\n    securityAlert = \"Use of unrecognized hash algorithm.\"\n  )\nselect cryptoHashOperation, securityAlert"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/xml-bomb]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测将不受限的用户输入作为XML文档处理的代码路径，此类代码易受XML实体扩展攻击（也称\"XML炸弹\"），可能导致资源耗尽和服务拒绝。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name XML实体扩展炸弹漏洞分析\n * @description 检测将不受限的用户输入作为XML文档处理的代码路径，此类代码易受XML实体扩展攻击（也称\"XML炸弹\"），可能导致资源耗尽和服务拒绝。\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @id py/xml-bomb\n * @tags security\n *       external/cwe/cwe-776\n *       external/cwe/cwe-400\n */\n\nimport python\nimport semmle.python.security.dataflow.XmlBombQuery\nimport XmlBombFlow::PathGraph\n\n// 检测XML炸弹漏洞：追踪从不可信输入源到XML处理器的数据流路径\nfrom \n  XmlBombFlow::PathNode untrustedSource,    // 不可信输入源头\n  XmlBombFlow::PathNode vulnerableXmlSink    // 存在漏洞的XML处理节点\nwhere \n  // 验证存在从输入源到XML处理器的完整数据流路径\n  XmlBombFlow::flowPath(untrustedSource, vulnerableXmlSink)\nselect \n  // 输出漏洞信息，包括目标位置、源位置、路径节点以及警告描述\n  vulnerableXmlSink.getNode(), \n  untrustedSource, \n  vulnerableXmlSink,\n  \"XML处理器接收到一个$@，但缺少对实体扩展的安全限制。\",\n  untrustedSource.getNode(), \n  \"不可信的输入源\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-inference-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code locations where type inference for 'object' types is incomplete.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type inference fails for 'object'\n * @description Detects code locations where type inference for 'object' types is incomplete.\n *              This limitation hinders security analysis by restricting data flow tracking\n *              and compromising type relationship precision. The problem manifests when\n *              control flow nodes utilize the basic 1-argument refersTo() predicate\n *              instead of the detailed 3-argument version that includes full type context.\n * @kind problem\n * @problem.severity info\n * @id py/type-inference-failure\n * @deprecated\n */\n\nimport python\n\nfrom ControlFlowNode flowNode, Object targetObject\nwhere \n  // Check if the node references an object using the simplified form\n  flowNode.refersTo(targetObject) \n  // Ensure the node does NOT use the comprehensive form with type information\n  and not flowNode.refersTo(targetObject, _, _)\nselect targetObject, \"Type inference fails for 'object'.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Provides a count of all repository commits, excluding artificial changes",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of commits\n * @description Provides a count of all repository commits, excluding artificial changes\n * @kind treemap\n * @id py/historical-number-of-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\n// Import Python language support for the analysis\nimport python\n// Import Version Control System (VCS) libraries to access commit history data\nimport external.VCS\n\n// Data source: retrieve all commit records from the repository\nfrom Commit revision\n// Filtering: exclude any commits that represent artificial or non-user changes\nwhere not artificialChange(revision)\n// Output: for each valid commit, return its revision name and a count of 1 for aggregation\nselect revision.getRevisionName(), 1"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type metrics\n * @description Quantifies different categories of type annotations in Python code\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents core Python built-in types\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Defines union type for elements supporting type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr functionExpr) { exists(functionExpr.getReturns()) } or \n  TAnnotatedParameter(Parameter parameter) { exists(parameter.getAnnotation()) } or \n  TAnnotatedAssignment(AnnAssign annotatedAssign) { exists(annotatedAssign.getAnnotation()) }\n\n// Base class for elements that can have type annotations\n_______________ // 补全条件\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Represents functions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr functionExpression;\n  AnnotatedFunction() { this = TAnnotatedFunction(functionExpression) }\n  override Expr getAnnotation() { result = functionExpression.getReturns() }\n}\n\n// Represents parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter parameter;\n  AnnotatedParameter() { this = TAnnotatedParameter(parameter) }\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\n// Represents assignments with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign annotatedAssignment;\n  AnnotatedAssignment() { this = TAnnotatedAssignment(annotatedAssignment) }\n  override Expr getAnnotation() { result = annotatedAssignment.getAnnotation() }\n}\n\n/** Determines if an annotation is a forward-declared type (string literal) */\npredicate is_forward_declaration(Expr annotationExpr) { annotationExpr instanceof StringLiteral }\n\n/** Determines if an annotation represents a complex type structure */\npredicate is_complex_type(Expr annotationExpr) {\n  annotationExpr instanceof Subscript and not is_optional_type(annotationExpr)\n  or\n  annotationExpr instanceof Tuple\n  or\n  annotationExpr instanceof List\n}\n\n/** Determines if an annotation is an Optional type */\npredicate is_optional_type(Subscript annotationExpr) { annotationExpr.getObject().(Name).getId() = \"Optional\" }\n\n/** Determines if an annotation is a simple user-defined type */\npredicate is_simple_type(Expr annotationExpr) {\n  annotationExpr instanceof Name and not annotationExpr instanceof BuiltinType\n  or\n  is_simple_type(annotationExpr.(Attribute).getObject())\n}\n\n/** Determines if an annotation is a built-in type */\npredicate is_builtin_type(Expr annotationExpr) { annotationExpr instanceof BuiltinType }\n\n// Computes type annotation metrics for different annotation categories\npredicate type_count(\n  string kind, int total, int built_in_count, int forward_declaration_count, \n  int simple_type_count, int complex_type_count, int optional_type_count\n) {\n  kind = \"Parameter annotation\" and\n  total = count(AnnotatedParameter annotatedParameter) and\n  built_in_count = count(AnnotatedParameter annotatedParameter | is_builtin_type(annotatedParameter.getAnnotation())) and\n  forward_declaration_count = count(AnnotatedParameter annotatedParameter | is_forward_declaration(annotatedParameter.getAnnotation())) and\n  simple_type_count = count(AnnotatedParameter annotatedParameter | is_simple_type(annotatedParameter.getAnnotation())) and\n  complex_type_count = count(AnnotatedParameter annotatedParameter | is_complex_type(annotatedParameter.getAnnotation())) and\n  optional_type_count = count(AnnotatedParameter annotatedParameter | is_optional_type(annotatedParameter.getAnnotation()))\n  or\n  kind = \"Return type annotation\" and\n  total = count(AnnotatedFunction annotatedFunction) and\n  built_in_count = count(AnnotatedFunction annotatedFunction | is_builtin_type(annotatedFunction.getAnnotation())) and\n  forward_declaration_count = count(AnnotatedFunction annotatedFunction | is_forward_declaration(annotatedFunction.getAnnotation())) and\n  simple_type_count = count(AnnotatedFunction annotatedFunction | is_simple_type(annotatedFunction.getAnnotation())) and\n  complex_type_count = count(AnnotatedFunction annotatedFunction | is_complex_type(annotatedFunction.getAnnotation())) and\n  optional_type_count = count(AnnotatedFunction annotatedFunction | is_optional_type(annotatedFunction.getAnnotation()))\n  or\n  kind = \"Annotated assignment\" and\n  total = count(AnnotatedAssignment annotatedAssignment) and\n  built_in_count = count(AnnotatedAssignment annotatedAssignment | is_builtin_type(annotatedAssignment.getAnnotation())) and\n  forward_declaration_count = count(AnnotatedAssignment annotatedAssignment | is_forward_declaration(annotatedAssignment.getAnnotation())) and\n  simple_type_count = count(AnnotatedAssignment annotatedAssignment | is_simple_type(annotatedAssignment.getAnnotation())) and\n  complex_type_count = count(AnnotatedAssignment annotatedAssignment | is_complex_type(annotatedAssignment.getAnnotation())) and\n  optional_type_count = count(AnnotatedAssignment annotatedAssignment | is_optional_type(annotatedAssignment.getAnnotation()))\n}\n\n// Query execution and result projection\nfrom\n  string message, int total, int built_in, int forward_decl, int simple, int complex, int optional\nwhere type_count(message, total, built_in, forward_decl, simple, complex, optional)\nselect message, total, built_in, forward_decl, simple, complex, optional",
    "output": "abstract class Annotatable extends TAnnotatable {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/call-graph]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Constructs a representation of the call graph by mapping function invocation sites to their potential callable targets.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python Call Graph Analysis\n * @description Constructs a representation of the call graph by mapping function invocation sites to their potential callable targets.\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/call-graph\n * @tags meta\n * @precision very-low\n */\n\n// Import the Python language analysis framework\nimport python\n// Import specialized utilities for internal data flow analysis used in call graph construction\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n// Import utilities for meta metrics and code analysis\nimport meta.MetaMetrics\n\n// Define the relationship between function call sites and their potential target functions\nfrom DataFlowCall invocationPoint, DataFlowCallable callableTarget\nwhere\n  // Filter out call sites located in ignored files\n  not invocationPoint.getLocation().getFile() instanceof IgnoredFile and\n  // Filter out target functions located in ignored files\n  not callableTarget.getScope().getLocation().getFile() instanceof IgnoredFile and\n  // Ensure the target function is a viable callable for the call site\n  callableTarget = viableCallable(invocationPoint)\nselect invocationPoint, \"Call to $@\", callableTarget.getScope(), callableTarget.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 分析目标类及其继承层次结构\n * 通过类名精确匹配定位目标类，可选通过文件路径进一步过滤\n */\n\nimport python\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n\n// 判断类是否为目标类的谓词\npredicate isTargetClass(Class cls) {\n  // 匹配指定类名\n  cls.getName() = \"YourClassName\"\n  // 可选：通过文件路径进一步限定\n  // and cls.getLocation().getFile().getAbsolutePath().matches(\"%/folder/file.py\")\n}\n\n// 查找目标类的所有祖先类（包括直接和间接父类）\nquery predicate findDirectSuperClass(Class cls, Class parent) {\n  isTargetClass(cls) and\n  parent = getADirectSuperclass+(cls)\n}\n\n// 查找目标类的所有后代类（包括直接和间接子类）\nquery predicate findDirectSubClass(Class cls, Class child) {\n  isTargetClass(cls) and\n  child = getADirectSubclass+(cls)\n}\n\n// 输出所有匹配的目标类\n_______________ // 补全条件\nwhere isTargetClass(cls)\nselect cls",
    "output": "from Class cls"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/member-test-non-container]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects membership tests ('in'/'not in') where the right-hand side is not a container type,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Membership test with non-container type\n * @description Detects membership tests ('in'/'not in') where the right-hand side is not a container type,\n *              which can lead to runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\nfrom \n  ControlFlowNode rightHandSideNode, \n  Compare comparisonExpr, \n  Value inferredTypeValue, \n  ClassValue nonContainerClass, \n  ControlFlowNode sourceNode\nwhere\n  // Step 1: Identify membership test operation and extract right operand\n  exists(Cmpop op, int idx |\n    comparisonExpr.getOp(idx) = op and \n    comparisonExpr.getComparator(idx) = rightHandSideNode.getNode() and\n    (op instanceof In or op instanceof NotIn)\n  ) and\n  \n  // Step 2: Perform points-to analysis to determine the type of the right operand\n  rightHandSideNode.pointsTo(_, inferredTypeValue, sourceNode) and\n  inferredTypeValue.getClass() = nonContainerClass and\n  \n  // Step 3: Filter out cases with incomplete type inference results\n  not Types::failedInference(nonContainerClass, _) and\n  \n  // Step 4: Verify the class lacks essential container interface methods\n  (not nonContainerClass.hasAttribute(\"__contains__\") and\n   not nonContainerClass.hasAttribute(\"__iter__\") and\n   not nonContainerClass.hasAttribute(\"__getitem__\")) and\n  \n  // Step 5: Exclude known pseudo-container types from triggering false positives\n  (not nonContainerClass = ClassValue::nonetype() and\n   not nonContainerClass = Value::named(\"types.MappingProxyType\"))\nselect \n  comparisonExpr, \n  \"This membership test may raise an Exception because $@ might be of non-container class $@.\", \n  sourceNode, \"target\", nonContainerClass, nonContainerClass.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-weak-salt-gen]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies key derivation functions (KDF) that use salt values",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak KDF salt generation\n * @description Identifies key derivation functions (KDF) that use salt values\n *              not generated by the approved random number generator (os.urandom).\n * @kind problem\n * @id py/kdf-weak-salt-gen\n * @problem.severity error\n * @precision high\n */\n\n// Import standard Python analysis library\nimport python\n// Import experimental cryptography concepts for cryptographic operations\nimport experimental.cryptography.Concepts\n// Import utility functions for cryptographic analysis, aliased as Utils\nprivate import experimental.cryptography.utils.Utils as Utils\n\n// Identify key derivation operations and their salt sources\nfrom KeyDerivationOperation kdfOp, DataFlow::Node saltOrigin\nwhere\n  // Validate operation requires salt parameter\n  kdfOp.requiresSalt() and\n  // Trace salt configuration source for the operation\n  saltOrigin = kdfOp.getSaltConfigSrc() and\n  // Ensure salt is not generated by approved os.urandom function\n  not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = saltOrigin\n// Report vulnerability with details about weak salt source\nselect kdfOp, \"Salt configuration is not from an accepted random source: $@. Must be os.urandom\",\n  saltOrigin, saltOrigin.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent method resolution order\n * @description Detects Python classes with inheritance hierarchies causing MRO conflicts,\n *              which may lead to runtime type errors during class construction\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n/**\n * Identifies classes that cannot be constructed due to inheritance conflicts.\n * The query detects when a class inherits from two classes where one is an\n_______________ // 补全条件\n */\nfrom ClassObject problematicClass, ClassObject precedingBase, ClassObject followingBase\nwhere \n  // Target class must be new-style to have proper inheritance semantics\n  problematicClass.isNewStyle() and\n  // Check for consecutive base classes with problematic inheritance relationships\n  exists(int basePosition | \n    // Skip first base class (index 0) since we need consecutive pairs\n    basePosition > 0 and\n    // Retrieve consecutive base classes from inheritance hierarchy\n    followingBase = problematicClass.getBaseType(basePosition) and \n    precedingBase = problematicClass.getBaseType(basePosition - 1) and\n    // Detect improper inheritance where precedingBase is an ancestor of followingBase\n    precedingBase = followingBase.getAnImproperSuperType()\n  )\nselect problematicClass,\n  \"Construction of class \" + problematicClass.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", precedingBase,\n  precedingBase.getName(), followingBase, followingBase.getName()",
    "output": "* improper superclass of the other, creating an invalid method resolution order."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during tarfile extraction\n * @description 在解压tar存档时，若未校验目标路径是否位于预期目录内，\n *              可能引发目录遍历攻击，导致覆盖目标目录外的任意文件。\n * @kind path-problem\n * @id py/tarslip\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       external/cwe/cwe-022\n */\n\nimport python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\n// 定义恶意输入源和易受攻击的文件提取操作\nfrom TarSlipFlow::PathNode maliciousSource, \n     TarSlipFlow::PathNode vulnerableExtraction\n// 检查是否存在从恶意输入源到易受攻击的文件提取操作的数据流路径\nwhere TarSlipFlow::flowPath(maliciousSource, vulnerableExtraction)\n// 输出结果：易受攻击的文件提取操作、恶意输入源、提取操作详情及安全警告\nselect vulnerableExtraction.getNode(), \n_______________ // 补全条件\n       vulnerableExtraction, \n       \"This file extraction depends on a $@.\", \n       maliciousSource.getNode(),\n       \"potentially untrusted source\"",
    "output": "maliciousSource,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects local variables that override built-in objects, rendering them \n *              inaccessible within the current scope and reducing code clarity.\n * @kind problem\n * @tags maintainability\n *       readability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/local-shadows-builtin\n */\n\nimport python\nimport semmle.python.types.Builtins\n\n// Predicate that defines variable names allowed to shadow built-ins without introducing ambiguity\npredicate isAllowedShadowing(string variableName) {\n  variableName in [\n      // Infrequently used built-ins with minimal risk of confusion\n      \"iter\", \"next\", \"input\", \"file\", \"apply\", \"slice\", \"buffer\", \"coerce\", \"intern\", \"exit\",\n      \"quit\", \"license\",\n      // Commonly used short names or identifiers that are difficult to avoid\n      \"dir\", \"id\", \"max\", \"min\", \"sum\", \"cmp\", \"chr\", \"ord\", \"bytes\", \"_\",\n    ]\n}\n\n// Predicate that identifies local variables that shadow built-in objects\npredicate variableShadowsBuiltin(Name nodeName, string variableName, Function scopeContainer, int lineNumber) {\n  exists(LocalVariable localVar |\n    nodeName.defines(localVar) and // Confirm the name node defines a local variable\n    localVar.getId() = variableName and // Ensure variable identifier matches\n    exists(Builtin::builtin(localVar.getId())) // Verify collision with a built-in\n  ) and\n  nodeName.getScope() = scopeContainer and // Capture the enclosing function scope\n  nodeName.getLocation().getStartLine() = lineNumber and // Retrieve the source line number\n  not isAllowedShadowing(variableName) // Filter out permitted shadowing instances\n}\n\n// Predicate that identifies the first occurrence of built-in shadowing within a specific scope\npredicate isFirstOccurrenceInScope(Name nodeName, string variableName) {\n  exists(Scope variableScope, int earliestLine |\n    variableShadowsBuiltin(nodeName, variableName, variableScope, earliestLine) and\n    earliestLine = min(int line | variableShadowsBuiltin(_, variableName, variableScope, line))\n  )\n}\n\n// Main query: Identify initial local variables that shadow built-in objects\nfrom Name nodeName, string variableName\nwhere isFirstOccurrenceInScope(nodeName, variableName)\nselect nodeName, \"Local variable '\" + variableName + \"' shadows a built-in object.\"",
    "output": "* @name Local variable shadows built-in object"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/implicit-string-concatenation-in-list]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies string literals that undergo implicit concatenation within list structures.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Implicit string concatenation in a list\n * @description Identifies string literals that undergo implicit concatenation within list structures.\n *              Such patterns often indicate missing commas between list elements and can compromise\n *              code readability and maintainability.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-665\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/implicit-string-concatenation-in-list\n */\n\nimport python\n\n/**\n * Determines whether an expression represents a string constant, accounting for\n * implicitly concatenated strings formed through adjacent string literals.\n * This predicate handles both primitive string literals and complex expressions\n * resulting from recursive concatenation operations.\n */\npredicate isStringConstant(Expr evaluatedExpr) {\n  // Base case: Primitive string literal\n  evaluatedExpr instanceof StringLiteral\n  // Recursive case: Binary concatenation operation between string constants\n  or \n  exists(BinaryExpr concatenationOp | \n    concatenationOp = evaluatedExpr and \n    isStringConstant(concatenationOp.getLeft()) and \n    isStringConstant(concatenationOp.getRight())\n  )\n}\n\nfrom StringLiteral targetString\nwhere\n  // Verification of implicit concatenation without explicit grouping\n  exists(targetString.getAnImplicitlyConcatenatedPart()) and\n  not targetString.isParenthesized() and\n  \n  // Contextual analysis: String appears within a list containing other string constants\n  exists(List containingList |\n    // Establish containment relationship\n    containingList.getAnElt() = targetString and\n    \n    // Identify co-located string constant within the same list structure\n    exists(Expr adjacentString |\n      adjacentString != targetString and\n      containingList.getAnElt() = adjacentString and\n      isStringConstant(adjacentString)\n    )\n  )\nselect targetString, \"Implicit string concatenation. Maybe missing a comma?\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/webapp-hardcoded-secret]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Static assignment of SECRET_KEY in Flask/Django applications",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Hardcoded SECRET_KEY in Web Applications\n * @description Static assignment of SECRET_KEY in Flask/Django applications\n * may enable authentication bypass attacks\n * @kind path-problem\n * @id py/webapp-hardcoded-secret\n * @problem.severity error\n * @security-severity 8.5\n * @precision high\n * @tags security\n *       experimental\n *       external/cwe/cwe-287\n */\n\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.filters.Tests\n\n// Framework classification for web applications\nnewtype WebFrameworkType =\n  FlaskFramework() or\n  DjangoFramework()\n\n// Configuration for secret key analysis with framework tracking\nprivate module SecretKeyAnalysisConfig implements DataFlow::StateConfigSig {\n  // Framework state representation\n  class FlowState = WebFrameworkType;\n\n  // Identify hardcoded string sources\n  predicate isSource(DataFlow::Node origin, FlowState framework) {\n    exists(string literalValue |\n      literalValue = origin.asExpr().(StringLiteral).getText() and\n      literalValue.length() > 0 and\n      // Filter non-secret placeholder values\n      not literalValue.matches([\"\", \"changeme\", \"secret\", \"password\", \"default\"]) and\n      (framework = FlaskFramework() or framework = DjangoFramework())\n    )\n  }\n\n  // Identify secret key assignment sinks\n  predicate isSink(DataFlow::Node destination, FlowState framework) {\n    exists(DataFlow::Node configAttr |\n      configAttr.asExpr().(Attribute).getName() = \"SECRET_KEY\" and\n      destination.asExpr() = configAttr.asExpr().(Attribute).getObject() and\n      (framework = FlaskFramework() or framework = DjangoFramework())\n    )\n  }\n\n  // Define sanitization barriers\n  predicate isBarrier(DataFlow::Node node) {\n    // Exclude standard library components\n    node.getLocation().getFile().inStdlib()\n    or\n    // Exclude test/demo files except specific test cases\n    exists(string filePath |\n      filePath = node.getLocation().getFile().getRelativePath() and\n      filePath.matches([\"%test%\", \"%demo%\", \"%example%\", \"%sample%\"]) and\n      not filePath.matches(\"%query-tests/Security/CWE-287%\")\n    )\n    or\n    // Filter obvious non-secret values\n    exists(string literalVal |\n      literalVal = node.asExpr().(StringLiteral).getText() and\n      literalVal in [\"\", \"changeme\", \"secret\", \"password\", \"default\"]\n    )\n  }\n\n  // Enable differential analysis in incremental mode\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global taint tracking with framework state awareness\nmodule SecretKeyTaintFlow = TaintTracking::GlobalWithState<SecretKeyAnalysisConfig>;\n\n// Import path graph for vulnerability flow visualization\nimport SecretKeyTaintFlow::PathGraph\n\n// Query to identify hardcoded secret key assignments\nfrom SecretKeyTaintFlow::PathNode origin, SecretKeyTaintFlow::PathNode destination\nwhere SecretKeyTaintFlow::flowPath(origin, destination)\nselect destination, origin, destination, \"SECRET_KEY assigned from $@.\", origin,\n  \" hardcoded value\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 类的源链接\n_______________ // 补全条件\n * @kind source-link\n * @id py/class-source-links\n * @metricType reftype\n */\n\nimport python\n\n// 查找所有 Python 类并获取其源文件位置\nfrom Class cls\n// 提取类对象及其源文件路径\nselect cls, cls.getLocation().getFile()",
    "output": "* @description 识别并定位 Python 代码中定义的所有类，提供其源文件的完整路径信息"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Superclass attribute shadows subclass method\n * @description 当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 本查询检测子类方法是否被超类初始化方法中定义的属性遮蔽的情况。\n * 当超类的 __init__ 方法中定义了一个属性，且该属性与子类中的方法同名时，\n * 子类方法将被该属性遮蔽，可能导致意外的行为。\n */\n\nimport python\n\n/**\n * 判断子类方法是否被超类属性遮蔽的谓词\n * \n * 参数说明:\n * - derivedClass: 子类对象\n * - superClass: 超类对象\n * - attrAssignment: 遮蔽子类方法的属性赋值语句\n * - shadowedMethod: 被遮蔽的子类方法\n */\npredicate isMethodShadowedBySuperAttribute(\n  ClassObject derivedClass, ClassObject superClass, Assign attrAssignment, FunctionObject shadowedMethod\n) {\n  // 验证类之间的继承关系\n  derivedClass.getASuperType() = superClass and\n  \n  // 确认子类声明了被遮蔽的方法\n  derivedClass.declaredAttribute(_) = shadowedMethod and\n  \n  // 检查超类初始化方法中是否存在同名属性赋值\n  exists(\n    FunctionObject initMethod,  // 超类的初始化方法\n    Attribute assignedAttr      // 被赋值的属性\n  |\n    // 超类定义了 __init__ 方法\n    superClass.declaredAttribute(\"__init__\") = initMethod and\n    \n_______________ // 补全条件\n    assignedAttr = attrAssignment.getATarget() and\n    \n    // 属性赋值对象是 self\n    assignedAttr.getObject().(Name).getId() = \"self\" and\n    \n    // 属性名称与子类方法名称相同\n    assignedAttr.getName() = shadowedMethod.getName() and\n    \n    // 赋值操作发生在超类的初始化方法中\n    attrAssignment.getScope() = initMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  \n  // 排除超类中定义同名方法的情况（视为有意设计）\n  not superClass.hasAttribute(shadowedMethod.getName())\n}\n\n/**\n * 查询被遮蔽的方法及其相关信息\n * \n * 输出:\n * - 被遮蔽的方法位置\n * - 描述信息，指明方法被哪个超类的属性遮蔽\n * - 遮蔽该方法的属性赋值语句\n */\nfrom \n  ClassObject derivedClass,    // 子类对象\n  ClassObject superClass,      // 超类对象\n  Assign attrAssignment,       // 遮蔽子类方法的属性赋值语句\n  FunctionObject shadowedMethod // 被遮蔽的子类方法\nwhere \n  isMethodShadowedBySuperAttribute(derivedClass, superClass, attrAssignment, shadowedMethod)\nselect \n  shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superClass.getName() +\n    \"'.\", \n  attrAssignment, \n  \"attribute\"",
    "output": "// 属性赋值的目标是 assignedAttr"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/missing-docstring]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Public classes, functions, or methods without documentation strings",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Missing docstring\n * @description Public classes, functions, or methods without documentation strings \n *              can hinder code maintenance by other developers.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/missing-docstring\n */\n\n/*\n * NOTE: Medium precision reflects the inherent subjectivity in docstring requirements.\n * The need for docstrings is context-dependent and varies based on the intended audience.\n */\n\nimport python\n\n// Helper predicate to determine if a function requires documentation\npredicate functionRequiresDocstring(Function func) {\n  // Check if the function is not a lambda\n  func.getName() != \"lambda\" and\n  // Check if the function has substantial implementation (excluding decorators)\n  (func.getMetrics().getNumberOfLinesOfCode() - count(func.getADecorator())) > 2 and\n  // Check if the function is not a property getter/setter\n  not exists(PythonPropertyObject prop |\n    prop.getGetter().getFunction() = func or\n    prop.getSetter().getFunction() = func\n  ) and\n  // Check if the function is not an overridden function with no docstring requirement in the base\n  not exists(FunctionValue overriding, FunctionValue base | \n    overriding.overrides(base) and \n    overriding.getScope() = func |\n    not functionRequiresDocstring(base.getScope())\n  )\n}\n\n// Helper predicate to determine if a scope requires documentation\npredicate requiresDocstring(Scope scope) {\n  scope.isPublic() and\n  (\n    // Non-function scopes always require docs\n    not scope instanceof Function\n    or\n    // Functions require docs if they meet specific criteria\n    functionRequiresDocstring(scope)\n  )\n}\n\n// Helper function to classify scope type\nstring getScopeType(Scope scope) {\n  result = \"Module\" and scope instanceof Module and not scope.(Module).isPackage()\n  or\n  result = \"Class\" and scope instanceof Class\n  or\n  result = \"Function\" and scope instanceof Function\n}\n\n// Main query: Find scopes requiring documentation but missing docstrings\nfrom Scope scope\nwhere \n  requiresDocstring(scope) and \n  not exists(scope.getDocString())\nselect \n  scope, \n  getScopeType(scope) + \" \" + scope.getName() + \" does not have a docstring.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name PAM授权绕过问题由于不正确使用\n * @description 在`pam_authenticate`之后不使用`pam_acct_mgmt`来检查登录的有效性，可能导致授权绕过。\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 8.1\n * @precision high\n * @id py/pam-auth-bypass\n * @tags security\n *       external/cwe/cwe-285\n */\n\nimport python\nimport PamAuthorizationFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.security.dataflow.PamAuthorizationQuery\n\n// 定义授权流程的起点和终点\n_______________ // 补全条件\n// 检查是否存在从起点到终点的完整授权流程路径\nwhere \n  exists(PamAuthorizationFlow::PathNode pathStart, PamAuthorizationFlow::PathNode pathEnd |\n    pathStart = authSource and\n    pathEnd = authSink and\n    PamAuthorizationFlow::flowPath(pathStart, pathEnd)\n  )\n// 选择结果并生成警告消息\nselect authSink.getNode(), authSource, authSink,\n  \"This PAM authentication depends on a $@, and 'pam_acct_mgmt' is not called afterwards.\",\n  authSource.getNode(), \"user-provided value\"",
    "output": "from PamAuthorizationFlow::PathNode authSource, PamAuthorizationFlow::PathNode authSink"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 调用图紧凑性度量分析：评估调用图中事实数量与关系大小的比例关系。\n * 本查询通过计算(ControlFlowNode, CallableValue)对与三元组(ControlFlowNode, CallableValue, PointsToContext)的比率，\n * 来量化调用图的紧凑程度，并记录上下文深度信息。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n_______________ // 补全条件\nfrom int totalFacts, int totalRelations, int callContextDepth, float compactnessMetric\nwhere\n  // 获取所有调用上下文的深度信息，确保每个上下文只计算一次\n  exists(PointsToContext callSiteContext |\n    callContextDepth = callSiteContext.getDepth() and\n    // 计算调用图中的事实总数：统计所有调用节点与目标函数的映射对\n    totalFacts =\n      strictcount(ControlFlowNode invocationNode, CallableValue targetFunction |\n        invocationNode = targetFunction.getACall(callSiteContext)\n      ) and\n    // 计算调用图关系的总大小：统计包含上下文信息的三元组数量\n    totalRelations =\n      strictcount(ControlFlowNode invocationNode, CallableValue targetFunction |\n        invocationNode = targetFunction.getACall(callSiteContext)\n      ) and\n    // 计算调用图紧凑性指标：事实数量相对于关系大小的百分比\n    compactnessMetric = 100.0 * totalFacts / totalRelations\n  )\nselect callContextDepth, totalFacts, totalRelations, compactnessMetric // 输出上下文深度、事实总数、关系总大小和紧凑性指标",
    "output": "// 定义输出变量：totalFacts（事实总数）、totalRelations（关系总大小）、callContextDepth（上下文深度）和compactnessMetric（紧凑性指标）"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Method signature mismatch in inheritance\n * @description Identifies methods that override a parent method but with incompatible signatures,\n *              potentially leading to runtime errors when invoked.\n * @kind problem\n * @tags maintainability\n * @problem.severity error\n_______________ // 补全条件\n * @precision high\n * @id py/inheritance/incorrect-overriding-signature\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Detects methods with signature mismatches in inheritance hierarchies\nfrom Call methodInvocation, FunctionValue derivedMethod, FunctionValue parentMethod, string problemDescription\nwhere\n  // Verify that derivedMethod actually overrides parentMethod\n  derivedMethod.overrides(parentMethod) and\n  (\n    // Case 1: Incorrect arguments when calling derivedMethod, but correct for parentMethod\n    wrong_args(methodInvocation, derivedMethod, _, problemDescription) and\n    correct_args_if_called_as_method(methodInvocation, parentMethod)\n    or\n    // Case 2: Presence of illegally named parameters\n    exists(string parameterName |\n      illegally_named_parameter(methodInvocation, derivedMethod, parameterName) and\n      problemDescription = \"an argument named '\" + parameterName + \"'\" and\n      // Check if parentMethod has a parameter with the same name\n      parentMethod.getScope().getAnArg().(Name).getId() = parameterName\n    )\n  )\nselect derivedMethod,\n  \"Overriding method signature does not match $@, where it is passed \" + problemDescription +\n    \". Overridden method $@ is correctly specified.\", methodInvocation, \"here\", parentMethod,\n  parentMethod.descriptiveString()",
    "output": "* @sub-severity low"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Functions with names starting with uppercase letters reduce code readability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed function\n * @description Functions with names starting with uppercase letters reduce code readability.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python  // Import Python library for analyzing Python source code\n\n// Predicate to identify functions with uppercase-initial names\npredicate hasUppercaseInitialName(Function func) {\n  exists(string initialChar |\n    initialChar = func.getName().prefix(1) and  // Extract first character of function name\n    initialChar != initialChar.toLowerCase()   // Check if character is not lowercase\n  )\n}\n\n// Query to find misnamed functions while avoiding duplicate reports\nfrom Function func\nwhere\n  func.inSource() and                    // Ensure function is defined in source code\n  hasUppercaseInitialName(func) and      // Verify function starts with uppercase letter\n  not exists(Function dupFunc |          // Exclude duplicate function reports\n    dupFunc != func and                  // Different function instance\n    dupFunc.getLocation().getFile() = func.getLocation().getFile() and  // Same file\n    hasUppercaseInitialName(dupFunc)     // Also has uppercase-initial name\n  )\nselect func, \"Function names should start in lowercase.\"  // Report finding with recommendation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies import statements that fail to resolve and lack",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unresolved import\n * @description Identifies import statements that fail to resolve and lack\n *              fallback mechanisms or platform-specific guards. Such imports\n *              may reduce analysis coverage and accuracy.\n * @kind problem\n * @problem.severity info\n * @id py/import-failure\n */\n\nimport python\n\n/**\n * Locates alternative import expressions for a specified main import.\n * The alternative must reside in a different branch (else/except) of\n * conditional or exception handling constructs.\n */\nImportExpr getAlternativeImport(ImportExpr mainImport) {\n  exists(Alias mainAlias, Alias altAlias |\n    // Associate main import with its alias\n    (mainAlias.getValue() = mainImport or mainAlias.getValue().(ImportMember).getModule() = mainImport) and\n    // Associate fallback import with its alias\n    (altAlias.getValue() = result or altAlias.getValue().(ImportMember).getModule() = result) and\n    (\n      // Verify conditional statement branches\n      exists(If ifStmt | \n        (ifStmt.getBody().contains(mainImport) and ifStmt.getOrelse().contains(result)) or\n        (ifStmt.getBody().contains(result) and ifStmt.getOrelse().contains(mainImport))\n      )\n      or\n      // Verify exception handling blocks\n      exists(Try tryStmt | \n        (tryStmt.getBody().contains(mainImport) and tryStmt.getAHandler().contains(result)) or\n        (tryStmt.getBody().contains(result) and tryStmt.getAHandler().contains(mainImport))\n      )\n    )\n  )\n}\n\n/**\n * Determines the operating system associated with a platform-specific import.\n * Returns OS identifier (e.g., \"win32\", \"darwin\") for known platform-specific modules.\n */\nstring getOSSpecificImport(ImportExpr importExpr) {\n  exists(string moduleName | moduleName = importExpr.getImportedModuleName() |\n    // Java platform modules\n    (moduleName.matches(\"org.python.%\") or moduleName.matches(\"java.%\")) and result = \"java\"\n    or\n    // macOS-specific modules\n    moduleName.matches(\"Carbon.%\") and result = \"darwin\"\n    or\n    // Windows-specific modules\n    result = \"win32\" and\n    (\n      moduleName = \"_winapi\" or\n      moduleName = \"_win32api\" or\n      moduleName = \"_winreg\" or\n      moduleName = \"nt\" or\n      moduleName.matches(\"win32%\") or\n      moduleName = \"ntpath\"\n    )\n    or\n    // Linux-specific modules\n    result = \"linux2\" and\n    (moduleName = \"posix\" or moduleName = \"posixpath\")\n    or\n    // Unsupported platform modules\n    result = \"unsupported\" and\n    (moduleName = \"__pypy__\" or moduleName = \"ce\" or moduleName.matches(\"riscos%\"))\n  )\n}\n\n/**\n * Retrieves the current platform identifier from Python's sys.platform.\n */\nstring getCurrentPlatform() { \n  py_flags_versioned(\"sys.platform\", result, major_version().toString()) \n}\n\n/**\n * Evaluates if an unresolved import is acceptable due to:\n * 1. Presence of working alternative imports\n * 2. OS-specific targeting differing from current platform\n */\npredicate isAcceptableImportFailure(ImportExpr importExpr) {\n  // Check for working alternative import\n  getAlternativeImport(importExpr).refersTo(_)\n  or\n  // Check OS-specific import for non-current platform\n  getOSSpecificImport(importExpr) != getCurrentPlatform()\n}\n\n/**\n * Represents control flow nodes checking Python interpreter version.\n * Used to identify version-specific imports that should not be flagged.\n */\nclass InterpreterVersionCheck extends ControlFlowNode {\n  InterpreterVersionCheck() {\n    exists(string versionAttrName |\n      versionAttrName.matches(\"%version%\") and\n      this.(CompareNode).getAChild+().pointsTo(Module::named(\"sys\").attr(versionAttrName))\n    )\n  }\n\n  override string toString() { result = \"VersionCheck\" }\n}\n\n/**\n * Represents condition blocks guarding code based on interpreter version.\n * Helps identify version-specific imports that should not be flagged.\n */\nclass VersionGuardBlock extends ConditionBlock {\n  VersionGuardBlock() { this.getLastNode() instanceof InterpreterVersionCheck }\n}\n\n// Main query: Identify problematic unresolved imports\nfrom ImportExpr failedImport\nwhere\n  // The import cannot be resolved\n  not failedImport.refersTo(_)\n  and\n  // The import is in a valid execution context\n  exists(Context context | context.appliesTo(failedImport.getAFlowNode()))\n  and\n  // There is no acceptable failure condition (like a fallback or OS-specific import)\n  not isAcceptableImportFailure(failedImport)\n  and\n  // There is no version guard protecting the import\n  not exists(VersionGuardBlock guardBlock | guardBlock.controls(failedImport.getAFlowNode().getBasicBlock(), _))\nselect failedImport, \"Unable to resolve import of '\" + failedImport.getImportedModuleName() + \"'.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/log-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies log entries constructed with untrusted user input,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Log Injection Vulnerability\n * @description Identifies log entries constructed with untrusted user input, \n *              enabling attackers to inject malicious content and forge log entries.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.8\n * @precision medium\n * @id py/log-injection\n * @tags security\n *       external/cwe/cwe-117\n */\n\n// Core Python analysis libraries\nimport python\n\n// Taint tracking configuration for log injection analysis\nimport semmle.python.security.dataflow.LogInjectionQuery\n\n// Path graph for visualizing vulnerability propagation paths\nimport LogInjectionFlow::PathGraph\n\nfrom \n  LogInjectionFlow::PathNode taintedSource,\n  LogInjectionFlow::PathNode vulnerableSink\nwhere \n  LogInjectionFlow::flowPath(taintedSource, vulnerableSink)\nselect \n  vulnerableSink.getNode(), \n  taintedSource, \n  vulnerableSink, \n  \"This log entry depends on a $@.\", \n  taintedSource.getNode(),\n  \"user-provided value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jump-to-definition]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Enhanced navigation helper for locating definitions from usage points in Python.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Definitions\n * @description Enhanced navigation helper for locating definitions from usage points in Python.\n *              This query establishes the mapping between code references and their source definitions,\n *              facilitating IDE navigation features such as \"Go to Definition\".\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import Python language library for comprehensive source code analysis\nimport python\n\n// Import definition tracking utilities to correlate references with their originating definitions\nimport analysis.DefinitionTracking\n\n// Define the main query components:\n//   - referencedExpr: Expression being referenced in the code\n//   - originDefn: The source definition that defines the referenced expression\n//   - defType: Category or type of the definition being referenced\nfrom NiceLocationExpr referencedExpr, Definition originDefn, string defType\n// Establish the relationship where the origin definition corresponds to the referenced expression\n// and matches the expected definition type\nwhere originDefn = definitionOf(referencedExpr, defType)\n// Return the referenced expression, its originating definition, and the definition type\nselect referencedExpr, originDefn, defType"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Missing docstring\n * @description Identifies public classes, functions, or methods lacking documentation strings,\n *              which hinders code maintainability by obscuring the intended purpose and usage.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/missing-docstring\n */\n\n/*\n * Note: This query exhibits medium precision since determining docstring necessity \n * involves subjective judgment. Documentation requirements differ based on codebase \n * context and target audience.\n */\n\nimport python\n\n// Evaluates whether a code scope necessitates documentation\npredicate requiresDocumentation(Scope codeScope) {\n  codeScope.isPublic() and\n  (\n    not codeScope instanceof Function\n    or\n    functionShouldHaveDoc(codeScope)\n  )\n}\n\n// Determines if a function should include documentation\npredicate functionShouldHaveDoc(Function function) {\n  // Exclude lambda functions from documentation requirement\n  function.getName() != \"lambda\" and\n  // Compute actual lines of code (excluding decorators)\n  (function.getMetrics().getNumberOfLinesOfCode() - count(function.getADecorator())) > 2 and\n  // Exclude property getter/setter methods\n  not exists(PythonPropertyObject pyProperty |\n    pyProperty.getGetter().getFunction() = function or\n    pyProperty.getSetter().getFunction() = function\n  ) and\n  // Check documentation requirements for overridden functions\n  not exists(FunctionValue derivedFunc, FunctionValue parentFunc | \n    derivedFunc.overrides(parentFunc) and derivedFunc.getScope() = function |\n    not functionShouldHaveDoc(parentFunc.getScope())\n  )\n}\n\n// Provides the type name of a code scope (Module, Class, or Function)\nstring determineScopeType(Scope codeScope) {\n  // Handle non-package modules\n  result = \"Module\" and codeScope instanceof Module and not codeScope.(Module).isPackage()\n  or\n  // Handle class definitions\n  result = \"Class\" and codeScope instanceof Class\n  or\n  // Handle function definitions\n  result = \"Function\" and codeScope instanceof Function\n}\n_______________ // 补全条件\n// Locates code scopes that require documentation but lack docstrings\nfrom Scope codeScope\nwhere requiresDocumentation(codeScope) and not exists(codeScope.getDocString())\nselect codeScope, determineScopeType(codeScope) + \" \" + codeScope.getName() + \" does not have a docstring.\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies modules that perform self-import operations, which typically indicates redundant code",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description Identifies modules that perform self-import operations, which typically indicates redundant code\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n// Predicate to detect modules importing themselves\npredicate isSelfImportingModule(ImportingStmt importStmt, ModuleValue targetModule) {\n  // Verify the importing module matches the imported module's scope\n  importStmt.getEnclosingModule() = targetModule.getScope() and\n  // Resolve the actual module from the imported name using shortest match\n  targetModule =\n    max(string modName, ModuleValue resolvedMod |\n      modName = importStmt.getAnImportedModuleName() and\n      resolvedMod.importedAs(modName)\n    |\n      resolvedMod order by modName.length()\n    )\n}\n\n// Query to locate all self-importing module instances\nfrom ImportingStmt importStmt, ModuleValue targetModule\nwhere isSelfImportingModule(importStmt, targetModule)\nselect importStmt, \"The module '\" + targetModule.getName() + \"' imports itself.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name 外部依赖源链接\n * @kind source-link\n * @metricType externalDependency\n * @id py/dependency-source-links\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 本查询用于识别Python项目中的外部依赖关系，并生成相应的源链接数据。\n * \n * 输出格式为：'/file/path<|>dependency'\n_______________ // 补全条件\n * - '/file/path'：相对于源代码存档根目录的文件路径，不绑定特定代码版本\n * - 'dependency'：被引用的外部依赖包名称\n * \n * 查询结果中的File实体（第二列）可通过仪表板数据库中的\n * ExternalEntity.getASourceLink()方法用于恢复源链接。\n */\n\nfrom File sourceFile, string dependencySourceLink\nwhere\n  exists(PackageObject externalPackage, AstNode importNode |\n    // 检查是否存在从导入节点到外部包的依赖关系\n    dependency(importNode, externalPackage) and\n    \n    // 确保导入节点位于当前分析的源文件中\n    importNode.getLocation().getFile() = sourceFile and\n    \n    // 生成标准化的依赖源链接字符串\n    dependencySourceLink = munge(sourceFile, externalPackage)\n  )\nselect dependencySourceLink, sourceFile",
    "output": "* 其中："
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak hashes\n * @description Finds uses of cryptography algorithms that are unapproved or otherwise weak.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n_______________ // 补全条件\nimport python\nimport experimental.cryptography.Concepts\n\n// 从HashAlgorithm操作符、字符串名称和消息中选择数据\nfrom HashAlgorithm op, string name, string msg\nwhere\n  // 获取哈希算法的名称并赋值给变量name\n  name = op.getHashName() and\n  // 过滤掉SHA256, SHA384, SHA512这些被认可的强哈希算法\n  not name = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // 如果哈希算法名称未知，则设置消息为“使用未识别的哈希算法”\n  if name = unknownAlgorithm()\n  then msg = \"Use of unrecognized hash algorithm.\"\n  // 否则，设置消息为“使用未经批准的哈希算法或API”并附加算法名称\n  else msg = \"Use of unapproved hash algorithm or API \" + name + \".\"\nselect op, msg",
    "output": "// 导入Python库和实验性加密概念库"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode\n * @description Identifies symmetric encryption block modes that are classified as weak, outdated, or not approved for use.\n * @id py/weak-block-mode\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n_______________ // 补全条件\n// Select encryption artifacts and their corresponding alert messages\nfrom CryptographicArtifact encryptionArtifact, string alertMessage\nwhere\n  // Filter out false positives by excluding results from cryptography/hazmat paths\n  // This is crucial because ECB mode is used internally in keywrap operations\n  not encryptionArtifact.asExpr()\n      .getLocation()\n      .getFile()\n      .getAbsolutePath()\n      .toString()\n      .matches(\"%cryptography/hazmat/%\") and\n  (\n    // Scenario 1: Examine BlockMode instances\n    encryptionArtifact instanceof BlockMode and\n    // ECB mode is permitted only for KeyWrapOperations\n    (encryptionArtifact.(BlockMode).getBlockModeName() = \"ECB\" implies \n     not encryptionArtifact instanceof KeyWrapOperation) and\n    exists(string blockModeName | blockModeName = encryptionArtifact.(BlockMode).getBlockModeName() |\n      // Only CBC, CTS, and XTS modes are approved\n      // Reference: https://liquid.microsoft.com/Web/Object/Read/MS.Security/Requirements/Microsoft.Security.Cryptography.10002\n      not blockModeName = [\"CBC\", \"CTS\", \"XTS\"] and\n      // Generate appropriate alert message based on the block mode\n      if blockModeName = unknownAlgorithm()\n      then alertMessage = \"Use of unrecognized block mode algorithm.\"\n      else\n        if blockModeName in [\"GCM\", \"CCM\"]\n        then\n          alertMessage =\n            \"Use of block mode algorithm \" + blockModeName +\n              \" requires special crypto board approval/review.\"\n        else alertMessage = \"Use of unapproved block mode algorithm or API \" + blockModeName + \".\"\n    )\n    or\n    // Scenario 2: Examine SymmetricCipher instances without a specified block mode\n    encryptionArtifact instanceof SymmetricCipher and\n    not encryptionArtifact.(SymmetricCipher).hasBlockMode() and\n    alertMessage = \"Cipher has unspecified block mode algorithm.\"\n  )\nselect encryptionArtifact, alertMessage",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Request Handlers\n * @description HTTP Server Request Handlers\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/alerts/request-handlers\n * @tags meta\n_______________ // 补全条件\n */\n\n// 导入Python库，用于处理Python代码的解析和分析\nprivate import python\n\n// 导入数据流分析库，用于跟踪数据在程序中的流动\nprivate import semmle.python.dataflow.new.DataFlow\n\n// 导入Python概念库，包含一些常用的Python编程概念\nprivate import semmle.python.Concepts\n\n// 导入MetaMetrics库，用于计算和报告元数据指标\nprivate import meta.MetaMetrics\n\n// 从Http::Server::RequestHandler类中选择requestHandler对象和title字符串\nfrom Http::Server::RequestHandler requestHandler, string title\nwhere\n  // 过滤掉被忽略的文件\n  not requestHandler.getLocation().getFile() instanceof IgnoredFile and\n  // 如果requestHandler是一个方法\n  if requestHandler.isMethod()\n  then\n    // 设置title为\"Method \" + 类名 + \".\" + 方法名\n    title = \"Method \" + requestHandler.getScope().(Class).getName() + \".\" + requestHandler.getName()\n  else \n    // 否则，将title设置为requestHandler的字符串表示形式\n    title = requestHandler.toString()\n// 选择requestHandler对象和带有前缀\"RequestHandler: \"的title字符串\nselect requestHandler, \"RequestHandler: \" + title",
    "output": "* @precision very-low"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Encoding error\n * @description 检测代码中可能存在的编码错误，这些错误会导致程序在运行时失败，\n *              并可能阻碍代码分析工具的正常工作。\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/encoding-error\n */\n\nimport python\n\n// 定义查询源：识别所有编码错误实例\nfrom EncodingError encodingIssue\n\n_______________ // 补全条件\nselect encodingIssue, encodingIssue.getMessage()",
    "output": "// 返回结果：编码错误对象及其对应的错误信息"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/incomplete-special-group]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies regex patterns with improperly formed special groups that are interpreted",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incomplete special group syntax in regular expressions\n * @description Identifies regex patterns with improperly formed special groups that are interpreted\n *              as literal groups, causing unexpected string matching behavior.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/regex/incomplete-special-group\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, string missingCharacter, string groupTypeName\nwhere \n  // Detect regex patterns containing incomplete named group declarations\n  regexPattern.getText().regexpMatch(\".*\\\\(P<\\\\w+>.*\")\n  and missingCharacter = \"?\"\n  and groupTypeName = \"named group\"\nselect \n  regexPattern, \n  \"Regular expression is missing '\" + missingCharacter + \"' in \" + groupTypeName + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/deprecated-slice-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects the use of obsolete slicing special methods that were deprecated in Python 2.0.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Deprecated slice method\n * @description Detects the use of obsolete slicing special methods that were deprecated in Python 2.0.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/deprecated-slice-method\n */\n\nimport python\n\n// Predicate to identify deprecated slice method names\npredicate is_deprecated_slice_method(string methodName) {\n  // Check if the method name matches any deprecated slice special methods\n  methodName = \"__getslice__\" or \n  methodName = \"__setslice__\" or \n  methodName = \"__delslice__\"\n}\n\n// Query to find deprecated slice methods in Python code\nfrom PythonFunctionValue functionObj, string methodName\nwhere\n  // Ensure the function name matches a deprecated slice method\n  functionObj.getName() = methodName and\n  is_deprecated_slice_method(methodName) and\n  // Verify the function is a class method and not overriding parent methods\n  functionObj.getScope().isMethod() and\n  not functionObj.isOverridingMethod()\n// Output deprecation warning with method name\nselect functionObj, methodName + \" method has been deprecated since Python 2.0.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 可调用对象的范围\n * @description 识别并列出Python代码库中的所有可调用实体，\n *              提供它们的位置信息和可调用对象本身。\n_______________ // 补全条件\n * @id py/function-extents\n * @metricType callable\n */\n\n// 导入Python分析库以启用代码检查\nimport python\n\n// 定义一个变量来表示所有可调用实体（函数、方法等）\nfrom Function func\n\n// 输出每个已识别函数的位置和可调用实体\nselect func.getLocation(), func",
    "output": "* @kind extent"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Request Handlers\n * @description Identifies HTTP server request handlers in Python code\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/alerts/request-handlers\n * @tags meta\n * @precision very-low\n */\n\n// Import core Python analysis framework\nprivate import python\n\n// Import data flow tracking capabilities for security analysis\nprivate import semmle.python.dataflow.new.DataFlow\n\n// Import fundamental Python language constructs and patterns\nprivate import semmle.python.Concepts\n\n// Import metrics collection and reporting functionality\nprivate import meta.MetaMetrics\n\n// Main query to detect HTTP server request handlers\nfrom Http::Server::RequestHandler requestHandler, string handlerDescription\nwhere\n_______________ // 补全条件\n  not requestHandler.getLocation().getFile() instanceof IgnoredFile\n  and\n  // Determine handler type and construct appropriate description\n  (\n    // Handler is a method within a class context\n    exists(Class enclosingClass |\n      requestHandler.isMethod() and\n      enclosingClass = requestHandler.getScope() and\n      handlerDescription = \"Method \" + enclosingClass.getName() + \".\" + requestHandler.getName()\n    )\n    or\n    // Handler is a standalone function\n    (\n      not requestHandler.isMethod() and\n      handlerDescription = requestHandler.toString()\n    )\n  )\n// Output results with standardized prefix\nselect requestHandler, \"RequestHandler: \" + handlerDescription",
    "output": "// Exclude handlers in ignored files from analysis"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-of-mutable-attribute]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Direct import of mutable attribute values prevents observing global state changes locally.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Importing value of mutable attribute\n * @description Direct import of mutable attribute values prevents observing global state changes locally.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity high\n * @precision medium\n * @id py/import-of-mutable-attribute\n */\n\nimport python\nimport semmle.python.filters.Tests\n\nfrom ImportMember importedAttribute, ModuleValue sourceModule, AttrNode attributeAssignment, string attributeName\nwhere\n  // Verify imported module reference matches actual module\n  sourceModule.importedAs(importedAttribute.getModule().(ImportExpr).getImportedModuleName()) and\n  // Ensure consistent attribute naming between import and modification\n  importedAttribute.getName() = attributeName and\n  // Confirm attribute assignment occurs within function scope\n  attributeAssignment.getScope() instanceof Function and\n  // Validate imported attribute originates from module-level scope\n  not importedAttribute.getScope() instanceof Function and\n  // Verify assignment operation performs attribute modification\n  attributeAssignment.isStore() and\n  // Confirm assignment targets the imported module's attribute\n  attributeAssignment.getObject(attributeName).pointsTo(sourceModule) and\n  // Ensure import and modification occur in separate modules\n  not importedAttribute.getEnclosingModule() = attributeAssignment.getScope().getEnclosingModule() and\n  // Exclude modifications within test code boundaries\n  not attributeAssignment.getScope().getScope*() instanceof TestScope\nselect importedAttribute,\n  \"Importing the value of '\" + attributeName +\n    \"' from $@ means that any change made to $@ will be not be observed locally.\", sourceModule,\n  \"module \" + sourceModule.getName(), attributeAssignment, sourceModule.getName() + \".\" + attributeName"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/duplicate-key-dict-literal]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies duplicate keys in dictionary literals where all but the last occurrence are lost",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Duplicate key in dict literal\n * @description Identifies duplicate keys in dictionary literals where all but the last occurrence are lost\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/duplicate-key-dict-literal\n */\n\nimport python\nimport semmle.python.strings\n\n// Converts dictionary key expressions to canonical string representation for comparison\npredicate canonicalKeyForm(Dict dictLiteral, Expr keyExpr, string canonicalKey) {\n  keyExpr = dictLiteral.getAKey() and\n  (\n    // Numeric keys: use numeric value as canonical form\n    canonicalKey = keyExpr.(Num).getN()\n    or\n    // String keys: handle Unicode and byte strings\n    not \"�\" = canonicalKey.charAt(_) and\n    exists(StringLiteral strLiteral | strLiteral = keyExpr |\n      canonicalKey = \"u\\\"\" + strLiteral.getText() + \"\\\"\" and strLiteral.isUnicode()\n      or\n      canonicalKey = \"b\\\"\" + strLiteral.getText() + \"\\\"\" and not strLiteral.isUnicode()\n    )\n  )\n}\n\n// Detects duplicate key pairs within the same dictionary literal\nfrom Dict dictLiteral, Expr firstKey, Expr laterKey\nwhere\n  exists(string keyCanonicalForm | \n    canonicalKeyForm(dictLiteral, firstKey, keyCanonicalForm) and \n    canonicalKeyForm(dictLiteral, laterKey, keyCanonicalForm) and \n    firstKey != laterKey\n  ) and\n  (\n    // Case 1: Keys appear in same basic block with firstKey preceding laterKey\n    exists(BasicBlock sharedBlock, int firstPos, int laterPos |\n      firstKey.getAFlowNode() = sharedBlock.getNode(firstPos) and\n      laterKey.getAFlowNode() = sharedBlock.getNode(laterPos) and\n      firstPos < laterPos\n    )\n    or\n    // Case 2: Basic block containing firstKey strictly dominates laterKey's block\n    firstKey.getAFlowNode().getBasicBlock().strictlyDominates(\n      laterKey.getAFlowNode().getBasicBlock()\n    )\n  )\n// Report duplicate key issue with overwrite location\nselect firstKey, \n  \"Dictionary key \" + repr(firstKey) + \" is subsequently $@.\", \n  laterKey, \n  \"overwritten\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name TODO comment detection\n * @description Identifies comments containing 'TODO' or 'TO DO' which may indicate\n *              incomplete or pending functionality in the codebase.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n_______________ // 补全条件\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/todo-comment\n */\n\nimport python\n\nfrom Comment todoComment\nwhere \n  todoComment.getText().matches(\"%TODO%\") or \n  todoComment.getText().matches(\"%TO DO%\")\nselect todoComment, todoComment.getText()",
    "output": "*       external/cwe/cwe-546"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary 'else' clause in loop\n * @description Detects 'for' or 'while' loops that contain an 'else' clause which serves no purpose\n *              because the loop body doesn't contain any 'break' statement, rendering the 'else' clause\n *              functionally redundant.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-else\n */\n\nimport python\n\n// Define variables for the loop analysis\nfrom Stmt currentLoop, StmtList loopContent, StmtList elseBlock, string loopKind\nwhere\n_______________ // 补全条件\n  (exists(For f | \n      f = currentLoop and \n      elseBlock = f.getOrelse() and \n      loopContent = f.getBody() and \n      loopKind = \"for\")\n   or\n   exists(While w | \n      w = currentLoop and \n      elseBlock = w.getOrelse() and \n      loopContent = w.getBody() and \n      loopKind = \"while\"))\n  and\n  // Ensure the loop body contains no break statements\n  not exists(Break b | loopContent.contains(b))\nselect currentLoop,\n  \"This '\" + loopKind + \"' statement has a redundant 'else' as no 'break' is present in the body.\"",
    "output": "// Identify either a for loop or while loop that has an else clause"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of an undefined placeholder variable\n * @description Detects placeholder variables used before initialization,\n *              which may cause runtime exceptions when accessed.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/undefined-placeholder-variable\n */\n\nimport python\nimport Variables.MonkeyPatched\n\n/**\n * Determines if a placeholder is properly initialized as a local variable\n * within its containing function scope. This predicate verifies whether\n * there exists an SSA variable representing a local variable that is used\n * at the placeholder's flow node and is not potentially undefined.\n */\npredicate isInitializedAsLocal(PlaceHolder placeholder) {\n  exists(SsaVariable ssaLocalVar, Function containingFunction |\n    containingFunction = placeholder.getScope() and\n    ssaLocalVar.getAUse() = placeholder.getAFlowNode() and\n    ssaLocalVar.getVariable() instanceof LocalVariable and\n    not ssaLocalVar.maybeUndefined()\n  )\n}\n_______________ // 补全条件\n/**\n * Retrieves the class that contains the placeholder usage.\n * This helper predicate identifies the enclosing class by checking\n * if the placeholder's scope is a method of that class.\n */\nClass getEnclosingClass(PlaceHolder placeholder) {\n  result.getAMethod() = placeholder.getScope()\n}\n\n/**\n * Checks if a placeholder corresponds to a template attribute\n * defined within its enclosing class. This predicate verifies\n * whether the placeholder's identifier is defined in the\n * import-time scope of its enclosing class.\n */\npredicate isTemplateAttribute(PlaceHolder placeholder) {\n  exists(ImportTimeScope classImportScope |\n    classImportScope = getEnclosingClass(placeholder) and\n    classImportScope.definesName(placeholder.getId())\n  )\n}\n\n/**\n * Verifies that a placeholder is neither a global variable,\n * monkey-patched builtin, nor globally defined name. This predicate\n * ensures the placeholder is not defined as an attribute in\n * the enclosing module, not a globally defined name, and not a\n * monkey-patched builtin.\n */\npredicate isNotGlobalVariable(PlaceHolder placeholder) {\n  // Check if the placeholder is not defined as an attribute in the enclosing module\n  not exists(PythonModuleObject moduleObject |\n    moduleObject.hasAttribute(placeholder.getId()) and\n    moduleObject.getModule() = placeholder.getEnclosingModule()\n  ) and\n  // Check if the placeholder is not a globally defined name\n  not globallyDefinedName(placeholder.getId()) and\n  // Check if the placeholder is not a monkey-patched builtin\n  not monkey_patched_builtin(placeholder.getId())\n}\n\n// Main query identifying undefined placeholder variables\n// This query finds placeholders that are:\n// 1. Not initialized as local variables\n// 2. Not template attributes in their enclosing class\n// 3. Not global variables, monkey-patched builtins, or globally defined names\nfrom PlaceHolder placeholder\nwhere\n  not isInitializedAsLocal(placeholder) and\n  not isTemplateAttribute(placeholder) and\n  isNotGlobalVariable(placeholder)\nselect placeholder, \"This use of place-holder variable '\" + placeholder.getId() + \"' may be undefined.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of the 'global' statement.\n * @description Use of the 'global' statement may indicate poor modularity.\n *              This query identifies global variables used outside of module scope,\n *              which can make code harder to maintain.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n_______________ // 补全条件\n * @id py/use-of-global\n */\n\nimport python\n\n// 查找所有全局变量声明\nfrom Global globalVar\n// 过滤条件：确保全局变量的作用域不是模块级别\nwhere not globalVar.getScope() instanceof Module\n// 返回结果：全局变量实例及其相关的警告信息\nselect globalVar, \"Updating global variables except at module initialization is discouraged.\"",
    "output": "* @precision very-high"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/modification-of-locals]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects modifications to the dictionary returned by locals(),",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Modification of dictionary returned by locals()\n * @description Detects modifications to the dictionary returned by locals(),\n *              which do not affect the actual local variables in a function.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/modification-of-locals\n */\n\nimport python\n\n// 检查控制流节点是否关联到 locals() 函数调用\npredicate isLocalsCallSource(ControlFlowNode node) { \n    node.pointsTo(_, _, Value::named(\"locals\").getACall()) \n}\n\n// 检查是否存在通过下标操作修改 locals() 返回字典的情况\npredicate isSubscriptModification(ControlFlowNode opNode) {\n    // 获取下标操作的对象并验证其来自 locals() 调用\n    isLocalsCallSource(opNode.(SubscriptNode).getObject()) and\n    // 确认是存储或删除操作\n    (opNode.isStore() or opNode.isDelete())\n}\n\n// 检查是否存在通过方法调用修改 locals() 返回字典的情况\npredicate isMethodModification(ControlFlowNode opNode) {\n    exists(string methodName, AttrNode attrNode |\n        // 获取方法调用的属性节点\n        attrNode = opNode.(CallNode).getFunction() and\n        // 验证属性对象来自 locals() 调用\n        isLocalsCallSource(attrNode.getObject(methodName))\n    |\n        // 检查方法名是否在修改字典的方法列表中\n        methodName in [\"pop\", \"popitem\", \"update\", \"clear\"]\n    )\n}\n\n// 检查是否存在对 locals() 返回字典的任何修改操作\npredicate hasLocalsModification(ControlFlowNode opNode) {\n    isSubscriptModification(opNode) or\n    isMethodModification(opNode)\n}\n\n// 主查询：查找并报告对 locals() 返回字典的修改操作\nfrom AstNode astNode, ControlFlowNode opNode\nwhere\n    // 确认存在对 locals() 返回字典的修改\n    hasLocalsModification(opNode) and\n    // 获取与控制流节点对应的 AST 节点\n    astNode = opNode.getNode() and\n    // 排除模块级别作用域，因为在模块级别 locals() 等同于 globals()\n    not astNode.getScope() instanceof ModuleScope\n// 选择结果并附加警告信息\nselect astNode, \"Modification of the locals() dictionary will have no effect on the local variables.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete URL substring sanitization\n * @description Detects security risks when URL substrings are validated without proper parsing, which can be bypassed.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Generates regex pattern for widely used top-level domains\nprivate string commonTldPattern() { result = \"com|org|edu|gov|uk|net|io\" }\n\n// Determines if a string literal exhibits URL-like characteristics\npredicate isUrlLike(StringLiteral urlLiteral) {\n  exists(string text | text = urlLiteral.getText() |\n    text.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + commonTldPattern() + \")(:[0-9]+)?/?\")\n    or\n    // Alternative pattern for HTTP URLs with arbitrary TLDs\n    text.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Identifies inadequate sanitization operations applied to URL substrings\npredicate hasInsufficientSanitization(Expr sanitizationExpr, StringLiteral urlLiteral) {\n  isUrlLike(urlLiteral) and\n  (\n    // Case 1: Direct comparison operations\n    exists(Compare comparisonOp |\n      comparisonOp.compares(urlLiteral, any(In inOperator), _) and\n      sanitizationExpr = comparisonOp\n    )\n    or\n    // Case 2: Unsafe prefix validation\n    exists(Call prefixCheck |\n      prefixCheck.getFunc().(Attribute).getName() = \"startswith\" and\n      prefixCheck.getArg(0) = urlLiteral and\n      not urlLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\") and\n      sanitizationExpr = prefixCheck\n    )\n    or\n    // Case 3: Unsafe suffix validation\n    exists(Call suffixCheck |\n      suffixCheck.getFunc().(Attribute).getName() = \"endswith\" and\n      suffixCheck.getArg(0) = urlLiteral and\n_______________ // 补全条件\n      sanitizationExpr = suffixCheck\n    )\n  )\n}\n\n// Main query: Finds expressions with incomplete URL substring sanitization\nfrom Expr sanitizationExpr, StringLiteral urlLiteral\nwhere hasInsufficientSanitization(sanitizationExpr, urlLiteral)\nselect sanitizationExpr, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlLiteral,\n  urlLiteral.getText()",
    "output": "not urlLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\") and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__slots__` in old-style class\n * @description Identifies legacy-style classes that do not inherit from 'object' (old-style) \n *              yet define the `__slots__` attribute. In such scenarios, `__slots__` fails \n *              to deliver the intended memory optimization and instead behaves as a \n *              conventional class attribute, potentially leading to unexpected behavior.\n *              This issue is particularly relevant when migrating code from Python 2.x to 3.x,\n *              as the behavior of `__slots__` differs significantly between old-style and new-style classes.\n * @kind problem\n * @problem.severity error\n * @tags portability\n *       correctness\n * @sub-severity low\n * @precision very-high\n * @id py/slots-in-old-style-class\n */\n\nimport python\n\nfrom ClassObject legacyStyleClass\nwhere \n_______________ // 补全条件\n  not legacyStyleClass.failedInference()\n  and\n  // Then, identify classes that do not inherit from 'object' (old-style classes)\n  not legacyStyleClass.isNewStyle() \n  and \n  // Finally, check for the presence of the __slots__ attribute definition\n  legacyStyleClass.declaresAttribute(\"__slots__\") \nselect legacyStyleClass,\n  \"Using '__slots__' in an old style class just creates a class attribute called '__slots__'.\"",
    "output": "// First, verify the class analysis completed successfully without inference failures"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * Detects insecure usage of Azure Storage client-side encryption v1.\n * @description Using version v1 of Azure Storage client-side encryption is insecure, potentially allowing attackers to decrypt encrypted data\n * @kind path-problem\n * @tags security\n *       experimental\n *       cryptography\n *       external/cwe/cwe-327\n * @id py/azure-storage/unsafe-client-side-encryption-in-use\n * @problem.severity error\n * @precision medium\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n/**\n * Identifies API nodes for Blob service client instances.\n * @param isCreationSource - True if node represents a client creation source\n * @returns API node for Blob service client\n */\nAPI::Node getBlobServiceClientNode(boolean isCreationSource) {\n  // Direct BlobServiceClient instantiation\n  isCreationSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getReturn()\n  or\n  // BlobServiceClient creation via connection string\n  isCreationSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getMember(\"from_connection_string\")\n        .getReturn()\n}\n\n/**\n * Identifies call nodes that transition to container clients.\n * @returns API call node for container client transition\n */\nAPI::CallNode getContainerClientTransitionCall() {\n  // Container client retrieval from blob service client\n  result = getBlobServiceClientNode(_).getMember(\"get_container_client\").getACall()\n  or\n  // Container client retrieval from blob client\n  result = getBlobClientNode(_).getMember(\"_get_container_client\").getACall()\n}\n\n/**\n * Identifies API nodes for container client instances.\n * @param isCreationSource - True if node represents a client creation source\n * @returns API node for container client\n */\nAPI::Node getContainerClientNode(boolean isCreationSource) {\n  // Container client from transition calls\n  isCreationSource = false and\n  result = getContainerClientTransitionCall().getReturn()\n  or\n  // Direct ContainerClient instantiation\n  isCreationSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getReturn()\n  or\n  // ContainerClient creation via connection string or URL\n  isCreationSource = true and\n  result =\n_______________ // 补全条件\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getMember([\"from_connection_string\", \"from_container_url\"])\n        .getReturn()\n}\n\n/**\n * Identifies call nodes that transition to blob clients.\n * @returns API call node for blob client transition\n */\nAPI::CallNode getBlobClientTransitionCall() {\n  // Blob client retrieval from blob service or container clients\n  result = [getBlobServiceClientNode(_), getContainerClientNode(_)]\n        .getMember(\"get_blob_client\")\n        .getACall()\n}\n\n/**\n * Identifies API nodes for blob client instances.\n * @param isCreationSource - True if node represents a client creation source\n * @returns API node for blob client\n */\nAPI::Node getBlobClientNode(boolean isCreationSource) {\n  // Blob client from transition calls\n  isCreationSource = false and\n  result = getBlobClientTransitionCall().getReturn()\n  or\n  // Direct BlobClient instantiation\n  isCreationSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getReturn()\n  or\n  // BlobClient creation via connection string or URL\n  isCreationSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getMember([\"from_connection_string\", \"from_blob_url\"])\n        .getReturn()\n}\n\n/**\n * Identifies any storage client API node (blob service, container, or blob).\n * @param isCreationSource - True if node represents a client creation source\n * @returns API node for any storage client\n */\nAPI::Node getAnyStorageClientNode(boolean isCreationSource) {\n  result in [\n    getBlobServiceClientNode(isCreationSource),\n    getContainerClientNode(isCreationSource),\n    getBlobClientNode(isCreationSource)\n  ]\n}\n\n// Define encryption state types for Azure storage clients\nnewtype AzureEncryptionState =\n  UsesV1Encryption()   // Indicates v1 encryption is in use\n  or\n  UsesNoEncryption()   // Indicates no encryption is configured\n\n/**\n * Configuration module for tracking encryption states in Azure blob clients.\n * Implements DataFlow::StateConfigSig interface.\n */\nprivate module AzureStorageClientConfig implements DataFlow::StateConfigSig {\n  class FlowState = AzureEncryptionState;\n\n  /**\n   * Identifies source nodes where encryption might not be configured.\n   * @param node - Data flow node to check\n   * @param state - Flow state to set\n   */\n  predicate isSource(DataFlow::Node node, FlowState state) {\n    state = UsesNoEncryption() and\n    node = getAnyStorageClientNode(true).asSource()\n  }\n\n  /**\n   * Identifies barrier nodes where encryption is properly configured.\n   * @param node - Data flow node to check\n   * @param state - Flow state to check\n   */\n  predicate isBarrier(DataFlow::Node node, FlowState state) {\n    exists(state) and\n    // Explicit v2 encryption configuration\n    exists(DataFlow::AttrWrite encryptionConfig |\n      node = getAnyStorageClientNode(_).getAValueReachableFromSource() and\n      encryptionConfig.accesses(node, \"encryption_version\") and\n      encryptionConfig.getValue().asExpr().(StringLiteral).getText() in [\"'2.0'\", \"2.0\"]\n    )\n    or\n    // Prevent flow when encryption properties are set\n    isAdditionalFlowStep(_, UsesNoEncryption(), node, UsesV1Encryption()) and\n    state = UsesNoEncryption()\n  }\n\n  /**\n   * Identifies additional flow steps between client objects.\n   * @param node1 - Source node\n   * @param node2 - Destination node\n   */\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(DataFlow::MethodCallNode transitionCall |\n      transitionCall in [getContainerClientTransitionCall(), getBlobClientTransitionCall()] and\n      node1 = transitionCall.getObject() and\n      node2 = transitionCall\n    )\n  }\n\n  /**\n   * Identifies state transitions during flow.\n   * @param node1 - Source node\n   * @param state1 - Source state\n   * @param node2 - Destination node\n   * @param state2 - Destination state\n   */\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    node1 = node2.(DataFlow::PostUpdateNode).getPreUpdateNode() and\n    state1 = UsesNoEncryption() and\n    state2 = UsesV1Encryption() and\n    // Encryption configuration that triggers v1 usage\n    exists(DataFlow::AttrWrite encryptionSetup |\n      node1 = getAnyStorageClientNode(_).getAValueReachableFromSource() and\n      encryptionSetup.accesses(node1, [\"key_encryption_key\", \"key_resolver_function\"])\n    )\n  }\n\n  /**\n   * Identifies sink nodes where v1 encryption is used for blob uploads.\n   * @param node - Data flow node to check\n   * @param state - Flow state to check\n   */\n  predicate isSink(DataFlow::Node node, FlowState state) {\n    state = UsesV1Encryption() and\n    // Blob upload operations\n    exists(DataFlow::MethodCallNode uploadCall |\n      uploadCall = getBlobClientNode(_).getMember(\"upload_blob\").getACall() and\n      node = uploadCall.getObject()\n    )\n  }\n\n  // Enable differential analysis for incremental mode\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Global data flow analysis module with state tracking\nmodule AzureStorageClientFlow = DataFlow::GlobalWithState<AzureStorageClientConfig>;\n\nimport AzureStorageClientFlow::PathGraph\n\n/**\n * Main query to detect unsafe v1 encryption usage.\n * Finds paths from unencrypted sources to v1-encrypted blob uploads.\n */\nfrom AzureStorageClientFlow::PathNode source, AzureStorageClientFlow::PathNode sink\nwhere AzureStorageClientFlow::flowPath(source, sink)\nselect sink, source, sink, \"Unsafe usage of v1 version of Azure Storage client-side encryption\"",
    "output": "API::moduleImport(\"azure\")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Directory traversal during tarball extraction from attacker-controlled source\n * @description Detects insecure tar extraction lacking path validation against destination directory,\n *             enabling arbitrary file writes outside target location. Exploitable when tar files\n *             originate from attacker-controlled inputs (remote sources or CLI arguments).\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n_______________ // 补全条件\nfrom UnsafeUnpackFlow::PathNode taintedSource, UnsafeUnpackFlow::PathNode extractionSink\nwhere UnsafeUnpackFlow::flowPath(taintedSource, extractionSink)\nselect extractionSink.getNode(), taintedSource, extractionSink,\n  \"Unsafe extraction from malicious tarball retrieved from remote location\"",
    "output": "// Trace data flow from attacker-controlled sources to vulnerable extraction points"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cyclomatic-complexity-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes the cyclomatic complexity metric for all Python functions in the codebase.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cyclomatic Complexity Analysis for Python Functions\n * @description Computes the cyclomatic complexity metric for all Python functions in the codebase.\n *              Cyclomatic complexity quantifies the number of independent execution paths through\n *              a function's code. Functions with higher complexity scores contain more decision points\n *              (conditionals, loops), making them harder to understand, test, and maintain.\n * @kind treemap\n * @id py/cyclomatic-complexity-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max sum\n * @tags testability\n *       complexity\n *       maintainability\n */\n\nimport python\n\n// For each Python function, calculate its cyclomatic complexity\nfrom Function pythonFunction, int complexityScore\nwhere complexityScore = pythonFunction.getMetrics().getCyclomaticComplexity()\n// Output functions ordered by their complexity score in descending order\nselect pythonFunction, complexityScore order by complexityScore desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call-to-non-callable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies attempts to call objects that do not support callable behavior,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-callable invoked\n * @description Identifies attempts to call objects that do not support callable behavior,\n *              resulting in runtime TypeError exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom \n  Call funcCall, \n  Value targetValue, \n  ClassValue objClass, \n  Expr funcExpr, \n  AstNode sourceLocation\nwhere\n  // Extract and resolve the function expression being called\n  funcExpr = funcCall.getFunc() and\n  funcExpr.pointsTo(targetValue, sourceLocation) and\n  \n  // Determine class and verify it lacks callable behavior\n  objClass = targetValue.getClass() and\n  not objClass.isCallable() and\n  \n  // Ensure type inference succeeded for accurate results\n  not objClass.failedInference(_) and\n  \n  // Exclude special cases that might appear non-callable but have valid semantics\n  not objClass.hasAttribute(\"__get__\") and\n  not targetValue = Value::named(\"None\") and\n  not use_of_not_implemented_in_raise(_, funcExpr)\nselect \n  funcCall, \n  \"Call to a $@ of $@.\", \n  sourceLocation, \n  \"non-callable\", \n  objClass, \n  objClass.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Multiple imports on one line\n * @description Placing multiple import statements on a single line reduces code readability;\n *              PEP8 recommends that imports should typically be on separate lines.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/multiple-imports-on-line\n */\n\n/*\n * This query identifies import statements with the following pattern:\n * import modA, modB\n * (According to PEP 8, each import should be on its own line)\n */\n\n// Import the Python module for parsing and analyzing Python code\nimport python\n\n// Define a predicate to detect multi-module import statements\npredicate multiple_import(Import importStmt) { \n    // Check if the import statement contains more than one module name\n    count(importStmt.getAName()) > 1 and \n    // Ensure the import is not a \"from ... import ...\" style statement\n    not importStmt.isFromImport() \n}\n\n// Query all import statements that match the multiple_import condition\nfrom Import importDeclaration\nwhere multiple_import(importDeclaration)\nselect importDeclaration, \"Multiple imports on one line.\"",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Conflicting attributes in base classes\n * @description Detects when a class inherits from multiple base classes that define the same attribute, potentially causing unexpected behavior due to attribute resolution conflicts.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n// Determines if a function contains only pass statements or docstrings\npredicate is_empty_function(PyFunctionObject func) {\n  // Verifies the function body contains no meaningful statements beyond pass or docstring\n  not exists(Stmt statement | statement.getScope() = func.getFunction() |\n    not statement instanceof Pass and \n    not statement.(ExprStmt).getValue() = func.getFunction().getDocString()\n  )\n}\n\n/* Methods invoking super() are safe as they explicitly call overridden methods */\n// Checks if a function contains a super() call\npredicate invokes_super(FunctionObject func) {\n  // Identifies super() method calls within the function body\n  exists(Call superCall, Call methodCall, Attribute attrRef, GlobalVariable superVar |\n    methodCall.getScope() = func.getFunction() and\n    methodCall.getFunc() = attrRef and\n    attrRef.getObject() = superCall and\n    attrRef.getName() = func.getName() and\n    superCall.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/** Identifies attribute names exempt from conflict detection */\npredicate is_exempted(string attributeName) {\n  /*\n   * Exemption for specific library-recommended patterns:\n   * See https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   */\n  attributeName = \"process_request\"\n}\n\nfrom\n  ClassObject derivedClass, \n  ClassObject baseClass1, \n  ClassObject baseClass2, \n  string attrName, \n  int index1, \n  int index2, \n  Object attrObj1, \n  Object attrObj2\nwhere\n  // Establish base class relationships with distinct indices\n  derivedClass.getBaseType(index1) = baseClass1 and\n  derivedClass.getBaseType(index2) = baseClass2 and\n  index1 < index2 and\n  \n  // Retrieve conflicting attribute objects from base classes\n  attrObj1 = baseClass1.lookupAttribute(attrName) and\n  attrObj2 = baseClass2.lookupAttribute(attrName) and\n  attrObj1 != attrObj2 and\n  \n  // Exclude special method names and exempted attributes\n  not attrName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  not is_exempted(attrName) and\n  \n  // Filter out safe resolution patterns\n  not invokes_super(attrObj1) and\n  not is_empty_function(attrObj2) and\n  \n  // Verify no override relationship exists between attributes\n  not attrObj1.overrides(attrObj2) and\n  not attrObj2.overrides(attrObj1) and\n  \n  // Ensure derived class doesn't explicitly declare the attribute\n_______________ // 补全条件\nselect \n  derivedClass, \n  \"Base classes have conflicting values for attribute '\" + attrName + \"': $@ and $@.\", \n  attrObj1, attrObj1.toString(), \n  attrObj2, attrObj2.toString()",
    "output": "not derivedClass.declaresAttribute(attrName)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测在旧式类中使用 super() 调用的情况，这种用法在 Python 中是不被支持的，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description 检测在旧式类中使用 super() 调用的情况，这种用法在 Python 中是不被支持的，\n *              因为旧式类没有实现新式类的 MRO (Method Resolution Order) 机制。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n// 判断给定的调用是否是在旧式类中的 super() 调用\npredicate isSuperCallInOldStyleClass(Call superCall) {\n  // 验证调用目标是 super() 函数\n  exists(Name funcName | \n    funcName = superCall.getFunc() and \n    funcName.getId() = \"super\"\n  ) and\n  // 获取包含调用的函数和类作用域\n  exists(Function enclosingFunction, ClassObject enclosingClass |\n    // 确保调用位于函数作用域内\n    superCall.getScope() = enclosingFunction and\n    // 确保函数定义在类作用域内\n    enclosingFunction.getScope() = enclosingClass.getPyClass() and\n    // 验证类类型推断成功\n    not enclosingClass.failedInference() and\n    // 确保类为旧式类（未继承自 object 或其他新式类）\n    not enclosingClass.isNewStyle()\n  )\n}\n\n// 查询所有在旧式类中使用 super() 的调用点\nfrom Call invalidSuperCall\n// 筛选条件：调用是在旧式类中的 super() 调用\nwhere isSuperCallInOldStyleClass(invalidSuperCall)\n// 输出问题调用点及相应的错误信息\nselect invalidSuperCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type metrics\n * @description Computes metrics for Python type annotations across parameters, \n *              return types, and annotated assignments, categorizing them by \n *              complexity and usage patterns.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents core Python built-in types (e.g., int, str, bool)\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements supporting type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr func) { exists(func.getReturns()) } or\n  TAnnotatedParameter(Parameter param) { exists(param.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign stmt) { exists(stmt.getAnnotation()) }\n\n// Base class for elements with type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr func;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(func) }\n  override Expr getAnnotation() { result = func.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter param;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(param) }\n  override Expr getAnnotation() { result = param.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assign;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assign) }\n  override Expr getAnnotation() { result = assign.getAnnotation() }\n}\n\n/** Identifies forward-declared types (string literals) */\npredicate is_forward_declaration(Expr expr) { expr instanceof StringLiteral }\n\n/** Identifies complex types that may be challenging to analyze */\npredicate is_complex_type(Expr expr) {\n  (expr instanceof Subscript and not is_optional_type(expr)) or\n  expr instanceof Tuple or\n  expr instanceof List\n}\n\n/** Identifies Optional[...] type patterns */\npredicate is_optional_type(Subscript expr) { expr.getObject().(Name).getId() = \"Optional\" }\n\n/** Identifies simple types (non-built-in identifiers or attribute chains) */\npredicate is_simple_type(Expr expr) {\n  (expr instanceof Name and not expr instanceof BuiltinType) or\n  is_simple_type(expr.(Attribute).getObject())\n}\n\n/** Identifies built-in types */\npredicate is_builtin_type(Expr expr) { expr instanceof BuiltinType }\n\n// Computes type annotation metrics for different categories\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  category = \"Parameter annotation\" and\n  totalCount = count(AnnotatedParameter p) and\n  builtinCount = count(AnnotatedParameter p | is_builtin_type(p.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedParameter p | is_forward_declaration(p.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedParameter p | is_simple_type(p.getAnnotation())) and\n  complexTypeCount = count(AnnotatedParameter p | is_complex_type(p.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedParameter p | is_optional_type(p.getAnnotation()))\n  or\n  // Return type annotation metrics\n  category = \"Return type annotation\" and\n  totalCount = count(AnnotatedFunction f) and\n  builtinCount = count(AnnotatedFunction f | is_builtin_type(f.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedFunction f | is_forward_declaration(f.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedFunction f | is_simple_type(f.getAnnotation())) and\n  complexTypeCount = count(AnnotatedFunction f | is_complex_type(f.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedFunction f | is_optional_type(f.getAnnotation()))\n  or\n  // Annotated assignment metrics\n  category = \"Annotated assignment\" and\n  totalCount = count(AnnotatedAssignment a) and\n  builtinCount = count(AnnotatedAssignment a | is_builtin_type(a.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedAssignment a | is_forward_declaration(a.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedAssignment a | is_simple_type(a.getAnnotation())) and\n_______________ // 补全条件\n  optionalTypeCount = count(AnnotatedAssignment a | is_optional_type(a.getAnnotation()))\n}\n\n// Query execution and result projection\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount",
    "output": "complexTypeCount = count(AnnotatedAssignment a | is_complex_type(a.getAnnotation())) and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks on substrings of unparsed URLs are vulnerable to bypass\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n_______________ // 补全条件\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Defines regex pattern for common top-level domains\nprivate string commonTldPattern() { \n  result = \"com|org|edu|gov|uk|net|io\" \n}\n\n// Checks if string literal exhibits URL characteristics\npredicate isUrlLike(StringLiteral urlLiteral) {\n  exists(string content | content = urlLiteral.getText() |\n    content.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + commonTldPattern() +\n        \")(:[0-9]+)?/?\")\n    or\n    content.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Identifies unsafe prefix validation using startswith()\npredicate containsUnsafePrefixCheck(Call methodCall, StringLiteral prefixLiteral) {\n  methodCall.getFunc().(Attribute).getName() = \"startswith\" and\n  methodCall.getArg(0) = prefixLiteral and\n  not prefixLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n}\n\n// Identifies unsafe suffix validation using endswith()\npredicate containsUnsafeSuffixCheck(Call methodCall, StringLiteral suffixLiteral) {\n  methodCall.getFunc().(Attribute).getName() = \"endswith\" and\n  methodCall.getArg(0) = suffixLiteral and\n  not suffixLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n}\n\n// Detects incomplete sanitization operations on URL substrings\npredicate hasIncompleteUrlSanitization(Expr sanitizationExpr, StringLiteral urlLiteral) {\n  isUrlLike(urlLiteral) and\n  (\n    sanitizationExpr.(Compare).compares(urlLiteral, any(In i), _)\n    or\n    containsUnsafePrefixCheck(sanitizationExpr, urlLiteral)\n    or\n    containsUnsafeSuffixCheck(sanitizationExpr, urlLiteral)\n  )\n}\n\n// Find expressions performing incomplete URL substring sanitization\nfrom Expr sanitizationExpr, StringLiteral urlLiteral\nwhere hasIncompleteUrlSanitization(sanitizationExpr, urlLiteral)\nselect sanitizationExpr, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlLiteral,\n  urlLiteral.getText()",
    "output": "* @id py/incomplete-url-substring-sanitization"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Duplicate function identification\n * @description Identifies functions with identical implementations across the codebase.\n *              Such duplication should be consolidated into shared modules or base classes\n *              to improve code reusability and maintainability.\n * @kind problem\n * @tags testability\n *       useless-code\n *       maintainability\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/duplicate-function\n */\n\nimport python\n\nfrom Function originalFunc, Function clonedFunc, string message\nwhere \n  // Ensure functions are distinct entities\n  originalFunc != clonedFunc and\n  // Verify both functions have implementations\n  exists(originalFunc.getBody()) and\n  exists(clonedFunc.getBody()) and\n  // Core check: identical function implementations\n  originalFunc.getBody() = clonedFunc.getBody() and\n  // Prevent duplicate reporting by enforcing lexical ordering\n  originalFunc.getName() < clonedFunc.getName() and\n  // Construct alert message\n_______________ // 补全条件\nselect originalFunc, message, clonedFunc, clonedFunc.getName()",
    "output": "message = \"Duplicate function: \" + originalFunc.getName() + \" and \" + clonedFunc.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Redundant constant comparison detection\n * @description Identifies code locations where two constant values are compared,\n *              which always yields a fixed result known at compile time. Such comparisons\n *              are unnecessary and should be replaced with literal boolean values (True/False)\n *              to improve code clarity, reduce complexity, and enhance maintainability.\n *              This analysis helps eliminate redundant constant comparisons for cleaner code.\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/comparison-of-constants\n */\n\nimport python\n\n// Identify comparison operations between constant expressions, excluding those in assert statements\nfrom Compare constantComparison, Expr leftConstant, Expr rightConstant\nwhere\n  // Ensure comparison involves two operands\n  constantComparison.compares(leftConstant, _, rightConstant) and\n_______________ // 补全条件\n  leftConstant.isConstant() and\n  rightConstant.isConstant() and\n  // Exclude comparisons within assert statements\n  not exists(Assert assertion | assertion.getTest() = constantComparison)\nselect constantComparison, \"Comparison of constants; use 'True' or 'False' instead.\"",
    "output": "// Verify both operands are constant expressions"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 输出模块依赖关系\n * @description 计算每个模块所依赖的其他模块数量（传出耦合度）\n * @kind 树状图\n * @id py/efferent-coupling-per-file\n * @treemap.warnOn 高值警告\n_______________ // 补全条件\n * @metricAggregate 平均值 最大值\n * @tags 可测试性\n *       模块化\n */\n\nimport python\n\n// 定义模块分析变量，用于计算传出耦合度\nfrom ModuleMetrics moduleDependency\n\n// 计算每个模块的传出耦合度（即该模块依赖的其他模块数量）\n// 传出耦合度是衡量模块独立性的重要指标，值越高表示模块依赖性越强\nselect \n  moduleDependency, \n  moduleDependency.getEfferentCoupling() as dependencyCount \norder by \n  dependencyCount desc",
    "output": "* @metricType 文件"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes the effective lines of code for each Python file (excluding",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File Code Line Count\n * @kind treemap\n * @description Computes the effective lines of code for each Python file (excluding\n *              lines that only contain docstrings, comments, or whitespace).\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n * @id py/lines-of-code-in-files\n */\n\nimport python\n\n// Identifies Python source files and computes their effective code line counts,\n// excluding documentation, comments, and whitespace-only lines\nfrom Module srcFile, int locCount\nwhere \n  // For each source file, determine the number of lines containing actual code\n  locCount = srcFile.getMetrics().getNumberOfLinesOfCode()\n// Return the source files and their corresponding code line counts,\n// sorted in descending order by line count\nselect srcFile, locCount order by locCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jump-to-definition]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Jump to definition helper query.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Definitions\n * @description Jump to definition helper query.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// 导入Python库，用于处理Python代码的查询\nimport python\n\n// 导入分析定义跟踪模块，用于跟踪变量和函数的定义\nimport analysis.DefinitionTracking\n\n// 从NiceLocationExpr使用、定义和字符串类型中选择数据\nfrom NiceLocationExpr use, Definition defn, string kind\n// 条件：定义与使用匹配，并且类型相同\nwhere defn = definitionOf(use, kind)\n// 选择使用位置、定义位置和定义类型\nselect use, defn, kind"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name An assert statement has a side-effect\n * @description Side-effects in assert statements result in differences between normal\n *              and optimized behavior.\n * @kind problem\n * @tags reliability\n_______________ // 补全条件\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/side-effect-in-assert\n */\n\nimport python\n\n// 定义一个谓词函数，用于判断表达式是否包含具有副作用的函数调用\npredicate func_with_side_effects(Expr e) {\n  // 检查表达式中的函数名或变量名是否在指定的具有副作用的函数名列表中\n  exists(string name | name = e.(Attribute).getName() or name = e.(Name).getId() |\n    name in [\n        \"print\", \"write\", \"append\", \"pop\", \"remove\", \"discard\", \"delete\", \"close\", \"open\", \"exit\"\n      ]\n  )\n}\n\n// 定义一个谓词函数，用于判断调用是否为特定的subprocess模块中的函数\npredicate call_with_side_effect(Call e) {\n  // 检查调用节点是否为subprocess.call, subprocess.check_call或subprocess.check_output\n  e.getAFlowNode() = Value::named(\"subprocess.call\").getACall()\n  or\n  e.getAFlowNode() = Value::named(\"subprocess.check_call\").getACall()\n  or\n  e.getAFlowNode() = Value::named(\"subprocess.check_output\").getACall()\n}\n\n// 定义一个谓词函数，用于判断表达式是否可能具有副作用\npredicate probable_side_effect(Expr e) {\n  // 仅考虑显式的yield语句，不包括理解中的人工yield语句\n  e instanceof Yield and not exists(Comp c | c.contains(e))\n  or\n  // 检查是否为YieldFrom实例\n  e instanceof YieldFrom\n  or\n  // 检查是否为调用具有副作用的函数\n  e instanceof Call and func_with_side_effects(e.(Call).getFunc())\n  or\n  // 检查是否为特定的subprocess模块中的函数调用\n  e instanceof Call and call_with_side_effect(e)\n}\n\n// 从Assert和Expr中选择数据，并应用条件过滤\nfrom Assert a, Expr e\nwhere probable_side_effect(e) and a.contains(e)\nselect a, \"This 'assert' statement contains an $@ which may have side effects.\", e, \"expression\"",
    "output": "*       maintainability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * 识别特定名称的目标类\n * 此查询定位名为\"YourClassName\"的类，可扩展为包含路径验证\n */\n\nimport python\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n\n// 检索符合名称条件的类定义\nfrom Class targetClass\nwhere \n  // 验证类名与预设目标匹配\n  targetClass.getName() = \"YourClassName\"\n  // 可选：验证类是否位于特定文件路径中\n  // and targetClass.getLocation().getFile().getAbsolutePath().matches(\"%/folder/file.py\")\nselect targetClass",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-hashes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of cryptographic hash algorithms that are either unapproved or considered weak.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak cryptographic hashes\n * @description Detects usage of cryptographic hash algorithms that are either unapproved or considered weak.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import required Python libraries and experimental cryptography concepts\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify weak hash operations and generate corresponding warnings\nfrom HashAlgorithm cryptoHash, string algorithmName, string alertMessage\nwhere\n  // Extract the algorithm name from the hash operation\n  algorithmName = cryptoHash.getHashName() and\n  // Exclude approved strong hash algorithms (SHA256, SHA384, SHA512)\n  not algorithmName in [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // Generate alert message based on algorithm recognition status\n  (\n    // Case: Recognized but unapproved algorithm\n    algorithmName != \"\" and\n    alertMessage = \"Use of unapproved hash algorithm or API \" + algorithmName + \".\"\n  )\n  or\n  (\n    // Case: Unrecognized algorithm\n    algorithmName = \"\" and\n    alertMessage = \"Use of unrecognized hash algorithm.\"\n  )\nselect cryptoHash, alertMessage"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commit-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Source links of commits",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Source links of commits\n * @kind source-link\n * @id py/commit-source-links\n * @metricType commit\n */\n\n// 引入Python模块以支持Python代码分析功能\nimport python\n// 引入外部版本控制系统模块，用于访问提交历史和文件变更信息\nimport external.VCS\n\n// 从版本控制系统中提取提交记录及其关联的源代码文件\nfrom Commit commitRecord, File affectedFile\n// 确保我们只处理源代码文件\nwhere affectedFile.fromSource()\n// 并且该文件确实受到了提交的影响\nand affectedFile = commitRecord.getAnAffectedFile()\n// 输出结果：提交的修订标识符和受影响的源代码文件\nselect commitRecord.getRevisionName(), affectedFile"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commented-out-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code segments that have been deactivated via commenting.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commented-out code\n * @description Detects code segments that have been deactivated via commenting. \n *              Such segments can degrade code quality by becoming outdated and \n *              creating confusion about active functionality.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code */\n\nimport python\nimport Lexical.CommentedOutCode\n\n// Identify all commented code segments while excluding potential examples\nfrom CommentedOutCodeBlock commentedCodeSegment\nwhere not commentedCodeSegment.maybeExampleCode()\n// Flag identified segments with contextual warning message\nselect commentedCodeSegment, \"This comment contains inactive code that should be removed.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 数据库中用户编写的Python代码总行数\n * @description 来自源代码目录的Python代码的总行数，不包括自动生成的文件。\n *   此查询计算代码行数，不包括空白或注释。注意：如果外部库包含在代码库中，\n *   无论是在已签入的虚拟环境中还是作为供应商代码，目前都将被计为用户编写的代码。\n * @kind metric\n * @tags summary\n *       代码行数\n *       调试\n * @id py/summary/lines-of-user-code\n_______________ // 补全条件\n\nimport python // 导入python模块\nimport semmle.python.filters.GeneratedCode // 导入GeneratedCode过滤器模块\n\n// 选择所有符合条件的模块，并计算其代码行数之和\nselect sum(Module m |\n    // 确保模块文件有相对路径\n    exists(m.getFile().getRelativePath()) and\n    // 排除自动生成的文件\n    not m.getFile() instanceof GeneratedFile\n  |\n    // 获取模块的代码行数指标\n    m.getMetrics().getNumberOfLinesOfCode()\n  )",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Finds syntax errors in Python code that result in runtime failures and prevent proper analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import necessary Python library for code querying and analysis\nimport python\n\n// Query for syntax errors, excluding encoding-related issues\nfrom SyntaxError syntaxIssue\nwhere not syntaxIssue instanceof EncodingError\nselect syntaxIssue, syntaxIssue.getMessage() + \" (in Python \" + major_version() + \").\"\n// Return the syntax error instance along with a detailed error message including Python version",
    "output": "* @name Syntax error"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lgtm/class-display-strings]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Display strings of classes",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Display strings of classes\n * @kind display-string\n * @id py/lgtm/class-display-strings\n * @metricType reftype\n */\n\nimport python\n\n// 检索所有Python类定义并生成其名称的显示字符串\nfrom Class pythonClass\nselect pythonClass, pythonClass.getName() // 返回类实例及其对应的名称作为显示字符串"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称密钥生成中的未知密钥大小\n * @description 检测在非对称加密算法生成密钥时，无法在静态分析阶段确定密钥长度的情况\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n_______________ // 补全条件\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找非对称密钥生成操作中密钥大小无法静态确认的情况\nfrom AsymmetricKeyGen keyGeneration, DataFlow::Node configSource, string algorithmName\nwhere\n  // 获取密钥配置的源节点\n  configSource = keyGeneration.getKeyConfigSrc() and\n  // 获取所使用的加密算法名称\n  algorithmName = keyGeneration.getAlgorithm().getName() and\n  // 确认密钥生成操作没有静态验证的密钥大小参数\n  not keyGeneration.hasKeySize(configSource)\nselect keyGeneration,\n  // 生成问题报告，包含算法信息和配置源\n  \"用于算法 \" + algorithmName.toString() + \" 的密钥生成使用了无法静态验证的密钥大小，在配置源 $@\", configSource, configSource.toString()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies functions that begin with an uppercase letter, which violates Python naming conventions and reduces code readability.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python\n\n// Detect functions with uppercase initial letters that are the only such functions in their file\nfrom Function func\nwhere\n  func.inSource() and  // Ensure function is present in source code\n  exists(string startingChar |\n    startingChar = func.getName().prefix(1) and  // Extract first character of function name\n    not startingChar = startingChar.toLowerCase()  // Verify if first character is uppercase\n  ) and\n  not exists(Function anotherFunc |\n    anotherFunc != func and  // Exclude current function\n    anotherFunc.getLocation().getFile() = func.getLocation().getFile() and  // Ensure same file\n    exists(string otherStartingChar |\n      otherStartingChar = anotherFunc.getName().prefix(1) and  // Extract first character of other function name\n      not otherStartingChar = otherStartingChar.toLowerCase()  // Verify if other function also starts with uppercase\n    )\n  )\nselect func, \"Function names should start in lowercase.\"  // Report these functions with naming convention reminder",
    "output": "* @name Misnamed function"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/percent-format/wrong-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies string formatting operations using % operator where conversion specifier count",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incorrect argument count for percent formatting\n * @description Identifies string formatting operations using % operator where conversion specifier count \n *              mismatches provided argument count. Example: '\"%s: %s, %s\" % (a,b)' triggers TypeError.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/percent-format/wrong-arguments\n */\n\nimport python\nimport semmle.python.strings\n\n// Detects percent-style string formatting operations\npredicate percent_format_operation(BinaryExpr formatOpExpr, StringLiteral formatString, Value argumentsValue, AstNode argumentsSource) {\n  // Verify modulo operator is used\n  formatOpExpr.getOp() instanceof Mod and\n  exists(Context ctx |\n    // Left operand must resolve to format string\n    formatOpExpr.getLeft().pointsTo(ctx, _, formatString) and\n    // Right operand must resolve to arguments\n    formatOpExpr.getRight().pointsTo(ctx, argumentsValue, argumentsSource)\n  )\n}\n\n// Computes the number of formatting arguments\nint count_format_arguments(Value argumentsValue) {\n  /* Handle tuple arguments */\n  exists(Tuple tupleArg | tupleArg.pointsTo(argumentsValue, _) |\n    result = strictcount(tupleArg.getAnElt()) and\n    // Exclude starred expressions from count\n    not tupleArg.getAnElt() instanceof Starred\n  )\n  or\n  /* Handle single literal arguments */\n  exists(ImmutableLiteral literalArg | literalArg.getLiteralValue() = argumentsValue | result = 1)\n}\n\nfrom\n  BinaryExpr formatOpExpr, StringLiteral formatString, Value argumentsValue, \n  int argumentsCount, int formatItemsCount, AstNode argumentsSource, string messageEnding\nwhere\n  // Identify percent formatting operation\n  percent_format_operation(formatOpExpr, formatString, argumentsValue, argumentsSource) and\n  // Calculate argument count\n  argumentsCount = count_format_arguments(argumentsValue) and\n  // Calculate format specifier count\n  formatItemsCount = format_items(formatString) and\n  // Detect count mismatch\n  argumentsCount != formatItemsCount and\n  // Generate context-aware message suffix\n  (if argumentsCount = 1 then messageEnding = \" is provided.\" else messageEnding = \" are provided.\")\nselect formatOpExpr,\n  // Construct error message\n  \"Incorrect number of $@ for string formatting. Format $@ expects \" + formatItemsCount.toString() + \n  \", but \" + argumentsCount.toString() + messageEnding, \n  argumentsSource, \"arguments\", formatString, formatString.getText()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Elliptic Curve Cryptography Detection\n * @description This query systematically identifies all elliptic curve cryptographic \n *              algorithm implementations throughout the codebase. It extracts critical\n *              information including curve names and key sizes to assess quantum \n *              vulnerability. Given that ECC algorithms are vulnerable to quantum \n *              computing attacks, this detection is crucial for cryptographic asset \n *              inventory management and quantum transition strategy development.\n * @kind problem\n * @id py/quantum-readiness/cbom/elliptic-curve-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n_______________ // 补全条件\nfrom EllipticCurveAlgorithm ellipticCurveInstance\nselect ellipticCurveInstance,\n  \"Algorithm: \" + ellipticCurveInstance.getCurveName() + \n  \" | Key Size (bits): \" + ellipticCurveInstance.getCurveBitSize().toString()",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-url-substring-sanitization]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Security checks that operate on substrings of unparsed URLs are vulnerable to bypass attacks,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks that operate on substrings of unparsed URLs are vulnerable to bypass attacks, \n *              as they don't account for the entire URL structure\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Defines regex pattern for common top-level domains used in URL validation\nprivate string commonTldPattern() { \n  result = \"com|org|edu|gov|uk|net|io\" \n}\n\n// Determines if a string literal exhibits URL-like characteristics\npredicate hasUrlCharacteristics(StringLiteral urlLiteral) {\n  exists(string textContent | \n    textContent = urlLiteral.getText() and\n    (\n      // Matches URLs with optional protocol and common TLDs\n      textContent.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + commonTldPattern() + \")(:[0-9]+)?/?\")\n      or\n      // Matches explicit HTTP/HTTPS URLs\n      textContent.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n    )\n  )\n}\n\n// Detects expressions performing incomplete URL substring sanitization\npredicate hasIncompleteSanitization(Expr sanitizationOperation, StringLiteral urlLiteral) {\n  hasUrlCharacteristics(urlLiteral) and\n  (\n    // Case 1: Substring containment check using 'in' operator\n    exists(Compare comparisonExpr |\n      comparisonExpr.compares(urlLiteral, any(In containmentOperator), _) and\n      sanitizationOperation = comparisonExpr\n    )\n    or\n    // Case 2: Unsafe startswith usage\n    exists(Call methodCall |\n      methodCall.getFunc().(Attribute).getName() = \"startswith\" and\n      methodCall.getArg(0) = urlLiteral and\n      not urlLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\") and\n      sanitizationOperation = methodCall\n    )\n    or\n    // Case 3: Unsafe endswith usage\n    exists(Call methodCall |\n      methodCall.getFunc().(Attribute).getName() = \"endswith\" and\n      methodCall.getArg(0) = urlLiteral and\n      not urlLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\") and\n      sanitizationOperation = methodCall\n    )\n  )\n}\n\n// Find expressions exhibiting incomplete URL substring sanitization patterns\nfrom Expr sanitizationOperation, StringLiteral urlLiteral\nwhere hasIncompleteSanitization(sanitizationOperation, urlLiteral)\nselect sanitizationOperation, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlLiteral,\n  urlLiteral.getText()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/functions-and-methods-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes the number of functions and methods in each Python file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Functions and methods per file\n * @description Computes the number of functions and methods in each Python file.\n * @kind treemap\n * @id py/functions-and-methods-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python // Import Python module for code structure analysis\n\n// For each Python module, calculate the number of contained functions\nfrom Module file, int methodCount\n// Count all non-lambda functions that belong to the module\nwhere methodCount = count(Function method | \n       method.getEnclosingModule() = file and \n       method.getName() != \"lambda\")\n// Display the module and its function count, sorted by count in descending order\nselect file, methodCount order by methodCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Navigate to Definitions\n * @description Helper query for navigating from expression usage to corresponding definition locations in Python code.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import the essential Python library for performing static analysis on Python source code\nimport python\n\n// Import the definition tracking functionality to trace variables, functions, and class definitions\nimport analysis.DefinitionTracking\n\n// Select expressions with detailed location information, their resolved definitions, and definition categories\nfrom NiceLocationExpr usageExpr, Definition resolvedDefinition, string defCategory\n// Filter to ensure that the resolved definition correctly matches the usage expression\n// and verify type compatibility between the usage and its definition\nwhere \n  resolvedDefinition = definitionOf(usageExpr, defCategory)\n// Return the usage location, definition location, and definition category to enable navigation\nselect usageExpr, resolvedDefinition, defCategory",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Vulnerable Elliptic Curve Cryptography\n * @description Detects the implementation of elliptic curve cryptographic algorithms that are either\n *              unrecognized or classified as weak, which may lead to security vulnerabilities.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm ellipticCurveImpl, string securityAlert, string curveIdentifier\nwhere\n  // Extract the curve name from the elliptic curve implementation\n  curveIdentifier = ellipticCurveImpl.getCurveName() and\n  (\n    // Case 1: Unrecognized algorithm\n    curveIdentifier = unknownAlgorithm() and\n    securityAlert = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: Recognized but weak algorithm\n    curveIdentifier != unknownAlgorithm() and\n    not curveIdentifier in\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curve\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    securityAlert = \"Use of weak curve algorithm \" + curveIdentifier + \".\"\n  )\nselect ellipticCurveImpl, securityAlert",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/direct-imports-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the count of modules directly imported by each Python file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Direct imports per file\n * @description Measures the count of modules directly imported by each Python file.\n * @kind treemap\n * @id py/direct-imports-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg max\n * @tags modularity\n *       maintainability\n */\n\n// Import the Python analysis framework for AST traversal and module analysis\nimport python\n\n// For each Python module, calculate its direct import count\nfrom ModuleValue analyzedModule, int importCount\nwhere \n  // Compute the number of unique modules directly imported by the analyzed module\n  importCount = count(ModuleValue importedModule | \n                    importedModule = analyzedModule.getAnImportedModule())\n// Output the file scope along with its corresponding direct import count\nselect analyzedModule.getScope(), importCount"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cryptographic operations utilizing elliptic curve algorithms that are either",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Detects cryptographic operations utilizing elliptic curve algorithms that are either\n *              not recognized or deemed cryptographically insecure, which may introduce security risks.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm ellipticCurveOp, string alertMessage, string curveIdentifier\nwhere\n  // Retrieve the elliptic curve identifier from the cryptographic operation\n  curveIdentifier = ellipticCurveOp.getCurveName() and\n  (\n    // Scenario 1: The curve algorithm is not recognized\n    curveIdentifier = unknownAlgorithm() and\n    alertMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Scenario 2: The curve algorithm is recognized but considered weak\n    curveIdentifier != unknownAlgorithm() and\n    not curveIdentifier =\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n    alertMessage = \"Use of weak curve algorithm \" + curveIdentifier + \".\"\n  )\nselect ellipticCurveOp, alertMessage"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during tarball extraction from user-controlled source\n * @description Identifies unsafe tar extraction operations lacking proper path validation \n *              against target directories, enabling potential overwrites outside the \n *              intended extraction scope. This vulnerability occurs when tar archives \n *              originate from user-influenced sources (network resources or CLI arguments).\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// Define source and sink nodes for the vulnerability path\nfrom UnsafeUnpackFlow::PathNode attackerControlledSource, \n     UnsafeUnpackFlow::PathNode vulnerableExtractionPoint\n// Trace data flow from attacker-controlled origin to unsafe extraction\n_______________ // 补全条件\n// Report vulnerable extraction location with full flow context\nselect vulnerableExtractionPoint.getNode(), \n       attackerControlledSource, \n       vulnerableExtractionPoint,\n       \"Dangerous extraction of tarball from attacker-controlled source without path validation\"",
    "output": "where UnsafeUnpackFlow::flowPath(attackerControlledSource, vulnerableExtractionPoint)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent method resolution order\n * @description Identifies class definitions that are prone to runtime type errors caused by an inconsistent method resolution order (MRO) in their inheritance hierarchy\n_______________ // 补全条件\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n// Identifies classes with inheritance hierarchies violating MRO consistency rules\n// by detecting problematic base class ordering that would cause runtime failures\npredicate has_mro_violation(ClassObject targetClass, ClassObject firstBase, ClassObject secondBase) {\n  // Restrict analysis to new-style classes (Python 3+ model)\n  targetClass.isNewStyle() and\n  // Locate consecutive base classes in the inheritance hierarchy\n  exists(int basePosition | \n    basePosition > 0 and \n    // secondBase immediately follows firstBase in base class declaration\n    secondBase = targetClass.getBaseType(basePosition) and \n    firstBase = targetClass.getBaseType(basePosition - 1)\n  ) and\n  // Verify MRO violation: firstBase must be an improper supertype of secondBase\n  firstBase = secondBase.getAnImproperSuperType()\n}\n\n// Query execution: Find all classes with MRO violations and generate diagnostic reports\nfrom ClassObject targetClass, ClassObject firstBase, ClassObject secondBase\nwhere has_mro_violation(targetClass, firstBase, secondBase)\nselect targetClass,\n  \"Construction of class \" + targetClass.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", firstBase,\n  firstBase.getName(), secondBase, secondBase.getName()",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Redundant assignment\n * @description Assigning a variable to itself is useless and very likely indicates an error in the code.\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-563\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-assignment\n */\n\nimport python\n\n// 定义一个谓词，用于判断是否为赋值语句，并且左值和右值分别为指定表达式。\npredicate assignment(AssignStmt a, Expr left, Expr right) {\n  a.getATarget() = left and a.getValue() = right\n}\n\n// 定义一个谓词，用于判断两个表达式是否对应。\npredicate corresponding(Expr left, Expr right) {\n  assignment(_, left, right) // 如果存在一个赋值语句，使得左值和右值为给定的表达式。\n  or\n  exists(Attribute la, Attribute ra |\n    corresponding(la, ra) and // 如果存在对应的属性。\n    left = la.getObject() and // 并且左表达式是该属性的对象。\n    right = ra.getObject() // 并且右表达式是另一个属性的对象。\n  )\n}\n\n// 定义一个谓词，用于判断两个表达式是否具有相同的值。\npredicate same_value(Expr left, Expr right) {\n  same_name(left, right) // 如果两个表达式具有相同的名称。\n  or\n  same_attribute(left, right) // 或者两个表达式具有相同的属性。\n}\n\n// 定义一个谓词，用于判断某个名称是否可能在外部作用域中未定义。\n_______________ // 补全条件\n  exists(SsaVariable v | v.getAUse().getNode() = n | v.maybeUndefined()) // 如果存在一个变量使用点，其节点为给定名称，并且可能未定义。\n}\n\n/*\n * Protection against FPs in projects that offer compatibility between Python 2 and 3,\n * since many of them make assignments such as\n *\n * if PY2:\n *     bytes = str\n * else:\n *     bytes = bytes\n */\n\n// 定义一个谓词，用于判断一个字符串是否为内建对象的名称。\npredicate isBuiltin(string name) { exists(Value v | v = Value::named(name) and v.isBuiltin()) }\n\n// 定义一个谓词，用于判断两个名称是否相同。\npredicate same_name(Name n1, Name n2) {\n  corresponding(n1, n2) and // 如果两个名称对应。\n  n1.getVariable() = n2.getVariable() and // 并且它们指向同一个变量。\n  not isBuiltin(n1.getId()) and // 并且第一个名称不是内建对象的名称。\n  not maybe_defined_in_outer_scope(n2) // 并且第二个名称不可能在外部作用域中未定义。\n}\n\n// 定义一个类值，用于获取属性对象的类型。\nClassValue value_type(Attribute a) { a.getObject().pointsTo().getClass() = result }\n\n// 定义一个谓词，用于判断一个属性是否为属性访问。\npredicate is_property_access(Attribute a) {\n  value_type(a).lookup(a.getName()) instanceof PropertyValue // 如果属性的类型查找结果是一个属性值实例。\n}\n\n// 定义一个谓词，用于判断两个属性是否相同。\npredicate same_attribute(Attribute a1, Attribute a2) {\n  corresponding(a1, a2) and // 如果两个属性对应。\n  a1.getName() = a2.getName() and // 并且它们的名称相同。\n  same_value(a1.getObject(), a2.getObject()) and // 并且它们的值相同。\n  exists(value_type(a1)) and // 并且第一个属性有类型值。\n  not is_property_access(a1) // 并且第一个属性不是属性访问。\n}\n\n// 定义一个pragma，用于防止魔法注释影响分析结果。\npragma[nomagic]\nComment pyflakes_comment() { result.getText().toLowerCase().matches(\"%pyflakes%\") } // 如果注释文本包含\"pyflakes\"（不区分大小写）。\n\n// 定义一个整数函数，用于获取文件中包含Pyflakes注释的行号。\nint pyflakes_commented_line(File file) {\n  pyflakes_comment().getLocation().hasLocationInfo(file.getAbsolutePath(), result, _, _, _) // 如果Pyflakes注释的位置信息与文件路径匹配，则返回行号。\n}\n\n// 定义一个谓词，用于判断一个赋值语句是否被Pyflakes注释标记。\npredicate pyflakes_commented(AssignStmt assignment) {\n  exists(Location loc |\n    assignment.getLocation() = loc and // 如果赋值语句的位置与位置变量匹配。\n    loc.getStartLine() = pyflakes_commented_line(loc.getFile()) // 并且位置变量的起始行号是Pyflakes注释的行号。\n  )\n}\n\n// 定义一个谓词，用于判断左侧表达式是否有副作用。\npredicate side_effecting_lhs(Attribute lhs) {\n  exists(ClassValue cls, ClassValue decl |\n    lhs.getObject().pointsTo().getClass() = cls and // 如果左侧表达式对象的类型是某个类。\n    decl = cls.getASuperType() and // 并且该类的某个超类型声明了__setattr__属性。\n    not decl.isBuiltin() // 并且该超类型不是内建类型。\n  |\n    decl.declaresAttribute(\"__setattr__\") // 或者该超类型声明了__setattr__属性。\n  )\n}\n\n// 查询语句：查找所有自赋值且没有Pyflakes注释且左侧表达式没有副作用的赋值语句。\nfrom AssignStmt a, Expr left, Expr right\nwhere\n  assignment(a, left, right) and // 如果是一个赋值语句。\n  same_value(left, right) and // 并且左右值相同。\n  not pyflakes_commented(a) and // 并且没有被Pyflakes注释标记。\n  not side_effecting_lhs(left) // 并且左侧表达式没有副作用。\nselect a, \"This assignment assigns a variable to itself.\" // 选择这些赋值语句，并报告“此赋值将变量赋值给自身”。",
    "output": "predicate maybe_defined_in_outer_scope(Name n) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Arbitrary file write during a tarball extraction from a user controlled source\n * @description 检测从用户控制的源提取tar文件时，未验证目标路径是否在目标目录内的漏洞。\n *             这种漏洞可能导致目录遍历攻击，特别是当tar文件来自不受信任的位置时。\n * @kind path-problem\n_______________ // 补全条件\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// 查找不安全的解包操作：从不信任的源到危险解包操作的数据流\nfrom UnsafeUnpackFlow::PathNode untrustedInput, UnsafeUnpackFlow::PathNode unsafeExtraction\nwhere UnsafeUnpackFlow::flowPath(untrustedInput, unsafeExtraction)\n// 输出漏洞位置、数据流起点和终点，并生成安全警告\nselect unsafeExtraction.getNode(), untrustedInput, unsafeExtraction,\n  \"危险解包操作：从不信任的远程位置获取的恶意tar文件可能导致目录遍历攻击\"",
    "output": "* @id py/unsafe-unpacking"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：使用 super() 访问继承的方法在旧式类中是不被支持的。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description 使用 super() 访问继承的方法在旧式类中是不被支持的。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * 识别在旧式类中使用 super() 的调用点\n * 当一个方法内部调用了 super()，且该方法属于一个旧式类时，\n * 此谓词会识别出这样的调用点。\n */\npredicate superCallInOldClass(Call superInvocation) {\n  exists(Function method, ClassObject cls |\n    // 调用点位于某个方法内\n    superInvocation.getScope() = method and\n    // 该方法定义在某个类中\n    method.getScope() = cls.getPyClass() and\n    // 确保类的类型推断没有失败\n    not cls.failedInference() and\n    // 确认这是一个旧式类\n    not cls.isNewStyle() and\n    // 确认调用的是 super 函数\n    superInvocation.getFunc().(Name).getId() = \"super\"\n  )\n}\n\n// 查找所有在旧式类中使用 super() 的调用点\nfrom Call superCall\n// 筛选出在旧式类中使用 super() 的调用点\nwhere superCallInOldClass(superCall)\n// 输出结果和错误信息\nselect superCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unhashable object hashed\n * @description Detects unhashable objects being hashed or used as dictionary keys,\n *              which will raise TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/hash-unhashable-value\n */\n\nimport python\n\n/*\n * Core logic: Objects are considered hashable if they have a valid __hash__ method.\n * Special cases:\n * - Sequences and numpy arrays are handled separately as they may allow non-hashable indices\n * - Try-except blocks catching TypeError are excluded to avoid false positives\n */\n\n// Identifies values with custom __getitem__ implementation (including numpy arrays)\npredicate hasCustomGetitem(Value value) {\n  // Check for custom __getitem__ method\n  value.getClass().lookup(\"__getitem__\") instanceof PythonFunctionValue\n  or\n  // Handle numpy array special case\n  exists(ModuleValue numpyModule | \n    numpyModule.getName() = \"numpy\" or numpyModule.getName() = \"numpy.core\" |\n    value.getClass().getASuperType() = numpyModule.attr(\"ndarray\")\n  )\n}\n\n// Detects explicit hash() calls on control flow nodes\npredicate isExplicitlyHashed(ControlFlowNode node) {\n  exists(CallNode hashCall, GlobalVariable hashGlobal |\n    hashCall.getArg(0) = node and \n    hashCall.getFunction().(NameNode).uses(hashGlobal) and \n    hashGlobal.getId() = \"hash\"\n  )\n}\n\n// Checks if a value belongs to an unhashable class (missing __hash__ or __hash__=None)\npredicate isUnhashableValue(ControlFlowNode node, ClassValue unhashableType, ControlFlowNode originNode) {\n  exists(Value value | \n    node.pointsTo(value, originNode) and \n    value.getClass() = unhashableType |\n    // Case 1: Class lacks __hash__ method\n    (not unhashableType.hasAttribute(\"__hash__\") and \n     not unhashableType.failedInference(_) and \n     unhashableType.isNewStyle())\n    or\n    // Case 2: Class explicitly sets __hash__ to None\n_______________ // 补全条件\n  )\n}\n\n// Identifies unhashable indices in subscript operations without custom __getitem__\npredicate hasUnhashableSubscript(ControlFlowNode indexExpr, ClassValue unhashableType, ControlFlowNode originNode) {\n  isUnhashableValue(indexExpr, unhashableType, originNode) and\n  exists(SubscriptNode subscript | subscript.getIndex() = indexExpr |\n    exists(Value container |\n      subscript.getObject().pointsTo(container) and\n      not hasCustomGetitem(container)\n    )\n  )\n}\n\n/**\n * Determines if a node is inside a try block that catches TypeError.\n * Used to eliminate false positives where TypeError is intentionally handled.\n */\npredicate typeErrorIsHandled(ControlFlowNode node) {\n  exists(Try tryBlock |\n    tryBlock.getBody().contains(node.getNode()) and\n    tryBlock.getAHandler().getType().pointsTo(ClassValue::typeError())\n  )\n}\n\n// Main query: Find unhandled unhashable operations\nfrom ControlFlowNode node, ClassValue unhashableType, ControlFlowNode originNode\nwhere\n  not typeErrorIsHandled(node) and\n  (\n    // Case 1: Explicit hash() call on unhashable value\n    isExplicitlyHashed(node) and isUnhashableValue(node, unhashableType, originNode)\n    or\n    // Case 2: Unhashable value used as subscript index\n    hasUnhashableSubscript(node, unhashableType, originNode)\n  )\nselect node.getNode(), \"This $@ of $@ is unhashable.\", originNode, \"instance\", unhashableType, unhashableType.getQualifiedName()",
    "output": "unhashableType.lookup(\"__hash__\") = Value::named(\"None\")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Detects mutations within descriptor protocol methods that can cause shared state issues.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Identifies descriptor classes containing mutation operations in protocol methods\npredicate has_descriptor_mutation(ClassObject descriptorClass, SelfAttributeStore mutationOperation) {\n  // Verify class implements descriptor protocol\n  descriptorClass.isDescriptorType() and\n  // Find descriptor protocol methods (__get__/__set__/__delete__)\n  exists(PyFunctionObject protocolMethod, string methodName |\n    descriptorClass.lookupAttribute(methodName) = protocolMethod and\n    (methodName = \"__get__\" or methodName = \"__set__\" or methodName = \"__delete__\") and\n    // Locate methods invoked by descriptor protocol methods\n    exists(PyFunctionObject invokedMethod |\n      // Invoked method belongs to the same descriptor class\n      descriptorClass.lookupAttribute(_) = invokedMethod and\n      // Trace call chain from protocol method to invoked method\n      protocolMethod.getACallee*() = invokedMethod and\n      // Exclude initialization methods from analysis\n      not invokedMethod.getName() = \"__init__\" and\n      // Mutation occurs within the invoked method's scope\n      mutationOperation.getScope() = invokedMethod.getFunction()\n    )\n  )\n}\n\n// Identify descriptor classes and their mutation operations\nfrom ClassObject descriptorClass, SelfAttributeStore mutationOperation\nwhere has_descriptor_mutation(descriptorClass, mutationOperation)\n_______________ // 补全条件\nselect mutationOperation,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorClass, descriptorClass.getName()",
    "output": "// Output mutation location with warning message and class details"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/summary/lines-of-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：提供数据库中所有Python文件的代码行总数统计，包括外部库和自动生成的文件。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Total lines of Python code in the database\n * @description 提供数据库中所有Python文件的代码行总数统计，包括外部库和自动生成的文件。\n *   此指标用于评估代码库的整体规模。统计仅计算有效代码行，不包括空白行和注释。\n * @kind metric\n * @tags summary\n *       telemetry\n * @id py/summary/lines-of-code\n */\n\nimport python // 引入Python分析模块，用于处理Python代码库的度量分析\n\n// 遍历数据库中的每个Python模块，并累加其有效代码行数\n// 此查询旨在提供代码库规模的整体视图，通过统计所有模块的非注释、非空白代码行\nfrom Module sourceFile\nselect sum(sourceFile.getMetrics().getNumberOfLinesOfCode())"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Block cipher mode detection\n * @description Identifies all instances of block cipher modes of operation \n *              across supported cryptographic libraries in Python codebases\n_______________ // 补全条件\n * @id py/quantum-readiness/cbom/block-cipher-mode\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Core Python language support for code analysis\nimport python\n\n// Cryptographic concepts library for operation detection\nimport experimental.cryptography.Concepts\n\n// Source of block cipher mode instances\nfrom BlockMode blockCipherMode\n\n// Result projection with algorithm identification\nselect blockCipherMode, \n       \"Algorithm in use: \" + blockCipherMode.getBlockModeName()",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Detects cryptographic implementations utilizing elliptic curve algorithms\n *              that are either unapproved or considered cryptographically weak, which\n *              may introduce security vulnerabilities.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm curveImpl, string alertMessage, string curveIdentifier\nwhere\n  // Define the collection of cryptographically secure elliptic curves\n  exists(string approvedCurve |\n    approvedCurve = [\n      \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n      \"SECP384R1\",              // P-384 curve\n      \"SECP521R1\",              // P-521 curve\n      \"ED25519\",                // Ed25519 curve\n      \"X25519\"                  // X25519 curve\n    ]\n  |\n    // Extract the curve identifier from the elliptic curve implementation\n    curveIdentifier = curveImpl.getCurveName() and\n    (\n      // Case 1: Detection of an unrecognized curve algorithm\n      curveIdentifier = unknownAlgorithm() and\n_______________ // 补全条件\n      or\n      // Case 2: Detection of a recognized but cryptographically weak curve algorithm\n      curveIdentifier != unknownAlgorithm() and\n      not curveIdentifier = approvedCurve and\n      alertMessage = \"Use of weak curve algorithm \" + curveIdentifier + \".\"\n    )\n  )\nselect curveImpl, alertMessage",
    "output": "alertMessage = \"Use of unrecognized curve algorithm.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/block-cipher-mode]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all instances of block cipher modes used in supported cryptographic libraries.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Block cipher mode of operation\n * @description Identifies all instances of block cipher modes used in supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/block-cipher-mode\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n/* Import necessary Python language support for code analysis */\nimport python\n\n/* Import experimental cryptography concepts for cryptographic operation analysis */\nimport experimental.cryptography.Concepts\n\n/* Define source of block cipher modes and prepare reporting */\nfrom BlockMode blockCipherMode\n\n/* Generate alert for each detected block cipher mode with algorithm name */\nselect blockCipherMode, \"Use of algorithm \" + blockCipherMode.getBlockModeName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Ambiguous backspace escape in regex character set\n * @description Identifies usage of '\\b' inside character sets which creates confusion\n *              due to conflict with the common word boundary assertion interpretation.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\n_______________ // 补全条件\nwhere\n  // Determine if the escape sequence is within a character set context\n  exists(int charSetBegin, int charSetFinish |\n    charSetBegin < escapeLocation and \n    charSetFinish > escapeLocation and\n    regexPattern.charSet(charSetBegin, charSetFinish)\n  ) and\n  // Check for an escape character at the specified location\n  regexPattern.escapingChar(escapeLocation) and\n  // Verify that 'b' character follows the escape character\n  regexPattern.getChar(escapeLocation + 1) = \"b\"\nselect regexPattern, \"Ambiguous backspace escape in character set at offset \" + escapeLocation + \".\"",
    "output": "from RegExp regexPattern, int escapeLocation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commented-out-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code segments that developers have commented out, which can reduce code readability and hinder long-term maintenance.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Commented-out code\n * @description Identifies code segments that developers have commented out, which can reduce code readability and hinder long-term maintenance.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code */\n\n// Import the Python language analysis library\nimport python\n\n// Import the CommentedOutCode class from Lexical module for detecting commented code\nimport Lexical.CommentedOutCode\n\n// Query to locate problematic commented code blocks\nfrom CommentedOutCodeBlock commentedBlock\n// Exclude blocks that could be example code or documentation\nwhere not commentedBlock.maybeExampleCode()\n// Report the identified commented code blocks with a warning message\nselect commentedBlock, \"This comment appears to contain commented-out code.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commit-display-strings]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Display strings of commits",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Display strings of commits\n * @kind display-string\n * @id py/commit-display-strings\n * @metricType commit\n */\n\nimport python  // 导入Python语言分析模块，支持Python代码的静态语义分析\nimport external.VCS  // 导入外部版本控制系统模块，提供版本控制历史和提交记录的访问接口\n\n// 查询范围：从版本控制系统中提取所有提交记录\nfrom Commit commitEntry\n\n// 输出格式：提交修订ID和格式化的提交信息（含日期）\nselect \n    commitEntry.getRevisionName(), \n    commitEntry.getMessage() + \"(\" + commitEntry.getDate().toString() + \")\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Analysis of incoming class dependencies\n * @description This query calculates the afferent coupling for each class,\n *              which represents the number of other classes that depend on it.\n *              Higher values indicate classes that are more central to the codebase.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n_______________ // 补全条件\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// Identify classes and compute their incoming dependency count\n// Afferent coupling measures how many other classes depend on a given class\nfrom ClassMetrics subjectClass, int inboundCoupling\nwhere \n  // Calculate the afferent coupling (incoming dependencies) for the class\n  inboundCoupling = subjectClass.getAfferentCoupling() and \n  // Ensure the coupling count exists (non-null and valid)\n  exists(inboundCoupling)\nselect subjectClass, \n       inboundCoupling as dependencyCount \norder by dependencyCount desc",
    "output": "* @metricType reftype"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/asymmetric-padding-schemes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query identifies all occurrences of padding schemes used in asymmetric cryptographic algorithms.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Asymmetric Encryption Padding Schemes Detection\n * @description This query identifies all occurrences of padding schemes used in asymmetric cryptographic algorithms.\n * @kind problem\n * @id py/quantum-readiness/cbom/asymmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// 导入必要的库\nimport python  // 用于Python代码分析\nimport experimental.cryptography.Concepts  // 提供加密相关概念支持\n\n// 查询并输出所有非对称加密填充方案\nfrom AsymmetricPadding asymmetricPadding\nselect asymmetricPadding, \"Detected asymmetric padding scheme: \" + asymmetricPadding.getPaddingName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unused-loop-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A loop iteration variable is unused, which suggests an error.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Suspicious unused loop iteration variable\n * @description A loop iteration variable is unused, which suggests an error.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/unused-loop-variable\n */\n\nimport python\n\n/**\n * Determines if the given statement is a variable increment operation, such as x += n or x = x + n\n * @param statement The statement to be checked\n */\npredicate is_increment_operation(Stmt statement) {\n  /* Check for increment operations in the form x += n */\n  statement.(AugAssign).getValue() instanceof IntegerLiteral\n  or\n  /* Check for increment operations in the form x = x + n */\n  exists(Name targetVariable, BinaryExpr additionExpr |\n    targetVariable = statement.(AssignStmt).getTarget(0) and\n    additionExpr = statement.(AssignStmt).getValue() and\n    additionExpr.getLeft().(Name).getVariable() = targetVariable.getVariable() and\n    additionExpr.getRight() instanceof IntegerLiteral\n  )\n}\n\n/**\n * Determines if the given for loop is a counting loop, where the iteration variable increments each time\n * @param loop The for loop to be checked\n */\npredicate is_counting_loop(For loop) { \n  is_increment_operation(loop.getAStmt()) \n}\n\n/**\n * Determines if the given for loop is an empty loop, i.e., the loop body only contains a Pass statement\n * @param loop The for loop to be checked\n */\npredicate is_empty_loop(For loop) { \n  not exists(loop.getStmt(1)) and \n  loop.getStmt(0) instanceof Pass \n}\n\n/**\n * Determines if the given for loop only contains a return or break statement\n * @param loop The for loop to be checked\n */\npredicate has_single_exit_statement(For loop) {\n  not exists(Continue continueStmt | loop.contains(continueStmt)) and\n  exists(Stmt finalStatement | finalStatement = loop.getBody().getLastItem() |\n    finalStatement instanceof Return\n    or\n    finalStatement instanceof Break\n  )\n}\n\n/**\n * Determines if a control flow node points to a call to range or xrange\n * @param node The control flow node to be checked\n */\npredicate is_range_function_call(ControlFlowNode node) {\n  /* Handle range/xrange function calls in Python 2/3 */\n  exists(Value rangeFunction |\n    rangeFunction = Value::named(\"range\") or\n    rangeFunction = Value::named(\"xrange\")\n  |\n    node = rangeFunction.getACall()\n  )\n  or\n  /* Handle direct calls using range/xrange names */\n  exists(string functionName | node.getNode().(Call).getFunc().(Name).getId() = functionName |\n    functionName = \"range\" or functionName = \"xrange\"\n  )\n  or\n  /* Handle nested calls, such as list(range(...)) */\n  node.(CallNode).pointsTo().getClass() = ClassValue::list() and\n  is_range_function_call(node.(CallNode).getArg(0))\n}\n\n/**\n * Determines if a name node uses a non-constant variable\n * @param nameNode The name node to be checked\n */\npredicate uses_non_constant_variable(Name nameNode) {\n  exists(Variable variable |\n    nameNode.uses(variable) and\n    /* Ensure the usage is local */\n    not nameNode.getScope() instanceof Module and\n    /* Ensure the variable is not global */\n    not variable.getScope() instanceof Module\n  |\n    /* The variable is defined multiple times (dynamic) */\n    strictcount(Name definition | definition.defines(variable)) > 1\n    or\n    /* The variable is defined in a for loop */\n    exists(For loop, Name definition | loop.contains(definition) and definition.defines(variable))\n    or\n    /* The variable is defined in a while loop */\n    exists(While loop, Name definition | loop.contains(definition) and definition.defines(variable))\n  )\n}\n\n/**\n * Determines if a loop body implicitly repeats some operation N times\n * For example: queue.add(None)\n * @param loop The for loop to be checked\n */\npredicate is_implicit_repetition(For loop) {\n  /* The loop body has only one statement */\n  not exists(loop.getStmt(1)) and\n  /* That statement contains an immutable literal */\n  exists(ImmutableLiteral literal | loop.getStmt(0).contains(literal)) and\n  /* Does not contain names that use non-constant variables */\n  not exists(Name varName | loop.getBody().contains(varName) and uses_non_constant_variable(varName))\n}\n\n/**\n * Gets the control flow graph node related to the iterable in a comprehension\n * The for statement `comprehensionFor` is an artificial for statement in a comprehension\n * The result is the iterable in that comprehension\n * For example: from `{ y for y in x }` get `x`\n * @param comprehensionFor The for statement in the comprehension\n * @return The control flow node of the iterable\n */\nControlFlowNode get_comprehension_iterable(For comprehensionFor) {\n  exists(Comp comprehensionExpr | \n    comprehensionExpr.getFunction().getStmt(0) = comprehensionFor | \n    comprehensionExpr.getAFlowNode().getAPredecessor() = result\n  )\n}\n\n/**\n * Determines if a variable name is suitable for an unused variable (starts with an underscore)\n * @param variable The variable to be checked\n */\npredicate name_acceptable_for_unused_variable(Variable variable) {\n  exists(string varName | varName = variable.getId() and varName.matches(\"_%\"))\n}\n\n/**\n * Finds unused loop iteration variables and generates corresponding warning messages\n */\nfrom For loop, Variable iterationVariable, string warningMessage\nwhere\n  /* The loop target variable is iterationVariable */\n  loop.getTarget() = iterationVariable.getAnAccess() and\n  /* The loop increment statement does not contain iterationVariable */\n  not loop.getAStmt().contains(iterationVariable.getAnAccess()) and\n  /* The loop iterator is not a call to range or xrange */\n  not is_range_function_call(loop.getIter().getAFlowNode()) and\n  /* The iterator in comprehensions is also not a call to range or xrange */\n  not is_range_function_call(get_comprehension_iterable(loop)) and\n  /* The name of iterationVariable is not suitable for an unused variable */\n  not name_acceptable_for_unused_variable(iterationVariable) and\n  /* Not in a generator expression */\n  not loop.getScope().getName() = \"genexpr\" and\n  /* Not an empty loop */\n  not is_empty_loop(loop) and\n  /* Does not only contain a return or break statement */\n  not has_single_exit_statement(loop) and\n  /* Not a counting loop */\n  not is_counting_loop(loop) and\n  /* Not an implicit repetition operation */\n  not is_implicit_repetition(loop) and\n  /* Set different warning messages based on whether the variable is deleted in the loop body */\n  if exists(Name deletionNode | deletionNode.deletes(iterationVariable) and loop.getAStmt().contains(deletionNode))\n  then warningMessage = \"' is deleted, but not used, in the loop body.\"\n  else warningMessage = \"' is not used in the loop body.\"\nselect loop, \"For loop variable '\" + iterationVariable.getId() + warningMessage"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Misleading super() first parameter\n * @description Detects super() calls where the first argument does not match\n *              the containing class name, which can lead to incorrect initialization\n *              in class inheritance hierarchies.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-687\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/super-not-enclosing-class\n */\n_______________ // 补全条件\nimport python  // 导入Python库，用于分析Python代码\nimport semmle.python.dataflow.new.DataFlow  // 导入数据流分析模块\nimport semmle.python.ApiGraphs  // 导入API图模块\n\n// 定义查询的输入变量：super()调用节点和包含类的名称\nfrom DataFlow::CallCfgNode superInvocation, string containerClassName\nwhere\n  // 确保节点是对super内置函数的调用\n  superInvocation = API::builtin(\"super\").getACall() and\n  // 获取当前类作用域的名称作为包含类名\n  containerClassName = superInvocation.getScope().getScope().(Class).getName() and\n  // 检查第一个参数存在且与包含类名不匹配\n  exists(DataFlow::Node initialParameter |\n    initialParameter = superInvocation.getArg(0) and\n    // 比较第一个参数的标识符与包含类名\n    initialParameter.getALocalSource().asExpr().(Name).getId() != containerClassName\n  )\n// 选择问题节点并生成报告消息\nselect superInvocation.getNode(), \"First argument to super() should be \" + containerClassName + \".\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class Cohesion Deficiency (HM Method)\n * @description Evaluates the deficiency of class cohesion using Hitz and Montazeri's methodology.\n * @kind treemap\n * @id py/lack-of-cohesion-hitz-montazeri\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n */\n\nimport python  // Required Python module for performing class cohesion analysis\n\n// This query analyzes Python classes to identify cohesion deficiencies\n// The results prioritize classes with the most severe cohesion issues\n_______________ // 补全条件\nselect \n    clsInfo, \n    clsInfo.getLackOfCohesionHM() as cohesionValue \norder by \n    cohesionValue desc",
    "output": "from ClassMetrics clsInfo"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/useless-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers that specify non-exception types,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-exception in 'except' clause\n * @description Identifies exception handlers that specify non-exception types,\n *              which are ineffective at runtime as they never match actual exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Variables for analyzing ineffective exception handling constructs\nfrom ExceptFlowNode exceptNode, Value caughtType, ClassValue exceptionBaseClass, \n     ControlFlowNode exceptionOrigin, string invalidTypeDesc\nwhere\n  // Verify the handler processes a specific exception type from the source\n  exceptNode.handledException(caughtType, exceptionBaseClass, exceptionOrigin) and\n  (\n    // Case 1: Type is a class but not a valid exception\n    exists(ClassValue nonExceptionClass | \n      nonExceptionClass = caughtType and\n      not nonExceptionClass.isLegalExceptionType() and\n      not nonExceptionClass.failedInference(_) and\n      invalidTypeDesc = \"class '\" + nonExceptionClass.getName() + \"'\"\n    )\n    or\n    // Case 2: Type is not a class value\n    not caughtType instanceof ClassValue and\n    invalidTypeDesc = \"instance of '\" + exceptionBaseClass.getName() + \"'\"\n  )\nselect exceptNode.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  exceptionOrigin, invalidTypeDesc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Accepting unknown SSH host keys when using Paramiko\n * @description Detects configurations where Paramiko accepts unknown host keys,\n *              which could enable man-in-the-middle attacks.\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/paramiko-missing-host-key-validation\n * @tags security\n *       external/cwe/cwe-295\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// 获取接受未知主机密钥的不安全Paramiko策略类节点\nprivate API::Node getInsecurePolicyNode(string policyName) {\n  policyName in [\"AutoAddPolicy\", \"WarningPolicy\"] and\n  (\n    result = API::moduleImport(\"paramiko\").getMember(\"client\").getMember(policyName)\n    or\n    result = API::moduleImport(\"paramiko\").getMember(policyName)\n  )\n}\n\n// 获取Paramiko SSHClient实例的构造节点\nprivate API::Node getSshClientConstructor() {\n  result = API::moduleImport(\"paramiko\").getMember(\"client\").getMember(\"SSHClient\").getReturn()\n  or\n  result = API::moduleImport(\"paramiko\").getMember(\"SSHClient\").getReturn()\n}\n\n// 检测不安全的主机密钥策略配置\nfrom DataFlow::CallCfgNode methodCall, string policyName, DataFlow::Node policyArg\nwhere\n  // 确认调用set_missing_host_key_policy方法\n  methodCall = getSshClientConstructor().getMember(\"set_missing_host_key_policy\").getACall() and\n  // 获取策略参数（位置参数或关键字参数）\n  (\n    policyArg = methodCall.getArg(0) \n    or \n    policyArg = methodCall.getArgByName(\"policy\")\n  ) and\n  // 策略名称为不安全类型\n  policyName in [\"AutoAddPolicy\", \"WarningPolicy\"] and\n_______________ // 补全条件\n  (\n    policyArg = getInsecurePolicyNode(policyName).getAValueReachableFromSource()\n    or\n    policyArg = getInsecurePolicyNode(policyName).getReturn().getAValueReachableFromSource()\n  )\nselect methodCall, \"Setting missing host key policy to \" + policyName + \" may be unsafe.\"",
    "output": "// 策略参数值来源于不安全策略节点"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Modification of dictionary returned by locals()\n * @description This query detects code that attempts to modify the dictionary returned by locals(). Such modifications do not affect the actual local variables, leading to potential misunderstandings.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/modification-of-locals\n */\n\nimport python\n\n// Identifies control flow nodes that refer to the return value of a locals() function call\npredicate referencesLocalsResult(ControlFlowNode cfgNode) { \n    cfgNode.pointsTo(_, _, Value::named(\"locals\").getACall()) \n}\n\n// Detects operations modifying the locals() dictionary through subscript access or method calls\npredicate modifiesLocalsDictionary(ControlFlowNode modificationNode) {\n    // Case 1: Dictionary subscript operations (assignment or deletion)\n    exists(SubscriptNode subscriptAccess |\n        subscriptAccess = modificationNode and\n        referencesLocalsResult(subscriptAccess.getObject()) and\n        (subscriptAccess.isStore() or subscriptAccess.isDelete())\n    )\n    or\n    // Case 2: Dictionary method calls that mutate content\n    exists(CallNode methodCall, AttrNode attributeRef, string mutatingMethod |\n        methodCall = modificationNode and\n_______________ // 补全条件\n        referencesLocalsResult(attributeRef.getObject(mutatingMethod)) and\n        mutatingMethod in [\"pop\", \"popitem\", \"update\", \"clear\"]\n    )\n}\n\nfrom AstNode astNode, ControlFlowNode dictAlterationNode\nwhere\n    // Identify operations modifying the locals() dictionary\n    modifiesLocalsDictionary(dictAlterationNode) and\n    // Map control flow node to corresponding AST node\n    astNode = dictAlterationNode.getNode() and\n    // Exclude module-level scope where locals() behaves like globals()\n    not astNode.getScope() instanceof ModuleScope\n// Output results with warning message\nselect astNode, \"Modification of the locals() dictionary will have no effect on the local variables.\"",
    "output": "attributeRef = methodCall.getFunction() and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Classify files\n * @description This query produces a list of all files in a snapshot\n *              that are classified as generated code or test code.\n * @kind file-classifier\n * @id py/file-classifier\n */\n\n// 导入python模块，用于处理Python代码的查询\nimport python\n// 导入GeneratedCode过滤器，用于识别生成的代码文件\nimport semmle.python.filters.GeneratedCode\n// 导入Tests过滤器，用于识别测试代码文件\nimport semmle.python.filters.Tests\n\n// 定义一个谓词函数classify，用于对文件进行分类\npredicate classify(File f, string tag) {\n  // 如果文件是生成的文件，则标记为\"generated\"\n  f instanceof GeneratedFile and tag = \"generated\"\n  // 或者如果文件属于某个测试范围，则标记为\"test\"\n  or\n  exists(TestScope t | t.getLocation().getFile() = f) and tag = \"test\"\n}\n\n_______________ // 补全条件\nfrom File f, string tag\nwhere classify(f, tag)\nselect f, tag",
    "output": "// 从所有文件和标签中选择符合条件的文件和标签"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "import python  // 导入Python分析库，提供Python代码解析和分析的基础功能\nimport semmle.python.pointsto.PointsTo  // 导入指向分析库，支持数据流和可达性分析\n\n// 计算程序中不可达基本块的总数\n// 不可达基本块是指在程序执行过程中永远不会被执行到的代码块\nfrom int unreachableBlockCount  // 声明整型变量，用于存储不可达基本块的数量\nwhere \n  // 计算所有不可达基本块的数量\n  unreachableBlockCount = count(ControlFlowNode node | \n    // 检查节点所属的基本块是否不可达\n_______________ // 补全条件\n  )\nselect unreachableBlockCount  // 返回不可达基本块的总数",
    "output": "not PointsToInternal::reachableBlock(node.getBasicBlock(), _)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/polluting-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Importing a module using 'import *' may unintentionally pollute the global",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' may pollute namespace\n * @description Importing a module using 'import *' may unintentionally pollute the global\n *              namespace if the module does not define `__all__`\n * @kind problem\n * @tags maintainability\n *       modularity\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/polluting-import\n */\n\n// 导入Python分析库\nimport python\n\n// 查询所有使用通配符导入且未定义__all__的模块\nfrom ImportStar wildcardImport, ModuleValue sourceModule\nwhere \n  // 验证导入模块与源模块名称匹配\n  sourceModule.importedAs(wildcardImport.getImportedModuleName())\n  and not (\n    // 排除已定义__all__的模块（包括内建模块）\n    sourceModule.isBuiltin()\n    or sourceModule.getScope().(ImportTimeScope).definesName(\"__all__\")\n    or sourceModule.getScope().getInitModule().(ImportTimeScope).definesName(\"__all__\")\n  )\n  // 确保源模块存在\n  and not sourceModule.isAbsent()\nselect wildcardImport,\n  \"Import pollutes the enclosing namespace, as the imported module $@ does not define '__all__'.\",\n  sourceModule, sourceModule.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/polluting-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies 'import *' statements that can cause namespace pollution",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' may pollute namespace\n * @description Identifies 'import *' statements that can cause namespace pollution\n *              when the imported module doesn't define '__all__' attribute\n * @kind problem\n * @tags maintainability\n *       modularity\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/polluting-import\n */\n\n// Import Python analysis library for code examination\nimport python\n\n// Checks if a module properly defines '__all__' attribute\npredicate moduleDefinesAllAttribute(ModuleValue modVal) {\n  // Built-in modules are considered safe\n  modVal.isBuiltin()\n  or\n  // Check '__all__' definition in module scope\n  modVal.getScope().(ImportTimeScope).definesName(\"__all__\")\n  or\n  // Check '__all__' definition in module initialization\n  modVal.getScope().getInitModule().(ImportTimeScope).definesName(\"__all__\")\n}\n\n// Identifies star import statements and their corresponding source modules\npredicate locateStarImport(ImportStar starImp, ModuleValue srcMod) {\n  // Verify module name matches the imported name\n  srcMod.importedAs(starImp.getImportedModuleName())\n}\n\n// Main query to detect namespace-polluting imports\nfrom ImportStar starImp, ModuleValue srcMod\nwhere \n  locateStarImport(starImp, srcMod) and\n  not moduleDefinesAllAttribute(srcMod) and\n  not srcMod.isAbsent()\nselect starImp,\n  \"Import pollutes the enclosing namespace, as the imported module $@ does not define '__all__'.\",\n  srcMod, srcMod.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert Suppression Information\n * @description Provides details about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import CodeQL alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing module\nprivate import semmle.python.Comment as P\n\n// Represents AST nodes with location tracking\nclass AstNode instanceof P::AstNode {\n  // Check if node matches specified location coordinates\n  predicate hasLocationInfo(\n    string filePath, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, beginLine, beginCol, endLine, endCol)\n  }\n\n  // Return string representation of the node\n  string toString() { result = super.toString() }\n}\n\n// Represents single-line comments with location tracking\nclass SingleLineComment instanceof P::Comment {\n  // Check if comment matches specified location coordinates\n  predicate hasLocationInfo(\n    string filePath, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, beginLine, beginCol, endLine, endCol)\n  }\n\n  // Retrieve comment text content\n  string getText() { result = super.getContents() }\n\n  // Return string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships using AS template\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Represents noqa-style suppression comments\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Initialize by matching noqa comment pattern\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Return suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define code coverage scope for this suppression\n  override predicate covers(\n    string filePath, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    // Extract location details from comment\n    exists(int cmtStartLine, int cmtEndLine, int cmtEndCol |\n      this.hasLocationInfo(filePath, cmtStartLine, _, cmtEndLine, cmtEndCol) and\n      // Match coverage boundaries to comment location\n      beginLine = cmtStartLine and\n      endLine = cmtEndLine and\n_______________ // 补全条件\n      endCol = cmtEndCol\n    )\n  }\n}",
    "output": "beginCol = 1 and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-recent-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：统计最近半年内的代码提交频率",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 近期代码提交活动分析\n * @description 统计最近半年内的代码提交频率\n * @kind treemap\n * @id py/historical-number-of-recent-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\nimport python // Python语言分析支持\nimport external.VCS // 版本控制系统集成模块\n\n// 查找符合时间范围和非自动生成条件的代码提交\nfrom Commit recentCommit\nwhere \n  // 筛选条件1：提交发生在最近180天内（半年时间窗口）\n  recentCommit.daysToNow() <= 180\n  and\n  // 筛选条件2：排除系统自动生成的提交\n  not artificialChange(recentCommit)\nselect recentCommit.getRevisionName(), 1  // 输出修订标识及计数（每条提交记录计为1）"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name PAM授权绕过问题由于不正确使用\n * @description 在`pam_authenticate`之后不使用`pam_acct_mgmt`来检查登录的有效性，可能导致授权绕过。\n_______________ // 补全条件\n * @problem.severity warning\n * @security-severity 8.1\n * @precision high\n * @id py/pam-auth-bypass\n * @tags security\n *       external/cwe/cwe-285\n */\n\nimport python\nimport PamAuthorizationFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.security.dataflow.PamAuthorizationQuery\n\n// 查找PAM授权流程的起点和终点节点\nfrom PamAuthorizationFlow::PathNode pamAuthStartNode, PamAuthorizationFlow::PathNode pamAuthEndNode\n// 检查是否存在从起点到终点的完整授权流程路径，这表示在pam_authenticate之后没有调用pam_acct_mgmt\nwhere PamAuthorizationFlow::flowPath(pamAuthStartNode, pamAuthEndNode)\n// 输出结果并生成安全警告消息，指出PAM认证依赖于用户提供的值，且之后没有调用pam_acct_mgmt\nselect pamAuthEndNode.getNode(), pamAuthStartNode, pamAuthEndNode,\n  \"This PAM authentication depends on a $@, and 'pam_acct_mgmt' is not called afterwards.\",\n  pamAuthStartNode.getNode(), \"user-provided value\"",
    "output": "* @kind path-problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/imprecise-assert]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using 'assertTrue' or 'assertFalse' rather than a more specific assertion can give uninformative failure messages.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Imprecise assert\n * @description Using 'assertTrue' or 'assertFalse' rather than a more specific assertion can give uninformative failure messages.\n * @kind problem\n * @tags maintainability\n *       testability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/imprecise-assert\n */\n\nimport python\n\n/* Helper predicate identifying comparison-based assertion calls */\npredicate isComparisonBasedAssert(Call targetCall, string assertMethodName, Cmpop op) {\n  // Verify the call targets assertTrue/assertFalse methods\n  targetCall.getFunc().(Attribute).getName() = assertMethodName and\n  (assertMethodName = \"assertTrue\" or assertMethodName = \"assertFalse\") and\n  exists(Compare compareExpr |\n    // Ensure first argument is a comparison operation\n    compareExpr = targetCall.getArg(0) and\n    /* Exclude chained comparisons like: a < b < c */\n    // Reject complex multi-operator comparisons\n    not exists(compareExpr.getOp(1)) and\n    op = compareExpr.getOp(0)\n  )\n}\n\nclass CallToAssertOnComparison extends Call {\n  // Constructor matches comparison-based assertions\n  CallToAssertOnComparison() { isComparisonBasedAssert(this, _, _) }\n\n  // Retrieve the comparison operator used\n  Cmpop getOperator() { isComparisonBasedAssert(this, _, result) }\n\n  // Get the name of the assertion method\n  string getMethodName() { isComparisonBasedAssert(this, result, _) }\n\n  // Determine the recommended specific assertion method\n  string getBetterName() {\n    exists(Cmpop cmpOperator |\n      // Handle assertTrue cases\n      isComparisonBasedAssert(this, \"assertTrue\", cmpOperator) and\n      (\n        cmpOperator instanceof Eq and result = \"assertEqual\"\n        or\n        cmpOperator instanceof NotEq and result = \"assertNotEqual\"\n        or\n        cmpOperator instanceof Lt and result = \"assertLess\"\n        or\n        cmpOperator instanceof LtE and result = \"assertLessEqual\"\n        or\n        cmpOperator instanceof Gt and result = \"assertGreater\"\n        or\n        cmpOperator instanceof GtE and result = \"assertGreaterEqual\"\n        or\n        cmpOperator instanceof In and result = \"assertIn\"\n        or\n        cmpOperator instanceof NotIn and result = \"assertNotIn\"\n        or\n        cmpOperator instanceof Is and result = \"assertIs\"\n        or\n        cmpOperator instanceof IsNot and result = \"assertIsNot\"\n      )\n      or\n      // Handle assertFalse cases\n      isComparisonBasedAssert(this, \"assertFalse\", cmpOperator) and\n      (\n        cmpOperator instanceof NotEq and result = \"assertEqual\"\n        or\n        cmpOperator instanceof Eq and result = \"assertNotEqual\"\n        or\n        cmpOperator instanceof GtE and result = \"assertLess\"\n        or\n        cmpOperator instanceof Gt and result = \"assertLessEqual\"\n        or\n        cmpOperator instanceof LtE and result = \"assertGreater\"\n        or\n        cmpOperator instanceof Lt and result = \"assertGreaterEqual\"\n        or\n        cmpOperator instanceof NotIn and result = \"assertIn\"\n        or\n        cmpOperator instanceof In and result = \"assertNotIn\"\n        or\n        cmpOperator instanceof IsNot and result = \"assertIs\"\n        or\n        cmpOperator instanceof Is and result = \"assertIsNot\"\n      )\n    )\n  }\n}\n\nfrom CallToAssertOnComparison targetCall\nwhere\n  /* Exclude assertions with explicit failure messages */\n  // Filter out cases where custom message is provided\n  not exists(targetCall.getArg(1))\nselect targetCall,\n  // Generate recommendation message with specific assertion alternatives\n  targetCall.getMethodName() + \"(a \" + targetCall.getOperator().getSymbol() + \" b) \" +\n    \"cannot provide an informative message. Using \" + targetCall.getBetterName() +\n    \"(a, b) instead will give more informative messages.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name All Cryptographic Algorithms\n * @description Finds all potential usage of cryptographic algorithms usage using the supported libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// 导入Python库，用于分析Python代码\nimport python\n// 导入实验性的加密概念库，用于识别加密算法\nimport experimental.cryptography.Concepts\n\n// 从CryptographicAlgorithm类中选择所有实例alg\nfrom CryptographicAlgorithm alg\n_______________ // 补全条件\nselect alg, \"Use of algorithm \" + alg.getName()",
    "output": "// 选择alg并返回一个包含算法名称的字符串"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Constructing cookies from user input may allow an attacker to perform a Cookie Poisoning attack.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Construction of a cookie using user-supplied input\n * @description Constructing cookies from user input may allow an attacker to perform a Cookie Poisoning attack.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// 导入Python库，用于分析Python代码\nimport python\n\n// 导入与Cookie注入相关的查询模块\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// 导入路径图类，用于表示数据流路径\nimport CookieInjectionFlow::PathGraph\n\n// 从路径图中选择源节点和汇节点\nfrom CookieInjectionFlow::PathNode source, CookieInjectionFlow::PathNode sink\n\n// 条件：存在从源节点到汇节点的数据流路径\nwhere CookieInjectionFlow::flowPath(source, sink)\n\n// 选择结果：汇节点、源节点、路径信息、描述信息等\nselect sink.getNode(), source, sink, \"Cookie is constructed from a $@.\", source.getNode(),\n  \"user-supplied input\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent method resolution order\n * @description Detects classes with inheritance hierarchies that violate method resolution order (MRO) rules, which can lead to runtime type errors during class construction\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n// Identifies classes where adjacent base classes in the inheritance hierarchy create MRO conflicts\npredicate has_mro_violation(ClassObject problematicClass, ClassObject precedingBase, ClassObject followingBase) {\n  // Focus on new-style classes (applicable in Python 3+)\n  problematicClass.isNewStyle() and\n  // Find consecutive base classes in the inheritance list\n  exists(int positionIndex | \n    positionIndex > 0 and \n    // followingBase comes immediately after precedingBase in the base class list\n    followingBase = problematicClass.getBaseType(positionIndex) and \n    precedingBase = problematicClass.getBaseType(positionIndex - 1)\n  ) and\n_______________ // 补全条件\n  precedingBase = followingBase.getAnImproperSuperType()\n}\n\n// Generate reports for classes with MRO violations, highlighting the conflicting base classes\nfrom ClassObject problematicClass, ClassObject precedingBase, ClassObject followingBase\nwhere has_mro_violation(problematicClass, precedingBase, followingBase)\nselect problematicClass,\n  \"Class \" + problematicClass.getName() +\n    \" construction may fail due to invalid MRO between base classes $@ and $@.\", precedingBase,\n  precedingBase.getName(), followingBase, followingBase.getName()",
    "output": "// Confirm MRO violation: precedingBase is an improper supertype of followingBase"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects the use of '\\b' to represent a backspace character within regular expressions,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Backspace escape in regular expression\n * @description Detects the use of '\\b' to represent a backspace character within regular expressions,\n *              which can lead to confusion as it is commonly interpreted as a word boundary.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int backslashPos\nwhere\n  // Locate a backslash character used for escaping at the specified position\n  regexPattern.escapingChar(backslashPos) and\n  // Verify that the character immediately following the backslash is 'b'\n  regexPattern.getChar(backslashPos + 1) = \"b\" and\n  // Check if this escape sequence is contained within a character set\n  exists(int charSetStart, int charSetEnd | \n    // Identify a character set that encompasses the escape sequence\n    regexPattern.charSet(charSetStart, charSetEnd) and\n    // Ensure the backslash position falls within the character set boundaries\n    charSetStart < backslashPos and \n    charSetEnd > backslashPos\n  )\nselect regexPattern, \"Backspace escape in regular expression at offset \" + backslashPos + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Default version of SSL/TLS may be insecure\n * @description Leaving the SSL/TLS version unspecified may result in an insecure\n *              default protocol being used.\n * @id py/insecure-default-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n_______________ // 补全条件\n\n// This query identifies deprecated SSL socket creation methods that lack protocol specification.\n// When ssl.wrap_socket is invoked without the ssl_version parameter, insecure defaults may be applied.\n// Note: Secure context configuration issues are covered by py/insecure-protocol dataflow query.\nimport python\nimport semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode insecureSslSocketCall\nwhere\n  // Target deprecated ssl.wrap_socket method invocations\n  insecureSslSocketCall = API::moduleImport(\"ssl\").getMember(\"wrap_socket\").getACall()\n  // Confirm absence of ssl_version parameter in the call\n  and not exists(insecureSslSocketCall.getArgByName(\"ssl_version\"))\nselect insecureSslSocketCall,\n  \"Call to deprecated method ssl.wrap_socket does not specify a protocol, which may result in an insecure default being used.\"",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Analysis of incoming class dependencies\n * @description Quantifies the number of external classes that depend on each target class.\n *              Higher values indicate classes with more incoming dependencies, which can impact modularity.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n_______________ // 补全条件\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// Identify classes for dependency analysis\nfrom ClassMetrics analyzedClass\n// Filter to include only classes that have measurable incoming dependencies\nwhere exists(analyzedClass.getAfferentCoupling())\n// Output the class and its incoming dependency count, sorted by highest dependency count\nselect analyzedClass, \n       analyzedClass.getAfferentCoupling() as dependencyInflowCount \norder by dependencyInflowCount desc",
    "output": "* @metricType reftype"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * 本查询计算三个关键指标：\n * 1. 特定深度下的唯一调用节点数量（表示边际增长）\n * 2. 该深度及以下的调用节点累计总数（表示整体规模）\n * 3. 唯一调用数与总调用数的比率（效率衡量标准）\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义结果变量：distinct_calls（唯一调用数）、cumulative_calls（累计调用数）、depth_level（上下文深度）和efficiency_metric（效率指标）\nfrom int distinct_calls, int cumulative_calls, int depth_level, float efficiency_metric\nwhere\n  // 计算在特定深度下的唯一调用节点数量\n  distinct_calls =\n    strictcount(ControlFlowNode node, CallableValue target |\n      exists(PointsToContext context |\n        node = target.getACall(context) and // 获取可调用对象在特定上下文中的调用节点\n        depth_level = context.getDepth() and // 获取当前上下文深度\n        not exists(PointsToContext shallow_ctx |\n          node = target.getACall(shallow_ctx) and // 确保没有更浅上下文包含相同调用节点\n          shallow_ctx.getDepth() < depth_level\n        )\n      )\n    ) and\n  // 计算在特定深度及以下的所有调用节点总数\n  cumulative_calls =\n    strictcount(ControlFlowNode node, CallableValue target, PointsToContext context |\n      node = target.getACall(context) and // 获取可调用对象在任意上下文中的调用节点\n      depth_level = context.getDepth() // 记录上下文深度\n    ) and\n  // 计算调用效率指标，即唯一调用数与总调用数的百分比\n  efficiency_metric = 100.0 * distinct_calls / cumulative_calls\nselect depth_level, distinct_calls, cumulative_calls, efficiency_metric // 输出结果字段",
    "output": "* 评估调用图在不同上下文深度下的性能效率。"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-shadowed-loop-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects loop variables that share names with imported module aliases,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Import shadowed by loop variable\n * @description Detects loop variables that share names with imported module aliases,\n *              potentially causing confusion by obscuring the imported identifier.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/import-shadowed-loop-variable\n */\n\nimport python\n\nfrom Variable loopVariable, Name variableNameNode\nwhere \n  // Verify the variable is defined as a loop iteration target\n  exists(For loopStatement | variableNameNode = loopStatement.getTarget()) and\n  variableNameNode.defines(loopVariable) and\n  // Identify conflicting import alias in the same scope hierarchy\n  exists(Import importStmt, Name aliasNode |\n    // Alias must originate from an import statement's 'as' clause\n    aliasNode = importStmt.getAName().getAsname() and\n    // Alias identifier must match the loop variable's name\n    aliasNode.getId() = loopVariable.getId() and\n    // Import must be accessible in the loop variable's scope\n    importStmt.getScope() = loopVariable.getScope().getScope*()\n  )\nselect variableNameNode, \"Loop variable '\" + loopVariable.getId() + \"' shadows an imported module alias.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Statement has no effect\n * @description Identifies statements that do not produce any effect during program execution\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/ineffectual-statement\n */\n\nimport python\n\n/* Determines if an attribute access is well-defined by examining its source and target classes */\npredicate is_attribute_understood(Attribute attributeAccess, ClassValue sourceCls, ClassValue attrCls) {\n  exists(string attributeName | attributeAccess.getName() = attributeName |\n    attributeAccess.getObject().pointsTo().getClass() = sourceCls and\n    sourceCls.attr(attributeName).getClass() = attrCls\n  )\n}\n\n/* Checks if an attribute access could potentially cause side effects */\npredicate has_side_effecting_attr(Attribute attributeAccess) {\n  exists(ClassValue attrCls |\n    is_attribute_understood(attributeAccess, _, attrCls) and\n    is_descriptor_type_side_effecting(attrCls)\n  )\n}\n\n// Determines if an attribute access might have side effects\npredicate might_have_side_effect_attr(Attribute attributeAccess) {\n  // Case 1: Attribute is not understood or doesn't point to a concrete value\n  (not is_attribute_understood(attributeAccess, _, _) and not attributeAccess.pointsTo(_))\n  or\n  // Case 2: Attribute is already identified as having side effects\n  has_side_effecting_attr(attributeAccess)\n}\n\n// Evaluates if a descriptor type has side effects when accessed\npredicate is_descriptor_type_side_effecting(ClassValue descriptorCls) {\n  descriptorCls.isDescriptorType() and\n  // All descriptor accesses technically have side effects, but some represent missing calls\n  // which we treat as having no effect\n  not descriptorCls = ClassValue::functionType() and\n  not descriptorCls = ClassValue::staticmethod() and\n  not descriptorCls = ClassValue::classmethod()\n}\n\n/**\n * Binary operators rarely have side effects, so we assume they have no side effects\n * unless there's evidence to the contrary\n */\npredicate is_binary_side_effecting(Expr binaryExpr) {\n  exists(Expr subExpr, ClassValue exprCls, string methodName |\n    // Handle binary operator special methods\n    is_special_binary_operator(binaryExpr, subExpr, exprCls, methodName)\n    or\n    // Handle comparison operator special methods\n    is_special_comparison_operator(binaryExpr, subExpr, exprCls, methodName)\n  |\n    methodName = get_special_method_name() and\n    exprCls.hasAttribute(methodName) and\n    // Exclude inherited methods from built-in types (except object)\n    not exists(ClassValue declaring |\n      declaring.declaresAttribute(methodName) and\n      declaring = exprCls.getASuperType() and\n      declaring.isBuiltin() and\n      not declaring = ClassValue::object()\n    )\n  )\n}\n\n// Identifies binary expressions that utilize special operator methods\npragma[nomagic]\nprivate predicate is_special_binary_operator(\n  BinaryExpr binaryExpr, Expr subExpr, ClassValue exprCls, string methodName\n) {\n  methodName = get_special_method_name() and\n  subExpr = binaryExpr.getLeft() and\n  methodName = binaryExpr.getOp().getSpecialMethodName() and\n  subExpr.pointsTo().getClass() = exprCls\n}\n\n// Identifies comparison expressions that utilize special operator methods\npragma[nomagic]\nprivate predicate is_special_comparison_operator(Compare binaryExpr, Expr subExpr, ClassValue exprCls, string methodName) {\n  exists(Cmpop op |\n    binaryExpr.compares(subExpr, op, _) and\n    methodName = op.getSpecialMethodName()\n  ) and\n  subExpr.pointsTo().getClass() = exprCls\n}\n\n// Retrieves the special method name for comparison or binary operators\nprivate string get_special_method_name() {\n  result = any(Cmpop comparisonOp).getSpecialMethodName()\n  or\n  result = any(BinaryExpr binaryExpr).getOp().getSpecialMethodName()\n}\n\n// Determines if a file is a Jupyter/IPython notebook\npredicate is_notebook_file(File notebook) {\n  exists(Comment comment | comment.getLocation().getFile() = notebook |\n    comment.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\n// Checks if an expression is located within a Jupyter/IPython notebook\npredicate expr_in_notebook(Expr expr) { \n  is_notebook_file(expr.getScope().(Module).getFile()) \n}\n\n// Retrieves the FunctionValue for unittest.TestCase's assertRaises method\nFunctionValue get_assert_raises_method() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\n// Checks if an expression is within a `with` block that tests exception raising\npredicate expr_in_raises_test(Expr expr) {\n  exists(With withStatement |\n    withStatement.contains(expr) and\n    withStatement.getContextExpr() = get_assert_raises_method().getACall().getNode()\n  )\n}\n\n// Checks if an expression is a Python 2 print statement (e.g., print >> out, ...)\npredicate is_python2_print_stmt(Expr expr) {\n  // Handle print >> syntax\n  (expr.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n   expr.(BinaryExpr).getOp() instanceof RShift)\n  or\n  // Recursively handle first element in tuple\n  is_python2_print_stmt(expr.(Tuple).getElt(0))\n}\n\n// Determines if an expression has no effect\npredicate expression_has_no_effect(Expr expr) {\n  // String literals can serve as documentation\n  not expr instanceof StringLiteral and\n  not expr.hasSideEffects() and\n  // Check all sub-expressions\n  forall(Expr subExpr | subExpr = expr.getASubExpression*() |\n    not is_binary_side_effecting(subExpr) and\n    not might_have_side_effect_attr(subExpr)\n  ) and\n  // Exclude special cases\n_______________ // 补全条件\n  not expr_in_raises_test(expr) and\n  not is_python2_print_stmt(expr)\n}\n\n// Select statements with no effect and report the issue\nfrom ExprStmt stmt\nwhere expression_has_no_effect(stmt.getValue())\nselect stmt, \"This statement has no effect.\"",
    "output": "not expr_in_notebook(expr) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects incorrect usage of super() in legacy class definitions that lack proper inheritance support.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description Detects incorrect usage of super() in legacy class definitions that lack proper inheritance support.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * Locates super() function invocations within methods of legacy class definitions.\n * \n * This predicate identifies super() calls that are destined to fail at execution time\n * due to the absence of proper inheritance mechanisms in old-style classes.\n */\npredicate superCallInOldClass(Call superCall) {\n  // Validate that the invocation targets the built-in super function\n  superCall.getFunc().(Name).getId() = \"super\" and\n  // Examine the surrounding context of the super() call\n  exists(Function methodInClass |\n    // The super() call must be located within a method definition\n    superCall.getScope() = methodInClass and\n    // This method must be nested inside an old-style class\n    exists(ClassObject parentClass |\n      // Establish the relationship between method and containing class\n      methodInClass.getScope() = parentClass.getPyClass() and\n      // Ensure the class type inference was successful\n      not parentClass.failedInference() and\n      // Verify the class uses old-style conventions (doesn't inherit from object)\n      not parentClass.isNewStyle()\n    )\n  )\n}\n\n// Primary query to identify problematic super() invocations\nfrom Call problematicSuperCall\n// Apply filter to isolate super() calls within old-style class contexts\nwhere superCallInOldClass(problematicSuperCall)\n// Generate alert with descriptive message for each identified issue\nselect problematicSuperCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of co-committed files\n * @description Calculates the average number of files modified together when a specific file is changed in a commit\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n_______________ // 补全条件\n */\n\nimport python\nimport external.VCS\n\n// Helper function: Computes the total number of files modified in a given commit\nint getTotalFilesInCommit(Commit commit) { \n    result = count(commit.getAnAffectedFile()) \n}\n\n// Main analysis: Evaluates co-modification patterns across different modules\nfrom Module analyzedModule\n// Filtering condition: Only process modules with available lines-of-code metrics\nwhere exists(analyzedModule.getMetrics().getNumberOfLinesOfCode())\nselect analyzedModule,\n  // Compute the average count of files modified alongside files in this module\n  avg(Commit commit, int coModifiedCount |\n    // Condition: The commit affects a file within the analyzed module\n    commit.getAnAffectedFile() = analyzedModule.getFile() and \n    // Calculate the number of additional files modified in the same commit\n    coModifiedCount = getTotalFilesInCommit(commit) - 1\n  |\n    coModifiedCount\n  )",
    "output": "* @metricAggregate avg min max"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raise-not-implemented]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code that raises 'NotImplemented' instead of 'NotImplementedError'.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name NotImplemented is not an Exception\n * @description Detects code that raises 'NotImplemented' instead of 'NotImplementedError'.\n *              This pattern leads to runtime type errors because NotImplemented is not\n *              an exception class, but rather a special value used for binary operations.\n * @kind problem\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Core Python language analysis libraries\nimport python\n\n// Specialized module for identifying NotImplemented misuse in exception handling\nimport Exceptions.NotImplemented\n\n// Identify expressions where NotImplemented is incorrectly used in raise statements\nfrom Expr problematicNotImplementedRaise\nwhere \n    // Detect raise statements that misuse NotImplemented instead of the proper\n    // NotImplementedError exception class\n    use_of_not_implemented_in_raise(_, problematicNotImplementedRaise)\nselect \n    // Report the problematic expression with guidance for correction\n    problematicNotImplementedRaise, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies data flow paths where untrusted user input propagates to cookie value assignments,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted Data Propagation to Cookie Construction\n * @description Identifies data flow paths where untrusted user input propagates to cookie value assignments,\n *              creating potential for injection attacks that compromise cookie integrity and security.\n * @id py/untrusted-cookie-injection\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 8.7\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\nfrom \n  CookieInjectionFlow::PathNode untrustedInputNode, \n  CookieInjectionFlow::PathNode cookieAssignmentNode\nwhere \n  CookieInjectionFlow::flowPath(untrustedInputNode, cookieAssignmentNode)\nselect \n  cookieAssignmentNode.getNode(), \n  untrustedInputNode, \n  cookieAssignmentNode, \n  \"Cookie value constructed from $@.\", \n  untrustedInputNode.getNode(), \n  \"untrusted user input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jump-to-definition]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Jump to definition helper query that identifies the definitions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Definitions\n * @description Jump to definition helper query that identifies the definitions\n *              corresponding to various expression usages in Python code.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import Python library for analyzing Python source code\nimport python\n\n// Import DefinitionTracking module to trace variable and function definitions\nimport analysis.DefinitionTracking\n\n// Select expression usages, their corresponding definitions, and definition types\nfrom NiceLocationExpr exprUsage, Definition targetDefinition, string definitionType\n// Condition: the target definition matches the expression usage for the given definition type\nwhere targetDefinition = definitionOf(exprUsage, definitionType)\n// Output the expression usage location, its definition location, and the definition type\nselect exprUsage, targetDefinition, definitionType"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-commented-out-code-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Counts the number of lines containing commented-out code in each source file, excluding lines that could be example code",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name File-based commented code line counter\n * @description Counts the number of lines containing commented-out code in each source file, excluding lines that could be example code\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n * @id py/lines-of-commented-out-code-in-files\n */\n\nimport python\nimport Lexical.CommentedOutCode\n\nfrom File sourceFile, int commentedCodeCount\nwhere \n  commentedCodeCount = count(CommentedOutCodeLine commentedLine |\n    commentedLine.getLocation().getFile() = sourceFile and\n    not commentedLine.maybeExampleCode()\n  )\nselect sourceFile, commentedCodeCount order by commentedCodeCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-exec]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of 'exec' statement/function which enables arbitrary code execution",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'exec' used\n * @description Detects usage of 'exec' statement/function which enables arbitrary code execution\n * @kind problem\n * @tags security\n *       correctness\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec\n */\n\nimport python\n\n/**\n * Generates version-specific warning message for 'exec' usage\n * @returns \"The 'exec' statement is used\" for Python 2\n *          \"The 'exec' function is used\" for Python 3\n */\nstring getExecWarningMessage() {\n  result = \"The 'exec' statement is used.\" and major_version() = 2\n  or\n  result = \"The 'exec' function is used.\" and major_version() = 3\n}\n\n/**\n * Identifies function calls to built-in 'exec'\n * @param callNode - AST node representing the function call\n */\npredicate isExecFunctionCall(Call callNode) {\n  exists(GlobalVariable execVar |\n    execVar = callNode.getFunc().(Name).getVariable() and\n    execVar.getId() = \"exec\"\n  )\n}\n\n// Main query logic\nfrom AstNode execNode\nwhere \n  isExecFunctionCall(execNode) or\n  execNode instanceof Exec\nselect execNode, getExecWarningMessage()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode IV or nonce\n * @description Identifies weak initialization vectors (IVs) or nonces in block cipher operations.\n *              Flags cases where IVs/nonces are missing or not generated by os.urandom.\n *              Excludes Fernet (handled internally) and requires manual review for complex cases.\n *\n *            NOTE: This simplified query flags any IV/nonce not from os.urandom or undetermined origin.\n *                  Nuanced patterns (e.g., GCM nonce usage) require expert review. Functions inferring\n *                  both mode and IV may trigger false positives (handled via suppression). Fernet is\n *                  explicitly excluded due to internal os.urandom usage.\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify block mode operations with weak IV/nonce configurations\nfrom BlockMode blockModeInstance, string diagnosticMessage, DataFlow::Node sourceNode\nwhere\n  // Exclude Fernet (handles IV generation internally)\n  not blockModeInstance instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet and\n  (\n    // Detect missing IV/nonce OR non-os.urandom source\n    not blockModeInstance.hasIVorNonce() or\n    not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = blockModeInstance.getIVorNonce()\n  ) and\n  // Assign diagnostic details based on IV/nonce presence\n  (\n    // Case 1: Missing IV/nonce\n    if not blockModeInstance.hasIVorNonce()\n    then (\n      sourceNode = blockModeInstance and \n      diagnosticMessage = \"Block mode is missing IV/Nonce initialization.\"\n    )\n    // Case 2: IV/nonce from insecure source\n_______________ // 补全条件\n      sourceNode = blockModeInstance.getIVorNonce()\n    )\n  ) and\n  // Finalize diagnostic message with source reference\n  diagnosticMessage = \"Block mode is not using an accepted IV/Nonce initialization: $@\"\nselect blockModeInstance, diagnosticMessage, sourceNode, sourceNode.toString()",
    "output": "else ("
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 明文存储敏感信息\n * @description 检测未加密或哈希处理的敏感信息存储，这些存储可能使敏感信息暴露给攻击者。\n * \n * 该查询识别应用程序中敏感数据以明文形式存储的情况，没有进行适当的加密或哈希处理。\n * 这种做法可能导致敏感信息泄露，违反数据保护最佳实践。\n * \n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/clear-text-storage-sensitive-data\n * @tags security\n *       external/cwe/cwe-312\n *       external/cwe/cwe-315\n *       external/cwe/cwe-359\n */\n\nimport python  // Python代码分析基础库\nprivate import semmle.python.dataflow.new.DataFlow  // 数据流分析模块\nimport CleartextStorageFlow::PathGraph  // 敏感数据流路径图\nimport semmle.python.security.dataflow.CleartextStorageQuery  // 明文存储安全查询模块\n\nfrom \n  CleartextStorageFlow::PathNode sensitiveDataSource,  // 敏感数据源节点\n  CleartextStorageFlow::PathNode dataStoragePoint,     // 明文存储位置节点\n  string dataClassification                           // 敏感数据分类标识\nwhere \n  // 检查是否存在从数据源到存储位置的完整数据流路径，并获取敏感数据的分类类型\n  CleartextStorageFlow::flowPath(sensitiveDataSource, dataStoragePoint)\n  and\n  dataClassification = sensitiveDataSource.getNode().(Source).getClassification()\nselect \n  dataStoragePoint.getNode(),                          // 报告位置：明文存储点\n  sensitiveDataSource, dataStoragePoint,              // 数据流路径：源节点 -> 目标节点\n  \"This expression stores $@ as clear text.\",          // 警告消息模板\n  sensitiveDataSource.getNode(),                       // 消息参数：敏感数据源位置\n_______________ // 补全条件",
    "output": "\"sensitive data (\" + dataClassification + \")\"       // 敏感数据分类详情"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Signature mismatch in overriding method\n * @description Identifies instances where a subclass method overrides a superclass method\n *              with incompatible parameter counts, which may lead to runtime errors.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Find methods with signature incompatibilities in inheritance hierarchies\nfrom FunctionValue parentMethod, PythonFunctionValue childMethod\nwhere\n  // Establish the override relationship between methods\n  childMethod.overrides(parentMethod) and\n  \n  // Filter to focus only on regular instance methods, excluding special cases\n_______________ // 补全条件\n  not childMethod.getScope().isSpecialMethod() and\n  childMethod.getName() != \"__init__\" and\n  \n  // Exclude scenarios where the superclass method is being called\n  not exists(parentMethod.getACall()) and\n  \n  // Ensure no other overriding subclass methods are being invoked\n  not exists(FunctionValue otherChild |\n    otherChild.overrides(parentMethod) and\n    exists(otherChild.getACall())\n  ) and\n  \n  // Detect parameter count incompatibility between parent and child methods\n  (\n    // Scenario 1: Child method requires more parameters than parent method can provide\n    childMethod.minParameters() > parentMethod.maxParameters()\n    or\n    // Scenario 2: Child method accepts fewer parameters than parent method requires\n    childMethod.maxParameters() < parentMethod.minParameters()\n  )\nselect childMethod, \"Overriding method '\" + childMethod.getName() + \"' has signature mismatch with $@.\",\n  parentMethod, \"overridden method\"",
    "output": "childMethod.isNormalMethod() and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects unsupported format characters in Python percent-style format strings.\n * This query identifies expressions containing invalid conversion specifiers that can cause runtime errors.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/percent-format/unsupported-character\n */\n\nimport python\nimport semmle.python.strings\n\n// Locate expressions with invalid conversion specifiers\nfrom Expr formatStrExpr, int invalidIndex\nwhere \n  // Determine position of illegal conversion specifier\n  invalidIndex = illegal_conversion_specifier(formatStrExpr)\nselect \n  formatStrExpr, \n  // Construct detailed error message with location details\n  \"Invalid conversion specifier at index \" + \n  invalidIndex + \n  \" of \" + \n  repr(formatStrExpr) + \n  \".\"",
    "output": "* @name Unsupported format character"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Generator in `__init__` method\n * @description Identifies class initialization methods that contain generator expressions (yield/yield from).\n *              This is considered a reliability issue as __init__ methods should not be generators.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n_______________ // 补全条件\n */\n\nimport python\n\nfrom Function initializerMethod\nwhere\n  // First condition: must be a class initializer\n  initializerMethod.isInitMethod()\n  // Second condition: must contain generator expressions\n  and (\n    exists(Yield generatorYield | generatorYield.getScope() = initializerMethod) or\n    exists(YieldFrom generatorYieldFrom | generatorYieldFrom.getScope() = initializerMethod)\n  )\nselect initializerMethod, \"__init__ method is a generator.\"",
    "output": "* @id py/init-method-is-generator"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Lines of commented-out code in files\n * @description The number of lines of commented out code per file\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n_______________ // 补全条件\n * @id py/lines-of-commented-out-code-in-files\n */\n\n// 导入Python语言支持库和注释代码分析模块\nimport python\nimport Lexical.CommentedOutCode\n\n// 从源文件targetFile和注释行数量度量值deadCodeMetric中选择数据\nfrom File targetFile, int deadCodeMetric\n// 条件：deadCodeMetric等于满足以下条件的注释行commentedLine的总数\nwhere deadCodeMetric = count(CommentedOutCodeLine commentedLine | \n       // 排除可能是示例代码的注释行\n       not commentedLine.maybeExampleCode() and \n       // 确保注释行属于当前分析的源文件\n       commentedLine.getLocation().getFile() = targetFile)\n// 选择源文件targetFile和对应的注释行数量deadCodeMetric，并按deadCodeMetric降序排列\nselect targetFile, deadCodeMetric order by deadCodeMetric desc",
    "output": "* @tags maintainability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Excessively large range iteration\n * @description Iterating over an extremely large range may cause performance degradation or resource exhaustion\n * @kind problem\n * @id python/augmented/overly-large-range\n * @problem.severity warning\n * @tags security\n *       external/cwe/cwe-020\n */\n\nimport python\n\nclass ExcessiveRangeCall extends Call {\n    ExcessiveRangeCall() {\n        exists(string funcName | \n            this.getFunc().(Name).getId() = \"range\" and\n            (\n                // Single argument case: range(stop)\n                this.getNumArg() = 1 and\n                exists(int stop | \n                    this.getArg(0).getValue().(IntValue).getIntValue() = stop and\n                    stop > 1000000\n                )\n                or\n                // Two argument case: range(start, stop)\n                this.getNumArg() = 2 and\n                exists(int start, int stop | \n                    this.getArg(0).getValue().(IntValue).getIntValue() = start and\n                    this.getArg(1).getValue().(IntValue).getIntValue() = stop and\n                    stop - start > 1000000\n                )\n            )\n        )\n    }\n}\n\nclass ForLoopWithExcessiveRange extends For {\n    ForLoopWithExcessiveRange() {\n        this.getIter() instanceof ExcessiveRangeCall\n    }\n}\n\nfrom ForLoopWithExcessiveRange problematicLoop\nselect problematicLoop, \n    \"This loop iterates over an excessively large range, potentially causing performance issues or resource exhaustion.\"",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Asymmetric Encryption Padding Schemes Detection\n * @description This query identifies all occurrences of padding schemes used in asymmetric cryptographic algorithms.\n_______________ // 补全条件\n * @id py/quantum-readiness/cbom/asymmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// 导入必要的库\nimport python  // 用于Python代码分析\nimport experimental.cryptography.Concepts  // 提供加密相关概念支持\n\n// 查询并输出所有非对称加密填充方案\nfrom AsymmetricPadding asymmetricPadding\nselect asymmetricPadding, \"Detected asymmetric padding scheme: \" + asymmetricPadding.getPaddingName()",
    "output": "* @kind problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/diagnostics/successfully-extracted-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别并列出代码库中所有成功提取的Python源文件。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python文件提取状态验证\n * @description 识别并列出代码库中所有成功提取的Python源文件。\n * @kind diagnostic\n * @id py/diagnostics/successfully-extracted-files\n * @tags successfully-extracted-files\n */\n\nimport python\n\n/* \n * 该查询用于验证Python源文件的提取状态。\n * 提取成功的标准：文件具备有效的相对路径，表明文件已被系统正确处理和索引。\n * 此查询有助于确认代码库中哪些Python文件可供进一步分析。\n */\nfrom File pythonSrcFile\nwhere \n  /* 验证文件是否成功提取：检查相对路径是否存在且有效 */\n  pythonSrcFile.getRelativePath() != \"\" and\n  exists(pythonSrcFile.getRelativePath())\nselect pythonSrcFile, \"\"  // 输出文件对象和空字符串（保持结果格式一致性）"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Complete server-side request forgery vulnerability\n * @description Detects HTTP requests where the entire URL is controlled by external input, enabling SSRF attacks\n * @kind path-problem\n_______________ // 补全条件\n * @security-severity 9.1\n * @precision high\n * @id py/full-ssrf\n * @tags security\n *       external/cwe/cwe-918\n */\n\n// Import required Python analysis modules\nimport python\n// Import SSRF detection framework\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\n// Import path tracking for SSRF flows\nimport FullServerSideRequestForgeryFlow::PathGraph\n\n// Identify SSRF vulnerability paths with enhanced variable naming\nfrom\n  // Origin point of untrusted external input\n  FullServerSideRequestForgeryFlow::PathNode untrustedSource,\n  // Destination point where tainted data reaches HTTP request\n  FullServerSideRequestForgeryFlow::PathNode vulnerableSink,\n  // HTTP client request susceptible to SSRF\n  Http::Client::Request affectedRequest\nwhere\n  // Associate sink node with actual HTTP request\n  affectedRequest = vulnerableSink.getNode().(Sink).getRequest()\n  // Verify complete external control over request URL\n  and fullyControlledRequest(affectedRequest)\n  // Trace data flow from source to sink\n  and FullServerSideRequestForgeryFlow::flowPath(untrustedSource, vulnerableSink)\nselect\n  // Report vulnerable request and flow path\n  affectedRequest, untrustedSource, vulnerableSink,\n  // Generate vulnerability description\n  \"Complete URL controlled by $@.\", untrustedSource.getNode(),\n  \"untrusted user input\"",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raises-tuple]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Raising a tuple will result in all but the first element being discarded",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Raising a tuple\n * @description Raising a tuple will result in all but the first element being discarded\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// Identify raise statements where the exception originates from a tuple\nfrom Raise raiseNode, DataFlow::LocalSourceNode tupleSource\nwhere\n  // Only applicable in Python 2 (Python 3 handles this as a type error)\n  major_version() = 2 and\n  // The source node must be a tuple expression\n  tupleSource.asExpr() instanceof Tuple and\n  // Verify data flow from tuple to the exception being raised\n  exists(DataFlow::Node exceptionNode |\n    exceptionNode.asExpr() = raiseNode.getException() and\n    tupleSource.flowsTo(exceptionNode)\n  )\n/* Raising a tuple is a type error in Python 3, so is handled by the IllegalRaise query. */\nselect raiseNode,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleSource, \"tuple\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name URL redirection from remote source\n * @description Detects security issues where web applications perform redirects\n *              to external locations using unvalidated user-supplied data, which could\n *              facilitate phishing attacks by directing users to harmful websites.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @sub-severity low\n * @id py/url-redirection\n * @tags security\n *       external/cwe/cwe-601\n * @precision high\n */\n\n// Import fundamental Python analysis functionality\nimport python\n\n// Import specialized data flow analysis for identifying URL redirection vulnerabilities\nimport semmle.python.security.dataflow.UrlRedirectQuery\n\n// Import path graph visualization capabilities for tracking data flow paths\nimport UrlRedirectFlow::PathGraph\n\n// Define source and sink nodes for detecting URL redirection vulnerabilities\nfrom UrlRedirectFlow::PathNode taintedSourceNode, UrlRedirectFlow::PathNode sinkRedirectNode\nwhere \n  // Establish data flow connection between untrusted input and redirect destination\n  UrlRedirectFlow::flowPath(taintedSourceNode, sinkRedirectNode)\nselect \n  // Identify the location of the vulnerable redirect in the code\n  sinkRedirectNode.getNode(), \n  // Provide complete data flow path for vulnerability analysis\n_______________ // 补全条件\n  // Generate security alert with source annotation\n  \"Untrusted URL redirection relies on a $@.\", \n  taintedSourceNode.getNode(), \n  \"user-provided value\"",
    "output": "taintedSourceNode, sinkRedirectNode,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__slots__` in old-style class\n * @description Old-style classes (not inheriting from `object`) do not properly support `__slots__`.\n *              Using `__slots__` creates a regular class attribute instead of overriding the instance dictionary,\n *              leading to unexpected behavior and memory inefficiency.\n * @kind problem\n * @problem.severity error\n * @tags portability\n *       correctness\n * @sub-severity low\n * @precision very-high\n_______________ // 补全条件\n */\n\nimport python\n\nfrom ClassObject cls\nwhere \n  not cls.isNewStyle() and \n  cls.declaresAttribute(\"__slots__\") and \n  not cls.failedInference()\nselect cls,\n  \"Using '__slots__' in an old style class just creates a class attribute called '__slots__'.\"",
    "output": "* @id py/slots-in-old-style-class"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Information exposure through an exception\n * @description Detects potential leakage of exception information (messages and stack traces) \n *              to unauthorized users, which may disclose system internals that attackers \n *              could leverage to develop further attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 5.4\n * @precision high\n * @id py/stack-trace-exposure\n * @tags security\n *       external/cwe/cwe-209\n *       external/cwe/cwe-497\n */\n_______________ // 补全条件\n// Import required Python analysis capabilities\nimport python\n\n// Import module for analyzing stack trace information exposure\nimport semmle.python.security.dataflow.StackTraceExposureQuery\n\n// Import path graph utilities for visualizing data flows\nimport StackTraceExposureFlow::PathGraph\n\n// Find paths where stack trace information flows from source to sink\nfrom StackTraceExposureFlow::PathNode startPointNode, StackTraceExposureFlow::PathNode endPointNode\nwhere StackTraceExposureFlow::flowPath(startPointNode, endPointNode)\nselect \n  endPointNode.getNode(), // Primary location to report\n  startPointNode, endPointNode, // Path context for visualization\n  \"$@ propagates to this location and could be exposed to an external user.\", startPointNode.getNode(), // Flow description\n  \"Stack trace details\" // Type of sensitive information",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'super' in old style class\n * @description Identifies super() calls in old-style classes where they are unsupported.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n// Detects super() calls occurring within old-style class definitions\npredicate superCallInOldStyleClass(Call superCall) {\n  exists(Function containerFunction, ClassObject containerClass |\n_______________ // 补全条件\n    superCall.getFunc().(Name).getId() = \"super\" and\n    // Ensure call is inside a function\n    superCall.getScope() = containerFunction and\n    // Verify function is class member\n    containerFunction.getScope() = containerClass.getPyClass() and\n    // Confirm class is successfully analyzed\n    not containerClass.failedInference() and\n    // Identify old-style classes (non-new-style)\n    not containerClass.isNewStyle()\n  )\n}\n\n// Query for problematic super() calls in old-style classes\nfrom Call superCall\nwhere superCallInOldStyleClass(superCall)\nselect superCall, \"'super()' will not work in old-style classes.\"",
    "output": "// Verify the call targets the 'super' function"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/catch-base-exception]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Capturing 'BaseException' can lead to improper handling of system exits and keyboard interrupts.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Exception block catches 'BaseException'\n * @description Capturing 'BaseException' can lead to improper handling of system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// 检查异常处理块是否没有重新抛出异常\n// 通过分析控制流，判断异常处理块的基本块是否能到达程序退出点\npredicate doesNotReraise(ExceptStmt exceptionHandler) { \n  exceptionHandler.getAFlowNode().getBasicBlock().reachesExit() \n}\n\n// 判断异常处理块是否捕获了BaseException\n// 包括直接捕获BaseException或未指定异常类型（相当于捕获所有异常）\npredicate catchesBaseException(ExceptStmt exceptionHandler) {\n  // 检查异常类型是否为BaseException\n  exceptionHandler.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  // 或者未指定异常类型（裸except子句）\n  not exists(exceptionHandler.getType())\n}\n\n// 主查询：识别不恰当的BaseException处理模式\n// 查找同时满足以下条件的异常处理块：\n// 1. 捕获了BaseException（或所有异常）\n// 2. 没有重新抛出异常\nfrom ExceptStmt exceptionHandler\nwhere\n  catchesBaseException(exceptionHandler) and\n  doesNotReraise(exceptionHandler)\nselect exceptionHandler, \"Except block directly handles BaseException.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/jump-to-definition]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Advanced navigation utility that identifies relationships between code expressions and their source definitions in Python projects.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Navigate to Definitions\n * @description Advanced navigation utility that identifies relationships between code expressions and their source definitions in Python projects.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import essential Python analysis modules for comprehensive source code examination\nimport python\n\n// Import definition tracking mechanisms to establish connections between variable references and their declarations\nimport analysis.DefinitionTracking\n\n// Select source expressions with detailed location information, their corresponding definitions, and definition categories\nfrom NiceLocationExpr sourceExpr, Definition correspondingDef, string defCategory\n// Establish precise mapping between expression usage and its definition with type compatibility verification\nwhere \n  correspondingDef = definitionOf(sourceExpr, defCategory)\n// Generate output containing source expression location, target definition location, and definition classification\nselect sourceExpr, correspondingDef, defCategory"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-recent-changed-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：最近编辑的文件数量",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 最近更改的文件\n * @description 最近编辑的文件数量\n * @kind treemap\n * @id py/historical-number-of-recent-changed-files\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// 查找在最近半年内有提交记录的Python模块\nfrom Module moduleObj\nwhere\n  // 检查该模块是否有相关的版本控制提交记录\n  exists(Commit commitEntry |\n    // 提交记录影响了当前模块的文件\n    commitEntry.getAnAffectedFile() = moduleObj.getFile() and\n    // 提交时间在最近180天内（约半年）\n    commitEntry.daysToNow() <= 180 and\n    // 排除非实质性的人工更改（如格式化、重构等）\n    not artificialChange(commitEntry)\n  ) and\n  // 确保模块有可度量的代码行数（排除空文件或配置文件）\n  exists(moduleObj.getMetrics().getNumberOfLinesOfCode())\n// 输出符合条件的模块及其计数（用于树状图可视化）\nselect moduleObj, 1"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-block-mode-iv-or-nonce]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies insecure initialization vectors/nonces in block cipher operations.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak block mode IV or nonce\n * @description Identifies insecure initialization vectors/nonces in block cipher operations.\n *              Flags IVs/nonces not generated using cryptographically secure methods (os.urandom).\n *\n *            IMPORTANT NOTES:\n *              1. Simplified detection: Any IV/nonce not originating from os.urandom is flagged\n *              2. Special handling:\n *                 - GCM mode: Requires unique nonce management (addressed in separate query)\n *                 - Fernet: Excluded from analysis (implements secure IV generation internally)\n *              3. Functions dynamically determining mode/IV may yield false positives (manual review needed)\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify block cipher operations with vulnerable IV/nonce configuration\nfrom BlockMode cipherOperation, string securityAlert, DataFlow::Node vulnerableSource\nwhere\n  // Exclude Fernet encryption as it handles IV generation securely internally\n  not cipherOperation instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet\n  and (\n    // Case 1: IV/Nonce is completely missing\n    not cipherOperation.hasIVorNonce()\n    and vulnerableSource = cipherOperation\n    and securityAlert = \"Block mode is missing IV/Nonce initialization\"\n    or\n    // Case 2: IV/Nonce comes from non-cryptographic source\n    cipherOperation.hasIVorNonce()\n    and not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = cipherOperation.getIVorNonce()\n    and vulnerableSource = cipherOperation.getIVorNonce()\n    and securityAlert = \"Block mode uses non-cryptographic IV/Nonce source: $@\"\n  )\nselect cipherOperation, securityAlert, vulnerableSource, vulnerableSource.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inconsistent-mro]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Inconsistent method resolution order\n * @description Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n// 获取指定类的直接左基类\n// 该函数检查类继承列表中的位置关系，返回给定基类左侧的基类\nClassObject getLeftBaseClass(ClassObject type, ClassObject base) {\n  // 存在一个正整数索引i，使得type的第i个基类等于base，返回其左侧相邻的基类\n  exists(int i | i > 0 and type.getBaseType(i) = base and result = type.getBaseType(i - 1))\n}\n\n// 判断类是否具有无效的方法解析顺序(MRO)\n// 当左基类同时是右基类的不适当超类型时，会导致MRO不一致\npredicate hasInvalidMethodResolutionOrder(ClassObject cls, ClassObject leftBase, ClassObject rightBase) {\n  // 检查类是否为新式类，获取基类关系，并验证MRO一致性\n  cls.isNewStyle() and\n  leftBase = getLeftBaseClass(cls, rightBase) and\n  leftBase = rightBase.getAnImproperSuperType()\n}\n\n// 查询所有具有无效MRO的类，并报告错误\nfrom ClassObject cls, ClassObject leftBase, ClassObject rightBase\nwhere hasInvalidMethodResolutionOrder(cls, leftBase, rightBase)\nselect cls,\n  \"Construction of class \" + cls.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", leftBase,\n  leftBase.getName(), rightBase, rightBase.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Invalid exception type in handler\n * @description Detects exception handling blocks that use non-exception types,\n *              making them incapable of catching actual exceptions when raised.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\n// Analyze exception handling constructs to identify ineffective handlers\nfrom ExceptFlowNode exceptionBlock, Value handledType, ClassValue baseType, \n     ControlFlowNode originNode, string typeDescription\nwhere\n  // Verify the exception block handles a specific type from the origin\n  exceptionBlock.handledException(handledType, baseType, originNode) and\n  // Check for invalid exception types in two scenarios\n  (\n    // Case 1: Type is a class but not a valid exception\n    exists(ClassValue nonExceptionClass | \n      nonExceptionClass = handledType and\n      not nonExceptionClass.isLegalExceptionType() and\n      not nonExceptionClass.failedInference(_) and\n_______________ // 补全条件\n    )\n    or\n    // Case 2: Type is not a class value at all\n    not handledType instanceof ClassValue and\n    typeDescription = \"instance of '\" + baseType.getName() + \"'\"\n  )\nselect exceptionBlock.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  originNode, typeDescription",
    "output": "typeDescription = \"class '\" + nonExceptionClass.getName() + \"'\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name XML external entity expansion\n * @description Detects potential XXE (XML External Entity) injection vulnerabilities\n *              where untrusted user input is processed as XML without proper\n *              security configurations to prevent external entity expansion.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.1\n * @precision high\n * @id py/xxe\n * @tags security\n *       external/cwe/cwe-611\n *       external/cwe/cwe-827\n */\n\n// Import Python analysis framework for code parsing and evaluation\nimport python\n\n// Import specialized XXE vulnerability detection modules for Python\nimport semmle.python.security.dataflow.XxeQuery\n\n// Import path graph representation for visualizing data flow trajectories\nimport XxeFlow::PathGraph\n\n// Define untrusted input sources and vulnerable XML parsing points\n_______________ // 补全条件\n\n// Verify existence of data flow path from untrusted input to XML parsing operation\nwhere XxeFlow::flowPath(untrustedInput, xmlParsingPoint)\n\n// Select the vulnerable XML parsing location, trace back to untrusted input source,\n// and generate detailed security alert with contextual information\nselect xmlParsingPoint.getNode(), untrustedInput, xmlParsingPoint,\n  \"XML parsing operation consumes a $@ without implementing security controls against external entity expansion.\",\n  untrustedInput.getNode(), \"user-provided input\"",
    "output": "from XxeFlow::PathNode untrustedInput, XxeFlow::PathNode xmlParsingPoint"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-not-enclosing-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects instances where super() is called with a first argument that does not",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incorrect first argument in super() call\n * @description Detects instances where super() is called with a first argument that does not\n *              correspond to the enclosing class, which may lead to incorrect object initialization.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-687\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/super-not-enclosing-class\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode superInvocation, string parentClassName\nwhere\n  // Identify calls to the built-in super() function\n  superInvocation = API::builtin(\"super\").getACall() and\n  // Extract the name of the class that contains this super() call\n  parentClassName = superInvocation.getScope().getScope().(Class).getName() and\n  // Ensure there is a first argument to the super() call\n  exists(DataFlow::Node initialArgument |\n    initialArgument = superInvocation.getArg(0) and\n    // Validate that the first argument does not match the enclosing class name\n    initialArgument.getALocalSource().asExpr().(Name).getId() != parentClassName\n  )\nselect superInvocation.getNode(), \"First argument to super() should be \" + parentClassName + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of parameters without defaults\n * @description Counts parameters in functions that lack default value definitions.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n_______________ // 补全条件\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // Import the Python library for analyzing Python code\n\n// Extract function metrics to analyze parameter definitions\nfrom FunctionMetrics funcMetric\n// Present results with functions and their respective counts of non-default parameters, sorted in descending order\nselect funcMetric, funcMetric.getNumberOfParametersWithoutDefault() as nonDefaultParamCount order by nonDefaultParamCount desc",
    "output": "* @treemap.warnOn highValues"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Regex Backspace Escape Misinterpretation\n * @description Detects ambiguous '\\b' usage within regex character sets,\n *              where it could be confused with word boundary instead of backspace.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexExpr, int escapePos\nwhere\n  // Verify escape sequence is inside a character set\n  exists(int setStart, int setEnd |\n    regexExpr.charSet(setStart, setEnd) and\n_______________ // 补全条件\n    setEnd > escapePos\n  ) and\n  // Confirm current position contains backslash escape\n  regexExpr.escapingChar(escapePos) and\n  // Ensure following character is 'b'\n  regexExpr.getChar(escapePos + 1) = \"b\"\nselect regexExpr, \"Ambiguous backspace escape at offset \" + escapePos + \" in character set.\"",
    "output": "setStart < escapePos and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-block-mode]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies symmetric encryption operations that utilize weak, obsolete, or otherwise unapproved block modes.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak block mode\n * @description Identifies symmetric encryption operations that utilize weak, obsolete, or otherwise unapproved block modes.\n * @id py/weak-block-mode\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Select cryptographic operations and generate appropriate security alerts\nfrom CryptographicArtifact encryptionOperation, string securityAlert\nwhere\n  // Exclude false positives from projects that include the entire cryptography module\n  // Filter out results matching the cryptography/hazmat path\n  // Particularly important for ECB usage within keywrap operations\n  not encryptionOperation.asExpr()\n      .getLocation()\n      .getFile()\n      .getAbsolutePath()\n      .toString()\n      .matches(\"%cryptography/hazmat/%\") and\n  (\n    // Case 1: Check if the operation uses a BlockMode\n    encryptionOperation instanceof BlockMode and\n    // ECB mode is only allowed for KeyWrapOperations, so alert if ECB is not part of a KeyWrapOperation\n    (encryptionOperation.(BlockMode).getBlockModeName() = \"ECB\" implies not encryptionOperation instanceof KeyWrapOperation) and\n    exists(string blockModeName | blockModeName = encryptionOperation.(BlockMode).getBlockModeName() |\n      // Only CBC, CTS, and XTS modes are approved\n      // Reference: https://liquid.microsoft.com/Web/Object/Read/MS.Security/Requirements/Microsoft.Security.Cryptography.10002\n      not blockModeName = [\"CBC\", \"CTS\", \"XTS\"] and\n      if blockModeName = unknownAlgorithm()\n      then securityAlert = \"Use of unrecognized block mode algorithm.\"\n      else\n        if blockModeName in [\"GCM\", \"CCM\"]\n        then\n          securityAlert =\n            \"Use of block mode algorithm \" + blockModeName +\n              \" requires special crypto board approval/review.\"\n        else securityAlert = \"Use of unapproved block mode algorithm or API \" + blockModeName + \".\"\n    )\n    or\n    // Case 2: Check if the operation is a SymmetricCipher without a specified block mode algorithm\n    encryptionOperation instanceof SymmetricCipher and\n    not encryptionOperation.(SymmetricCipher).hasBlockMode() and\n    securityAlert = \"Cipher has unspecified block mode algorithm.\"\n  )\nselect encryptionOperation, securityAlert"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects classes violating naming conventions by starting with lowercase letters",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed class\n * @description Detects classes violating naming conventions by starting with lowercase letters\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-class\n * @tags maintainability\n */\n\nimport python\n\n// Helper predicate to identify classes with lowercase initial characters\npredicate hasLowerCaseInitial(Class cls) {\n  // Check if the first character of the class name is not uppercase\n  exists(string initialChar |\n    initialChar = cls.getName().prefix(1) and\n    not initialChar = initialChar.toUpperCase()\n  )\n}\n\n// Main query to find isolated naming violations\nfrom Class misnamedClass\nwhere\n  misnamedClass.inSource() and\n  hasLowerCaseInitial(misnamedClass) and\n  // Verify no other misnamed classes exist in the same file\n  not exists(Class otherMisnamedClass |\n    otherMisnamedClass != misnamedClass and\n    otherMisnamedClass.getLocation().getFile() = misnamedClass.getLocation().getFile() and\n    hasLowerCaseInitial(otherMisnamedClass)\n  )\nselect misnamedClass, \"Class names should start in uppercase.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression utilities with alias SuppressionUtils\nprivate import codeql.util.suppression.AlertSuppression as SuppressionUtils\n// Import Python comment handling utilities with alias CommentHandler\nprivate import semmle.python.Comment as CommentHandler\n\n// Define AST node representation extending Python's AST node\nclass SourceNode instanceof CommentHandler::AstNode {\n  /**\n   * Retrieves location information for the AST node\n   * @param sourceFile - Path to source file\n   * @param beginLine - Starting line number\n   * @param beginCol - Starting column number\n   * @param endLine - Ending line number\n   * @param endCol - Ending column number\n   */\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    // Delegate location resolution to parent class\n_______________ // 补全条件\n  }\n\n  // Provide string representation of the AST node\n  string toString() { result = super.toString() }\n}\n\n// Define single-line comment representation extending Python's comment class\nclass LineComment instanceof CommentHandler::Comment {\n  /**\n   * Retrieves location information for the comment\n   * @param sourceFile - Path to source file\n   * @param beginLine - Starting line number\n   * @param beginCol - Starting column number\n   * @param endLine - Ending line number\n   * @param endCol - Ending column number\n   */\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    // Delegate location resolution to parent class\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginCol, endLine, endCol)\n  }\n\n  // Extract text content from the comment\n  string getText() { result = super.getContents() }\n\n  // Provide string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Establish alert suppression relationships using CodeQL's Make template\nimport SuppressionUtils::Make<SourceNode, LineComment>\n\n/**\n * Represents a noqa suppression comment. Both pylint and pyflakes respect this annotation,\n * so LGTM analysis should also honor it.\n */\nclass NoqaSuppression extends SuppressionComment instanceof LineComment {\n  // Initialize with comments matching noqa pattern (case-insensitive)\n  NoqaSuppression() {\n    LineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Return the annotation identifier for LGTM\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Determine code coverage of this suppression comment\n  override predicate covers(\n    string sourceFile, int beginLine, int beginCol, int endLine, int endCol\n  ) {\n    // Verify comment location and ensure it starts at column 1 (line beginning)\n    this.hasLocationInfo(sourceFile, beginLine, _, endLine, endCol) and\n    beginCol = 1\n  }\n}",
    "output": "super.getLocation().hasLocationInfo(sourceFile, beginLine, beginCol, endLine, endCol)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Implicit string concatenation in a list\n * @description Identifies string literals that are implicitly concatenated within a list context.\n *              This pattern often indicates a missing comma between list elements and can lead to\n *              reduced code readability and potential maintenance issues.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-665\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/implicit-string-concatenation-in-list\n */\n\nimport python\n\n// Determines if an expression represents a string literal or a concatenation of string literals\npredicate isStringLiteralOrConcatenation(Expr expr) {\n  // Base case: Expression is a direct string literal\n  expr instanceof StringLiteral\n  // Recursive case: Expression is a binary operation combining string literals\n  or \n  exists(BinaryExpr concatenationOp | \n    expr = concatenationOp and \n    isStringLiteralOrConcatenation(concatenationOp.getLeft()) and \n    isStringLiteralOrConcatenation(concatenationOp.getRight())\n  )\n}\n\nfrom StringLiteral suspectString\nwhere\n  // Condition 1: Verify the string is part of an implicit concatenation\n  exists(suspectString.getAnImplicitlyConcatenatedPart()) and\n_______________ // 补全条件\n  not suspectString.isParenthesized() and\n  // Condition 3: Check if the string appears within a list containing other string constants\n  exists(List parentList |\n    // Verify the suspect string is an element of the list\n    parentList.getAnElt() = suspectString and\n    // Find another string constant in the same list\n    exists(Expr adjacentString |\n      adjacentString != suspectString and\n      parentList.getAnElt() = adjacentString and\n      isStringLiteralOrConcatenation(adjacentString)\n    )\n  )\nselect suspectString, \"Implicit string concatenation. Maybe missing a comma?\"",
    "output": "// Condition 2: Ensure the string is not explicitly wrapped in parentheses"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/failed-inheritance-inference]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects classes for which the inheritance hierarchy could not be resolved",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class inheritance hierarchy inference failure\n * @description Detects classes for which the inheritance hierarchy could not be resolved\n *              during the analysis process, which may impact the accuracy of analysis outcomes.\n * @id py/failed-inheritance-inference\n * @kind problem\n * @problem.severity info\n * @tags debug\n */\n\nimport python\n\n// Find classes experiencing inheritance inference problems along with the reasons for failure\nfrom Class problematicClass, string failureReason\nwhere exists(ClassObject classObj | \n    classObj.getPyClass() = problematicClass and \n    classObj.failedInference(failureReason))\nselect problematicClass, \"Failed to determine inheritance hierarchy for class '\" + problematicClass.getName() + \"': \" + failureReason + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The use of '\\b' inside character sets to represent backspace is ambiguous",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Ambiguous backspace escape in regex character set\n * @description The use of '\\b' inside character sets to represent backspace is ambiguous\n *              because it conflicts with the standard word boundary assertion interpretation.\n *              This can lead to confusion and potential bugs in regular expression patterns.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int escapeCharPosition\nwhere\n  // Identify escape character at the current position in the regex pattern\n  regexPattern.escapingChar(escapeCharPosition) and\n  // Confirm that 'b' immediately follows the escape character, forming '\\b'\n  regexPattern.getChar(escapeCharPosition + 1) = \"b\" and\n  // Ensure this '\\b' sequence is contained within a character set definition\n  exists(int charSetStart, int charSetEnd |\n    // The position must be within the bounds of a character set\n    charSetStart < escapeCharPosition and \n    charSetEnd > escapeCharPosition and\n    // Verify these positions indeed define a character set\n    regexPattern.charSet(charSetStart, charSetEnd)\n  )\nselect regexPattern, \"Ambiguous backspace escape in character set at offset \" + escapeCharPosition + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name 错误的类实例化参数数量\n * @description 识别在类实例化过程中参数数量不匹配的情况。当调用类的构造函数或\n *              `__init__` 方法时，如果提供的参数数量与定义不符，将导致运行时\n *              TypeError 异常，影响程序的可靠性。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstanceCall, ClassValue targetClass, string errorType, string constraintDescription, int expectedParamCount, FunctionValue classInitializer\nwhere\n  (\n    // 检测参数数量不匹配的情况\n    (\n      // 参数过多的情况\n      too_many_args(classInstanceCall, targetClass, expectedParamCount) and\n      errorType = \"too many arguments\" and\n      constraintDescription = \"no more than \"\n    )\n    or\n    (\n      // 参数过少的情况\n      too_few_args(classInstanceCall, targetClass, expectedParamCount) and\n      errorType = \"too few arguments\" and\n      constraintDescription = \"no fewer than \"\n    )\n  ) and\n  // 获取目标类的构造函数或初始化方法\n  classInitializer = get_function_or_initializer(targetClass)\nselect classInstanceCall, \n  \"Call to $@ with \" + errorType + \"; should be \" + constraintDescription + expectedParamCount.toString() + \".\", \n  classInitializer,\n  classInitializer.getQualifiedName()",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies functions with uppercase initial letters, violating Python naming conventions.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed function\n * @description Identifies functions with uppercase initial letters, violating Python naming conventions.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n * \n * This query detects functions whose names begin with uppercase letters, which contradicts PEP8 guidelines.\n * The exclusion logic prevents duplicate reports within the same file by filtering out functions when\n * another uppercase-named function exists in the same file. Note: This may reduce reporting frequency\n * in files containing multiple such functions.\n */\n\nimport python\n\nfrom Function func\nwhere\n  // Ensure function is source-defined (not library/built-in)\n  func.inSource() and\n  // Check if function name starts with uppercase letter\n  exists(string initialChar |\n    initialChar = func.getName().prefix(1) and\n    not initialChar = initialChar.toLowerCase()\n  ) and\n  // Exclude functions if another uppercase-named function exists in same file\n  not exists(Function otherFunc |\n    otherFunc != func and\n    otherFunc.getLocation().getFile() = func.getLocation().getFile() and\n    exists(string otherInitialChar |\n      otherInitialChar = otherFunc.getName().prefix(1) and\n      not otherInitialChar = otherInitialChar.toLowerCase()\n    )\n  )\nselect func, \"Function names should start in lowercase.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/shell-command-constructed-from-input]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Constructing shell commands from externally controlled strings",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unsafe shell command constructed from library input\n * @description Constructing shell commands from externally controlled strings\n *              may enable command injection attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.3\n * @precision medium\n * @id py/shell-command-constructed-from-input\n * @tags correctness\n *       security\n *       external/cwe/cwe-078\n *       external/cwe/cwe-088\n *       external/cwe/cwe-073\n */\n\n// Core Python language support\nimport python\n\n// Security analysis module for unsafe shell command construction\nimport semmle.python.security.dataflow.UnsafeShellCommandConstructionQuery\n\n// Path graph representation for data flow tracking\nimport UnsafeShellCommandConstructionFlow::PathGraph\n\n// Identify vulnerable command construction paths\nfrom\n  UnsafeShellCommandConstructionFlow::PathNode sourceNode, // External input source\n  UnsafeShellCommandConstructionFlow::PathNode sinkNode,    // Command execution point\n  Sink sinkInfo                                            // Detailed sink information\nwhere\n  // Verify data flow from external input to command execution\n  UnsafeShellCommandConstructionFlow::flowPath(sourceNode, sinkNode)\n  and\n  // Map flow node to detailed sink representation\n  sinkInfo = sinkNode.getNode()\nselect \n  // Vulnerability location: string construction details\n  sinkInfo.getStringConstruction(), \n  sourceNode, \n  sinkNode,\n  // Security context: input origin and command execution details\n  \"This \" + sinkInfo.describe() + \n  \" which depends on $@ is later used in a $@.\", \n  sourceNode.getNode(), \"library input\", \n  sinkInfo.getCommandExecution(), \"shell command\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Comparison of identical values\n * @description Detects redundant comparisons where a value is compared against itself,\n *              which usually indicates a logical error or unclear programming intent.\n_______________ // 补全条件\n * @tags reliability\n *       correctness\n *       readability\n *       convention\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-of-identical-expressions\n */\n\nimport python\nimport Expressions.RedundantComparison\n\n// Identify redundant comparisons while filtering out intentional cases\nfrom RedundantComparison redundantComparison\nwhere \n  // Skip constant comparisons which may represent intentional design patterns\n  not redundantComparison.isConstant() \n  // Avoid false positives when 'self' might be accidentally omitted\n  and not redundantComparison.maybeMissingSelf()\n// Report findings with remediation guidance for floating-point comparisons\nselect redundantComparison, \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\"",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Invalid keyword argument in class instantiation\n * @description Detects class instantiations using keyword arguments that don't match \n *              any parameter in the class's __init__ method, which will cause runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n_______________ // 补全条件\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call instanceCall, ClassValue instantiatedClass, string invalidArgName, FunctionValue initMethod\nwhere\n  // Obtain the initializer method for the target class\n  initMethod = get_function_or_initializer(instantiatedClass)\n  and\n  // Identify class instantiations containing invalid keyword arguments\n  illegally_named_parameter(instanceCall, instantiatedClass, invalidArgName)\nselect instanceCall, \n       \"Keyword argument '\" + invalidArgName + \"' is not a supported parameter name of $@.\", \n       initMethod,\n       initMethod.getQualifiedName()",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Overly permissive file permissions\n * @description Detects file operations that grant excessive read/write access to non-owner users, potentially exposing sensitive data.\n_______________ // 补全条件\n * @id py/overly-permissive-file\n * @problem.severity warning\n * @security-severity 7.8\n * @sub-severity high\n * @precision medium\n * @tags external/cwe/cwe-732\n *       security\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Extract world-readable/writable permission bits (lowest 3 bits) from octal mask\nbindingset[permValue]\nint get_world_perm_bits(int permValue) { \n  result = permValue % 8 \n}\n\n// Extract group-readable/writable permission bits (middle 3 bits) from octal mask\nbindingset[permValue]\nint get_group_perm_bits(int permValue) { \n  result = (permValue / 8) % 8 \n}\n\n// Convert permission bits to human-readable access type (read/write)\nbindingset[permValue]\nstring describe_access_type(int permValue) {\n  permValue % 4 >= 2 and result = \"writable\"  // Write bit set (bit 1)\n  or\n  permValue % 4 < 2 and permValue != 0 and result = \"readable\"  // Read-only (bit 0 set)\n}\n\n// Generate violation description for excessive permissions (world/group access)\nbindingset[permValue]\nstring get_perm_violation_desc(int permValue) {\n  result = \"world \" + describe_access_type(get_world_perm_bits(permValue))  // World access violation\n  or\n  get_world_perm_bits(permValue) = 0 and result = \"group \" + describe_access_type(get_group_perm_bits(permValue))  // Group access violation\n}\n\n// Identify os.chmod calls with explicit permission mask\npredicate is_chmod_op(API::CallNode fileApiCall, string opName, int permMask) {\n  fileApiCall = API::moduleImport(\"os\").getMember(\"chmod\").getACall() and\n  permMask = fileApiCall.getParameter(1, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue() and\n  opName = \"chmod\"\n}\n\n// Identify os.open calls with explicit permission mask\npredicate is_open_op(API::CallNode fileApiCall, string opName, int permMask) {\n  fileApiCall = API::moduleImport(\"os\").getMember(\"open\").getACall() and\n  permMask = fileApiCall.getParameter(2, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue() and\n  opName = \"open\"\n}\n\n// Detect file operations with overly permissive permissions\nfrom API::CallNode fileApiCall, string opName, int permMask, string permViolationDesc\nwhere\n  (is_chmod_op(fileApiCall, opName, permMask) or is_open_op(fileApiCall, opName, permMask)) and\n  permViolationDesc = get_perm_violation_desc(permMask)\nselect fileApiCall, \"Overly permissive mask in \" + opName + \" sets file to \" + permViolationDesc + \".\"",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Missing docstring\n * @description Public classes, functions, or methods without documentation strings\n *              hinder code maintainability and understanding for other developers.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/missing-docstring\n */\n\n/*\n * NOTE: The 'medium' precision reflects the subjective nature of docstring requirements.\n * The necessity of a docstring often depends on the context and intended audience.\n */\n\nimport python\n\n// Determines if a given code scope should have a documentation string\npredicate should_have_docstring(Scope targetScope) {\n  // The scope must be public and meet one of the following criteria:\n  // - It's not a function\n  // - It's a function that meets docstring requirements\n  targetScope.isPublic() and\n  (\n    not targetScope instanceof Function\n    or\n    function_needs_docstring(targetScope)\n  )\n}\n\n// Evaluates whether a function requires a documentation string\npredicate function_needs_docstring(Function targetFunction) {\n  // A function requires a docstring if it meets all these conditions:\n  // 1. It doesn't override a base method that doesn't require a docstring\n  // 2. It's not a lambda function\n  // 3. Its code length (excluding decorators) exceeds 2 lines\n  // 4. It's not a property getter or setter method\n  not exists(FunctionValue overridingFunction, FunctionValue baseFunction | \n    overridingFunction.overrides(baseFunction) and overridingFunction.getScope() = targetFunction |\n    not function_needs_docstring(baseFunction.getScope())\n  ) and\n  targetFunction.getName() != \"lambda\" and\n  (targetFunction.getMetrics().getNumberOfLinesOfCode() - count(targetFunction.getADecorator())) > 2 and\n  not exists(PythonPropertyObject propertyObj |\n    propertyObj.getGetter().getFunction() = targetFunction or\n    propertyObj.getSetter().getFunction() = targetFunction\n  )\n}\n\n// Provides a type description for the given code scope\nstring describe_scope_type(Scope targetScope) {\n  // Returns \"Module\" for non-package modules\n  result = \"Module\" and targetScope instanceof Module and not targetScope.(Module).isPackage()\n  // Returns \"Class\" for class scopes\n  or\n  result = \"Class\" and targetScope instanceof Class\n  // Returns \"Function\" for function scopes\n  or\n  result = \"Function\" and targetScope instanceof Function\n}\n\n// Identifies public scopes that lack required documentation strings\n_______________ // 补全条件\nwhere should_have_docstring(targetScope) and not exists(targetScope.getDocString())\nselect targetScope, describe_scope_type(targetScope) + \" \" + targetScope.getName() + \" does not have a docstring.\"",
    "output": "from Scope targetScope"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Method Cohesion Deficiency (CK Metric)\n * @description Detects classes with poor method cohesion using Chidamber and Kemerer's metric.\n * @kind treemap\n * @id py/lack-of-cohesion-chidamber-kemerer\n_______________ // 补全条件\n * @metricType reftype\n * @metricAggregate avg max\n */\n\nimport python\n\n// Identify all Python classes and evaluate their method cohesion deficiency\n// Higher values indicate poorer cohesion according to Chidamber-Kemerer metric\nfrom ClassMetrics targetClass\nselect targetClass, targetClass.getLackOfCohesionCK() as cohesionMetric order by cohesionMetric desc",
    "output": "* @treemap.warnOn highValues"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-global]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects 'global' declarations outside module scope, which may lead to code maintainability issues.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of the 'global' statement.\n * @description Detects 'global' declarations outside module scope, which may lead to code maintainability issues.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/use-of-global\n */\n\nimport python\n\n// This query identifies global variable declarations that are not at the module level,\n// which can be a sign of poor code organization and make the code harder to maintain.\nfrom Global globalDecl\nwhere \n  // Check if the global declaration is not at the module scope\n  not globalDecl.getScope() instanceof Module\n// We report each non-module global declaration with a message discouraging this practice.\nselect globalDecl, \"Usage of global variables outside of module initialization is considered bad practice and is discouraged.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Superclass attribute shadows subclass method\n * @description 定义在超类方法中的一个属性，其名称与子类方法匹配，会隐藏子类的方法。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 检测子类方法是否被超类中定义的属性遮蔽\n * 关键点：超类在__init__方法中定义的属性会遮蔽子类同名方法\n */\n\nimport python\n\n// 判断子类方法是否被超类属性遮蔽的谓词\npredicate shadowed_by_super_class(\n  ClassObject subClass, ClassObject superClass, Assign attrAssign, FunctionObject shadowedMethod\n) {\n  // 基础继承关系验证\n  subClass.getASuperType() = superClass and\n  \n  // 子类声明了被遮蔽的方法\n  subClass.declaredAttribute(_) = shadowedMethod and\n  \n  // 定位超类中的属性定义\n  exists(FunctionObject superInit, Attribute attrNode |\n    // 超类必须定义__init__方法\n    superClass.declaredAttribute(\"__init__\") = superInit and\n    \n    // 属性赋值发生在__init__方法内\n    attrAssign.getScope() = superInit.getOrigin().(FunctionExpr).getInnerScope() and\n    \n    // 赋值目标是通过self访问的属性\n    attrNode = attrAssign.getATarget() and\n    attrNode.getObject().(Name).getId() = \"self\" and\n_______________ // 补全条件\n    // 属性名与子类方法名相同\n    attrNode.getName() = shadowedMethod.getName()\n  ) and\n  \n  // 排除超类已定义同名方法的情况\n  not superClass.hasAttribute(shadowedMethod.getName())\n}\n\n// 查询被遮蔽的子类方法\nfrom ClassObject subClass, ClassObject superClass, Assign attrAssign, FunctionObject shadowedMethod\nwhere shadowed_by_super_class(subClass, superClass, attrAssign, shadowedMethod)\n// 输出结果：方法位置、描述信息、遮蔽属性位置、属性类型标识\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superClass.getName() +\n    \"'.\", attrAssign, \"attribute\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Timing attack against secret\n * @description Identifies non-constant-time verification routines for secret values,\n *              which could enable timing attacks exposing sensitive information.\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/possible-timing-attack-sensitive-info\n * @tags security\n *       external/cwe/cwe-208\n *       experimental\n */\n\n// Core Python language analysis imports\nimport python\n// Data flow analysis framework\nimport semmle.python.dataflow.new.DataFlow\n// Taint propagation capabilities\nimport semmle.python.dataflow.new.TaintTracking\n// Experimental timing attack detection utilities\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * Configuration for tracking data flow from secret origins to non-constant-time comparisons.\n * This setup identifies potential timing attack vulnerabilities in code.\n */\nprivate module TimingAttackConfig implements DataFlow::ConfigSig {\n  // Define sources: nodes representing secret origins\n  predicate isSource(DataFlow::Node secretSource) { \n    secretSource instanceof SecretSource \n  }\n\n  // Define sinks: nodes representing non-constant-time comparison operations\n  predicate isSink(DataFlow::Node nonConstantTimeComparisonSink) { \n    nonConstantTimeComparisonSink instanceof NonConstantTimeComparisonSink \n  }\n\n  // Enable differential observation mode for all scenarios\n  predicate observeDiffInformedIncrementalMode() { \n    any() \n  }\n}\n\n// Establish global taint tracking using the timing attack configuration\nmodule TimingAttackFlow = TaintTracking::Global<TimingAttackConfig>;\n\n// Import path visualization module for flow paths\nimport TimingAttackFlow::PathGraph\n\n// Main query to detect timing attack vulnerabilities\nfrom\n_______________ // 补全条件\n  TimingAttackFlow::PathNode comparisonTarget    // Target comparison operation\nwhere \n  // Verify existence of flow path from secret origin to comparison target\n  TimingAttackFlow::flowPath(secretOrigin, comparisonTarget)\nselect \n  comparisonTarget.getNode(),   // Location where vulnerability manifests\n  secretOrigin,                 // Origin of the flow\n  comparisonTarget,             // Termination point of the flow\n  \"Timing attack against $@ verification.\", // Security alert\n  secretOrigin.getNode(),       // Reference point for alert\n  \"client-provided secret\"      // Description of the sensitive source",
    "output": "TimingAttackFlow::PathNode secretOrigin,      // Origin of the secret data"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unreachable-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Handling general exceptions before specific exceptions means that the specific",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unreachable 'except' block\n * @description Handling general exceptions before specific exceptions means that the specific\n *              handlers are never executed.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n/**\n * Retrieves the exception type associated with an exception handler.\n * @param handler - The exception statement to analyze\n * @return The class value representing the handled exception type\n */\nClassValue getExceptionClass(ExceptStmt handler) { \n  handler.getType().pointsTo(result) \n}\n\n// Main query to detect unreachable exception handlers\nfrom ExceptStmt subsequentHandler, ClassValue specificException, \n     ExceptStmt precedingHandler, ClassValue broaderException\nwhere \n  exists(int precedingIndex, int subsequentIndex, Try tryStmt |\n    // Both handlers must belong to the same try statement\n    precedingHandler = tryStmt.getHandler(precedingIndex) and\n    subsequentHandler = tryStmt.getHandler(subsequentIndex) and\n    // Verify handlers appear in correct sequence\n    precedingIndex < subsequentIndex and\n    // Retrieve exception types for both handlers\n    broaderException = getExceptionClass(precedingHandler) and\n    specificException = getExceptionClass(subsequentHandler) and\n    // Check inheritance: broader exception is superclass of specific exception\n    broaderException = specificException.getASuperType()\n  )\nselect subsequentHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  specificException, specificException.getName(), precedingHandler, \"except block\", broaderException, broaderException.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Source File Type Classification\n * @description Identifies and classifies code files by detecting auto-generated\n *              artifacts and test components using pattern recognition and\n *              structural context analysis. This classification enables\n *              security analysts to filter and prioritize code review efforts\n *              based on file origin and purpose.\n * @kind file-classifier\n * @id py/file-classifier\n */\n\n// Import core Python analysis framework for language-specific processing\nimport python\n// Import auto-generated code detection utilities for identifying machine-created files\nimport semmle.python.filters.GeneratedCode\n// Import test identification module for locating test-related code components\nimport semmle.python.filters.Tests\n\n// Core classification logic that determines file type based on generation source and functional context\nfrom File sourceFile, string classificationType\nwhere \n  // Classification condition 1: Files automatically produced by code generation tools or processes\n  (sourceFile instanceof GeneratedFile and classificationType = \"generated\")\n  // Classification condition 2: Files located within test directories or serving test functions\n_______________ // 补全条件\n  (exists(TestScope testScope | testScope.getLocation().getFile() = sourceFile) and classificationType = \"test\")\nselect sourceFile, classificationType",
    "output": "or"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "import python\n\n/**\n * @name Integer division result may be truncated in Python 2\n * @description Detects integer division operations in Python 2 that may truncate results.\n *              In Python 2, the '/' operator performs floor division when both operands\n *              are integers, which can lead to unexpected truncation of fractional parts.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\n// Identify integer division operations that may produce truncated results\nfrom BinaryExpr divisionExpr, ControlFlowNode leftOperand, ControlFlowNode rightOperand\nwhere\n  // Target only Python 2 environments where this behavior exists\n  major_version() = 2 and\n  \n  // Verify the operation is a division with integer operands\n  exists(BinaryExprNode binaryExprNode, Value leftIntValue, Value rightIntValue |\n    // Check if the expression is a division operation\n    binaryExprNode = divisionExpr.getAFlowNode() and\n    binaryExprNode.getNode().getOp() instanceof Div and\n    \n    // Verify both operands are integers\n    binaryExprNode.getLeft().pointsTo(leftIntValue, leftOperand) and\n    leftIntValue.getClass() = ClassValue::int_() and\n_______________ // 补全条件\n    rightIntValue.getClass() = ClassValue::int_() and\n    \n    // Exclude cases where division would have no remainder\n    not leftIntValue.(NumericValue).getIntValue() % rightIntValue.(NumericValue).getIntValue() = 0 and\n    \n    // Exclude modules that have enabled true division via future import\n    not binaryExprNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // Exclude cases where the result is explicitly converted to int\n    not exists(CallNode intConversionCall |\n      intConversionCall = ClassValue::int_().getACall() and\n      intConversionCall.getAnArg() = binaryExprNode\n    )\n  )\nselect divisionExpr, \n  \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftOperand, \"left\", rightOperand, \"right\"",
    "output": "binaryExprNode.getRight().pointsTo(rightIntValue, rightOperand) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mostly-duplicate-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies modules with substantial code duplication. Consolidation improves maintainability and reduces technical debt.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Significant code duplication detector\n * @description Identifies modules with substantial code duplication. Consolidation improves maintainability and reduces technical debt.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-file\n */\n\nimport python\n\nfrom \n  Module sourceModule,\n  Module duplicateModule,\n  string alertMessage\nwhere \n  none()\nselect \n  sourceModule,\n  alertMessage,\n  duplicateModule,\n  duplicateModule.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-url-substring-sanitization]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Security checks that operate on substrings of unparsed URLs are vulnerable to bypass attacks,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks that operate on substrings of unparsed URLs are vulnerable to bypass attacks, \n *              as they don't account for the entire URL structure\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Defines regex pattern for common top-level domains used in URL validation\nprivate string commonTldRegex() { result = \"com|org|edu|gov|uk|net|io\" }\n\n// Determines if a string literal exhibits URL-like characteristics\npredicate showsUrlFeatures(StringLiteral urlLiteral) {\n  exists(string textContent | textContent = urlLiteral.getText() |\n    textContent.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + commonTldRegex() + \")(:[0-9]+)?/?\")\n    or\n    textContent.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Detects expressions performing incomplete URL substring sanitization\npredicate containsIncompleteSanitization(Expr expr, StringLiteral urlLiteral) {\n  showsUrlFeatures(urlLiteral) and\n  (\n    expr.(Compare).compares(urlLiteral, any(In op), _)\n    or\n    // Unsafe startswith usage\n    exists(Call methodCall |\n      methodCall.getFunc().(Attribute).getName() = \"startswith\" and\n      methodCall.getArg(0) = urlLiteral and\n      not urlLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\") and\n      expr = methodCall\n    )\n    or\n    // Unsafe endswith usage\n    exists(Call methodCall |\n      methodCall.getFunc().(Attribute).getName() = \"endswith\" and\n      methodCall.getArg(0) = urlLiteral and\n      not urlLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\") and\n      expr = methodCall\n    )\n  )\n}\n\n// Find expressions exhibiting incomplete URL substring sanitization patterns\nfrom Expr expr, StringLiteral urlLiteral\nwhere containsIncompleteSanitization(expr, urlLiteral)\nselect expr, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlLiteral,\n  urlLiteral.getText()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-shadowed-loop-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies instances where a loop variable shares the same name as an imported module,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Import shadowed by loop variable\n * @description Identifies instances where a loop variable shares the same name as an imported module,\n *              which can lead to code confusion and potential runtime errors.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision very-high\n * @id py/import-shadowed-loop-variable\n */\n\n// Import the Python analysis library to examine code structures and relationships\nimport python\n\n// Identify variables that shadow imported module names within loop constructs\nfrom Variable shadowingVariable, Name variableDefinition\nwhere \n  // Verify there's an import statement being shadowed by our variable\n  exists(Import importedModule, Name importedAlias |\n    // The imported alias name must match the loop variable identifier\n    importedAlias.getId() = shadowingVariable.getId() and\n    \n    // Ensure the alias is defined via an 'as' clause in an import statement\n    importedAlias = importedModule.getAName().getAsname() and\n    \n    // Confirm the import's scope encompasses the variable's scope (hierarchical containment)\n    importedModule.getScope() = shadowingVariable.getScope().getScope*() and\n    \n    // Validate that the name definition corresponds to our shadowing variable\n    variableDefinition.defines(shadowingVariable) and\n    \n    // Ensure the definition is used as a target in a for loop (confirming loop variable status)\n    exists(For forLoopStatement | variableDefinition = forLoopStatement.getTarget())\n  )\n// Select the variable definition node and generate an appropriate warning message\nselect variableDefinition, \"Loop variable '\" + shadowingVariable.getId() + \"' shadows an import.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Reflected server-side cross-site scripting\n * @description Detects security vulnerabilities where untrusted user-supplied data\n *              is directly rendered in web content without proper sanitization,\n *              enabling attackers to execute malicious scripts in victims' browsers.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @sub-severity high\n * @precision high\n * @id py/reflective-xss\n * @tags security\n *       external/cwe/cwe-079\n *       external/cwe/cwe-116\n */\n\n// Import necessary modules for XSS vulnerability detection\nimport python\nimport semmle.python.security.dataflow.ReflectedXssQuery\nimport ReflectedXssFlow::PathGraph\n\n// Define source and sink nodes for XSS vulnerability analysis\nfrom \n  ReflectedXssFlow::PathNode maliciousInputOrigin,  // Entry point of untrusted user data\n  ReflectedXssFlow::PathNode xssVulnerableSink      // Location where data is unsafely output\n_______________ // 补全条件\n// Verify data flow from untrusted input to vulnerable sink\nwhere ReflectedXssFlow::flowPath(maliciousInputOrigin, xssVulnerableSink)\n\n// Generate security alert with detailed vulnerability information\nselect \n  xssVulnerableSink.getNode(),                      // Location of the vulnerable sink\n  maliciousInputOrigin,                             // Source of the untrusted input\n  xssVulnerableSink,                                // Path node information\n  \"Cross-site scripting vulnerability caused by a $@.\", // Alert message\n  maliciousInputOrigin.getNode(),                   // Source node location\n  \"user-provided input\"                             // Source description",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Lines of commented-out code in files\n * @description The number of lines of commented out code per file\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType file\n * @tags maintainability\n_______________ // 补全条件\n */\n\n// Import Python language support and lexical analysis for commented code\nimport python\nimport Lexical.CommentedOutCode\n\n// Define variables representing source files and their comment metrics\nfrom File sourceFile, int commentLineCount\n// Calculate the total count of non-example commented lines per file\nwhere commentLineCount = count(CommentedOutCodeLine commentedLine | \n        not commentedLine.maybeExampleCode() and \n        commentedLine.getLocation().getFile() = sourceFile)\n// Return files with their comment counts, sorted from highest to lowest\nselect sourceFile, commentLineCount order by commentLineCount desc",
    "output": "* @id py/lines-of-commented-out-code-in-files"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python extraction warnings\n * @description Identifies extraction warnings for Python files in the source code directory.\n * @kind diagnostic\n * @id py/diagnostics/extraction-warnings\n */\n\nimport python\n\n/**\n * Determines the SARIF severity level for warnings.\n * \n_______________ // 补全条件\n */\nint getWarningSeverity() { result = 1 }\n\n// SARIF specification (https://docs.oasis-open.org/sarif/sarif/v2.1.0/csprd01/sarif-v2.1.0-csprd01.html#_Toc10541338) defines error levels:\n//\n// \"error\": A critical issue was found. The tool encountered a condition that caused analysis to be aborted or results to be incorrect/incomplete.\n//\n// \"warning\": A non-critical issue was found. The tool encountered a condition where it's uncertain if a problem occurred, or analysis may be incomplete but generated results are potentially valid.\n//\n// SyntaxErrors are reported as warnings since analysis may be incomplete but generated results remain potentially valid.\nfrom SyntaxError syntaxErr, File sourceFile\nwhere\n  sourceFile = syntaxErr.getFile() and // Retrieve the file where the error occurred\n  exists(sourceFile.getRelativePath()) // Ensure the file has a valid relative path\nselect \n  syntaxErr, \n  \"Extraction failed in \" + sourceFile + \" with error \" + syntaxErr.getMessage(), // Format diagnostic message\n  getWarningSeverity() // Assign warning severity level",
    "output": "* Reference: https://docs.oasis-open.org/sarif/sarif/v2.1.0/csprd01/sarif-v2.1.0-csprd01.html#_Toc10541338"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of weak cryptographic key\n * @description Use of a cryptographic key that is too small may allow the encryption to be broken.\n * @kind problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/weak-crypto-key\n * @tags security\n *       external/cwe/cwe-326\n */\n\nimport python\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.filters.Tests\n\n_______________ // 补全条件\nfrom Cryptography::PublicKey::KeyGeneration keyCreation, int weakKeySize, DataFlow::Node sourceNode\nwhere\n  // 获取密钥生成操作中的密钥大小及其来源节点\n  weakKeySize = keyCreation.getKeySizeWithOrigin(sourceNode) and\n  // 验证密钥大小是否低于安全阈值\n  weakKeySize < keyCreation.minimumSecureKeySize() and\n  // 确保密钥生成不在测试代码范围内\n  not sourceNode.getScope().getScope*() instanceof TestScope\nselect keyCreation,\n  \"Creation of an \" + keyCreation.getName() + \" key uses $@ bits, which is below \" +\n    keyCreation.minimumSecureKeySize() + \" and considered breakable.\", sourceNode, weakKeySize.toString()",
    "output": "// 查询目标：识别使用不安全密钥长度的加密密钥生成操作"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/encoding-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Python code with incorrect character encoding configurations",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Encoding error\n * @description Identifies Python code with incorrect character encoding configurations\n *              that may trigger runtime exceptions and obstruct static analysis.\n * @kind problem\n * @id py/encoding-error\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n */\n\nimport python\n\n// Identify all encoding-related configuration issues in the Python codebase\nfrom EncodingError encodingProblem\n\n// Extract the diagnostic message for each encoding problem\n// and present it alongside the problem instance\nselect encodingProblem, encodingProblem.getMessage()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Comparison of constants\n * @description Detects comparisons between constant values. These comparisons always yield\n *              the same result but are less readable than using boolean literals directly.\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n_______________ // 补全条件\n * @id py/comparison-of-constants\n */\n\nimport python\n\n// Identify constant comparison expressions in the code\nfrom Compare constantComparison, Expr leftOperand, Expr rightOperand\nwhere\n  // Verify the operation is a comparison with two operands\n  constantComparison.compares(leftOperand, _, rightOperand) and\n  // Ensure both operands are constant values\n  leftOperand.isConstant() and\n  rightOperand.isConstant() and\n  // Exclude comparisons used in assert statements as they may be intentional\n  not exists(Assert assertStmt | assertStmt.getTest() = constantComparison)\nselect constantComparison, \"Comparison of constants; use 'True' or 'False' instead.\"",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Identifies cryptographic operations that employ elliptic curve algorithms which are either \n *              unrecognized or considered cryptographically weak, potentially leading to security vulnerabilities.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm cryptoOperation, string securityWarning, string ellipticCurveName\nwhere\n  // Extract the elliptic curve name from the cryptographic operation\n  ellipticCurveName = cryptoOperation.getCurveName() and\n  (\n    // Case 1: Unrecognized curve algorithm\n    ellipticCurveName = unknownAlgorithm() and\n    securityWarning = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: Recognized but weak curve algorithm\n    ellipticCurveName != unknownAlgorithm() and\n    not ellipticCurveName =\n      [\n        \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n        \"SECP384R1\",              // P-384 curve\n        \"SECP521R1\",              // P-521 curve\n        \"ED25519\",                // Ed25519 curve\n        \"X25519\"                  // X25519 curve\n      ] and\n_______________ // 补全条件\n  )\nselect cryptoOperation, securityWarning",
    "output": "securityWarning = \"Use of weak curve algorithm \" + ellipticCurveName + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/unmatchable-caret]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies regular expressions that contain a caret '^' character",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unmatchable caret in regular expression\n * @description Identifies regular expressions that contain a caret '^' character\n *              in positions other than the start, rendering them incapable of\n *              matching any input under standard interpretation modes.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/regex/unmatchable-caret\n */\n\nimport python\nimport semmle.python.regex\n\n// Define variables for regex pattern and caret location analysis\nfrom RegExp regexPattern, int caretPosition\n\n// Check for problematic caret usage by verifying multiple conditions:\n// Ensure regex is not in MULTILINE mode (where '^' can match line starts)\nwhere not regexPattern.getAMode() = \"MULTILINE\"\n\n// Ensure regex is not in VERBOSE mode (which might alter interpretation)\nand not regexPattern.getAMode() = \"VERBOSE\"\n\n// Confirm the presence of a caret character at the specified position\nand regexPattern.specialCharacter(caretPosition, caretPosition + 1, \"^\")\n\n// Verify the caret is not at the beginning of the regex pattern\nand not regexPattern.firstItem(caretPosition, caretPosition + 1)\n\n// Generate alert with position information for the identified issue\nselect regexPattern,\n  \"Unmatchable caret detected at offset \" + caretPosition.toString() + \" in this regular expression.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import CodeQL alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing module\nprivate import semmle.python.Comment as P\n\n// Represents AST nodes with location tracking capabilities\nclass AstNode instanceof P::AstNode {\n  // Verify node matches specified location coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n_______________ // 补全条件\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Return string representation of the AST node\n  string toString() { result = super.toString() }\n}\n\n// Represents single-line comments with location tracking\nclass SingleLineComment instanceof P::Comment {\n  // Verify comment matches specified location coordinates\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Retrieve text content of the comment\n  string getText() { result = super.getContents() }\n\n  // Return string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships using AS template\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Represents noqa-style suppression comments\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Initialize by matching noqa comment pattern\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Return suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define code coverage scope for this suppression\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Match comment location and enforce line-start position\n    this.hasLocationInfo(filePath, startLine, _, endLine, endCol) and\n    startCol = 1\n  }\n}",
    "output": ") {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-weak-mode]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies Key Derivation Function (KDF) implementations that use modes other than CounterMode,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insecure KDF Configuration\n * @description Identifies Key Derivation Function (KDF) implementations that use modes other than CounterMode,\n *              which are considered vulnerable to attacks. Proper KDF security requires CounterMode usage.\n * @kind problem\n * @id py/kdf-weak-mode\n * @problem.severity error\n * @precision high\n */\n\n// Import Python language support\nimport python\n// Import experimental cryptography security analysis concepts\nimport experimental.cryptography.Concepts\n// Import experimental cryptography utilities with alias for helper functions\nprivate import experimental.cryptography.utils.Utils as Utils\n\n// Find KDF operations with insecure mode configurations\nfrom KeyDerivationOperation keyDerivationOp, DataFlow::Node modeSource\nwhere\n  // Ensure the KDF operation requires mode configuration\n  keyDerivationOp.requiresMode() and\n  // Identify the source of the mode configuration\n  modeSource = keyDerivationOp.getModeSrc() and\n  // Check that the mode is not the secure CounterMode\n  not modeSource =\n    API::moduleImport(\"cryptography\")\n        .getMember(\"hazmat\")\n        .getMember(\"primitives\")\n        .getMember(\"kdf\")\n        .getMember(\"kbkdf\")\n        .getMember(\"Mode\")\n        .getMember(\"CounterMode\")\n        .asSource()\n// Report the insecure KDF operation with details about the problematic mode configuration\nselect keyDerivationOp, \"Key derivation mode is not set to CounterMode. Mode Config: $@\", modeSource,\n  modeSource.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Duplicate code block\n_______________ // 补全条件\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @deprecated\n * @precision medium\n * @id py/duplicate-block\n */\n\nimport python\n\n// Identify code segments represented as basic blocks\nfrom BasicBlock duplicateBlock\n// Apply filtering condition that excludes all results (preserving original logic)\nwhere duplicateBlock != duplicateBlock\n// Generate output message for identified duplicate code blocks\nselect duplicateBlock, \n       \"Duplicate code: \" + \n       \"-1\" + \n       \" lines are duplicated at \" + \n       \"<file>\" + \n       \":\" + \n       \"-1\"",
    "output": "* @description Identifies duplicated code blocks. Refactoring shared code into a single occurrence is recommended when feasible. Note that this query provides broad coverage; higher-confidence duplicates are detected by specialized checks like duplicate function/class detection. Not all findings may be addressable due to contextual differences."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/side-effect-in-assert]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects assert statements containing expressions with side effects,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name An assert statement has a side-effect\n * @description Detects assert statements containing expressions with side effects,\n *              which can cause behavioral differences between normal and optimized execution.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/side-effect-in-assert\n */\n\nimport python\n\n// 判断表达式是否调用具有副作用的内置函数\npredicate has_side_effect_function(Expr expression) {\n  exists(string funcName | \n    funcName = expression.(Attribute).getName() or funcName = expression.(Name).getId() |\n    funcName in [\n        \"print\", \"write\", \"append\", \"pop\", \"remove\", \"discard\", \"delete\", \"close\", \"open\", \"exit\"\n      ]\n  )\n}\n\n// 判断是否调用subprocess模块中的系统命令\npredicate is_subprocess_call(Call methodCall) {\n  exists(string subprocessFunc | \n    subprocessFunc = \"subprocess.call\" or \n    subprocessFunc = \"subprocess.check_call\" or \n    subprocessFunc = \"subprocess.check_output\" |\n    methodCall.getAFlowNode() = Value::named(subprocessFunc).getACall()\n  )\n}\n\n// 综合判断表达式是否可能产生副作用\npredicate may_cause_side_effect(Expr expression) {\n  // 检查是否为yield表达式（排除推导式中的伪yield）\n  expression instanceof Yield and not exists(Comp c | c.contains(expression))\n  or\n  // 检查是否为YieldFrom表达式\n  expression instanceof YieldFrom\n  or\n  // 检查是否调用具有副作用的函数\n  exists(Call methodCall | \n    methodCall = expression and \n    has_side_effect_function(methodCall.getFunc())\n  )\n  or\n  // 检查是否调用subprocess系统命令\n  exists(Call methodCall | \n    methodCall = expression and \n    is_subprocess_call(methodCall)\n  )\n}\n\n// 查询包含副作用表达式的断言语句\nfrom Assert assertStmt, Expr expression\nwhere may_cause_side_effect(expression) and assertStmt.contains(expression)\nselect assertStmt, \"This 'assert' statement contains an $@ which may have side effects.\", expression, \"expression\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects vulnerabilities where user-controlled inputs directly influence cookie values,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted Cookie Value Injection\n * @description Detects vulnerabilities where user-controlled inputs directly influence cookie values,\n *              potentially enabling session hijacking or data tampering. This pattern violates\n *              CWE-20 (Improper Input Validation) and exposes systems to cookie-based attacks.\n * @id py/untrusted-cookie-injection\n * @kind path-problem\n * @precision medium\n * @problem.severity high\n * @security-severity 8.7\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\nfrom \n  CookieInjectionFlow::PathNode maliciousInputSource, \n  CookieInjectionFlow::PathNode vulnerableCookieSink, \n  int flowConfigId\nwhere \n  flowConfigId = 1\n  and CookieInjectionFlow::flowPath(maliciousInputSource, vulnerableCookieSink)\nselect \n  vulnerableCookieSink.getNode(), \n  maliciousInputSource, \n  vulnerableCookieSink, \n  \"Cookie value constructed from $@.\", \n  maliciousInputSource.getNode(), \n  \"untrusted user input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes metrics for different kinds of type annotations in Python code,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Computes metrics for different kinds of type annotations in Python code, \n *              including parameters, return types, and annotated assignments.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents built-in Python types\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements supporting type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr func) { exists(func.getReturns()) } or\n  TAnnotatedParameter(Parameter param) { exists(param.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign stmt) { exists(stmt.getAnnotation()) }\n\n// Abstract base class for type-annotated elements\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr functionExpr;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(functionExpr) }\n  override Expr getAnnotation() { result = functionExpr.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter parameter;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(parameter) }\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assignmentStmt;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assignmentStmt) }\n  override Expr getAnnotation() { result = assignmentStmt.getAnnotation() }\n}\n\n/** Holds if `annotationExpr` is a forward declaration using string literal */\npredicate is_forward_declaration(Expr annotationExpr) { \n  annotationExpr instanceof StringLiteral \n}\n\n/** Holds if `annotationExpr` represents a complex type construct */\npredicate is_complex_type(Expr annotationExpr) {\n  (annotationExpr instanceof Subscript and not is_optional_type(annotationExpr)) or\n  annotationExpr instanceof Tuple or\n  annotationExpr instanceof List\n}\n\n/** Holds if `annotationExpr` is an Optional type annotation */\npredicate is_optional_type(Subscript annotationExpr) { \n  annotationExpr.getObject().(Name).getId() = \"Optional\" \n}\n\n/** Holds if `annotationExpr` is a simple non-built-in type identifier */\npredicate is_simple_type(Expr annotationExpr) {\n  (annotationExpr instanceof Name and not annotationExpr instanceof BuiltinType) or\n  (annotationExpr instanceof Attribute and is_simple_type(annotationExpr.(Attribute).getObject()))\n}\n\n/** Holds if `annotationExpr` is a built-in type */\npredicate is_builtin_type(Expr annotationExpr) { \n  annotationExpr instanceof BuiltinType \n}\n\n// Calculates type annotation metrics for each annotation category\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  category = \"Parameter annotation\" and\n  totalCount = count(AnnotatedParameter param) and\n  builtinCount = count(AnnotatedParameter param | is_builtin_type(param.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedParameter param | is_forward_declaration(param.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedParameter param | is_simple_type(param.getAnnotation())) and\n  complexTypeCount = count(AnnotatedParameter param | is_complex_type(param.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedParameter param | is_optional_type(param.getAnnotation()))\n  or\n  // Return type annotation metrics\n  category = \"Return type annotation\" and\n  totalCount = count(AnnotatedFunction func) and\n  builtinCount = count(AnnotatedFunction func | is_builtin_type(func.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedFunction func | is_forward_declaration(func.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedFunction func | is_simple_type(func.getAnnotation())) and\n  complexTypeCount = count(AnnotatedFunction func | is_complex_type(func.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedFunction func | is_optional_type(func.getAnnotation()))\n  or\n  // Annotated assignment metrics\n  category = \"Annotated assignment\" and\n  totalCount = count(AnnotatedAssignment assign) and\n  builtinCount = count(AnnotatedAssignment assign | is_builtin_type(assign.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedAssignment assign | is_forward_declaration(assign.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedAssignment assign | is_simple_type(assign.getAnnotation())) and\n  complexTypeCount = count(AnnotatedAssignment assign | is_complex_type(assign.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedAssignment assign | is_optional_type(assign.getAnnotation()))\n}\n\n// Main query execution\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Detection of unsafe 'input' function in Python 2\n * @description Identifies usage of the built-in 'input' function which, in Python 2, \n *              can execute arbitrary code provided as input, posing a security risk.\n * @kind problem\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/use-of-input\n */\n\nimport python  // Provides fundamental capabilities for Python language analysis\nimport semmle.python.dataflow.new.DataFlow  // Enables data flow analysis to trace code execution paths\nimport semmle.python.ApiGraphs  // Facilitates identification and analysis of standard library function calls\n\n// Identify potentially dangerous invocations of the 'input' function in Python 2 code\nfrom DataFlow::CallCfgNode riskyInputInvocation\nwhere\n  // Verify that the code is intended to run in a Python 2 environment\n  major_version() = 2\n  and\n  (\n    // Locate calls to the built-in 'input' function, which in Python 2 evaluates\n    // the input as Python code, creating a code injection vulnerability\n    riskyInputInvocation = API::builtin(\"input\").getACall()\n    and\n    // Exclude calls to 'raw_input' as it safely treats input as strings in Python 2\n    riskyInputInvocation != API::builtin(\"raw_input\").getACall()\n_______________ // 补全条件\nselect riskyInputInvocation, \"The unsafe built-in function 'input' is used in Python 2.\"  // Report location of unsafe 'input' function usage",
    "output": ")"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/raises-tuple]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects instances where a tuple is raised as an exception in Python 2.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Raising a tuple in Python 2\n * @description Detects instances where a tuple is raised as an exception in Python 2.\n *              In Python 2, raising a tuple causes only the first element to be raised\n *              as an exception, while all other elements are silently discarded.\n *              This behavior can lead to unexpected runtime issues and bugs.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n// Identify raise statements that use a tuple as the exception object\n// In Python 2, this is problematic because only the first tuple element\n// gets raised while others are discarded, potentially causing bugs\nfrom Raise exceptionRaise, DataFlow::LocalSourceNode tupleExprSource\nwhere\n  // Issue is specific to Python 2 environments\n  major_version() = 2 and\n  // Source must be a tuple expression\n  tupleExprSource.asExpr() instanceof Tuple and\n  // Verify data flows from tuple to exception target\n  exists(DataFlow::Node exceptionTargetNode |\n    // Target node corresponds to the exception in raise statement\n    exceptionTargetNode.asExpr() = exceptionRaise.getException() and\n    // Confirm data flow path exists\n    tupleExprSource.flowsTo(exceptionTargetNode)\n  )\n/* Note: Python 3 raises TypeError for tuple exceptions (handled by IllegalRaise query).\n   This query specifically targets Python 2 where this behavior is allowed but problematic. */\nselect exceptionRaise,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleExprSource, \"tuple\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unsafe shell command constructed from library input\n * @description Building shell commands using external string inputs\n *              can lead to command injection vulnerabilities.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.3\n * @precision medium\n * @id py/shell-command-constructed-from-input\n * @tags correctness\n *       security\n *       external/cwe/cwe-078\n *       external/cwe/cwe-088\n *       external/cwe/cwe-073\n */\n\n// Core Python language support\nimport python\n\n// Security analysis for dangerous shell command construction\nimport semmle.python.security.dataflow.UnsafeShellCommandConstructionQuery\n\n// Data flow path visualization framework\nimport UnsafeShellCommandConstructionFlow::PathGraph\n\n_______________ // 补全条件\nfrom\n  Sink commandSink,                                         // Command execution details\n  UnsafeShellCommandConstructionFlow::PathNode inputOrigin, // Untrusted input source\n  UnsafeShellCommandConstructionFlow::PathNode executionPoint // Command execution point\nwhere\n  // Map execution point to detailed sink representation\n  commandSink = executionPoint.getNode()\n  and\n  // Trace data flow from input to command execution\n  UnsafeShellCommandConstructionFlow::flowPath(inputOrigin, executionPoint)\nselect \n  // Vulnerability context: string construction details\n  commandSink.getStringConstruction(), \n  inputOrigin, \n  executionPoint,\n  // Security impact: input source and command execution context\n  \"This \" + commandSink.describe() + \n  \" which depends on $@ is subsequently used in a $@.\", \n  inputOrigin.getNode(), \"library input\", \n  commandSink.getCommandExecution(), \"shell command\"",
    "output": "// Identify vulnerable command construction flows"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-co-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This analysis quantifies the average number of files that are modified together",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Co-committed Files Analysis\n * @description This analysis quantifies the average number of files that are modified together \n *              with a module's files in the same commit. It helps identify modules that are \n *              frequently modified in conjunction with other files, which may indicate tight \n *              coupling or dependencies.\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Filter modules that have valid metrics for co-modification analysis\nfrom Module analyzedModule\nwhere exists(analyzedModule.getMetrics().getNumberOfLinesOfCode())\nselect analyzedModule,\n  // Compute the average number of files co-modified with this module's files\n  avg(Commit versionCommit, int coModifiedFilesCount |\n    // Identify commits that affect the target module's file\n    versionCommit.getAnAffectedFile() = analyzedModule.getFile() and \n    // Calculate the count of additional files modified in the same commit (excluding the module file)\n    coModifiedFilesCount = count(versionCommit.getAnAffectedFile()) - 1\n  |\n    coModifiedFilesCount\n  )"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Cors misconfiguration with credentials\n * @description Disabling or weakening SOP protection may make the application\n *              vulnerable to a CORS attack.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n// 定义一个谓词函数，用于检查数组是否包含星号或null字符串\npredicate containsStar(DataFlow::Node array) {\n  // 检查数组表达式是否是列表类型，并且其子表达式是字符串字面量且值为\"*\"或\"null\"\n  array.asExpr() instanceof List and\n  array.asExpr().getASubExpression().(StringLiteral).getText() in [\"*\", \"null\"]\n  // 或者数组表达式本身是字符串字面量且值为\"*\"或\"null\"\n  or\n  array.asExpr().(StringLiteral).getText() in [\"*\", \"null\"]\n}\n\n// 定义一个谓词函数，用于判断给定的中间件是否是CORS中间件\npredicate isCorsMiddleware(Http::Server::CorsMiddleware middleware) {\n  // 检查中间件的名称是否为\"CORSMiddleware\"\n_______________ // 补全条件\n}\n\n// 定义一个谓词函数，用于判断给定的CORS中间件是否允许凭证\npredicate credentialsAllowed(Http::Server::CorsMiddleware middleware) {\n  // 检查中间件的凭证允许属性是否为True\n  middleware.getCredentialsAllowed().asExpr() instanceof True\n}\n\n// 从所有CORS中间件中选择满足特定条件的中间件\nfrom Http::Server::CorsMiddleware a\nwhere\n  // 条件1：中间件允许凭证\n  credentialsAllowed(a) and\n  // 条件2：中间件的来源包含星号或null字符串\n  containsStar(a.getOrigins().getALocalSource()) and\n  // 条件3：中间件是CORS中间件\n  isCorsMiddleware(a)\nselect a,\n  // 输出警告信息，说明该CORS中间件使用了不安全的配置，允许任意网站进行跨站请求\n  \"This CORS middleware uses a vulnerable configuration that allows arbitrary websites to make authenticated cross-site requests\"",
    "output": "middleware.getMiddlewareName() = \"CORSMiddleware\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Class Efferent Coupling Analysis\n * @description Quantifies the number of distinct external classes that each class depends on.\n * @kind treemap\n * @id py/efferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n_______________ // 补全条件\n *       modularity\n */\n\nimport python\n\n// Evaluate the external coupling for each class in the codebase\nfrom ClassMetrics targetClass\nselect targetClass, \n       targetClass.getEfferentCoupling() as externalDependencyCount \norder by externalDependencyCount desc",
    "output": "* @tags testability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unnecessary pass\n * @description Detects redundant 'pass' statements in Python code\n * @kind problem\n_______________ // 补全条件\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/unnecessary-pass\n */\n\nimport python\n\n/**\n * Identifies if an expression statement serves as a docstring.\n * Docstrings are string literals that appear at the beginning of modules,\n * classes, or functions to document their purpose.\n */\npredicate isDocString(ExprStmt docStringExpr) {\n  // A docstring is represented as either a Unicode or Bytes literal\n  docStringExpr.getValue() instanceof Unicode or docStringExpr.getValue() instanceof Bytes\n}\n\n/**\n * Checks if a statement list begins with a docstring.\n * This is typically the first statement in a module, class, or function body.\n */\npredicate containsDocString(StmtList stmtListWithDoc) {\n  // The statement list must belong to a scope and have a docstring as its first element\n  stmtListWithDoc.getParent() instanceof Scope and\n  isDocString(stmtListWithDoc.getItem(0))\n}\n\nfrom Pass redundantPass, StmtList parentStmtList\nwhere\n  // The redundant pass statement must be contained within the parent statement list\n  parentStmtList.getAnItem() = redundantPass and\n  (\n    // Scenario 1: Statement list has exactly 2 items without a docstring\n    strictcount(parentStmtList.getAnItem()) = 2 and \n    not containsDocString(parentStmtList)\n    or\n    // Scenario 2: Statement list has more than 2 items\n    strictcount(parentStmtList.getAnItem()) > 2\n  )\nselect redundantPass, \"Unnecessary 'pass' statement.\"",
    "output": "* @tags maintainability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-named-class-argument]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies class instantiations using named arguments that don't correspond",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incorrect named argument in class instantiation\n * @description Identifies class instantiations using named arguments that don't correspond\n *              to any parameter in the class's __init__ method, leading to runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\n// Import necessary modules for Python code analysis and call argument evaluation\nimport python\nimport Expressions.CallArgs\n\n// Identify class instantiation calls with invalid named parameters\nfrom Call problematicInstantiation, ClassValue targetClass, string invalidArgName, FunctionValue initMethod\nwhere\n  // Locate class instantiations that contain unrecognized named parameters\n  illegally_named_parameter(problematicInstantiation, targetClass, invalidArgName)\n  and\n  // Retrieve the initialization method (__init__) of the target class\n  initMethod = get_function_or_initializer(targetClass)\nselect \n  // Report the location of the problematic class instantiation\n  problematicInstantiation, \n  // Generate error message specifying the unsupported argument\n  \"Keyword argument '\" + invalidArgName + \"' is not a supported parameter name of $@.\", \n  // Reference the initialization method for additional context\n  initMethod,\n  // Include the qualified name of the initialization method in the report\n  initMethod.getQualifiedName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak cryptographic hash algorithms\n * @description Identifies the use of cryptographic hash algorithms that are either unapproved or considered weak for security purposes.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import necessary Python language support and experimental cryptography analysis modules\nimport python\nimport experimental.cryptography.Concepts\n\n// Detect weak or unapproved hash operations and generate corresponding security alerts\nfrom HashAlgorithm hashOperation, string algorithmName, string securityWarning\nwhere\n  // Extract the algorithm name from the hash operation being analyzed\n  algorithmName = hashOperation.getHashName() and\n  // Filter out operations using approved strong hash algorithms (SHA256, SHA384, SHA512)\n  not algorithmName in [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // Generate appropriate security warning based on algorithm recognition status\n  (\n    // Handle recognized but unapproved algorithms\n    algorithmName != \"\" and\n    securityWarning = \"Use of unapproved hash algorithm or API \" + algorithmName + \".\"\n_______________ // 补全条件\n  or\n  (\n    // Handle unrecognized algorithms\n    algorithmName = \"\" and\n    securityWarning = \"Use of unrecognized hash algorithm.\"\n  )\nselect hashOperation, securityWarning",
    "output": ")"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/log-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects potential log injection issues where untrusted user input",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Log Injection Vulnerability\n * @description Detects potential log injection issues where untrusted user input\n *              is incorporated into log entries without proper sanitization,\n *              allowing attackers to forge or manipulate log content.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.8\n * @precision medium\n * @id py/log-injection\n * @tags security\n *       external/cwe/cwe-117\n */\n\n// Import Python code analysis library for parsing and processing Python source code\nimport python\n\n// Import security data flow module specifically for detecting log injection vulnerabilities\nimport semmle.python.security.dataflow.LogInjectionQuery\n\n// Import the path graph class from the log injection data flow module\nimport LogInjectionFlow::PathGraph\n\n// Define a query to identify potential log injection paths through the code\nfrom LogInjectionFlow::PathNode origin, LogInjectionFlow::PathNode destination\nwhere LogInjectionFlow::flowPath(origin, destination)\n// Select the vulnerable log entry, its data flow source and sink, along with descriptive message\nselect destination.getNode(), origin, destination, \n       \"This log entry incorporates a $@.\", origin.getNode(), \n       \"user-provided value\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Polynomial regular expression used on uncontrolled data\n * @description A regular expression that can require polynomial time\n *              to match may be vulnerable to denial-of-service attacks.\n * @kind path-problem\n_______________ // 补全条件\n * @security-severity 7.5\n * @precision high\n * @id py/polynomial-redos\n * @tags security\n *       external/cwe/cwe-1333\n *       external/cwe/cwe-730\n *       external/cwe/cwe-400\n */\n\n// Import core Python analysis modules for general code analysis\nimport python\n// Import specialized module for detecting polynomial complexity regex patterns\nimport semmle.python.security.dataflow.PolynomialReDoSQuery\n// Import path analysis infrastructure to track data flow paths\nimport PolynomialReDoSFlow::PathGraph\n\nfrom\n  // Identify regex patterns that can cause exponential backtracking\n  PolynomialBackTrackingTerm vulnerableRegexPattern,\n  // Locate sources of uncontrolled input data that could be used in regex operations\n  PolynomialReDoSFlow::PathNode uncontrolledInputSource,\n  // Pinpoint exact locations where regex operations are performed in the code\n  PolynomialReDoSFlow::PathNode regexOperationSite,\n  // Identify sink entities that represent the regex operations\n  Sink regexOperationSink\nwhere\n  // Trace data flow from uncontrolled input source to regex operation site\n  PolynomialReDoSFlow::flowPath(uncontrolledInputSource, regexOperationSite)\n  and\n  // Connect the regex operation sink to its usage location and extract the vulnerable pattern\n  (\n    // Map the sink entity to its corresponding usage location\n    regexOperationSink = regexOperationSite.getNode()\n    and\n    // Extract the vulnerable regex pattern from the sink entity\n    vulnerableRegexPattern = regexOperationSink.getABacktrackingTerm()\n  )\n  // Original excluded condition (preserved as comment):\n  //   not (\n  //     uncontrolledInputSource.getNode().(Source).getKind() = \"url\" and\n  //     vulnerableRegexPattern.isAtEndLine()\n  //   )\nselect \n  // Highlight the vulnerable regex location in the source code\n  regexOperationSink.getHighlight(), \n  uncontrolledInputSource, \n  regexOperationSite,\n  // Generate a detailed vulnerability warning message\n  \"This $@ that depends on a $@ may run slow on strings \" + vulnerableRegexPattern.getPrefixMessage() +\n    \"with many repetitions of '\" + vulnerableRegexPattern.getPumpString() + \"'.\", \n  // Reference the vulnerable regex pattern for reporting purposes\n  vulnerableRegexPattern, \"regular expression\",\n  // Reference the source of the uncontrolled input data\n  uncontrolledInputSource.getNode(), \"user-provided value\"",
    "output": "* @problem.severity warning"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Show string representations of Python classes\n * @kind display-string\n * @id py/lgtm/class-display-strings\n * @metricType reftype\n */\n\nimport python\n\n_______________ // 补全条件\nfrom Class cls\n// 输出类对象及其名称作为显示字符串\nselect cls, cls.getName()",
    "output": "// 遍历代码库中的所有Python类定义"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of co-committed files\n * @description Measures the average number of files modified together with files in a module\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Identify modules with valid metrics for analysis\nfrom Module targetModule\nwhere exists(targetModule.getMetrics().getNumberOfLinesOfCode())\nselect targetModule,\n  // Calculate the average number of files co-committed with the target module\n  avg(Commit revision, int coCommittedFileCount |\n    // Find commits that affect the target module\n    revision.getAnAffectedFile() = targetModule.getFile() and \n    // Count the total files modified in the commit, excluding the target module file\n    coCommittedFileCount = count(revision.getAnAffectedFile()) - 1\n  |\n    coCommittedFileCount\n_______________ // 补全条件",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 分析指向关系数据结构的压缩性能：通过测量不同上下文深度下的\n * 去重事实数量与总关系规模的比例，评估压缩算法的效率。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义查询输出变量：去重事实计数、关系总规模、上下文深度和压缩比率\nfrom int distinctFactsCount, int totalRelationsSize, int contextDepth, float compressionRatio\nwhere\n  // 计算去重事实数量：统计唯一的(控制流节点, 目标对象, 对象类)三元组\n  distinctFactsCount =\n    strictcount(ControlFlowNode controlFlowNode, Object targetObject, ClassObject objectClass |\n      exists(PointsToContext pointsToContext |\n        // 检查在给定上下文中，控制流节点是否指向特定对象，且该对象属于特定类\n_______________ // 补全条件\n        contextDepth = pointsToContext.getDepth()\n      )\n    ) and\n  // 计算关系总规模：统计所有(控制流节点, 目标对象, 对象类, 上下文, 源节点)五元组\n  totalRelationsSize =\n    strictcount(ControlFlowNode controlFlowNode, Object targetObject, ClassObject objectClass, \n      PointsToContext pointsToContext, ControlFlowNode sourceNode |\n      // 验证完整的指向关系，包括源节点信息\n      PointsTo::points_to(controlFlowNode, pointsToContext, targetObject, objectClass, sourceNode) and\n      contextDepth = pointsToContext.getDepth()\n    ) and\n  // 计算压缩比率：去重事实数量占关系总规模的百分比\n  compressionRatio = 100.0 * distinctFactsCount / totalRelationsSize\n// 输出结果：上下文深度、去重事实数量、关系总规模和压缩比率\nselect contextDepth, distinctFactsCount, totalRelationsSize, compressionRatio",
    "output": "PointsTo::points_to(controlFlowNode, pointsToContext, targetObject, objectClass, _) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Counts different kinds of type annotations in Python code, including parameters, return types, and annotated assignments.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type Metrics\n * @description Counts different kinds of type annotations in Python code, including parameters, return types, and annotated assignments.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents a built-in Python type (e.g., int, float, str, etc.)\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr funcExpr) { exists(funcExpr.getReturns()) } or\n  TAnnotatedParameter(Parameter param) { exists(param.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign annotatedAssign) { exists(annotatedAssign.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr func;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(func) }\n  override Expr getAnnotation() { result = func.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter param;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(param) }\n  override Expr getAnnotation() { result = param.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assign;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assign) }\n  override Expr getAnnotation() { result = assign.getAnnotation() }\n}\n\n/** Holds if `typeExpr` is a forward declaration (string literal) of a type. */\npredicate is_forward_declaration(Expr typeExpr) { typeExpr instanceof StringLiteral }\n\n/** Holds if `typeExpr` is a type that may be difficult to analyze. */\npredicate is_complex_type(Expr typeExpr) {\n  (typeExpr instanceof Subscript and not is_optional_type(typeExpr)) or\n  typeExpr instanceof Tuple or\n  typeExpr instanceof List\n}\n\n/** Holds if `typeExpr` is a type of the form `Optional[...]`. */\npredicate is_optional_type(Subscript typeExpr) { typeExpr.getObject().(Name).getId() = \"Optional\" }\n\n/** Holds if `typeExpr` is a simple type (non-built-in identifier or attribute chain). */\npredicate is_simple_type(Expr typeExpr) {\n  (typeExpr instanceof Name and not typeExpr instanceof BuiltinType) or\n  is_simple_type(typeExpr.(Attribute).getObject())\n}\n\n/** Holds if `typeExpr` is a built-in type. */\npredicate is_builtin_type(Expr typeExpr) { typeExpr instanceof BuiltinType }\n\n// Computes type annotation metrics for different annotation categories\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  (\n    category = \"Parameter annotation\" and\n    totalCount = count(AnnotatedParameter param) and\n    builtinCount = count(AnnotatedParameter param | is_builtin_type(param.getAnnotation())) and\n    forwardDeclCount = count(AnnotatedParameter param | is_forward_declaration(param.getAnnotation())) and\n    simpleTypeCount = count(AnnotatedParameter param | is_simple_type(param.getAnnotation())) and\n    complexTypeCount = count(AnnotatedParameter param | is_complex_type(param.getAnnotation())) and\n    optionalTypeCount = count(AnnotatedParameter param | is_optional_type(param.getAnnotation()))\n  )\n  or\n  // Return type annotation metrics\n  (\n    category = \"Return type annotation\" and\n    totalCount = count(AnnotatedFunction func) and\n    builtinCount = count(AnnotatedFunction func | is_builtin_type(func.getAnnotation())) and\n    forwardDeclCount = count(AnnotatedFunction func | is_forward_declaration(func.getAnnotation())) and\n    simpleTypeCount = count(AnnotatedFunction func | is_simple_type(func.getAnnotation())) and\n    complexTypeCount = count(AnnotatedFunction func | is_complex_type(func.getAnnotation())) and\n    optionalTypeCount = count(AnnotatedFunction func | is_optional_type(func.getAnnotation()))\n  )\n  or\n  // Annotated assignment metrics\n  (\n    category = \"Annotated assignment\" and\n    totalCount = count(AnnotatedAssignment assign) and\n    builtinCount = count(AnnotatedAssignment assign | is_builtin_type(assign.getAnnotation())) and\n    forwardDeclCount = count(AnnotatedAssignment assign | is_forward_declaration(assign.getAnnotation())) and\n    simpleTypeCount = count(AnnotatedAssignment assign | is_simple_type(assign.getAnnotation())) and\n    complexTypeCount = count(AnnotatedAssignment assign | is_complex_type(assign.getAnnotation())) and\n    optionalTypeCount = count(AnnotatedAssignment assign | is_optional_type(assign.getAnnotation()))\n  )\n}\n\n// Query execution and output\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Mostly duplicate file detector\n * @description Identifies Python files with near-identical code content. Such duplicates increase maintenance burden and should be consolidated.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-file\n */\n\nimport python\n_______________ // 补全条件\nfrom \n  Module originalFile, \n  Module duplicateFile, \n  string description\nwhere \n  /* Ensure we're comparing distinct files */\n  originalFile != duplicateFile and\n  /* Compare file contents for exact duplication */\n  originalFile.getLocation().getFile().getContents() = duplicateFile.getLocation().getFile().getContents() and\n  /* Prevent duplicate reporting by enforcing path ordering */\n  originalFile.getLocation().getFile().getAbsolutePath() < duplicateFile.getLocation().getFile().getAbsolutePath() and\n  /* Generate descriptive alert message */\n  description = \"This file is a duplicate of \" + duplicateFile.getName()\nselect \n  originalFile, \n  description, \n  duplicateFile, \n  duplicateFile.getName()",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies regular expressions using '\\b' for backspace character,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Backspace escape in regular expression\n * @description Identifies regular expressions using '\\b' for backspace character,\n *              which conflicts with its common usage as word boundary assertion.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int backslashPos\nwhere\n  // Locate backslash escape sequence followed by 'b'\n  regexPattern.escapingChar(backslashPos) and\n  regexPattern.getChar(backslashPos + 1) = \"b\" and\n  // Validate escape sequence occurs within character class\n  exists(int charSetStart, int charSetEnd | \n    charSetStart < backslashPos and \n    charSetEnd > backslashPos and\n    regexPattern.charSet(charSetStart, charSetEnd)\n  )\nselect regexPattern, \"Backspace escape in regular expression at offset \" + backslashPos + \".\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Backspace escape in regular expression\n_______________ // 补全条件\n *              since it could be mistaken for a word boundary assertion.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regex, int position\nwhere\n  // 验证指定偏移位置存在转义字符\n  regex.escapingChar(position) and\n  // 确认转义字符后紧跟着字符 'b'\n  regex.getChar(position + 1) = \"b\" and\n  // 保证该转义序列位于字符集定义范围内\n  exists(int charSetStart, int charSetEnd | \n    charSetStart < position and \n    charSetEnd > position and \n    regex.charSet(charSetStart, charSetEnd)\n  )\nselect regex, \"Backspace escape in regular expression at offset \" + position + \".\"",
    "output": "* @description Using '\\b' to escape the backspace character in a regular expression is confusing"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/kdf-low-iteration-count]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies key derivation functions with insufficient iteration counts.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use iteration count at least 100k to prevent brute force attacks\n * @description Identifies key derivation functions with insufficient iteration counts.\n * \n * Cryptographic keys derived from user inputs (like passwords) should use a high iteration count\n * (minimum 100,000 iterations) to make brute force attacks computationally infeasible.\n * \n * This query detects two potential security issues:\n * 1. Explicitly configured iteration counts below the recommended threshold\n * 2. Iteration counts that cannot be statically verified (potentially unsafe)\n * \n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import standard Python analysis library\nimport python\n// Import experimental cryptography concepts for key derivation operations\nimport experimental.cryptography.Concepts\n// Import utility functions for cryptography analysis, aliased as CryptoUtils\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Find key derivation functions with potentially insufficient iteration counts\nfrom KeyDerivationOperation keyDerivationFunc, string alertMessage, DataFlow::Node iterationSource\nwhere\n  // Filter to operations that require iteration configuration\n  keyDerivationFunc.requiresIteration() and\n  // Identify the source of the iteration count configuration\n  iterationSource = keyDerivationFunc.getIterationSizeSrc() and\n  // Check for two potential security issues\n  (\n    // Security issue 1: Explicitly defined iteration count is too low\n    exists(iterationSource.asExpr().(IntegerLiteral).getValue()) and\n    iterationSource.asExpr().(IntegerLiteral).getValue() < 10000 and\n    alertMessage = \"Insufficient iteration count detected. \"\n    // Security issue 2: Iteration count cannot be statically verified\n    or\n    not exists(iterationSource.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Iteration count cannot be statically verified. \"\n  )\nselect \n  // Generate alert for the key derivation function with appropriate security warning\n  keyDerivationFunc, alertMessage + \"Minimum required iteration count is 10000. Configuration source: $@\",\n  iterationSource.asExpr(), iterationSource.asExpr().toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/missing-docstring]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Public classes, functions, or methods without documentation strings",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Missing docstring\n * @description Public classes, functions, or methods without documentation strings\n *              hinder code maintainability and understanding for other developers.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/missing-docstring\n */\n\n/*\n * NOTE: The 'medium' precision reflects the subjective nature of docstring requirements.\n * The necessity of a docstring often depends on the context and intended audience.\n */\n\nimport python\n\n// Identify scopes requiring documentation based on visibility and type\npredicate should_have_documentation(Scope targetScope) {\n  targetScope.isPublic() and (\n    not targetScope instanceof Function\n    or\n    function_needs_documentation(targetScope)\n  )\n}\n\n// Determine if a function requires documentation based on specific criteria\npredicate function_needs_documentation(Function func) {\n  // Skip if overriding a base method that doesn't require docs\n  not exists(FunctionValue overridingFunc, FunctionValue baseFunc | \n    overridingFunc.overrides(baseFunc) and overridingFunc.getScope() = func |\n    not function_needs_documentation(baseFunc.getScope())\n  ) and\n  // Exclude lambda functions\n  func.getName() != \"lambda\" and\n  // Require docs for functions longer than 2 lines (excluding decorators)\n  (func.getMetrics().getNumberOfLinesOfCode() - count(func.getADecorator())) > 2 and\n  // Skip property getters/setters\n  not exists(PythonPropertyObject propObj |\n    propObj.getGetter().getFunction() = func or\n    propObj.getSetter().getFunction() = func\n  )\n}\n\n// Categorize scope type for result reporting\nstring describe_scope_type(Scope targetScope) {\n  result = \"Module\" and targetScope instanceof Module and not targetScope.(Module).isPackage()\n  or\n  result = \"Class\" and targetScope instanceof Class\n  or\n  result = \"Function\" and targetScope instanceof Function\n}\n\n// Find public scopes missing required documentation\nfrom Scope targetScope\nwhere should_have_documentation(targetScope) and not exists(targetScope.getDocString())\nselect targetScope, describe_scope_type(targetScope) + \" \" + targetScope.getName() + \" does not have a docstring.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when '\\b' is used to represent a backspace character within regex character sets,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Backspace escape in regular expression\n * @description Detects when '\\b' is used to represent a backspace character within regex character sets,\n *              which can be confused with the word boundary assertion '\\b'.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int backslashPos\nwhere\n  // Check for an escape character (backslash) at the specified position\n  regexPattern.escapingChar(backslashPos) and\n  // Verify the character following the backslash is 'b', forming '\\b'\n  regexPattern.getChar(backslashPos + 1) = \"b\" and\n  // Confirm this escape sequence is contained within a character set [...]\n  exists(int setStart, int setEnd | \n    setStart < backslashPos and \n    setEnd > backslashPos and \n    regexPattern.charSet(setStart, setEnd)\n  )\nselect regexPattern, \"Backspace escape in regular expression at offset \" + backslashPos + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/function-extents]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Discovers and enumerates all callable elements (functions and methods)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Extents of callables\n * @kind extent\n * @id py/function-extents\n * @metricType callable\n * @description Discovers and enumerates all callable elements (functions and methods)\n *              present in the analyzed Python codebase, along with their source locations.\n *              This analysis provides a comprehensive overview of the callable components\n *              distribution, serving as a basis for further structural analysis and\n *              understanding of the Python project under examination.\n */\n\n// Import the necessary Python analysis module for code examination\nimport python\n\n// Query all callable elements (functions and methods) in the codebase\nfrom Function functionOrMethod\n\n// Output the source location and the callable element itself\nselect functionOrMethod.getLocation(), functionOrMethod"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 明文存储敏感信息\n * @description 检测敏感数据未经加密/哈希处理直接存储的漏洞\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/clear-text-storage-sensitive-data\n * @tags security\n *       external/cwe/cwe-312\n *       external/cwe/cwe-315\n *       external/cwe/cwe-359\n */\n\nimport python\nprivate import semmle.python.dataflow.new.DataFlow\nimport CleartextStorageFlow::PathGraph\nimport semmle.python.security.dataflow.CleartextStorageQuery\n\nfrom \n  CleartextStorageFlow::PathNode sourceNode, \n  CleartextStorageFlow::PathNode sinkNode, \n  string classification\nwhere \n  CleartextStorageFlow::flowPath(sourceNode, sinkNode) and\n  classification = sourceNode.getNode().(Source).getClassification()\nselect \n  sinkNode.getNode(), \n  sourceNode, \n  sinkNode, \n_______________ // 补全条件\n  sourceNode.getNode(), \n  \"sensitive data (\" + classification + \")\"",
    "output": "\"This expression stores $@ as clear text.\","
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python类的源文件映射\n * @description 该查询用于识别代码库中的所有Python类定义，\n *              并建立每个类与其所在源文件之间的映射关系，\n *              帮助开发者快速定位类定义位置。\n * @kind source-link\n * @id py/class-source-links\n * @metricType reftype\n */\n\nimport python\n\n// 定义查询范围：从Python代码库中获取所有类定义及其对应的源文件\n_______________ // 补全条件\nwhere \n    // 建立映射关系：获取类定义的位置信息，并提取其所在的源文件\n    sourceFile = clsDef.getLocation().getFile()\n// 输出结果：类定义对象及其对应的源文件对象，用于建立源链接\nselect clsDef, sourceFile",
    "output": "from Class clsDef, File sourceFile"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-exit-or-quit]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects calls to exit() or quit() which may not be available when",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of exit() or quit()\n * @description Detects calls to exit() or quit() which may not be available when \n *              the Python interpreter runs with the -S flag (disables 'site' module)\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/use-of-exit-or-quit\n */\n\nimport python  // 导入Python模块，用于分析Python代码结构\n\nfrom CallNode exitCall, string exitFunctionName  // 获取退出函数调用节点和函数名\nwhere \n  // 验证调用是否指向site模块的Quitter对象\n  exitCall.getFunction().pointsTo(Value::siteQuitter(exitFunctionName))\nselect \n  exitCall,  // 选择符合条件的退出函数调用\n  \"The '\" + exitFunctionName + \n  \"' site.Quitter object may not exist if the 'site' module is not loaded or is modified.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-callable invoked\n * @description Detects invocations of objects that lack callability,\n *              which would trigger runtime TypeError exceptions.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom \n  Call invocation, \n  Value referencedObject, \n  ClassValue objectType, \n  Expr callableExpr, \n  AstNode sourceLocation\nwhere\n  // Identify the expression being invoked in the call\n  callableExpr = invocation.getFunc() and\n  \n  // Resolve the expression to its concrete value and origin\n  callableExpr.pointsTo(referencedObject, sourceLocation) and\n_______________ // 补全条件\n  // Determine the class type of the referenced object\n  objectType = referencedObject.getClass() and\n  \n  // Verify the object's class lacks callability\n  not objectType.isCallable() and\n  \n  // Ensure type inference was successful for accurate analysis\n  not objectType.failedInference(_) and\n  \n  // Exclude descriptor objects implementing __get__ method\n  // These objects might be callable through the descriptor protocol\n  not objectType.hasAttribute(\"__get__\") and\n  \n  // Filter out None values as they are explicitly non-callable\n  not referencedObject = Value::named(\"None\") and\n  \n  // Special case: exclude NotImplemented when used in raise statements\n  not use_of_not_implemented_in_raise(_, callableExpr)\nselect \n  invocation, \n  \"Call to a $@ of $@.\", \n  sourceLocation, \n  \"non-callable\", \n  objectType, \n  objectType.toString()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable 'except' block\n * @description Detects exception handlers that can never execute due to being positioned\n *              after a more general handler that intercepts exceptions first.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Extracts the exception type handled by an except clause\nClassValue getHandledExceptionType(ExceptStmt handler) { \n  handler.getType().pointsTo(result) \n}\n\n// Identifies when an except handler becomes unreachable due to handler ordering\npredicate hasUnreachableExceptionHandler(ExceptStmt precedingExcept, ClassValue broaderType, \n                                        ExceptStmt succeedingExcept, ClassValue narrowerType) {\n  exists(int precedingIndex, int succeedingIndex, Try tryBlock |\n    // Both handlers belong to the same try statement\n    precedingExcept = tryBlock.getHandler(precedingIndex) and\n    succeedingExcept = tryBlock.getHandler(succeedingIndex) and\n    // Preceding handler appears before succeeding handler in source order\n    precedingIndex < succeedingIndex and\n    // Extract exception types for both handlers\n    broaderType = getHandledExceptionType(precedingExcept) and\n    narrowerType = getHandledExceptionType(succeedingExcept) and\n    // Preceding handler catches a superclass of the succeeding handler's exception\n    broaderType = narrowerType.getASuperType()\n_______________ // 补全条件\n}\n\n// Main query identifying all unreachable exception handlers\nfrom ExceptStmt precedingExcept, ClassValue broaderType, \n     ExceptStmt succeedingExcept, ClassValue narrowerType\nwhere hasUnreachableExceptionHandler(precedingExcept, broaderType, succeedingExcept, narrowerType)\nselect succeedingExcept,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  narrowerType, narrowerType.getName(), precedingExcept, \"except block\", broaderType, broaderType.getName()",
    "output": ")"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A module imports itself",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description A module imports itself\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n/**\n * Identifies modules that perform self-import operations.\n * This predicate detects when a module references itself through import statements\n * by comparing the importing module's context with the imported module's scope.\n */\npredicate isSelfImporting(ImportingStmt importDeclaration, ModuleValue importedModule) {\n  // Verify that the module containing the import statement is the same as the module being imported\n  importDeclaration.getEnclosingModule() = importedModule.getScope() and\n  // Resolve the most specific module reference using longest-name matching\n  // This approach ensures proper handling of relative import paths\n  importedModule = \n    max(string moduleName, ModuleValue potentialModule |\n      moduleName = importDeclaration.getAnImportedModuleName() and\n      potentialModule.importedAs(moduleName)\n    |\n      potentialModule order by moduleName.length()\n    )\n}\n\n// Query to locate all instances of self-importing modules\nfrom ImportingStmt importDeclaration, ModuleValue importedModule\nwhere isSelfImporting(importDeclaration, importedModule)\nselect importDeclaration, \"The module '\" + importedModule.getName() + \"' imports itself.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Jinja2 templating with autoescape=False\n_______________ // 补全条件\n *              cause a cross-site scripting vulnerability.\n * @kind problem\n * @problem.severity error\n * @security-severity 6.1\n * @precision medium\n * @id py/jinja2/autoescape-false\n * @tags security\n *       external/cwe/cwe-079\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n/*\n * This query identifies potentially unsafe Jinja2 template configurations.\n * Both Environment and Template constructors accept an 'autoescape' parameter.\n * When autoescape is disabled (explicitly set to False or left unspecified),\n * the application becomes vulnerable to cross-site scripting (XSS) attacks\n * as user-provided input won't be properly escaped.\n * \n * API References:\n * - Environment: https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Environment\n * - Template: https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template\n */\n\n// Define predicate to check for calls with variable arguments\npredicate usesVariableArguments(API::CallNode invocation) {\n  exists(invocation.asCfgNode().(CallNode).getNode().getStarargs())\n  or\n  exists(invocation.asCfgNode().(CallNode).getNode().getKwargs())\n}\n\n// Define predicate to check if autoescape is explicitly set to False\npredicate hasAutoescapeDisabled(API::CallNode invocation) {\n  invocation.getKeywordParameter(\"autoescape\")\n      .getAValueReachingSink()\n      .asExpr()\n      .(ImmutableLiteral)\n      .booleanValue() = false\n}\n\n// Retrieves API nodes for Jinja2's main constructor classes\nprivate API::Node jinja2CoreConstructors() {\n  result = API::moduleImport(\"jinja2\").getMember(\"Environment\")\n  or\n  result = API::moduleImport(\"jinja2\").getMember(\"Template\")\n}\n\nfrom API::CallNode tmplConstructorCall\nwhere\n  // Identify calls to Jinja2 constructor methods\n  tmplConstructorCall = jinja2CoreConstructors().getACall()\n  and\n  // Filter out calls using variable arguments\n  not usesVariableArguments(tmplConstructorCall)\n  and\n  (\n    // Case 1: autoescape parameter is not explicitly defined\n    not exists(tmplConstructorCall.getArgByName(\"autoescape\"))\n    or\n    // Case 2: autoescape is explicitly set to False\n    hasAutoescapeDisabled(tmplConstructorCall)\n  )\nselect tmplConstructorCall, \"Using jinja2 templates with autoescape=False can potentially allow XSS attacks.\"",
    "output": "* @description Using jinja2 templates with 'autoescape=False' can"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 最近更改的文件\n * @description 检测过去180天内被修改过的Python文件\n * @kind treemap\n * @id py/historical-number-of-recent-changed-files\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// 从Python模块中选择满足以下条件的文件：\nfrom Module pyModule\nwhere\n  // 条件1：模块具有可度量的代码行数\n  exists(pyModule.getMetrics().getNumberOfLinesOfCode()) and\n  // 条件2：存在近期提交记录（非人工更改）\n  exists(Commit recentCommit |\n    // 提交影响了当前模块的文件\n    recentCommit.getAnAffectedFile() = pyModule.getFile() and\n    // 提交发生在过去180天内\n_______________ // 补全条件\n    // 排除人工更改\n    not artificialChange(recentCommit)\n  )\n// 输出模块及计数（用于treemap可视化）\nselect pyModule, 1",
    "output": "recentCommit.daysToNow() <= 180 and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/nested-loops-with-same-variable-reused]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when an inner loop redefines a variable that is subsequently",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Nested loops with same variable reused after inner loop body\n * @description Detects when an inner loop redefines a variable that is subsequently \n *              used in the outer loop, leading to unexpected behavior.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/nested-loops-with-same-variable-reused\n */\n\nimport python\n\n/**\n * Determines if a loop defines a variable's SSA version.\n * @param loopNode - The loop statement being checked\n * @param var - The variable being defined\n * @param ssaVar - The SSA variable representation\n */\npredicate loop_variable_ssa(For loopNode, Variable var, SsaVariable ssaVar) {\n  loopNode.getTarget().getAFlowNode() = ssaVar.getDefinition() and \n  var = ssaVar.getVariable()\n}\n\n/**\n * Identifies problematic variable reuse in nested loops.\n * @param innerLoop - The inner loop statement\n * @param outerLoop - The outer loop statement\n * @param var - The reused variable\n * @param nameNode - The usage location of the variable\n */\npredicate variableUsedInNestedLoops(For innerLoop, For outerLoop, Variable var, Name nameNode) {\n  // Ensure usage occurs in outer loop but not inner loop\n  outerLoop.contains(nameNode) and \n  not innerLoop.contains(nameNode) and\n  \n  // Verify inner loop is directly nested in outer loop's body (not else clause)\n  outerLoop.getBody().contains(innerLoop) and\n  \n  exists(SsaVariable ssaVar |\n    // Confirm variable redefinition in inner loop\n    loop_variable_ssa(innerLoop, var, ssaVar.getAnUltimateDefinition()) and\n    \n    // Verify variable was originally defined in outer loop\n    loop_variable_ssa(outerLoop, var, _) and\n    \n    // Identify specific usage location\n    ssaVar.getAUse().getNode() = nameNode\n  )\n}\n\n// Query execution: Find instances of problematic variable reuse\nfrom For inner, For outer, Variable v, Name n\nwhere variableUsedInNestedLoops(inner, outer, v, n)\nselect inner, \"Nested for statement $@ loop variable '\" + v.getId() + \"' of enclosing $@.\", n,\n  \"uses\", outer, \"for statement\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unused-loop-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects loop iteration variables that are never used, which often indicates programming errors",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Suspicious unused loop iteration variable\n * @description Detects loop iteration variables that are never used, which often indicates programming errors\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/unused-loop-variable\n */\n\nimport python\n\n/**\n * Identifies variable increment operations (e.g., x += n or x = x + n)\n * @param stmt The statement to be analyzed\n */\npredicate is_increment_operation(Stmt stmt) {\n  /* Case 1: Augmented assignment with integer literal (x += n) */\n  stmt.(AugAssign).getValue() instanceof IntegerLiteral\n  or\n  /* Case 2: Binary expression assignment with same variable (x = x + n) */\n  exists(Name targetVar, BinaryExpr binExpr |\n    targetVar = stmt.(AssignStmt).getTarget(0) and\n    binExpr = stmt.(AssignStmt).getValue() and\n    binExpr.getLeft().(Name).getVariable() = targetVar.getVariable() and\n    binExpr.getRight() instanceof IntegerLiteral\n  )\n}\n\n/**\n * Checks if a for loop implements counting behavior where iteration variable increments\n * @param loop The for loop to examine\n */\npredicate is_counting_loop(For loop) { \n  is_increment_operation(loop.getAStmt()) \n}\n\n/**\n * Determines if a for loop body is empty (contains only Pass statement)\n * @param loop The for loop to examine\n */\npredicate is_empty_loop(For loop) { \n  not exists(loop.getStmt(1)) and \n  loop.getStmt(0) instanceof Pass \n}\n\n/**\n * Checks if a for loop contains only a single exit statement (return/break)\n * @param loop The for loop to examine\n */\npredicate has_single_exit_statement(For loop) {\n  not exists(Continue continueStmt | loop.contains(continueStmt)) and\n  exists(Stmt terminalStmt | terminalStmt = loop.getBody().getLastItem() |\n    terminalStmt instanceof Return or terminalStmt instanceof Break\n  )\n}\n\n/**\n * Identifies calls to range/xrange functions including nested patterns\n * @param node The control flow node to analyze\n */\npredicate is_range_function_call(ControlFlowNode node) {\n  /* Direct range/xrange function calls */\n  exists(Value rangeFunc |\n    rangeFunc = Value::named(\"range\") or rangeFunc = Value::named(\"xrange\")\n  |\n    node = rangeFunc.getACall()\n  )\n  or\n  /* Name-based range/xrange calls */\n  exists(string funcName | node.getNode().(Call).getFunc().(Name).getId() = funcName |\n    funcName = \"range\" or funcName = \"xrange\"\n  )\n  or\n  /* Nested calls like list(range(...)) */\n  node.(CallNode).pointsTo().getClass() = ClassValue::list() and\n  is_range_function_call(node.(CallNode).getArg(0))\n}\n\n/**\n * Detects names that use non-constant variables with dynamic definitions\n * @param nameNode The name node to analyze\n */\npredicate uses_non_constant_variable(Name nameNode) {\n  exists(Variable var |\n    nameNode.uses(var) and\n    /* Exclude module-level references */\n    not nameNode.getScope() instanceof Module and\n    not var.getScope() instanceof Module\n  |\n    /* Variable has multiple definitions */\n    strictcount(Name def | def.defines(var)) > 1\n    or\n    /* Variable defined inside a for loop */\n    exists(For loop, Name def | loop.contains(def) and def.defines(var))\n    or\n    /* Variable defined inside a while loop */\n    exists(While loop, Name def | loop.contains(def) and def.defines(var))\n  )\n}\n\n/**\n * Identifies loops that perform implicit N-time operations with immutable literals\n * @param loop The for loop to examine\n */\npredicate is_implicit_repetition(For loop) {\n  /* Loop body contains exactly one statement */\n  not exists(loop.getStmt(1)) and\n  /* Statement contains an immutable literal */\n  exists(ImmutableLiteral lit | loop.getStmt(0).contains(lit)) and\n  /* No non-constant variable usage in body */\n  not exists(Name varName | loop.getBody().contains(varName) and uses_non_constant_variable(varName))\n}\n\n/**\n * Retrieves the iterable from a comprehension's for statement\n * @param compFor The artificial for statement in comprehension\n * @return Control flow node of the iterable\n */\nControlFlowNode get_comprehension_iterable(For compFor) {\n  exists(Comp compExpr | \n    compExpr.getFunction().getStmt(0) = compFor | \n    compExpr.getAFlowNode().getAPredecessor() = result\n  )\n}\n\n/**\n * Checks if variable name follows convention for unused variables (starts with underscore)\n * @param var The variable to examine\n */\npredicate name_acceptable_for_unused_variable(Variable var) {\n  exists(string varName | varName = var.getId() and varName.matches(\"_%\"))\n}\n\n/**\n * Main query logic to detect unused loop iteration variables\n */\nfrom For loop, Variable iterVar, string warningMsg\nwhere\n  /* Basic condition: iteration variable is defined but never used */\n  loop.getTarget() = iterVar.getAnAccess() and\n  not loop.getAStmt().contains(iterVar.getAnAccess()) and\n  \n  /* Exclude common false-positive patterns */\n  not is_range_function_call(loop.getIter().getAFlowNode()) and\n  not is_range_function_call(get_comprehension_iterable(loop)) and\n  not name_acceptable_for_unused_variable(iterVar) and\n  not loop.getScope().getName() = \"genexpr\" and\n  not is_empty_loop(loop) and\n  not has_single_exit_statement(loop) and\n  not is_counting_loop(loop) and\n  not is_implicit_repetition(loop) and\n  \n  /* Generate context-specific warning message */\n  (if exists(Name delNode | delNode.deletes(iterVar) and loop.getAStmt().contains(delNode))\n   then warningMsg = \"' is deleted but never used in the loop body.\"\n   else warningMsg = \"' is never used in the loop body.\")\nselect loop, \"For loop variable '\" + iterVar.getId() + warningMsg"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/conflicting-attributes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别继承自多个基类的类中存在的同名属性冲突。这种多继承场景下的属性命名冲突",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 基类中的属性冲突检测\n * @description 识别继承自多个基类的类中存在的同名属性冲突。这种多继承场景下的属性命名冲突\n *              可能导致运行时行为不可预测，影响代码的可靠性和维护性。\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n/**\n * 判断函数实现是否为空实现（仅包含pass语句或文档字符串）\n */\npredicate is_empty_implementation(PyFunctionObject function) {\n  not exists(Stmt statement | statement.getScope() = function.getFunction() |\n    not statement instanceof Pass and \n    not statement.(ExprStmt).getValue() = function.getFunction().getDocString()\n  )\n}\n\n/**\n * 判断函数是否通过显式调用super()来处理方法解析顺序\n */\npredicate invokes_super(FunctionObject function) {\n  exists(Call superInvocation, Call methodCall, Attribute attributeRef, GlobalVariable superVariable |\n    methodCall.getScope() = function.getFunction() and\n    methodCall.getFunc() = attributeRef and\n    attributeRef.getObject() = superInvocation and\n    attributeRef.getName() = function.getName() and\n    superInvocation.getFunc() = superVariable.getAnAccess() and\n    superVariable.getId() = \"super\"\n  )\n}\n\n/**\n * 识别在冲突检测中应豁免的属性名称\n */\npredicate is_exempt_attribute(string attributeName) {\n  /*\n   * 根据Python官方文档，socketserver模块中的process_request方法被豁免：\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   * 这是Python多继承设计中的特例，不应视为冲突\n   */\n  attributeName = \"process_request\"\n}\n\nfrom\n  ClassObject childClass, \n  ClassObject firstBaseClass, \n  ClassObject secondBaseClass, \n  string conflictingAttrName, \n  int firstInheritanceOrder, \n  int secondInheritanceOrder, \n  Object firstBaseAttr, \n  Object secondBaseAttr\nwhere\n  // 确保派生类继承自两个不同的基类，并记录继承顺序\n  childClass.getBaseType(firstInheritanceOrder) = firstBaseClass and\n  childClass.getBaseType(secondInheritanceOrder) = secondBaseClass and\n  firstInheritanceOrder < secondInheritanceOrder and\n  \n  // 识别两个基类中的同名属性，并确保它们是不同的对象实例\n  firstBaseAttr != secondBaseAttr and\n  firstBaseAttr = firstBaseClass.lookupAttribute(conflictingAttrName) and\n  secondBaseAttr = secondBaseClass.lookupAttribute(conflictingAttrName) and\n  \n  // 排除Python特殊方法（双下划线包围的方法）和已知豁免属性\n  not conflictingAttrName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  not is_exempt_attribute(conflictingAttrName) and\n  \n  // 排除已通过super()调用显式处理方法解析顺序的情况\n  not invokes_super(firstBaseAttr) and\n  \n  // 忽略第二个基类中的空实现，因为它们通常不会造成实际冲突\n  not is_empty_implementation(secondBaseAttr) and\n  \n  // 确保两个属性间不存在覆盖关系（即它们不是重写关系）\n  not firstBaseAttr.overrides(secondBaseAttr) and\n  not secondBaseAttr.overrides(firstBaseAttr) and\n  \n  // 确保派生类没有显式声明该属性，否则冲突会被派生类解决\n  not childClass.declaresAttribute(conflictingAttrName)\nselect childClass, \n  \"Base classes have conflicting values for attribute '\" + conflictingAttrName + \"': $@ and $@.\", \n  firstBaseAttr, firstBaseAttr.toString(), \n  secondBaseAttr, secondBaseAttr.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies when attributes set in a superclass's __init__ method",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description Identifies when attributes set in a superclass's __init__ method \n *              hide methods defined in subclasses, potentially causing runtime errors.\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * This analysis detects methods declared in subclasses that become inaccessible\n * due to attributes with matching names being assigned in the superclass's __init__ method.\n */\n\nimport python\n\n// Predicate identifying subclass methods hidden by superclass attributes\npredicate method_obscured_by_super_attr(\n  ClassObject childClass, ClassObject parentClass, Assign attributeAssignment, FunctionObject shadowedMethod\n) {\n  // Establish inheritance relationship between classes\n  childClass.getASuperType() = parentClass and\n  // Verify subclass declares the method being shadowed\n  childClass.declaredAttribute(_) = shadowedMethod and\n  // Locate superclass __init__ method containing the shadowing attribute\n  exists(FunctionObject parentInit |\n    parentClass.declaredAttribute(\"__init__\") = parentInit and\n    // Identify attribute assignment within __init__ causing shadowing\n    exists(Attribute assignedAttribute |\n      assignedAttribute = attributeAssignment.getATarget() and\n      // Confirm attribute is assigned to 'self' reference\n      assignedAttribute.getObject().(Name).getId() = \"self\" and\n      // Match attribute name with shadowed method name\n      assignedAttribute.getName() = shadowedMethod.getName() and\n      // Verify assignment occurs within __init__ method scope\n      attributeAssignment.getScope() = parentInit.getOrigin().(FunctionExpr).getInnerScope()\n    )\n  ) and\n  // Exclude cases where superclass defines the same method\n  not parentClass.hasAttribute(shadowedMethod.getName())\n}\n\n// Query to identify shadowed methods and corresponding attribute assignments\nfrom ClassObject childClass, ClassObject parentClass, Assign attributeAssignment, FunctionObject shadowedMethod\nwhere method_obscured_by_super_attr(childClass, parentClass, attributeAssignment, shadowedMethod)\n// Output: shadowed method location, descriptive message, attribute assignment location\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is obscured by an $@ in superclass '\" + parentClass.getName() +\n    \"'.\", attributeAssignment, \"attribute\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/iv-sources]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies potential sources of initialization vectors (IV) or nonce values utilized in block cipher operations across supported cryptographic libraries.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Initialization Vector (IV) or nonces\n * @description Identifies potential sources of initialization vectors (IV) or nonce values utilized in block cipher operations across supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/iv-sources\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python // 导入Python语言库，用于分析Python代码\nimport experimental.cryptography.Concepts // 导入实验性加密概念库，用于处理加密相关的概念和模式\n\n// 查找所有块密码模式中使用的初始化向量(IV)或随机数(nonce)的来源表达式\nfrom BlockMode cipherMode\nselect cipherMode.getIVorNonce().asExpr(), \"Block mode IV/Nonce source\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Mostly duplicate class\n * @description Identifies classes with over 80% method duplication in another class. \n *              Creating a common supertype is recommended to improve code sharing.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-class\n */\n\nimport python\n\n// Define source variables for class comparison\nfrom \n  Class targetClass,     // Primary class being analyzed\n  Class sourceClass,     // Class to compare against\n  string notification    // Result notification message\n_______________ // 补全条件\n  none()                 // No filtering applied (preserves original logic)\nselect \n  targetClass,           // First element: analyzed class\n  notification,          // Second element: result message\n  sourceClass,           // Third element: comparison class\n  sourceClass.getName()  // Fourth element: comparison class name",
    "output": "where"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/class-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别Python代码中声明的所有类，并追踪每个类的源文件位置信息",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python类的源文件链接\n * @description 识别Python代码中声明的所有类，并追踪每个类的源文件位置信息\n * @kind source-link\n * @id py/class-source-links\n * @metricType reftype\n */\n\nimport python\n\n// 从Python代码中提取所有类定义\nfrom Class classDefinition\n// 获取每个类定义的源文件位置\nselect classDefinition, classDefinition.getLocation().getFile()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unreachable-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers that are unreachable because general exceptions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unreachable 'except' block\n * @description Identifies exception handlers that are unreachable because general exceptions\n *              are caught before specific ones that inherit from them in the same try block.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n/**\n * Retrieves the exception class associated with an exception handler.\n * @param exceptionHandler - The exception handler statement to examine\n * @return - The ClassValue representing the exception type handled by this handler\n */\nClassValue getExceptionClass(ExceptStmt exceptionHandler) { \n  exceptionHandler.getType().pointsTo(result) \n}\n\n/**\n * Finds exception handlers with incorrect ordering where a general exception\n * is caught before a more specific one that inherits from it.\n * @param earlierHandler - The exception handler that appears first in the code\n * @param generalException - The general exception type handled by earlierHandler\n * @param laterHandler - The exception handler that appears later in the code\n * @param specificException - The specific exception type handled by laterHandler\n */\npredicate hasIncorrectExceptOrder(ExceptStmt earlierHandler, ClassValue generalException, \n                                 ExceptStmt laterHandler, ClassValue specificException) {\n  // Both handlers must belong to the same try block with earlierHandler appearing first\n  exists(int earlierIdx, int laterIdx, Try tryStatement |\n    earlierHandler = tryStatement.getHandler(earlierIdx) and\n    laterHandler = tryStatement.getHandler(laterIdx) and\n    earlierIdx < laterIdx\n  ) and\n  // Get the exception types for both handlers\n  generalException = getExceptionClass(earlierHandler) and\n  specificException = getExceptionClass(laterHandler) and\n  // Verify inheritance relationship (generalException is a superclass of specificException)\n  generalException = specificException.getASuperType()\n}\n\n// Main query that detects unreachable exception handlers due to improper ordering\nfrom ExceptStmt laterHandler, ClassValue specificException, \n     ExceptStmt earlierHandler, ClassValue generalException\nwhere hasIncorrectExceptOrder(earlierHandler, generalException, \n                             laterHandler, specificException)\nselect laterHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  specificException, specificException.getName(), earlierHandler, \"except block\", generalException, generalException.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name CSRF protection weakened or disabled\n * @description Disabling or weakening CSRF protection may make the application\n *              vulnerable to a Cross-Site Request Forgery (CSRF) attack.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/csrf-protection-disabled\n * @tags security\n *       external/cwe/cwe-352\n */\n\nimport python\nimport semmle.python.Concepts\n\n// Predicate to identify CSRF protection settings outside test environments\n// Excludes test files where CSRF protection is commonly disabled\npredicate isProductionCsrfSetting(Http::Server::CsrfProtectionSetting csrfConfig) {\n  not csrfConfig.getLocation().getFile().getAbsolutePath().matches(\"%test%\")\n}\n\n// Predicate to detect vulnerable CSRF configurations\n// Identifies settings where verification is disabled and no local protection exists\npredicate hasVulnerableCsrfConfig(Http::Server::CsrfProtectionSetting csrfConfig) {\n  csrfConfig.getVerificationSetting() = false and\n  not exists(Http::Server::CsrfLocalProtectionSetting localProtection | localProtection.csrfEnabled()) and\n  isProductionCsrfSetting(csrfConfig)\n}\n\n_______________ // 补全条件\n// Ensures all relevant settings are consistently vulnerable\nfrom Http::Server::CsrfProtectionSetting csrfConfig\nwhere\n  hasVulnerableCsrfConfig(csrfConfig) and\n  // Validate all production settings share the same vulnerability state\n  forall(Http::Server::CsrfProtectionSetting otherConfig | \n         isProductionCsrfSetting(otherConfig) | \n         hasVulnerableCsrfConfig(otherConfig))\nselect csrfConfig, \"Potential CSRF vulnerability due to forgery protection being disabled or weakened.\"",
    "output": "// Main query finding CSRF vulnerabilities in production configurations"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/property-in-old-style-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects property descriptors used in old-style classes, which are not supported from Python 2.1 onward.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Property in old-style class\n * @description Detects property descriptors used in old-style classes, which are not supported from Python 2.1 onward.\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/property-in-old-style-class\n */\n\nimport python\n\n// Identify property objects defined within old-style classes\nfrom PropertyObject propertyDescriptor, ClassObject containerClass\nwhere \n  // Condition 1: Property is explicitly declared in the class\n  containerClass.declaredAttribute(_) = propertyDescriptor and\n  // Condition 2: Class inference completed successfully\n  not containerClass.failedInference() and\n  // Condition 3: Class uses old-style inheritance (not new-style)\n  not containerClass.isNewStyle()\n// Select the problematic property with contextual warning message\nselect propertyDescriptor,\n  \"Property \" + propertyDescriptor.getName() + \" will not work properly, as class \" + containerClass.getName() +\n    \" is an old-style class.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name 未配置初始化向量 (IV) 或 nonce\n * @description 识别块密码操作中缺少初始化向量或nonce配置的代码点，这些参数可能源自不可信输入源\n * @kind problem\n * @id py/quantum-readiness/cbom/unkown-iv-sources\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 安全分析目标：识别所有使用块密码加密模式的代码位置\n// 此类代码在IV或nonce未正确设置时可能引入严重安全漏洞\nfrom BlockMode vulnerableBlockMode\nwhere \n    // 过滤条件：验证块密码模式是否缺少必要的IV或nonce配置\n    // 缺少这些关键参数可能导致加密强度降低，使系统易受密码分析攻击\n    exists(vulnerableBlockMode) and\n    not vulnerableBlockMode.hasIVorNonce()\nselect \n    // 报告结果：标记存在安全风险的块密码模式实例\n    vulnerableBlockMode, \n    // 提供安全问题描述\n    \"Block mode with unknown IV or Nonce configuration\"",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name File Deletion Analysis\n * @description Computes the total number of lines deleted from each file across the repository's complete commit history.\n *              This metric identifies files that have experienced substantial code refactoring or feature elimination.\n_______________ // 补全条件\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\nfrom Module fileModule, int cumulativeDeletedLines\nwhere\n  // Verify that the module contains valid code metrics for accurate analysis\n  exists(fileModule.getMetrics().getNumberOfLinesOfCode()) and\n  // Compute the cumulative count of lines removed from this file across all commits\n  cumulativeDeletedLines = sum(Commit revision, int linesRemovedInRevision |\n    // For each commit, determine the number of lines deleted from this file, excluding trivial or automated changes\n    linesRemovedInRevision = revision.getRecentDeletionsForFile(fileModule.getFile()) and \n    not artificialChange(revision)\n  |\n    linesRemovedInRevision\n  )\nselect fileModule, cumulativeDeletedLines order by cumulativeDeletedLines desc",
    "output": "* @kind treemap"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Python 2 'input' function usage\n * @description Identifies calls to the built-in 'input' function in Python 2, which evaluates user input as code, creating a code injection vulnerability.\n * @kind problem\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/use-of-input\n */\n\nimport python  // Import Python language support for analysis\nimport semmle.python.dataflow.new.DataFlow  // Import data flow tracking functionality\nimport semmle.python.ApiGraphs  // Import API graph utilities for function identification\n\n// Find all calls to the unsafe 'input' function in Python 2\nfrom DataFlow::CallCfgNode unsafeInputCall\nwhere\n  // Check if we're analyzing Python 2 code\n  major_version() = 2\n  \n_______________ // 补全条件\n  and unsafeInputCall = API::builtin(\"input\").getACall()\n  \n  // Exclude 'raw_input' calls which are safe\n  and unsafeInputCall != API::builtin(\"raw_input\").getACall()\n  \nselect unsafeInputCall, \"The unsafe built-in function 'input' is used in Python 2.\"  // Flag the security issue with descriptive message",
    "output": "// Verify this is a call to the 'input' builtin"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Identical code block\n * @description Detects code blocks that are identical and could potentially be refactored.\n * This analysis flags every basic block as a possible duplicate since true\n * duplicate identification needs more sophisticated analysis. Note: This check may produce\n * false positives as it relies on statistical methods.\n * @kind problem\n * @problem.severity recommendation\n * @sub-severity low\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @deprecated\n * @precision medium\n * @id py/duplicate-block\n */\n_______________ // 补全条件\nimport python\n\n// Select all basic blocks without filtering conditions\n// Note: This query intentionally selects every basic block as a placeholder\n// for more sophisticated duplicate detection logic\nfrom BasicBlock basicBlock\n// No filtering applied (equivalent to original 'where none()')\nselect basicBlock, \n       \"Identical code: \" + \"-1\" + \" lines are repeated at \" + \"<file>\" + \":\" + \"-1\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Deleted lines per file\n_______________ // 补全条件\n *              the complete version control history. This analysis identifies files\n *              that have undergone significant refactoring or feature elimination,\n *              potentially indicating architectural changes or removal of deprecated code.\n * @kind treemap\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python\nimport external.VCS\n\nfrom Module analyzedFile, int totalDeletedLines\nwhere\n  // Validate that the module contains meaningful code for analysis\n  analyzedFile.getMetrics().getNumberOfLinesOfCode() > 0\n  and\n  // Aggregate the total lines deleted from this file throughout all commits\n  totalDeletedLines = sum(Commit versionCommit, int deletedLinesCount |\n    // Retrieve the number of lines deleted for this specific file in each commit\n    deletedLinesCount = versionCommit.getRecentDeletionsForFile(analyzedFile.getFile())\n    and\n    // Exclude commits that are artificial or insignificant to the analysis\n    not artificialChange(versionCommit)\n  |\n    deletedLinesCount\n  )\nselect analyzedFile, totalDeletedLines order by totalDeletedLines desc",
    "output": "* @description Calculates the cumulative count of lines removed from each file across"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'import *' used\n * @description Detects Python files utilizing wildcard imports ('from ... import *'), which may cause namespace pollution and reduce code maintainability.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n_______________ // 补全条件\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\n// Import Python analysis module for source code examination\nimport python\n\n// Identify all wildcard import statements in the codebase\nfrom ImportStar wildcardImport\n// Generate alert for each detected wildcard import\nselect wildcardImport, \"Using 'from ... import *' pollutes the namespace.\"",
    "output": "* @sub-severity low"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/external-dependencies]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：量化Python源文件所依赖的外部包数量。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name 外部依赖关系\n * @description 量化Python源文件所依赖的外部包数量。\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType externalDependency\n * @id py/external-dependencies\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 此查询用于分析Python项目中的外部依赖关系，提供以下信息：\n *\n * 1. Python源文件的路径（作为依赖关系的主体）\n * 2. 外部包对象（通常指PyPI或其他外部源提供的包）\n * 3. 包的版本信息（如果可获取）\n * 4. 源文件对该特定包的依赖数量\n *\n * 当前实现输出两列数据，但实际涵盖了四个方面的信息。\n * 理想情况下，查询应当输出三列数据，但这需要调整仪表板数据库架构和数据提取器。\n *\n * 文件路径添加了'/'前缀，以匹配仪表板数据库中使用的相对文件路径格式。\n */\n\n// 定义查询的主要数据源\nfrom File sourceFile, ExternalPackage externalPkg, int depCount, string depEntity\nwhere\n  // 计算每个源文件对外部包的依赖数量\n  depCount =\n    strictcount(AstNode astNode |\n      // 检查AST节点是否依赖于指定的外部包\n      dependency(astNode, externalPkg) and\n      // 确保AST节点位于指定的源文件中\n      astNode.getLocation().getFile() = sourceFile\n    ) and\n  // 将源文件和外部包信息合并为单个实体标识符\n  depEntity = munge(sourceFile, externalPkg)\n// 选择依赖实体和依赖计数，并按依赖数量降序排列\nselect depEntity, depCount order by depCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/ineffectual-statement]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：A statement has no effect",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Statement has no effect\n * @description A statement has no effect\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/ineffectual-statement\n */\n\nimport python\n\n// Attribute analysis predicates\n/**\n * Determines if an attribute is understood by tracking its class hierarchy\n */\npredicate understood_attribute(Attribute attrNode, ClassValue sourceClass, ClassValue attrClass) {\n  exists(string attrName | attrNode.getName() = attrName |\n    attrNode.getObject().pointsTo().getClass() = sourceClass and\n    sourceClass.attr(attrName).getClass() = attrClass\n  )\n}\n\n/**\n * Checks if attribute access has side effects through descriptor types\n */\npredicate side_effecting_attribute(Attribute attrNode) {\n  exists(ClassValue descriptorClass |\n    understood_attribute(attrNode, _, descriptorClass) and\n    side_effecting_descriptor_type(descriptorClass)\n  )\n}\n\n/**\n * Identifies attributes that might have side effects\n */\npredicate maybe_side_effecting_attribute(Attribute attrNode) {\n  not understood_attribute(attrNode, _, _) and not attrNode.pointsTo(_)\n  or\n  side_effecting_attribute(attrNode)\n}\n\n/**\n * Determines if a descriptor type has side effects\n */\npredicate side_effecting_descriptor_type(ClassValue descriptor) {\n  descriptor.isDescriptorType() and\n  // Exclude specific built-in descriptor types known to be side-effect free\n  not descriptor = ClassValue::functionType() and\n  not descriptor = ClassValue::staticmethod() and\n  not descriptor = ClassValue::classmethod()\n}\n\n// Binary operation analysis predicates\n/**\n * Identifies binary operations with potential side effects\n */\npredicate side_effecting_binary(Expr binaryExpr) {\n  exists(Expr operand, ClassValue operandClass, string methodName |\n    binary_operator_special_method(binaryExpr, operand, operandClass, methodName)\n    or\n    comparison_special_method(binaryExpr, operand, operandClass, methodName)\n  |\n    methodName = special_method() and\n    operandClass.hasAttribute(methodName) and\n    not exists(ClassValue declaringClass |\n      declaringClass.declaresAttribute(methodName) and\n      declaringClass = operandClass.getASuperType() and\n      declaringClass.isBuiltin() and\n      not declaringClass = ClassValue::object()\n    )\n  )\n}\n\npragma[nomagic]\nprivate predicate binary_operator_special_method(\n  BinaryExpr binaryExpr, Expr leftOperand, ClassValue leftClass, string methodName\n) {\n  methodName = special_method() and\n  leftOperand = binaryExpr.getLeft() and\n  methodName = binaryExpr.getOp().getSpecialMethodName() and\n  leftOperand.pointsTo().getClass() = leftClass\n}\n\npragma[nomagic]\nprivate predicate comparison_special_method(\n  Compare compareExpr, Expr comparedOperand, ClassValue operandClass, string methodName\n) {\n  exists(Cmpop op |\n    compareExpr.compares(comparedOperand, op, _) and\n    methodName = op.getSpecialMethodName()\n  ) and\n  comparedOperand.pointsTo().getClass() = operandClass\n}\n\nprivate string special_method() {\n  result = any(Cmpop c).getSpecialMethodName()\n  or\n  result = any(BinaryExpr b).getOp().getSpecialMethodName()\n}\n\n// Notebook analysis predicates\n/**\n * Checks if a file is a Jupyter/IPython notebook\n */\npredicate is_notebook(File sourceFile) {\n  exists(Comment comment | comment.getLocation().getFile() = sourceFile |\n    comment.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\n/** Identifies expressions within Jupyter/IPython notebooks */\npredicate in_notebook(Expr expr) { is_notebook(expr.getScope().(Module).getFile()) }\n\n// Testing context predicates\n/**\n * Gets the FunctionValue for unittest.TestCase's assertRaises method\n */\nFunctionValue assertRaises() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\n/** Checks if an expression is within a test for exception raising */\npredicate in_raises_test(Expr expr) {\n  exists(With withBlock |\n    withBlock.contains(expr) and\n    withBlock.getContextExpr() = assertRaises().getACall().getNode()\n  )\n}\n\n// Python 2 compatibility predicates\n/** Identifies Python 2 print statements (>> syntax) */\npredicate python2_print(Expr expr) {\n  expr.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n  expr.(BinaryExpr).getOp() instanceof RShift\n  or\n  python2_print(expr.(Tuple).getElt(0))\n}\n\n// Core analysis predicate\n/**\n * Determines if an expression has no effect\n */\npredicate no_effect(Expr expr) {\n  // Exclude string literals (used as docstrings/comments)\n  not expr instanceof StringLiteral and\n  // Exclude expressions with known side effects\n  not expr.hasSideEffects() and\n  // Check all sub-expressions for potential side effects\n  forall(Expr subExpr | subExpr = expr.getASubExpression*() |\n    not side_effecting_binary(subExpr) and\n    not maybe_side_effecting_attribute(subExpr)\n  ) and\n  // Exclude special contexts where expressions might have semantic meaning\n  not in_notebook(expr) and\n  not in_raises_test(expr) and\n  not python2_print(expr)\n}\n\n// Main query\nfrom ExprStmt stmt\nwhere no_effect(stmt.getValue())\nselect stmt, \"This statement has no effect.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Result of integer division may be truncated\n * @description Identifies division operations where both operands are integers,\n *              potentially causing truncation in Python 2.\n * @kind problem\n_______________ // 补全条件\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// Detect integer division operations that may truncate results\nfrom BinaryExpr divisionOp, ControlFlowNode leftArg, ControlFlowNode rightArg\nwhere\n  // Restrict analysis to Python 2 (true division was introduced in Python 3)\n  major_version() = 2 and\n  exists(\n    BinaryExprNode divNode, \n    Value leftIntVal, \n    Value rightIntVal\n    |\n    // Verify division operator and node relationship\n    divNode = divisionOp.getAFlowNode() and\n    divNode.getNode().getOp() instanceof Div and\n    \n    // Validate left operand is integer\n    divNode.getLeft().pointsTo(leftIntVal, leftArg) and\n    leftIntVal.getClass() = ClassValue::int_() and\n    \n    // Validate right operand is integer\n    divNode.getRight().pointsTo(rightIntVal, rightArg) and\n    rightIntVal.getClass() = ClassValue::int_() and\n    \n    // Exclude exact divisions (no truncation when remainder is zero)\n    not leftIntVal.(NumericValue).getIntValue() % rightIntVal.(NumericValue).getIntValue() = 0 and\n    \n    // Exclude modules using future division imports\n    not divNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // Exclude explicit integer conversions of division results\n    not exists(CallNode intCastCall |\n      intCastCall = ClassValue::int_().getACall() and\n      intCastCall.getAnArg() = divNode\n    )\n  )\nselect divisionOp, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftArg, \"left\", rightArg, \"right\"",
    "output": "* @tags maintainability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Should use a 'with' statement\n * @description Detects 'try-finally' blocks that only close resources, which can be simplified\n *              using 'with' statements for better readability and maintainability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/should-use-with\n */\n_______________ // 补全条件\nimport python\n\n// Determines if a call invokes the 'close' method\npredicate isCloseMethodCall(Call closeCall) { \n    exists(Attribute attr | \n        closeCall.getFunc() = attr and \n        attr.getName() = \"close\"\n    ) \n}\n\n// Checks if a try statement's finally block contains only a single close call\npredicate hasOnlyCloseInFinally(Try tryStmt, Call closeCall) {\n    exists(ExprStmt stmt |\n        tryStmt.getAFinalstmt() = stmt and \n        stmt.getValue() = closeCall and \n        strictcount(tryStmt.getAFinalstmt()) = 1\n    )\n}\n\n// Verifies if a control flow node references a context manager instance\npredicate referencesContextManager(ControlFlowNode flowNode, ClassValue contextManagerClass) {\n    forex(Value value | flowNode.pointsTo(value) | \n        value.getClass() = contextManagerClass\n    ) and\n    contextManagerClass.isContextManager()\n}\n\n// Identifies try-finally blocks that only close context managers\nfrom Call close, Try tryBlock, ClassValue contextManager\nwhere\n    hasOnlyCloseInFinally(tryBlock, close) and\n    isCloseMethodCall(close) and\n    exists(ControlFlowNode targetNode | \n        targetNode = close.getFunc().getAFlowNode().(AttrNode).getObject() and\n        referencesContextManager(targetNode, contextManager)\n    )\nselect close,\n    \"Instance of context-manager class $@ is closed in a finally block. Consider using 'with' statement.\",\n    contextManager, contextManager.getName()",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-misconfiguration-with-credentials]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Disabling or weakening Same-Origin Policy (SOP) protection may expose",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name CORS Misconfiguration with Credentials\n * @description Disabling or weakening Same-Origin Policy (SOP) protection may expose\n *              the application to CORS attacks when credentials are allowed.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n// Validate CORS middleware type\npredicate isCorsType(Http::Server::CorsMiddleware middlewareInstance) {\n  middlewareInstance.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n// Check if credentials are enabled\npredicate allowsCredentials(Http::Server::CorsMiddleware middlewareInstance) {\n  middlewareInstance.getCredentialsAllowed().asExpr() instanceof True\n}\n\n// Detect wildcard or null origin configurations\npredicate containsWildcardOrigin(DataFlow::Node originConfigNode) {\n  // Case 1: Origin is a list containing \"*\" or \"null\"\n  originConfigNode.asExpr() instanceof List and\n  exists(StringLiteral wildcardLiteral |\n    wildcardLiteral = originConfigNode.asExpr().getASubExpression() and\n    wildcardLiteral.getText() in [\"*\", \"null\"]\n  )\n  // Case 2: Origin is directly \"*\" or \"null\" string\n  or\n  exists(StringLiteral wildcardLiteral |\n    wildcardLiteral = originConfigNode.asExpr() and\n    wildcardLiteral.getText() in [\"*\", \"null\"]\n  )\n}\n\n// Identify risky CORS configurations\nfrom Http::Server::CorsMiddleware middlewareInstance\nwhere\n  // Combined conditions: valid CORS type + credentials enabled + wildcard origin\n  isCorsType(middlewareInstance) and\n  allowsCredentials(middlewareInstance) and\n  containsWildcardOrigin(middlewareInstance.getOrigins().getALocalSource())\nselect middlewareInstance,\n  \"This CORS middleware configuration allows authenticated cross-origin requests from any source, potentially exposing sensitive data\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Detects use of weak asymmetric key sizes (less than 2048 bits).",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak key generation key size (< 2048 bits)\n * @description\n * Detects use of weak asymmetric key sizes (less than 2048 bits).\n * @id py/weak-asymmetric-key-gen-size\n * @kind problem\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Locate asymmetric key generation operations with insufficient key strength\nfrom AsymmetricKeyGen cryptoKeyGen, DataFlow::Node keyConfigNode, int keySizeBits, string algorithmName\nwhere\n  // Extract key size from configuration source\n  keySizeBits = cryptoKeyGen.getKeySizeInBits(keyConfigNode) and\n  // Verify key size is below minimum security requirement\n  keySizeBits < 2048 and\n  // Obtain algorithm name for reporting\n  algorithmName = cryptoKeyGen.getAlgorithm().getName() and\n  // Exclude elliptic curve algorithms (different security paradigms)\n  not isEllipticCurveAlgorithm(algorithmName, _)\n// Report findings with context about the weak key configuration\nselect cryptoKeyGen,\n  \"Weak asymmetric key size (\" + keySizeBits.toString() + \" bits) for algorithm \" +\n    algorithmName + \" configured at $@\", keyConfigNode, keyConfigNode.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/init-method-is-generator]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies class initializers that include generator expressions (yield or yield from),",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Generator in `__init__` method\n * @description Identifies class initializers that include generator expressions (yield or yield from),\n *              which can cause unexpected behavior as __init__ methods should return None.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/init-method-is-generator\n */\n\nimport python\n\nfrom Function classInitializer\nwhere\n  // Verify that we're analyzing a class initialization method\n  classInitializer.isInitMethod() and\n  // Determine if the method body contains generator expressions\n  (\n    exists(Yield generatorExpr | generatorExpr.getScope() = classInitializer) or\n    exists(YieldFrom yieldFromExpr | yieldFromExpr.getScope() = classInitializer)\n  )\nselect classInitializer, \"__init__ method is a generator.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-exec]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The 'exec' statement or function is used which could cause arbitrary code to be executed.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'exec' used\n * @description The 'exec' statement or function is used which could cause arbitrary code to be executed.\n * @kind problem\n * @tags security\n *       correctness\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec\n */\n\n// Import Python library for code parsing and analysis\nimport python\n\n// Function to generate version-specific error message for exec usage\nstring getExecErrorMessage() {\n  // Return message for Python 2 where exec is a statement\n  result = \"The 'exec' statement is used.\" and major_version() = 2\n  // Return message for Python 3 where exec is a function\n  or\n  result = \"The 'exec' function is used.\" and major_version() = 3\n}\n\n// Predicate to identify calls to the exec function\npredicate isExecFunctionCall(Call functionCall) {\n  // Check if the call references a global variable named 'exec'\n  exists(GlobalVariable execVariable | \n    execVariable = functionCall.getFunc().(Name).getVariable() and \n    execVariable.getId() = \"exec\"\n  )\n}\n\n// Select all AST nodes representing exec usage\nfrom AstNode execNode\n// Condition: node is either an exec function call or an exec statement\nwhere isExecFunctionCall(execNode) or execNode instanceof Exec\n// Output the exec usage node with appropriate error message\nselect execNode, getExecErrorMessage()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-callable called\n * @description Detects calls to objects that are not callable, which will raise a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom \n  Call callSite, \n  Value calledValue, \n  ClassValue valueType, \n  Expr functionExpr, \n  AstNode valueOrigin\nwhere\n  // Identify the function expression in the call\n  functionExpr = callSite.getFunc() and\n  \n  // Trace the function expression to its underlying value and origin\n  functionExpr.pointsTo(calledValue, valueOrigin) and\n  \n  // Determine the class of the called value\n  valueType = calledValue.getClass() and\n  \n  // Verify the class is not callable\n  not valueType.isCallable() and\n  \n  // Ensure type inference succeeded\n  not valueType.failedInference(_) and\n  \n  // Exclude descriptor objects with __get__ (which might be callable through protocol)\n  not valueType.hasAttribute(\"__get__\") and\n  \n  // Exclude None values (explicitly non-callable)\n  not calledValue = Value::named(\"None\") and\n  \n_______________ // 补全条件\n  not use_of_not_implemented_in_raise(_, functionExpr)\nselect \n  callSite, \n  \"Call to a $@ of $@.\", \n  valueOrigin, \n  \"non-callable\", \n  valueType, \n  valueType.toString()",
    "output": "// Exclude NotImplemented in raise statements (special handling)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-iterable used in for loop\n * @description Detects for loops attempting to iterate over non-iterable objects, which would cause runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/non-iterable-in-for-loop\n */\n\nimport python\n\n// Identify for-loops using non-iterable values\nfrom For forLoop, ControlFlowNode iterNode, Value iteratedValue, ClassValue iteratedType, ControlFlowNode sourceNode\nwhere\n  // Connect for-loop to its iterator expression node\n  forLoop.getIter().getAFlowNode() = iterNode and\n  // Trace iterator node to its source value and origin\n  iterNode.pointsTo(_, iteratedValue, sourceNode) and\n  // Obtain class type of the iterated value\n  iteratedValue.getClass() = iteratedType and\n  // Verify class type is non-iterable\n  not iteratedType.isIterable() and\n  // Exclude cases with failed type inference\n  not iteratedType.failedInference(_) and\n_______________ // 补全条件\n  not iteratedValue = Value::named(\"None\") and\n  // Exclude descriptor types with special iteration behavior\n  not iteratedType.isDescriptorType()\nselect forLoop, \"This for-loop may attempt to iterate over a $@ of class $@.\", sourceNode,\n  \"non-iterable instance\", iteratedType, iteratedType.getName()",
    "output": "// Exclude None values (intentionally non-iterable)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-randomness]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Using a cryptographically weak pseudo-random number generator to generate a",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Insecure randomness\n * @description Using a cryptographically weak pseudo-random number generator to generate a\n *              security-sensitive value may allow an attacker to predict what value will\n *              be generated.\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/insecure-randomness\n * @tags security\n *       experimental\n *       external/cwe/cwe-338\n */\n\n// 导入Python库，用于分析Python代码\nimport python\n\n// 导入实验性的semmle.python.security.InsecureRandomness模块，用于检测不安全的随机数生成\nimport experimental.semmle.python.security.InsecureRandomness\n\n// 导入数据流分析模块，用于跟踪数据流路径\nimport semmle.python.dataflow.new.DataFlow\n\n// 从InsecureRandomness::Flow::PathGraph中导入路径图，用于表示数据流路径\nimport InsecureRandomness::Flow::PathGraph\n\n// 定义查询语句，查找不安全随机数生成的路径问题\nfrom InsecureRandomness::Flow::PathNode source, InsecureRandomness::Flow::PathNode sink\nwhere InsecureRandomness::Flow::flowPath(source, sink) // 条件：存在从源节点到汇节点的数据流路径\nselect sink.getNode(), source, sink, \"Cryptographically insecure $@ in a security context.\",\n  source.getNode(), \"random value\" // 选择结果：汇节点、源节点、路径信息和描述信息"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Expression reference resolution failure\n * @description Identifies expressions that cannot be resolved to any specific object reference,\n *              which limits type inference and static analysis effectiveness.\n * @kind problem\n_______________ // 补全条件\n * @problem.severity info\n * @tags debug\n * @deprecated\n */\n\n// Import Python analysis framework for code examination\nimport python\n\n// Locate expressions that have control flow nodes unable to reference any concrete object\nfrom Expr unresolvedExpression\nwhere \n  // Verify the expression has at least one associated control flow node\n  exists(ControlFlowNode associatedFlowNode | \n    // Link the expression to its corresponding control flow node\n    associatedFlowNode = unresolvedExpression.getAFlowNode()\n  ) and\n  // Confirm that none of the expression's control flow nodes reference any object\n  forall(ControlFlowNode connectedFlowNode | \n    connectedFlowNode = unresolvedExpression.getAFlowNode() |\n    not connectedFlowNode.refersTo(_)\n  )\n// Output the identified expression with a descriptive message\nselect unresolvedExpression, \"Expression does not 'point-to' any object.\"",
    "output": "* @id py/points-to-failure"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-be-context-manager]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects classes that implement __del__ for resource cleanup",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class should be a context manager\n * @description Detects classes that implement __del__ for resource cleanup\n *              but do not support the context manager protocol. Converting\n *              such classes to context managers enhances resource management\n *              and code clarity.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision medium\n * @id py/should-be-context-manager\n */\n\nimport python\n\nfrom ClassValue resourceClass\nwhere\n  // Exclude built-in classes from our analysis scope\n  not resourceClass.isBuiltin() and\n  // Check that the class doesn't implement the context manager protocol\n  not resourceClass.isContextManager() and\n  // Verify the class has a __del__ method for resource cleanup\n  exists(resourceClass.declaredAttribute(\"__del__\"))\nselect resourceClass,\n  \"Class \" + resourceClass.getName() +\n    \" implements __del__ (presumably to release some resource). Consider making it a context manager.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-padding]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* This query identifies asymmetric encryption padding methods that are considered insecure,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Detection of insecure asymmetric cryptographic padding\n * @description\n * This query identifies asymmetric encryption padding methods that are considered insecure,\n * deprecated, or have unclear security implications. In modern cryptographic practices,\n * only OAEP (Optimal Asymmetric Encryption Padding), KEM (Key Encapsulation Mechanism),\n * and PSS (Probabilistic Signature Scheme) are recognized as secure padding schemes for\n * asymmetric cryptography. Any other padding method may introduce security vulnerabilities\n * and should be replaced with one of the approved algorithms.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// This query detects asymmetric cryptographic padding schemes that are not secure\nfrom AsymmetricPadding insecurePaddingMethod, string paddingAlgorithmName\nwhere \n  // Step 1: Obtain the name of the padding algorithm being used\n  paddingAlgorithmName = insecurePaddingMethod.getPaddingName()\n  // Step 2: Verify that the padding scheme is not one of the approved secure algorithms\n  and not (paddingAlgorithmName = \"OAEP\" or \n           paddingAlgorithmName = \"KEM\" or \n           paddingAlgorithmName = \"PSS\")\nselect insecurePaddingMethod, \"Detected use of unapproved, weak, or unknown asymmetric padding algorithm or API: \" + paddingAlgorithmName"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name File-wise deletion statistics\n * @description Aggregates the cumulative count of removed lines for each file \n *              across the complete version history maintained in the database.\n * @kind treemap\n * @id py/historical-lines-deleted\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python // Python模块，提供Python代码分析功能\nimport external.VCS // 外部版本控制模块，用于访问代码版本历史数据\n\n// 提取模块文件及其对应的总删除行数\nfrom Module codeModule, int totalRemovedLines\nwhere\n  // 确保模块具有可度量的代码行数\n  exists(codeModule.getMetrics().getNumberOfLinesOfCode()) and\n  // 计算该模块在所有版本提交中的累计删除行数\n  totalRemovedLines =\n    sum(Commit versionCommit, int linesRemoved |\n      // 获取每次提交中对应文件的删除行数，并排除自动生成的变更\n      linesRemoved = versionCommit.getRecentDeletionsForFile(codeModule.getFile()) \n      and not artificialChange(versionCommit)\n    |\n      linesRemoved // 累计每次提交的删除行数\n    )\nselect codeModule, totalRemovedLines order by totalRemovedLines desc // 按总删除行数降序排列结果",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/key-exchange]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and reports all cryptographic key exchange algorithm implementations",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Key Exchange Algorithms Detection\n * @description Identifies and reports all cryptographic key exchange algorithm implementations\n *              across supported cryptographic libraries for quantum readiness assessment.\n * @kind problem\n * @id py/quantum-readiness/cbom/key-exchange\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import core Python analysis framework\nimport python\n\n// Import experimental cryptographic concepts module\nimport experimental.cryptography.Concepts\n\n// Identify cryptographic key exchange implementations\nfrom KeyExchangeAlgorithm keyExchangeImpl\n\n// Generate alert for each detected key exchange algorithm\nselect keyExchangeImpl, \"Detected key exchange algorithm: \" + keyExchangeImpl.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-url-substring-sanitization]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Security checks on URL substrings without full parsing are vulnerable to bypass techniques.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks on URL substrings without full parsing are vulnerable to bypass techniques.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Defines regex pattern for common top-level domains\nprivate string getCommonTLDRegex() { result = \"com|org|edu|gov|uk|net|io\" }\n\n// Checks if string literal matches URL structural patterns\npredicate resemblesUrl(StringLiteral urlLiteral) {\n  exists(string urlContent | urlContent = urlLiteral.getText() |\n    // Matches URLs with common TLDs (case-insensitive)\n    urlContent.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + getCommonTLDRegex() +\n        \")(:[0-9]+)?/?\")\n    or\n    // Matches HTTP/HTTPS URLs with any TLD\n    urlContent.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Identifies sanitization operations with incomplete URL validation\npredicate hasIncompleteUrlSanitization(Expr sanitizedExpr, StringLiteral urlLiteral) {\n  resemblesUrl(urlLiteral) and\n  (\n    // Direct comparison operations\n    sanitizedExpr.(Compare).compares(urlLiteral, any(In i), _)\n    or\n    // Unsafe prefix checks\n    isUnsafePrefixCheck(sanitizedExpr, urlLiteral)\n    or\n    // Unsafe suffix checks\n    isUnsafeSuffixCheck(sanitizedExpr, urlLiteral)\n  )\n}\n\n// Detects unsafe prefix checks using startswith without full URL validation\npredicate isUnsafePrefixCheck(Call methodCall, StringLiteral urlLiteral) {\n  methodCall.getFunc().(Attribute).getName() = \"startswith\" and\n  methodCall.getArg(0) = urlLiteral and\n  // Exclude cases where full URL path is validated\n  not urlLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n}\n\n// Detects unsafe suffix checks using endswith without proper TLD validation\npredicate isUnsafeSuffixCheck(Call methodCall, StringLiteral urlLiteral) {\n  methodCall.getFunc().(Attribute).getName() = \"endswith\" and\n  methodCall.getArg(0) = urlLiteral and\n  // Exclude cases with proper domain structure\n  not urlLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n}\n\n// Query: Find expressions with incomplete URL substring sanitization\nfrom Expr sanitizedExpr, StringLiteral urlLiteral\nwhere hasIncompleteUrlSanitization(sanitizedExpr, urlLiteral)\nselect sanitizedExpr, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlLiteral,\n  urlLiteral.getText()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/constant-conditional-expression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies conditional expressions that always evaluate to the same",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Constant in conditional expression or statement\n * @description Identifies conditional expressions that always evaluate to the same\n *              result due to containing constant values or builtin constants.\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/constant-conditional-expression\n */\n\nimport python\n\n// Determines if an expression is utilized within a conditional context\npredicate used_as_condition(Expr conditionNode) {\n  // Verifies if expression serves as test condition in if statement\n  exists(If ifNode | ifNode.getTest() = conditionNode) or\n  // Verifies if expression serves as test condition in conditional expression\n  exists(IfExp ifExprNode | ifExprNode.getTest() = conditionNode)\n}\n\n/* Identifies specific builtin names as constants when they remain unredefined. */\npredicate is_effective_constant(Name nameNode) {\n  // Locates unredefined global builtin constants\n  exists(GlobalVariable globalVar | \n    globalVar = nameNode.getVariable() and \n    not exists(NameNode definingNode | definingNode.defines(globalVar)) |\n    globalVar.getId() = \"True\" or \n    globalVar.getId() = \"False\" or \n    globalVar.getId() = \"NotImplemented\"\n  )\n}\n\n// Detects conditional expressions that result in unreachable code paths\npredicate causes_unreachable_code(Expr conditionNode) {\n  // Checks if statements where condition creates unreachable branches\n  exists(If ifNode | \n    ifNode.getTest() = conditionNode and \n    (ifNode.getStmt(0).isUnreachable() or \n     ifNode.getOrelse(0).isUnreachable())\n  )\n  or\n  // Checks while loops where condition creates unreachable loop body\n  exists(While whileNode | \n    whileNode.getTest() = conditionNode and \n    whileNode.getStmt(0).isUnreachable()\n  )\n}\n\n// Locates all constant expressions appearing in conditional contexts\nfrom Expr conditionNode\nwhere\n  // Confirms expression is used in conditional context\n  used_as_condition(conditionNode) and\n  // Validates expression is either constant or effectively constant\n  (conditionNode.isConstant() or is_effective_constant(conditionNode)) and\n  /* Excludes conditions resulting in unreachable code (addressed separately) */\n  // Filters out conditions leading to unreachable code (handled by different query)\n  not causes_unreachable_code(conditionNode)\n// Reports detection results\nselect conditionNode, \"Testing a constant will always give the same result.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/incorrect-overridden-signature]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测方法重写场景下，派生类方法签名与基类方法签名不一致，且调用时参数不匹配的情况，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 重写方法签名与使用不匹配\n * @description 检测方法重写场景下，派生类方法签名与基类方法签名不一致，且调用时参数不匹配的情况，\n *              这种不匹配可能导致运行时错误或未定义行为。\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/inheritance/incorrect-overridden-signature\n */\n\nimport python  // 导入Python库，用于处理Python代码的查询\nimport Expressions.CallArgs  // 导入表达式调用参数库，用于处理函数调用参数\n\nfrom Call methodCall, FunctionValue baseMethod, FunctionValue derivedMethod, string issueDescription  // 从方法调用、基类方法、派生类方法和问题描述字符串中选择数据\nwhere\n  // 基础验证：排除构造函数并确保存在重写关系\n  not baseMethod.getName() = \"__init__\" and  // 排除构造函数 '__init__'\n  derivedMethod.overrides(baseMethod) and  // 确保 'derivedMethod' 是 'baseMethod' 的重写方法\n  \n  // 调用验证：获取派生类方法的调用节点并验证参数合法性\n  methodCall = derivedMethod.getAMethodCall().getNode() and  // 获取派生类方法的调用节点\n  correct_args_if_called_as_method(methodCall, derivedMethod) and  // 验证作为方法调用时参数是否正确\n  \n  // 参数不匹配检测：检查参数数量或名称的不一致\n  (\n    // 参数数量不匹配的情况\n    (\n      arg_count(methodCall) + 1 < baseMethod.minParameters() and issueDescription = \"too few arguments\"  // 当参数数量少于最小要求时标记为\"参数过少\"\n      or\n      arg_count(methodCall) >= baseMethod.maxParameters() and issueDescription = \"too many arguments\"  // 当参数数量超过最大限制时标记为\"参数过多\"\n    )\n    or\n    // 参数名称不匹配的情况\n    exists(string parameterName |\n      methodCall.getAKeyword().getArg() = parameterName and  // 获取调用中的关键字参数名称\n      derivedMethod.getScope().getAnArg().(Name).getId() = parameterName and  // 验证派生类方法中存在该参数\n      not baseMethod.getScope().getAnArg().(Name).getId() = parameterName and  // 确认基类方法中不存在该参数\n      issueDescription = \"an argument named '\" + parameterName + \"'\"  // 标记为\"存在名为 'parameterName' 的参数\"\n    )\n  )\nselect baseMethod,  // 选择基类方法作为主要输出\n  \"Overridden method signature does not match $@, where it is passed \" + issueDescription +\n    \". Overriding method $@ matches the call.\", methodCall, \"call\", derivedMethod,  // 生成问题描述，指出签名不匹配和参数问题\n  derivedMethod.descriptiveString()  // 提供派生类方法的描述性字符串"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak cryptographic hash algorithms\n * @description Identifies cryptographic hash functions considered weak or unapproved \n *              for security purposes, excluding only SHA-256, SHA-384, and SHA-512.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n_______________ // 补全条件\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom HashAlgorithm hashOperation, string algorithmName, string alertMessage\nwhere\n  // Extract algorithm name from the hash operation\n  algorithmName = hashOperation.getHashName() and\n  // Exclude strong, approved hash algorithms\n  not algorithmName = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  // Generate appropriate alert based on algorithm recognition status\n  (\n    // Case: Recognized but unapproved algorithm\n    algorithmName != \"\" and\n    alertMessage = \"Use of unapproved hash algorithm or API \" + algorithmName + \".\"\n    or\n    // Case: Unrecognized algorithm\n    algorithmName = \"\" and\n    alertMessage = \"Use of unrecognized hash algorithm.\"\n  )\nselect hashOperation, alertMessage",
    "output": "* @precision high"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-default-protocol]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Leaving the SSL/TLS version unspecified may result in an insecure",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Default version of SSL/TLS may be insecure\n * @description Leaving the SSL/TLS version unspecified may result in an insecure\n *              default protocol being used.\n * @id py/insecure-default-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\n// This query identifies deprecated SSL/TLS socket configurations lacking explicit protocol versioning.\n// Unspecified ssl_version parameters in ssl.wrap_socket calls may trigger insecure protocol defaults.\n// Focuses specifically on deprecated direct socket wrapping. For broader connection security analysis,\n// refer to the py/insecure-protocol query.\nimport python\nimport semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode deprecatedSocketWrapCall\nwhere\n  // Identify all calls to the deprecated ssl.wrap_socket function\n  deprecatedSocketWrapCall = API::moduleImport(\"ssl\").getMember(\"wrap_socket\").getACall()\n  and\n  // Ensure no explicit ssl_version parameter is specified\n  not exists(deprecatedSocketWrapCall.getArgByName(\"ssl_version\"))\nselect deprecatedSocketWrapCall,\n  \"Call to deprecated method ssl.wrap_socket does not specify a protocol, which may result in an insecure default being used.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Commented-out code\n * @description Identifies code segments that have been commented out, which can reduce code readability and maintainability.\n * @kind problem\n * @tags maintainability\n_______________ // 补全条件\n *       documentation\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/commented-out-code */\n\n// Import the Python language analysis library\nimport python\n\n// Import the CommentedOutCode class from Lexical module for code analysis\nimport Lexical.CommentedOutCode\n\n// Define a query that identifies commented-out code blocks\nfrom CommentedOutCodeBlock commentBlock\n// Apply filter to exclude example code blocks\nwhere not commentBlock.maybeExampleCode()\n// Select the identified comment blocks with descriptive message\nselect commentBlock, \"This comment appears to contain commented-out code.\"",
    "output": "*       readability"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/undefined-attribute]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Accessing an attribute of `self` that is not initialized anywhere in the class in the `__init__` method may cause an AttributeError at runtime",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Undefined class attribute\n * @description Accessing an attribute of `self` that is not initialized anywhere in the class in the `__init__` method may cause an AttributeError at runtime\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision low\n * @id py/undefined-attribute\n */\n\nimport python\nimport ClassAttributes\n\n// 定义一个谓词函数，用于检查未定义的类属性\npredicate undefined_class_attribute(SelfAttributeRead a, CheckClass c, int line, string name) {\n  // 获取属性名称\n  name = a.getName() and\n  // 检查该属性是否在类中有时被定义\n  not c.sometimesDefines(name) and\n  // 检查该属性是否是有趣的未定义属性\n  c.interestingUndefined(a) and\n  // 获取属性访问的行号\n  line = a.getLocation().getStartLine() and\n  // 检查该属性是否在初始化方法中被赋值\n  not attribute_assigned_in_method(c.getAMethodCalledFromInit(), name)\n}\n\n// 定义一个报告未定义类属性的谓词函数\npredicate report_undefined_class_attribute(Attribute a, ClassObject c, string name) {\n  // 存在一个行号，使得未定义的类属性条件成立，并且是最小的行号\n  exists(int line |\n    undefined_class_attribute(a, c, line, name) and\n    line = min(int x | undefined_class_attribute(_, c, x, name))\n  )\n}\n\n// 从所有属性和类对象中选择满足条件的未定义类属性，并生成报告\nfrom Attribute a, ClassObject c, string name\nwhere report_undefined_class_attribute(a, c, name)\nselect a, \"Attribute '\" + name + \"' is not defined in either the class body or in any method.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/signature-mismatch]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a subclass method overrides a superclass method",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Signature mismatch in overriding method\n * @description Detects when a subclass method overrides a superclass method\n *              with incompatible parameter counts, potentially causing runtime errors.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Identify overriding methods with signature mismatches\nfrom FunctionValue superclassMethod, PythonFunctionValue subclassMethod\nwhere\n  // Verify inheritance override relationship\n  subclassMethod.overrides(superclassMethod) and\n  \n  // Restrict to normal instance methods (exclude special methods and constructors)\n  subclassMethod.isNormalMethod() and\n  not subclassMethod.getScope().isSpecialMethod() and\n  subclassMethod.getName() != \"__init__\" and\n  \n  // Exclude cases where superclass method is directly called\n  not exists(superclassMethod.getACall()) and\n  \n  // Ensure no alternative overriding methods are being called\n  not exists(FunctionValue alternativeSubclassMethod |\n    alternativeSubclassMethod.overrides(superclassMethod) and\n    exists(alternativeSubclassMethod.getACall())\n  ) and\n  \n  // Detect parameter count incompatibility between subclass and superclass methods\n  (\n    // Case 1: Subclass requires more parameters than superclass can provide\n    subclassMethod.minParameters() > superclassMethod.maxParameters()\n    or\n    // Case 2: Subclass accepts fewer parameters than superclass requires\n    subclassMethod.maxParameters() < superclassMethod.minParameters()\n  )\nselect subclassMethod, \"Overriding method '\" + subclassMethod.getName() + \"' has signature mismatch with $@.\",\n  superclassMethod, \"overridden method\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-named-argument]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects calls using named arguments that don't match any parameter",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Wrong name for an argument in a call\n * @description Detects calls using named arguments that don't match any parameter\n *              of the target function/method, causing runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-argument\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Identify function calls with invalid named arguments\nfrom Call invocation, FunctionObject targetFunc, string paramName\nwhere\n  // Core check: argument name doesn't match any parameter\n  illegally_named_parameter_objectapi(invocation, targetFunc, paramName) and\n  // Exclude abstract functions (may have dynamic parameters)\n  not targetFunc.isAbstract() and\n  // Exclude cases where parent class defines the parameter\n  not exists(FunctionObject overriddenMethod |\n    targetFunc.overrides(overriddenMethod) and\n    overriddenMethod.getFunction().getAnArg().(Name).getId() = paramName\n  )\nselect invocation, \n  \"Keyword argument '\" + paramName + \"' is not a supported parameter name of $@.\", \n  targetFunc, \n  targetFunc.descriptiveString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Block cipher mode detection\n * @description Identifies all instances of block cipher modes of operation \n *              across supported cryptographic libraries in Python codebases\n * @kind problem\n * @id py/quantum-readiness/cbom/block-cipher-mode\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Core Python language support for code analysis\nimport python\n\n_______________ // 补全条件\nimport experimental.cryptography.Concepts\n\n// Source of block cipher mode instances\nfrom BlockMode mode\n\n// Result projection with algorithm identification\nselect mode, \n       \"Algorithm in use: \" + mode.getBlockModeName()",
    "output": "// Cryptographic concepts library for operation detection"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Hash Algorithms Usage\n * @description Identifies all instances where cryptographic hash algorithms are utilized through supported libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/hash-algorithms\n * @problem.severity error\n_______________ // 补全条件\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom HashAlgorithm hashAlg\n\nselect hashAlg, \"Use of algorithm \" + hashAlg.getName()",
    "output": "* @tags cbom"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'import *' used\n * @description Using import * prevents some analysis\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n_______________ // 补全条件\n// 导入Python分析库，提供对Python代码结构的解析支持\nimport python\n\n// 定义变量表示所有星号通配符导入语句\nfrom ImportStar starImportStmt\n\n// 报告所有通配符导入实例，说明其污染命名空间的危害\nselect starImportStmt, \"Using 'from ... import *' pollutes the namespace.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 分析指向关系图的压缩效率指标：统计唯一事实数量、关系图总大小，\n * 并计算它们相对于上下文深度的压缩比率。\n * 该查询有助于评估点对分析中数据结构的优化程度。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义查询输出变量：唯一事实数量、关系总大小、上下文深度和压缩比率\nfrom int distinctFactsNum, int relationsTotalSize, int contextDepth, float compressionRatio\nwhere\n  // 获取当前分析的上下文深度\n  exists(PointsToContext ctx | contextDepth = ctx.getDepth()) and\n  // 计算唯一事实数量：统计不同的(控制流节点, 被指向对象, 类对象)组合\n  distinctFactsNum =\n    strictcount(ControlFlowNode controlFlowNode, Object pointedObject, ClassObject classObject |\n      exists(PointsToContext ctx |\n        // 验证在指定上下文中，控制流节点指向对象，且该对象是类对象的实例\n        PointsTo::points_to(controlFlowNode, ctx, pointedObject, classObject, _) and\n        ctx.getDepth() = contextDepth\n      )\n    ) and\n  // 计算关系总大小：统计所有(控制流节点, 被指向对象, 类对象, 上下文, 源控制流节点)组合\n  relationsTotalSize =\n_______________ // 补全条件\n      PointsToContext ctx, ControlFlowNode sourceControlFlowNode |\n      // 验证在指定上下文中，控制流节点指向对象，且该对象是类对象的实例，并记录源控制流节点\n      PointsTo::points_to(controlFlowNode, ctx, pointedObject, classObject, sourceControlFlowNode) and\n      ctx.getDepth() = contextDepth\n    ) and\n  // 计算压缩比率：唯一事实数量占关系总大小的百分比\n  compressionRatio = 100.0 * distinctFactsNum / relationsTotalSize\n// 输出结果：上下文深度、唯一事实数量、关系总大小和压缩比率\nselect contextDepth, distinctFactsNum, relationsTotalSize, compressionRatio",
    "output": "strictcount(ControlFlowNode controlFlowNode, Object pointedObject, ClassObject classObject,"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-co-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the average number of files that are modified together whenever a specific file is changed in a commit",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of co-committed files\n * @description Measures the average number of files that are modified together whenever a specific file is changed in a commit\n * @kind treemap\n * @id py/historical-number-of-co-commits\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg min max\n */\n\nimport python\nimport external.VCS\n\n// Main analysis: Evaluates co-modification patterns across different modules\nfrom Module analyzedModule\n// Filtering condition: Only process modules that have measurable lines of code\nwhere exists(analyzedModule.getMetrics().getNumberOfLinesOfCode())\nselect analyzedModule,\n  // Compute the average count of files modified alongside files in this module\n  avg(Commit commitRecord, int coCommitCount |\n    // Condition: The commitRecord includes a file from the analyzedModule\n    commitRecord.getAnAffectedFile() = analyzedModule.getFile() and \n    // Calculate the number of additional files modified in the same commitRecord\n    coCommitCount = count(commitRecord.getAnAffectedFile()) - 1\n  |\n    coCommitCount\n  )"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies data flow paths where untrusted user input",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted Data Propagation to Cookie Construction\n * @description Identifies data flow paths where untrusted user input\n *              is incorporated into cookie value assignments, potentially\n *              enabling injection attacks that compromise cookie integrity.\n * @id py/untrusted-cookie-injection\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 8.7\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\nfrom \n  CookieInjectionFlow::PathNode sourceNode, \n  CookieInjectionFlow::PathNode sinkNode\nwhere \n  // Direct data flow verification for cookie injection analysis\n  CookieInjectionFlow::flowPath(sourceNode, sinkNode)\nselect \n  sinkNode.getNode(), \n  sourceNode, \n  sinkNode, \n  \"Cookie value constructed from $@.\", \n  sourceNode.getNode(), \n  \"untrusted user input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/external-dependencies]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：量化Python源文件所依赖的外部包数量。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name 外部依赖关系\n * @description 量化Python源文件所依赖的外部包数量。\n * @kind treemap\n * @treemap.warnOn highValues\n * @metricType externalDependency\n * @id py/external-dependencies\n */\n\nimport python\nimport semmle.python.dependencies.TechInventory\n\n/*\n * 本查询分析Python源文件与外部包之间的依赖关系。\n * \n * 输出数据包含以下关键信息：\n * 1. 依赖实体标识符 - 由源文件路径和外部包名组合而成\n * 2. 依赖计数 - 源文件中引用该外部包的次数\n * \n * 尽管输出只有两列，但实际上涵盖了源文件、外部包、\n * 版本信息和依赖数量四个维度的数据。\n * \n * 文件路径添加了'/'前缀，以匹配仪表板数据库中使用的\n * 相对文件路径格式。\n */\n\n// 定义源文件、外部包、依赖计数和依赖实体\nfrom File sourceFile, ExternalPackage externalPkg, int depCount, string depEntity\nwhere\n  // 计算源文件中对外部包的依赖数量\n  depCount = strictcount(AstNode astNode |\n    dependency(astNode, externalPkg) and  // 检查AST节点是否依赖于指定的外部包\n    astNode.getLocation().getFile() = sourceFile  // 确保AST节点位于指定的源文件中\n  ) and\n  // 将源文件和外部包信息合并为单个实体标识符\n  depEntity = munge(sourceFile, externalPkg)\n// 选择依赖实体和依赖计数，并按依赖数量降序排列\nselect depEntity, depCount order by depCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-hostname-regexp]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies security weaknesses in regular expressions utilized for URL or hostname validation.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Vulnerable hostname regular expression patterns\n * @description Identifies security weaknesses in regular expressions utilized for URL or hostname validation.\n *              This query specifically targets patterns where dots (.) are not properly escaped,\n *              resulting in overly permissive hostname matching that could lead to security bypasses.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-hostname-regexp\n * @tags correctness\n *       security\n *       external/cwe/cwe-020\n */\n\n// Import the specialized analysis module for security assessment of hostname regular expressions\nprivate import semmle.python.security.regexp.HostnameRegex as HostnameSecurityAnalyzer\n\n// Define the main predicate to detect and report security vulnerabilities in hostname regular expression patterns\nquery predicate hostnameValidationFlaws = HostnameSecurityAnalyzer::incompleteHostnameRegExp/4;"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Initialization method invokes overridden method\n * @description Identifies invocations within `__init__` methods targeting functions that could be overridden by derived classes,\n *              potentially leading to exposure of partially constructed instances.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/init-calls-subclass\n */\n\nimport python\n\nfrom\n  ClassObject parentClass, string methodName, Call initializationCall,\n  FunctionObject derivedClassMethod, FunctionObject parentClassMethod\nwhere\n  // Identify the initialization method of the parent class\n  exists(FunctionObject initializationMethod |\n    parentClass.declaredAttribute(\"__init__\") = initializationMethod and\n    initializationCall.getScope() = initializationMethod.getFunction()\n  |\n    // Confirm the call is to a self attribute method\n    exists(SelfAttribute selfAttr |\n      initializationCall.getFunc() = selfAttr and\n      selfAttr.getName() = methodName\n    |\n_______________ // 补全条件\n      parentClassMethod = parentClass.declaredAttribute(methodName) and\n      derivedClassMethod.overrides(parentClassMethod)\n    )\n  )\n// Generate alert with method call details and override information\nselect initializationCall, \"Call to self.$@ in __init__ method, which is overridden by $@.\", \n  parentClassMethod, methodName, derivedClassMethod, derivedClassMethod.descriptiveString()",
    "output": "// Validate the method exists in parent class and is overridden"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-protocol]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code that uses deprecated SSL/TLS protocol versions, which can expose connections to known security vulnerabilities.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of insecure SSL/TLS version\n * @description Identifies code that uses deprecated SSL/TLS protocol versions, which can expose connections to known security vulnerabilities.\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n/* Represents nodes that configure deprecated SSL/TLS protocol versions */\nclass InsecureSSLConfig extends DataFlow::Node {\n  InsecureSSLConfig() {\n    /* Case 1: Creating vulnerable connection with security context */\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    /* Case 2: Creating vulnerable connection without security context */\n    unsafe_connection_creation_without_context(this, _)\n    or\n    /* Case 3: Creating insecure security context */\n    unsafe_context_creation(this, _)\n  }\n\n  /* Retrieves the function node associated with this configuration */\n  DataFlow::Node getAssociatedFunction() { \n    result = this.(DataFlow::CallCfgNode).getFunction() \n  }\n}\n\n/* Represents nodes that can be identified by name (function calls or attribute references) */\nclass NamedNode extends DataFlow::Node {\n  NamedNode() {\n    /* Case 1: Node is a function from protocol configuration */\n    this = any(InsecureSSLConfig insecureConfig).getAssociatedFunction()\n    or\n    /* Case 2: Node is an attribute reference of another identifiable node */\n    this = any(NamedNode attributeNode).(DataFlow::AttrRef).getObject()\n  }\n}\n\n/* Constructs the fully qualified name for a named node */\nstring getQualifiedName(NamedNode node) {\n  /* Case 1: Direct function name */\n  result = node.asExpr().(Name).getId()\n  or\n  /* Case 2: Attribute access chain */\n  exists(DataFlow::AttrRef attrRef | \n    attrRef = node and\n    result = getQualifiedName(attrRef.getObject()) + \".\" + attrRef.getAttributeName()\n  )\n}\n\n/* Helper functions for generating descriptive text */\n\n/* Generates descriptive text for SSL configuration */\nstring getConfigurationDescription(InsecureSSLConfig config) {\n  /* Case 1: Function call configuration */\n  exists(DataFlow::CallCfgNode callNode | \n    callNode = config and\n    result = \"call to \" + getQualifiedName(callNode.getFunction())\n  )\n  or\n  /* Case 2: Context modification (non-call, non-context creation) */\n  not config instanceof DataFlow::CallCfgNode and\n  not config instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n/* Determines appropriate verb based on explicit configuration flag */\nstring getVerbForConfiguration(boolean explicitFlag) {\n  explicitFlag = true and result = \"specified\"\n  or\n  explicitFlag = false and result = \"allowed\"\n}\n\n/* Query to identify usage of deprecated SSL/TLS protocol versions */\nfrom\n  DataFlow::Node vulnerabilityPoint, string protocolVersion, \n  InsecureSSLConfig configNode, boolean explicitFlag\nwhere\n  (\n    /* Case 1: Insecure connection with security context */\n    unsafe_connection_creation_with_context(vulnerabilityPoint, protocolVersion, configNode, explicitFlag)\n  )\n  or\n  (\n    /* Case 2: Insecure connection without security context */\n    unsafe_connection_creation_without_context(vulnerabilityPoint, protocolVersion) and\n    configNode = vulnerabilityPoint and\n    explicitFlag = true\n  )\n  or\n  (\n    /* Case 3: Insecure security context creation */\n    unsafe_context_creation(configNode, protocolVersion) and\n    vulnerabilityPoint = configNode and\n    explicitFlag = true\n  )\nselect vulnerabilityPoint,\n  \"Insecure SSL/TLS protocol version \" + protocolVersion + \" \" + getVerbForConfiguration(explicitFlag) + \" by $@.\",\n  configNode, getConfigurationDescription(configNode)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：定义在超类方法中的一个属性，其名称与子类方法匹配，会隐藏子类的方法。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 定义在超类方法中的一个属性，其名称与子类方法匹配，会隐藏子类的方法。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/* \n * 检测场景：子类中定义的方法被超类中定义的属性遮蔽\n * 关键逻辑：\n * 1. 确定子类与超类的继承关系\n * 2. 验证超类在初始化方法中定义了同名属性\n * 3. 确保超类本身未定义同名方法\n */\n\nimport python\n\n// 检测子类方法是否被超类属性遮蔽\npredicate shadowed_by_super_class(\n  ClassObject subcls, ClassObject superclass, Assign shadowingAssign, FunctionObject shadowedMethod\n) {\n  // 验证继承关系：subcls 继承自 superclass\n  subcls.getASuperType() = superclass and\n  // 确认子类中存在被遮蔽的方法\n  subcls.declaredAttribute(_) = shadowedMethod and\n  // 检查超类初始化方法中的属性定义\n  exists(FunctionObject superInit, Attribute attr, string methodName |\n    // 超类必须定义 __init__ 方法\n    superclass.declaredAttribute(\"__init__\") = superInit and\n    // 赋值语句的目标属性\n    attr = shadowingAssign.getATarget() and\n    // 属性必须属于 self 对象\n    attr.getObject().(Name).getId() = \"self\" and\n    // 属性名与方法名匹配\n    methodName = shadowedMethod.getName() and\n    attr.getName() = methodName and\n    // 赋值操作必须发生在超类的 __init__ 作用域内\n    shadowingAssign.getScope() = superInit.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  // 排除超类已定义同名方法的情况（避免误报）\n  not superclass.hasAttribute(shadowedMethod.getName())\n}\n\n// 主查询：定位被遮蔽的方法\nfrom ClassObject subcls, ClassObject superclass, Assign shadowingAssign, FunctionObject shadowedMethod\nwhere shadowed_by_super_class(subcls, superclass, shadowingAssign, shadowedMethod)\n// 输出格式保持不变：方法位置 + 描述信息 + 遮蔽赋值位置 + 属性类型\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superclass.getName() +\n    \"'.\", shadowingAssign, \"attribute\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/asymmetric-padding-schemes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query identifies all padding schemes used in asymmetric cryptographic algorithms,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Asymmetric Cryptography Padding Scheme Detection\n * @description This query identifies all padding schemes used in asymmetric cryptographic algorithms,\n *              which is crucial for quantum readiness assessment in cryptographic implementations.\n * @kind problem\n * @id py/quantum-readiness/cbom/asymmetric-padding-schemes\n * @problem.severity error\n * @tags cbom\n *       cryptography\n *       quantum-readiness\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找所有非对称加密算法中使用的填充方案并输出结果\nfrom AsymmetricPadding paddingScheme\nselect paddingScheme, \"Detected asymmetric padding scheme: \" + paddingScheme.getPaddingName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Tuple raised as exception in Python 2\n * @description In Python 2, raising a tuple causes only the first element to be used as the exception, ignoring the rest.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raises-tuple\n_______________ // 补全条件\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\n\n/* Python 3 treats raising tuples as type errors, handled by IllegalRaise query */\nfrom Raise raiseStmt, DataFlow::LocalSourceNode tupleSrcNode\nwhere\n  // Limit analysis to Python 2 environments where this behavior occurs\n  major_version() = 2 and\n  // Confirm the source node represents a tuple expression\n  tupleSrcNode.asExpr() instanceof Tuple and\n  // Establish data flow connection from tuple to the raised exception\n  exists(DataFlow::Node exceptionDestNode | \n    exceptionDestNode.asExpr() = raiseStmt.getException() and\n    tupleSrcNode.flowsTo(exceptionDestNode)\n  )\nselect raiseStmt,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  tupleSrcNode, \"tuple\"",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/signature-mismatch]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies overriding methods with parameter count mismatches",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incompatible method signature in override\n * @description Identifies overriding methods with parameter count mismatches\n *              relative to their superclass methods, which may cause runtime failures.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Detect signature mismatches between overridden and overriding methods\nfrom FunctionValue parentMethod, PythonFunctionValue childMethod\nwhere\n  // Establish valid override relationship\n  childMethod.overrides(parentMethod) and\n  \n  // Exclude special methods and constructors from analysis scope\n  (\n    not childMethod.getScope().isSpecialMethod() and\n    childMethod.getName() != \"__init__\" and\n    childMethod.isNormalMethod()\n  ) and\n  \n  // Validate parameter count incompatibility\n  (\n    // Child method requires more parameters than parent can provide\n    childMethod.minParameters() > parentMethod.maxParameters()\n    or\n    // Child method accepts fewer parameters than parent requires\n    childMethod.maxParameters() < parentMethod.minParameters()\n  ) and\n  \n  // Filter out scenarios where parent method is actively called\n  not exists(parentMethod.getACall()) and\n  \n  // Ensure no other overriding methods are being invoked\n  not exists(FunctionValue siblingMethod |\n    siblingMethod.overrides(parentMethod) and\n    exists(siblingMethod.getACall())\n  )\nselect childMethod, \"Overriding method '\" + childMethod.getName() + \"' has signature mismatch with $@.\",\n  parentMethod, \"overridden method\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insufficient KDF Salt Size\n * @description Identifies Key Derivation Function (KDF) implementations with salt sizes\n * below the security minimum of 128 bits (16 bytes).\n *\n * This query detects two critical security vulnerabilities:\n * 1. Salt size explicitly configured below the 16-byte threshold\n * 2. Salt size determined dynamically (preventing static verification)\n * \n * Focuses specifically on salt generation using Python's os.urandom() function.\n * @kind problem\n * @id py/kdf-small-salt-size\n_______________ // 补全条件\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Locate KDF operations with vulnerable salt configurations\nfrom KeyDerivationOperation kdfOperation, \n     DataFlow::Node saltSizeParam, \n     API::CallNode urandomInvocation, \n     string warningMsg\nwhere\n  // Ensure the KDF operation requires a salt parameter\n  kdfOperation.requiresSalt() and\n  \n  // Validate that salt configuration uses os.urandom\n  urandomInvocation = kdfOperation.getSaltConfigSrc() and\n  urandomInvocation = API::moduleImport(\"os\").getMember(\"urandom\").getACall() and\n  \n  // Trace the salt size parameter back to its origin\n  saltSizeParam = CryptoUtils::getUltimateSrcFromApiNode(urandomInvocation.getParameter(0, \"size\")) and\n  \n  // Identify security vulnerability patterns\n  (\n    // Case 1: Dynamic salt size (cannot be statically verified)\n    not exists(saltSizeParam.asExpr().(IntegerLiteral).getValue()) and\n    warningMsg = \"Salt size is not statically determinable. \"\n    or\n    // Case 2: Salt size below minimum security threshold\n    saltSizeParam.asExpr().(IntegerLiteral).getValue() < 16 and\n    warningMsg = \"Salt size is below security minimum. \"\n  )\n\n// Generate security alert with detailed context\nselect kdfOperation,\n  warningMsg + \"Minimum required salt size is 16 bytes. os.urandom Configuration: $@, Size Parameter: $@\", \n  urandomInvocation,\n  urandomInvocation.toString(), \n  saltSizeParam, \n  saltSizeParam.toString()",
    "output": "* @problem.severity error"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * 调用图结构效率分析：评估Python代码中调用图的紧凑性和优化空间。\n * 此查询通过统计调用事实数量、关系规模、上下文深度并计算密度指标，\n * 量化调用图的结构效率和数据压缩率，为代码重构提供量化参考。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义输出变量：callFactCount（调用事实总数）、callRelationCount（关系总规模）、\n// callContextDepth（上下文深度）和callGraphDensity（调用图密度指标）\nfrom int callFactCount, int callRelationCount, int callContextDepth, float callGraphDensity\nwhere\n  // 统计调用事实总数和关系规模，同时获取上下文深度信息\n  exists(int depth |\n    // 计算调用事实总数：统计所有(调用节点, 目标函数)二元组的数量\n    callFactCount =\n      strictcount(ControlFlowNode invokingNode, CallableValue targetFunction |\n        exists(PointsToContext invocationContext |\n          invokingNode = targetFunction.getACall(invocationContext) and // 获取目标函数在调用上下文中的调用节点\n          depth = invocationContext.getDepth() // 记录调用上下文的深度\n        )\n      ) and\n    // 计算调用图关系总规模：统计所有(调用节点, 目标函数, 调用上下文)三元组的数量\n    callRelationCount =\n      strictcount(ControlFlowNode invokingNode, CallableValue targetFunction, PointsToContext invocationContext |\n        invokingNode = targetFunction.getACall(invocationContext) and // 获取目标函数在调用上下文中的调用节点\n        depth = invocationContext.getDepth() // 确保使用相同的上下文深度\n      ) and\n    // 设置上下文深度值\n    callContextDepth = depth\n  ) and\n  // 计算调用图密度指标：将调用事实总数转换为相对于关系总规模的百分比密度\n  // 该指标反映调用图的紧凑程度，值越高表示结构越紧凑，优化空间越小\n  callGraphDensity = 100.0 * callFactCount / callRelationCount\nselect callContextDepth, callFactCount, callRelationCount, callGraphDensity // 返回上下文深度、调用事实总数、关系总规模和调用图密度指标"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use iteration count at least 100k to prevent brute force attacks\n * @description Detects insufficient iteration counts in key derivation functions.\n * Cryptographic keys derived from user inputs (like passwords) should use a high iteration count\n * (minimum 100,000 iterations) to prevent brute force attacks.\n *\n * The query flags two potential issues:\n * 1. When the iteration count is a constant value less than 100,000\n * 2. When the iteration count source cannot be statically determined\n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import standard Python analysis library\nimport python\n// Import experimental cryptography concepts for key derivation operations\nimport experimental.cryptography.Concepts\n// Import utility functions for cryptography analysis, aliased as CryptoUtils\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Select key derivation operations with insufficient iteration counts\nfrom KeyDerivationOperation kdfOp, string alertMsg, DataFlow::Node iterSrc\nwhere\n  // Focus on operations requiring iteration configuration\n  kdfOp.requiresIteration() and\n  // Identify the source of iteration count configuration\n  iterSrc = kdfOp.getIterationSizeSrc() and\n  // Evaluate iteration count source for security compliance\n_______________ // 补全条件\n    // Case 1: Explicitly defined iteration count below threshold\n    exists(IntegerLiteral lit |\n      lit = iterSrc.asExpr() and\n      lit.getValue() < 100000 and\n      alertMsg = \"Insufficient iteration count detected. \"\n    )\n    or\n    // Case 2: Iteration count cannot be statically verified\n    not iterSrc.asExpr() instanceof IntegerLiteral and\n    alertMsg = \"Iteration count cannot be statically verified. \"\n  )\nselect \n  // Report the key derivation operation with appropriate warning message\n  kdfOp, \n  alertMsg + \"Minimum required iteration count is 100000. \" + \n  \"Configuration source: $@\",\n  iterSrc.asExpr(), \n  iterSrc.asExpr().toString()",
    "output": "("
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/use-of-input]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of the built-in 'input' function in Python 2 code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Potentially unsafe 'input' function usage in Python 2\n * @description Detects usage of the built-in 'input' function in Python 2 code.\n *              In Python 2, 'input()' evaluates user input as Python code, creating a code injection vulnerability.\n *              Unlike the safe 'raw_input()' which returns a string, 'input()' can execute arbitrary code.\n * @kind problem\n * @tags security\n *       correctness\n *       security/cwe/cwe-94\n *       security/cwe/cwe-95\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/use-of-input\n */\n\nimport python  // Import the Python library for analyzing Python code\nimport semmle.python.dataflow.new.DataFlow  // Import data flow analysis library\nimport semmle.python.ApiGraphs  // Import API graph analysis library\n\n// Select call configuration nodes representing function calls\nfrom DataFlow::CallCfgNode dangerousInputUsage\nwhere\n  // Restrict analysis to Python 2 code\n  major_version() = 2\n  and\n  // Identify calls to the unsafe 'input' function\n  dangerousInputUsage = API::builtin(\"input\").getACall()\n  and\n  // Exclude calls to the safe 'raw_input' function\n  dangerousInputUsage != API::builtin(\"raw_input\").getACall()\nselect dangerousInputUsage, \"The unsafe built-in function 'input' is used in Python 2, which can lead to code injection.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-recent-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：统计过去180天内的代码提交数量",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 近期变更统计\n * @description 统计过去180天内的代码提交数量\n * @kind treemap\n * @id py/historical-number-of-recent-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\nimport python // 导入Python支持库\nimport external.VCS // 导入外部版本控制系统(VCS)集成库\n\n// 从Commit类中选择数据\nfrom Commit recentCommit\n// 过滤条件：提交日期在180天以内\nwhere recentCommit.daysToNow() <= 180\n// 排除人工更改的提交\nand not artificialChange(recentCommit)\n// 选择提交的修订名称和计数1\nselect recentCommit.getRevisionName(), 1"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/attribute-shadows-method]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Superclass attribute shadows subclass method\n * @description 当超类中定义的属性与子类方法同名时，会导致子类方法被隐藏。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/*\n * 检测子类方法被超类属性遮蔽的情况\n * 逻辑说明：\n * 1. 确认继承关系：子类继承自超类\n * 2. 子类声明了被遮蔽的方法\n * 3. 超类构造函数中存在同名属性赋值\n * 4. 排除超类中定义同名方法的情况\n */\n\nimport python\n\n// 判断子类方法是否被超类属性遮蔽\npredicate methodShadowedBySuperAttribute(\n  ClassObject subClass, ClassObject superClass, Assign attributeAssignment, FunctionObject shadowedMethod\n) {\n  // 确认继承关系\n  subClass.getASuperType() = superClass and\n  \n  // 子类声明了被遮蔽的方法\n  subClass.declaredAttribute(_) = shadowedMethod and\n  \n  // 定位超类构造函数中的同名属性赋值\n  exists(FunctionObject superInitMethod, Attribute assignedAttribute |\n    // 超类定义了__init__方法\n    superClass.declaredAttribute(\"__init__\") = superInitMethod and\n    \n    // 属性赋值目标为assignedAttribute\n    assignedAttribute = attributeAssignment.getATarget() and\n    \n    // 属性赋值对象是self\n    assignedAttribute.getObject().(Name).getId() = \"self\" and\n    \n    // 属性名与子类方法名相同\n    assignedAttribute.getName() = shadowedMethod.getName() and\n    \n    // 赋值发生在超类构造函数作用域内\n    attributeAssignment.getScope() = superInitMethod.getOrigin().(FunctionExpr).getInnerScope()\n  ) and\n  \n  // 排除超类中定义同名方法的情况（避免误报）\n  not superClass.hasAttribute(shadowedMethod.getName())\n}\n\n// 查询被遮蔽的方法及其相关上下文\nfrom ClassObject subClass, ClassObject superClass, Assign attributeAssignment, FunctionObject shadowedMethod\nwhere methodShadowedBySuperAttribute(subClass, superClass, attributeAssignment, shadowedMethod)\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superClass.getName() +\n    \"'.\", attributeAssignment, \"attribute\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable 'except' block\n * @description Identifies situations where a specific exception handler is positioned after a general one,\n *              causing it to be unreachable because the general handler will always intercept the exception first.\n_______________ // 补全条件\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Retrieves the exception type handled by an except statement\nClassValue getHandledExceptionType(ExceptStmt exceptStmt) { \n  exceptStmt.getType().pointsTo(result) \n}\n\n// Determines if an exception handler is unreachable due to handler ordering\npredicate hasUnreachableExceptionHandler(ExceptStmt earlierHandler, ClassValue generalExceptionType, \n                                        ExceptStmt laterHandler, ClassValue specificExceptionType) {\n  exists(Try tryStatement, int earlierIndex, int laterIndex |\n    // Both handlers belong to the same try statement\n    earlierHandler = tryStatement.getHandler(earlierIndex) and\n    laterHandler = tryStatement.getHandler(laterIndex) and\n    // Earlier handler appears before later handler\n    earlierIndex < laterIndex and\n    // Retrieve handled exception types\n    generalExceptionType = getHandledExceptionType(earlierHandler) and\n    specificExceptionType = getHandledExceptionType(laterHandler) and\n    // Earlier handler catches a superclass of the later handler's exception\n    generalExceptionType = specificExceptionType.getASuperType()\n  )\n}\n\n// Identify unreachable exception handlers across all code\nfrom ExceptStmt earlierHandler, ClassValue generalExceptionType, \n     ExceptStmt laterHandler, ClassValue specificExceptionType\n// Verify handler ordering causes unreachability\nwhere hasUnreachableExceptionHandler(earlierHandler, generalExceptionType, laterHandler, specificExceptionType)\n// Generate alert for unreachable handler\nselect laterHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  specificExceptionType, specificExceptionType.getName(), earlierHandler, \"except block\", generalExceptionType, generalExceptionType.getName()",
    "output": "* @kind problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes with lowercase initial letters, which violates naming conventions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed class\n * @description Identifies classes with lowercase initial letters, which violates naming conventions\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-class\n * @tags maintainability\n */\n\nimport python\n\n// Predicate to identify classes starting with lowercase letters\npredicate lower_case_class(Class cls) {\n  // Extract first character and verify it's not uppercase\n  exists(string firstChar |\n    firstChar = cls.getName().prefix(1) and\n    not firstChar = firstChar.toUpperCase()\n  )\n}\n\n// Identify classes violating naming conventions\nfrom Class cls\nwhere\n  cls.inSource() and\n  lower_case_class(cls) and\n  // Ensure this is the only misnamed class in its file\n  not exists(Class anotherClass |\n    anotherClass != cls and\n    anotherClass.getLocation().getFile() = cls.getLocation().getFile() and\n    lower_case_class(anotherClass)\n  )\nselect cls, \"Class names should start in uppercase.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Identifies and analyzes alert suppression mechanisms in Python source code\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing utilities\nprivate import semmle.python.Comment as PythonComment\n\n// Represents a single-line Python comment with location tracking\nclass SingleLineComment instanceof PythonComment::Comment {\n  // Retrieve location information for the comment\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Extract location details from parent class\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Extract the textual content of the comment\n  string getText() { result = super.getContents() }\n\n  // Provide string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Represents a Python AST node equipped with location tracking\nclass AstNode instanceof PythonComment::AstNode {\n  // Retrieve location information for the AST node\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Extract location details from parent class\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  // Provide string representation of the AST node\n  string toString() { result = super.toString() }\n}\n\n// Establish suppression relationships between AST nodes and comments\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Represents a noqa-style suppression comment for alert suppression\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Initialize by identifying noqa pattern in comment text\n  NoqaSuppressionComment() {\n    // Match case-insensitive noqa with optional suffix\n    super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Retrieve the annotation identifier for this suppression\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define the code range affected by this suppression\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Extract comment location and verify it starts at column 1\n_______________ // 补全条件\n    startCol = 1\n  }\n}",
    "output": "this.hasLocationInfo(filePath, startLine, _, endLine, endCol) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：使用 super() 访问继承的方法在旧式类中是不被支持的。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description 使用 super() 访问继承的方法在旧式类中是不被支持的。\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n/**\n * 检测在旧式类中使用 super() 的调用点\n * \n * 在 Python 中，旧式类（不继承自 object 的类）不支持使用 super() 函数\n * 来访问父类方法。此谓词识别这些不兼容的用法。\n */\npredicate superCallInOldStyleClass(Call superInvocation) {\n  exists(Function enclosingFunction, ClassObject enclosingClass |\n    // super() 调用必须位于某个函数内\n    superInvocation.getScope() = enclosingFunction and\n    // 该函数必须位于某个类内\n    enclosingFunction.getScope() = enclosingClass.getPyClass() and\n    // 确保类类型推断成功\n    not enclosingClass.failedInference() and\n    // 确保类是旧式类（不继承自 object）\n    not enclosingClass.isNewStyle() and\n    // 确保调用的是 super 函数\n    superInvocation.getFunc().(Name).getId() = \"super\"\n  )\n}\n\n// 查找所有在旧式类中使用 super() 的调用点\nfrom Call invalidSuperCall\n// 应用谓词筛选不兼容的 super() 调用\nwhere superCallInOldStyleClass(invalidSuperCall)\n// 输出结果和错误信息\nselect invalidSuperCall, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/iter-returns-non-iterator]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes returned by `__iter__` methods that fail to implement",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__iter__` method returns non-iterator type\n * @description Identifies classes returned by `__iter__` methods that fail to implement \n *              the iterator protocol, causing TypeError in iteration contexts like for-loops.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iter-returns-non-iterator\n */\n\nimport python\n\nfrom ClassValue sourceClass, FunctionValue iterMethod, ClassValue returnType\nwhere\n  // Locate the __iter__ method within the iterable class\n  iterMethod = sourceClass.lookup(\"__iter__\") and\n  // Derive the inferred return type of the __iter__ method\n  returnType = iterMethod.getAnInferredReturnType() and\n  // Confirm the return type violates iterator protocol requirements\n  not returnType.isIterator()\nselect \n  returnType,\n  \"Class \" + returnType.getName() + \n    \" is returned as an iterator (by $@) but doesn't implement the iterator protocol.\",\n  iterMethod, iterMethod.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unreachable-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers that become unreachable due to positioning",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unreachable 'except' block\n * @description Identifies exception handlers that become unreachable due to positioning\n *              after more general handlers which intercept exceptions first.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n// Detect unreachable exception handlers caused by improper handler ordering\nfrom ExceptStmt subsequentHandler, ClassValue derivedException,\n     ExceptStmt precedingHandler, ClassValue baseException\nwhere exists(Try enclosingTry, int precedingPosition, int subsequentPosition |\n    // Both handlers belong to the same try statement\n    precedingHandler = enclosingTry.getHandler(precedingPosition) and\n    subsequentHandler = enclosingTry.getHandler(subsequentPosition) and\n    // Preceding handler appears before subsequent handler\n    precedingPosition < subsequentPosition and\n    // Resolve exception types handled by each block\n    precedingHandler.getType().pointsTo(baseException) and\n    subsequentHandler.getType().pointsTo(derivedException) and\n    // Preceding handler catches a superclass of the subsequent handler's exception\n    baseException = derivedException.getASuperType()\n  )\n// Generate alert for the unreachable handler\nselect subsequentHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  derivedException, derivedException.getName(), precedingHandler, \"except block\", baseException, baseException.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Reflected server-side cross-site scripting\n * @description Detects security vulnerabilities where untrusted user input\n *              is directly rendered in web responses without adequate\n *              sanitization, potentially enabling XSS attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.1\n * @sub-severity high\n * @precision high\n * @id py/reflective-xss\n * @tags security\n *       external/cwe/cwe-079\n *       external/cwe/cwe-116\n */\n\n// Import core Python analysis capabilities\nimport python\n// Import specialized XSS vulnerability detection framework\nimport semmle.python.security.dataflow.ReflectedXssQuery\n// Import path visualization components for data flow analysis\nimport ReflectedXssFlow::PathGraph\n\n// Define input source and output sink nodes for vulnerability tracking\nfrom ReflectedXssFlow::PathNode inputSource, ReflectedXssFlow::PathNode outputSink\n\n// Establish the condition that a complete data flow path exists\n// between the identified input source and output sink\nwhere ReflectedXssFlow::flowPath(inputSource, outputSink)\n\n// Report the identified vulnerability with detailed flow path information\nselect outputSink.getNode(), \n_______________ // 补全条件\n       outputSink, \n       \"Cross-site scripting vulnerability due to a $@.\", \n       inputSource.getNode(), \n       \"user-provided value\"",
    "output": "inputSource,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Membership test with non-container type\n * @description Detects membership tests ('in'/'not in') where the right-hand side is not a container type,\n *              which can lead to runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\nfrom \n  ControlFlowNode rightHandSideNode, \n  Compare comparisonExpr, \n  Value inferredTypeValue, \n  ClassValue nonContainerClass, \n  ControlFlowNode sourceNode\nwhere\n_______________ // 补全条件\n  exists(Cmpop op, int idx |\n    comparisonExpr.getOp(idx) = op and \n    comparisonExpr.getComparator(idx) = rightHandSideNode.getNode() and\n    (op instanceof In or op instanceof NotIn)\n  ) and\n  \n  // Step 2: Perform points-to analysis to determine the type of the right operand\n  rightHandSideNode.pointsTo(_, inferredTypeValue, sourceNode) and\n  inferredTypeValue.getClass() = nonContainerClass and\n  \n  // Step 3: Filter out cases with incomplete type inference results\n  not Types::failedInference(nonContainerClass, _) and\n  \n  // Step 4: Verify the class lacks essential container interface methods\n  (not nonContainerClass.hasAttribute(\"__contains__\") and\n   not nonContainerClass.hasAttribute(\"__iter__\") and\n   not nonContainerClass.hasAttribute(\"__getitem__\")) and\n  \n  // Step 5: Exclude known pseudo-container types from triggering false positives\n  (not nonContainerClass = ClassValue::nonetype() and\n   not nonContainerClass = Value::named(\"types.MappingProxyType\"))\nselect \n  comparisonExpr, \n  \"This membership test may raise an Exception because $@ might be of non-container class $@.\", \n  sourceNode, \"target\", nonContainerClass, nonContainerClass.getName()",
    "output": "// Step 1: Identify membership test operation and extract right operand"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Analysis of incoming class dependencies\n * @description This query identifies and counts the number of classes that depend on each target class,\n *              providing insight into the afferent coupling metric for modularity assessment.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// Define the source of class metrics and extract the afferent coupling value\nfrom ClassMetrics measuredClass\nwhere exists(measuredClass.getAfferentCoupling())\nselect measuredClass, \n       measuredClass.getAfferentCoupling() as dependencyCount \norder by dependencyCount desc",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Signature mismatch in overriding method\n * @description Detects methods that override parent methods with incompatible signatures.\n *              Such mismatches may cause runtime errors when method calls expect arguments\n *              accepted by the parent but rejected by the child, or vice versa.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n_______________ // 补全条件\nfrom FunctionValue overriddenMethod, PythonFunctionValue overridingMethod\nwhere\n  // Establish inheritance relationship\n  overridingMethod.overrides(overriddenMethod) and\n  \n  // Exclude special methods and constructors\n  overridingMethod.isNormalMethod() and\n  not overridingMethod.getScope().isSpecialMethod() and\n  overridingMethod.getName() != \"__init__\" and\n  \n  // Detect parameter count incompatibility\n  (\n    overridingMethod.minParameters() > overriddenMethod.maxParameters() or\n    overridingMethod.maxParameters() < overriddenMethod.minParameters()\n  ) and\n  \n  // Verify no overridden methods in hierarchy are called\n  not exists(FunctionValue methodInHierarchy |\n    (methodInHierarchy = overriddenMethod or methodInHierarchy.overrides(overriddenMethod)) and\n    exists(methodInHierarchy.getACall())\n  )\nselect overridingMethod, \"Overriding method '\" + overridingMethod.getName() + \"' has signature mismatch with $@.\",\n  overriddenMethod, \"overridden method\"",
    "output": "// Identify overriding methods with signature incompatibilities"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-number-of-recent-commits]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：分析最近半年内的代码提交活动，评估项目开发活跃度",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 代码提交频率分析\n * @description 分析最近半年内的代码提交活动，评估项目开发活跃度\n * @kind treemap\n * @id py/historical-number-of-recent-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\nimport python // 导入Python语言支持库\nimport external.VCS // 导入版本控制系统(VCS)集成库\n\n// 从Commit类中选择符合条件的提交记录\nfrom Commit recentCommit\nwhere \n  // 条件1：筛选最近180天内的提交（约半年时间范围）\n  recentCommit.daysToNow() <= 180\n  and\n  // 条件2：排除由自动化工具生成的非人工提交\n  not artificialChange(recentCommit)\n// 输出提交的唯一修订标识符及计数\nselect \n  // 获取提交的修订名称作为标识\n  recentCommit.getRevisionName(), \n  // 每个提交记录计为1个单位，用于统计汇总\n  1"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Module is imported more than once\n * @description Identifies redundant module imports that impair code readability\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/repeated-import\n */\n\nimport python\n\n// Predicate to check if an import statement is a simple import (without attribute access)\npredicate isSimpleImport(Import imp) { not exists(Attribute a | imp.contains(a)) }\n\n// Predicate to identify duplicate imports within the same module scope\npredicate hasDuplicateImport(Import mainImport, Import duplicateImport, Module targetModule) {\n  // Ensure imports are distinct and both are simple imports\n  mainImport != duplicateImport and\n  isSimpleImport(mainImport) and\n  isSimpleImport(duplicateImport) and\n  \n  // Verify both imports reference the same target module\n  exists(ImportExpr mainExpr, ImportExpr dupExpr |\n    mainExpr.getName() = targetModule.getName() and\n    dupExpr.getName() = targetModule.getName() and\n    mainExpr = mainImport.getAName().getValue() and\n    dupExpr = duplicateImport.getAName().getValue()\n  ) and\n  \n  // Confirm both imports use identical aliases\n  mainImport.getAName().getAsname().(Name).getId() = duplicateImport.getAName().getAsname().(Name).getId() and\n  \n  // Check scope conditions: both imports in same module with either:\n  // - Duplicate import in nested scope, OR\n  // - Main import appears before duplicate in source order\n  exists(Module parentModule |\n    mainImport.getScope() = parentModule and\n    duplicateImport.getEnclosingModule() = parentModule and\n    (\n_______________ // 补全条件\n      mainImport.getAnEntryNode().dominates(duplicateImport.getAnEntryNode())\n    )\n  )\n}\n\n// Query to detect and report redundant module imports\nfrom Import mainImport, Import duplicateImport, Module targetModule\nwhere hasDuplicateImport(mainImport, duplicateImport, targetModule)\nselect duplicateImport,\n  \"This import of module \" + targetModule.getName() + \" is redundant, as it was previously imported $@.\",\n  mainImport, \"on line \" + mainImport.getLocation().getStartLine().toString()",
    "output": "duplicateImport.getScope() != parentModule or"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of exit() or quit()\n * @description Detects calls to exit() or quit() which may fail under '-S' interpreter option.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/use-of-exit-or-quit\n */\n\nimport python\n_______________ // 补全条件\nfrom CallNode funcCall, string funcName\nwhere \n  // Check if the called function points to site.Quitter objects (exit/quit)\n  funcCall.getFunction().pointsTo(Value::siteQuitter(funcName))\nselect \n  funcCall,\n  \"The '\" + funcName + \n  \"' site.Quitter object may not exist if the 'site' module is not loaded or is modified.\"",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Detects classes violating naming conventions by starting with lowercase letters\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-class\n * @tags maintainability\n */\n\nimport python\n\n// Helper predicate to identify classes with lowercase initial characters\npredicate hasLowerCaseInitial(Class cls) {\n  // Check if the first character of the class name is not uppercase\n  exists(string initialChar |\n    initialChar = cls.getName().prefix(1) and\n    not initialChar = initialChar.toUpperCase()\n  )\n}\n\n// Main query to find isolated naming violations\nfrom Class misnamedClass\nwhere\n  misnamedClass.inSource() and\n  hasLowerCaseInitial(misnamedClass) and\n  // Verify no other misnamed classes exist in the same file\n  not exists(Class otherMisnamedClass |\n    otherMisnamedClass != misnamedClass and\n    otherMisnamedClass.getLocation().getFile() = misnamedClass.getLocation().getFile() and\n    hasLowerCaseInitial(otherMisnamedClass)\n  )\nselect misnamedClass, \"Class names should start in uppercase.\"",
    "output": "* @name Misnamed class"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Signature mismatch in overriding method\n * @description Identifies overriding methods in subclasses with incompatible signatures\n *              compared to their parent class methods. Such mismatches may cause runtime\n *              errors when method calls expect arguments accepted by the parent but\n_______________ // 补全条件\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Identify child methods that override parent methods with incompatible signatures\nfrom FunctionValue parentMethod, PythonFunctionValue childMethod\nwhere\n  // Establish inheritance relationship between methods\n  childMethod.overrides(parentMethod) and\n  \n  // Exclude special methods, constructors, and non-normal methods\n  childMethod.isNormalMethod() and\n  not childMethod.getScope().isSpecialMethod() and\n  childMethod.getName() != \"__init__\" and\n  \n  // Verify parameter count incompatibility between child and parent methods\n  (\n    // Child method requires more parameters than parent method's maximum\n    childMethod.minParameters() > parentMethod.maxParameters() or\n    // Child method accepts fewer parameters than parent method's minimum\n    childMethod.maxParameters() < parentMethod.minParameters()\n  ) and\n  \n  // Ensure neither the parent method nor any ancestor methods are called in the codebase\n  not exists(FunctionValue ancestor |\n    (ancestor = parentMethod or ancestor.overrides(parentMethod)) and\n    exists(ancestor.getACall())\n  )\nselect childMethod, \"Overriding method '\" + childMethod.getName() + \"' has signature mismatch with $@.\",\n  parentMethod, \"overridden method\"",
    "output": "*              rejected by the child, or vice versa."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/catch-base-exception]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies exception handlers that catch BaseException without re-raising,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Exception block catches 'BaseException'\n * @description Identifies exception handlers that catch BaseException without re-raising,\n *              potentially masking system exits and keyboard interrupts.\n * @kind problem\n * @tags reliability\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Main query: Detect problematic exception handlers\nfrom ExceptStmt exceptStmt\nwhere\n  // Condition 1: Handler catches BaseException or has no type specified\n  (exceptStmt.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n   or\n   not exists(exceptStmt.getType()))\n  and\n  // Condition 2: Handler lacks re-raise mechanism (reaches program exit)\n  exceptStmt.getAFlowNode().getBasicBlock().reachesExit()\nselect exceptStmt, \"Except block directly handles BaseException.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incomplete URL substring sanitization\n * @description Detects security checks on URL substrings that may be bypassed due to incomplete sanitization\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Defines regex pattern for common top-level domains\nprivate string getCommonTldPattern() { \n  result = \"com|org|edu|gov|uk|net|io\" \n}\n\n// Determines if string literal exhibits URL characteristics\npredicate isUrlLikeString(StringLiteral urlStrLiteral) {\n  exists(string strContent | strContent = urlStrLiteral.getText() |\n    // Match URLs with optional protocol and common TLDs\n    strContent.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + getCommonTldPattern() +\n        \")(:[0-9]+)?/?\")\n    or\n    // Match standard HTTP/HTTPS URLs\n    strContent.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n_______________ // 补全条件\n}\n\n// Identifies unsafe prefix validation using startswith()\npredicate hasUnsafePrefixValidation(Call methodInvocation, StringLiteral prefixStrLiteral) {\n  methodInvocation.getFunc().(Attribute).getName() = \"startswith\" and\n  methodInvocation.getArg(0) = prefixStrLiteral and\n  // Exclude proper protocol prefixes\n  not prefixStrLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n}\n\n// Identifies unsafe suffix validation using endswith()\npredicate hasUnsafeSuffixValidation(Call methodInvocation, StringLiteral suffixStrLiteral) {\n  methodInvocation.getFunc().(Attribute).getName() = \"endswith\" and\n  methodInvocation.getArg(0) = suffixStrLiteral and\n  // Exclude proper domain suffixes\n  not suffixStrLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n}\n\n// Detects incomplete sanitization operations on URL substrings\npredicate exhibitsIncompleteUrlSanitization(Expr sanitizationOperation, StringLiteral urlStrLiteral) {\n  isUrlLikeString(urlStrLiteral) and\n  (\n    // Case 1: Direct comparison operations\n    sanitizationOperation.(Compare).compares(urlStrLiteral, any(In i), _)\n    or\n    // Case 2: Unsafe prefix validation\n    hasUnsafePrefixValidation(sanitizationOperation, urlStrLiteral)\n    or\n    // Case 3: Unsafe suffix validation\n    hasUnsafeSuffixValidation(sanitizationOperation, urlStrLiteral)\n  )\n}\n\n// Find expressions performing incomplete URL substring sanitization\nfrom Expr sanitizationOperation, StringLiteral urlStrLiteral\nwhere exhibitsIncompleteUrlSanitization(sanitizationOperation, urlStrLiteral)\nselect sanitizationOperation, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlStrLiteral,\n  urlStrLiteral.getText()",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Log Injection Vulnerability\n * @description Detects security flaws where untrusted user input is directly\n *              written to logs without proper sanitization, potentially enabling\n *              log tampering, forgery, or injection attacks.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.8\n * @precision medium\n * @id py/log-injection\n * @tags security\n_______________ // 补全条件\n */\n\nimport python\nimport semmle.python.security.dataflow.LogInjectionQuery\nimport LogInjectionFlow::PathGraph\n\nfrom LogInjectionFlow::PathNode untrustedInput, LogInjectionFlow::PathNode logSink\nwhere LogInjectionFlow::flowPath(untrustedInput, logSink)\nselect logSink.getNode(), untrustedInput, logSink,\n       \"This log entry incorporates a $@.\", untrustedInput.getNode(),\n       \"user-provided value\"",
    "output": "*       external/cwe/cwe-117"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'import *' may pollute namespace\n * @description Identifies star imports that pollute the namespace when the \n *              imported module lacks '__all__' definition\n * @kind problem\n * @tags maintainability\n *       modularity\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/polluting-import\n */\n_______________ // 补全条件\n// Import Python analysis library for code examination\nimport python\n\n// Main query to detect namespace-polluting imports\nfrom ImportStar pollutingImport, ModuleValue importedModule\nwhere \n  // Verify module existence and name consistency\n  importedModule.importedAs(pollutingImport.getImportedModuleName()) and\n  not importedModule.isAbsent() and\n  \n  // Exclude safe modules (built-ins are always safe)\n  not importedModule.isBuiltin() and\n  \n  // Check absence of '__all__' definition in all relevant scopes\n  not (\n    // Check module's main execution scope\n    importedModule.getScope().(ImportTimeScope).definesName(\"__all__\") or\n    // Check module's initialization scope (for packages)\n    importedModule.getScope().getInitModule().(ImportTimeScope).definesName(\"__all__\")\n  )\nselect pollutingImport,\n  \"Import pollutes the enclosing namespace, as the imported module $@ does not define '__all__'.\",\n  importedModule, importedModule.getName()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Find new subclasses to model\n * @id py/meta/find-subclasses-to-model\n * @kind table\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nprivate import semmle.python.ApiGraphs\nimport semmle.python.frameworks.internal.SubclassFinder::NotExposed\nprivate import semmle.python.frameworks.Flask\nprivate import semmle.python.frameworks.FastApi\nprivate import semmle.python.frameworks.Django\nprivate import semmle.python.frameworks.Tornado\nprivate import semmle.python.frameworks.Stdlib\nprivate import semmle.python.frameworks.Requests\nprivate import semmle.python.frameworks.Starlette\nprivate import semmle.python.frameworks.ClickhouseDriver\nprivate import semmle.python.frameworks.Aiohttp\nprivate import semmle.python.frameworks.Fabric\nprivate import semmle.python.frameworks.Httpx\nprivate import semmle.python.frameworks.Invoke\nprivate import semmle.python.frameworks.MarkupSafe\nprivate import semmle.python.frameworks.Multidict\nprivate import semmle.python.frameworks.Pycurl\nprivate import semmle.python.frameworks.RestFramework\nprivate import semmle.python.frameworks.SqlAlchemy\nprivate import semmle.python.frameworks.Tornado\nprivate import semmle.python.frameworks.Urllib3\nprivate import semmle.python.frameworks.Pydantic\nprivate import semmle.python.frameworks.Peewee\nprivate import semmle.python.frameworks.Aioch\nprivate import semmle.python.frameworks.Lxml\nimport semmle.python.frameworks.data.internal.ApiGraphModelsExtensions as Extensions\n\n// 定义一个类，用于查找 Flask View 类的子类\nclass FlaskViewClasses extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  FlaskViewClasses() { this = \"flask.View~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() { result = Flask::Views::View::subclassRef() }\n}\n\n// 定义一个类，用于查找 Flask MethodView 类的子类\nclass FlaskMethodViewClasses extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  FlaskMethodViewClasses() { this = \"flask.MethodView~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() { result = Flask::Views::MethodView::subclassRef() }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof FlaskViewClasses }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"flask.views.MethodView\" }\n}\n\n// 定义一个类，用于查找 FastApiRouter 类的子类\nclass FastApiRouter extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  FastApiRouter() { this = \"fastapi.APIRouter~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() { result = FastApi::ApiRouter::cls() }\n}\n\n// 定义一个类，用于查找 Django Form 类的子类\nclass DjangoForms extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoForms() { this = \"django.forms.BaseForm~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = any(Django::Forms::Form::ModeledSubclass subclass)\n  }\n}\n\n// 定义一个类，用于查找 Django View 类的子类\nclass DjangoView extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoView() { this = \"Django.Views.View~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = any(Django::Views::View::ModeledSubclass subclass)\n  }\n}\n\n// 定义一个类，用于查找 Django Field 类的子类\nclass DjangoField extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoField() { this = \"Django.Forms.Field~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = any(Django::Forms::Field::ModeledSubclass subclass)\n  }\n}\n\n// 定义一个类，用于查找 Django Model 类的子类\nclass DjangoModel extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoModel() { this = \"Django.db.models.Model~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DB::Models::Model::subclassRef()\n  }\n}\n\n// 定义一个类，用于查找 Tornado RequestHandler 类的子类\nclass TornadoRequestHandler extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  TornadoRequestHandler() { this = \"tornado.web.RequestHandler~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = Tornado::TornadoModule::Web::RequestHandler::subclassRef()\n  }\n}\n\n// 定义一个类，用于查找 WSGIServer 类的子类\nclass WSGIServer extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  WSGIServer() { this = \"wsgiref.simple_server.WSGIServer~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = StdlibPrivate::WsgirefSimpleServer::subclassRef()\n  }\n}\n\n// 定义一个类，用于查找 Stdlib BaseHttpRequestHandler 类的子类\nclass StdlibBaseHttpRequestHandler extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  StdlibBaseHttpRequestHandler() { this = \"http.server.BaseHTTPRequestHandler~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = StdlibPrivate::BaseHttpRequestHandler::subclassRef()\n  }\n}\n\n// 定义一个类，用于查找 Stdlib CgiFieldStorage 类的子类\nclass StdlibCgiFieldStorage extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  StdlibCgiFieldStorage() { this = \"cgi.FieldStorage~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = StdlibPrivate::Cgi::FieldStorage::subclassRef()\n  }\n}\n\n// 定义一个类，用于查找 Django HttpResponse 类的子类\nclass DjangoHttpResponse extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponse() { this = \"django.http.response.HttpResponse~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponse::classRef()\n  }\n}\n\n// 定义一个类，用于查找 Django HttpResponseRedirect 类的子类\nclass DjangoHttpResponseRedirect extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseRedirect() { this = \"django.http.response.HttpResponseRedirect~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseRedirect::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseRedirect\" }\n}\n\n// 定义一个类，用于查找 Django HttpResponsePermanentRedirect 类的子类\nclass DjangoHttpResponsePermanentRedirect extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponsePermanentRedirect() { this = \"django.http.response.HttpResponsePermanentRedirect~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponsePermanentRedirect::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponsePermanentRedirect\" }\n}\n\n// 定义一个类，用于查找 Django HttpResponseNotModified 类的子类\nclass DjangoHttpResponseNotModified extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseNotModified() { this = \"django.http.response.HttpResponseNotModified~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseNotModified::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseNotModified\" }\n}\n\n_______________ // 补全条件\nclass DjangoHttpResponseBadRequest extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseBadRequest() { this = \"django.http.response.HttpResponseBadRequest~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseBadRequest::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseBadRequest\" }\n}\n\n// 定义一个类，用于查找 Django HttpResponseNotFound 类的子类\nclass DjangoHttpResponseNotFound extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseNotFound() { this = \"django.http.response.HttpResponseNotFound~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseNotFound::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseNotFound\" }\n}\n\n// 定义一个类，用于查找 Django HttpResponseForbidden 类的子类\nclass DjangoHttpResponseForbidden extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseForbidden() { this = \"django.http.response.HttpResponseForbidden~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseForbidden::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseForbidden\" }\n}\n\n// 定义一个类，用于查找 Django HttpResponseNotAllowed 类的子类\nclass DjangoHttpResponseNotAllowed extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseNotAllowed() { this = \"django.http.response.HttpResponseNotAllowed~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseNotAllowed::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseNotAllowed\" }\n}\n\n// 定义一个类，用于查找 Django HttpResponseGone 类的子类\nclass DjangoHttpResponseGone extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseGone() { this = \"django.http.response.HttpResponseGone~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseGone::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseGone\" }\n}\n\n// 定义一个类，用于查找 Django HttpResponseServerError 类的子类\nclass DjangoHttpResponseServerError extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseServerError() { this = \"django.http.response.HttpResponseServerError~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseServerError::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseServerError\" }\n}\n\n// 定义一个类，用于查找 Django HttpResponseJsonResponse 类的子类\nclass DjangoHttpResponseJsonResponse extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseJsonResponse() { this = \"django.http.response.JsonResponse~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::JsonResponse::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.JsonResponse\" }\n}\n\n// 定义一个类，用于查找 Django StreamingHttpResponse 类的子类\nclass DjangoHttpResponseStreamingResponse extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseStreamingResponse() { this = \"django.http.response.StreamingHttpResponse~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::StreamingHttpResponse::classRef()\n  }\n}\n\n// 定义一个类，用于查找 Django FileResponse 类的子类\nclass DjangoHttpResponseFileResponse extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  DjangoHttpResponseFileResponse() { this = \"django.http.response.FileResponse~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::FileResponse::classRef()\n  }\n\n  // 重写方法，返回父类\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponseStreamingResponse }\n\n  // 重写方法，返回完全限定名\n  override string getFullyQualifiedName() { result = \"django.http.response.FileResponse\" }\n}\n\n// 定义一个类，用于查找 Flask Response 类的子类\nclass FlaskResponse extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  FlaskResponse() { this = \"flask.Response~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() { result = Flask::Response::classRef() }\n}\n\n// 定义一个类，用于查找 Requests Response 类的子类\nclass RequestsResponse extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  RequestsResponse() { this = \"requests.models.Response~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() { result = Requests::Response::classRef() }\n}\n\n// 定义一个类，用于查找 HTTPClient HTTPResponse 类的子类\nclass HttpClientHttpResponse extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  HttpClientHttpResponse() { this = \"http.client.HTTPResponse~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() { result = StdlibPrivate::HttpResponse::classRef() }\n}\n\n// 定义一个类，用于查找 Starlette WebSocket 类的子类\nclass StarletteWebsocket extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  StarletteWebsocket() { this = \"starlette.websockets.WebSocket~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() { result = Starlette::WebSocket::classRef() }\n}\n\n// 定义一个类，用于查找 Starlette URL 类的子类\nclass StarletteUrl extends FindSubclassesSpec {\n  // 构造函数，指定要查找的子类类型\n  StarletteUrl() { this = \"starlette.requests.URL~Subclass\" }\n\n  // 重写方法，返回已经建模的类\n  override API::Node getAlreadyModeledClass() { result = Starlette::Url::classRef() }\n}\n\n// 定义一个类，用于查找 Clickhouse Driver Client 类的子类\nclass ClickhouseClient extends FindSubclassesSpec {",
    "output": "// 定义一个类，用于查找 Django HttpResponseBadRequest 类的子类"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'exec' used\n * @description Identifies occurrences of the 'exec' statement/function that can potentially lead to arbitrary code execution vulnerabilities.\n * @kind problem\n * @tags security\n *       correctness\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec\n */\n\nimport python\n\n// Creates a tailored alert message based on the Python version in use\nstring createVersionSpecificExecWarning() {\n  // For Python 2: 'exec' is implemented as a statement\n  result = \"The 'exec' statement is used.\" and major_version() = 2\n  // For Python 3: 'exec' is implemented as a built-in function\n  or\n  result = \"The 'exec' function is used.\" and major_version() = 3\n}\n\n// Primary query logic to detect all instances of 'exec' usage\nfrom AstNode execInstance\nwhere \n  // Identify 'exec' function calls through global variable access\n  (exists(GlobalVariable globalExecVariable | \n_______________ // 补全条件\n    globalExecVariable = execInstance.(Call).getFunc().(Name).getVariable() and \n    globalExecVariable.getId() = \"exec\"\n  ))\n  or\n  // Identify 'exec' statement (Python 2 specific syntax)\n  execInstance instanceof Exec\n// Report each detected instance with its appropriate version-specific warning\nselect execInstance, createVersionSpecificExecWarning()",
    "output": "execInstance instanceof Call and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/loop-variable-capture]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when loop variables are captured in closures instead of their values",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Loop variable capture\n * @description Detects when loop variables are captured in closures instead of their values\n * @kind problem\n * @tags correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/loop-variable-capture\n */\n\nimport python\n\n/**\n * Retrieves the scope where iteration variables are defined for loop constructs.\n * - For For-loops: returns the loop's immediate scope\n * - For comprehensions: returns the enclosing function's scope\n */\nScope getIterationScope(AstNode loopNode) {\n  result = loopNode.(For).getScope()\n  or\n  result = loopNode.(Comp).getFunction()\n}\n\n/**\n * Detects when a callable expression captures a loop variable within its iteration scope.\n * Conditions:\n * 1. Variable is defined in the loop's iteration scope\n * 2. Variable is accessed inside the callable's inner scope\n * 3. Callable is nested within the loop construct\n * 4. Variable is either a For-loop target or comprehension iteration variable\n */\npredicate capturesLoopVariable(CallableExpr capturedFunc, AstNode loopNode, Variable loopVar) {\n  loopVar.getScope() = getIterationScope(loopNode) and\n  loopVar.getAnAccess().getScope() = capturedFunc.getInnerScope() and\n  capturedFunc.getParentNode+() = loopNode and\n  (\n    loopNode.(For).getTarget() = loopVar.getAnAccess()\n    or\n    loopVar = loopNode.(Comp).getAnIterationVariable()\n  )\n}\n\n/**\n * Determines if a captured loop variable escapes its original loop context.\n * Escape scenarios:\n * 1. For-loops: Callable is referenced outside the loop body\n * 2. Comprehensions: Callable is used as the element or within a tuple element\n */\npredicate escapesLoopCapture(CallableExpr capturedFunc, AstNode loopNode, Variable loopVar) {\n  capturesLoopVariable(capturedFunc, loopNode, loopVar) and\n  (\n    loopNode instanceof For and\n    exists(Expr ref | ref.pointsTo(_, _, capturedFunc) | not loopNode.contains(ref))\n    or\n    exists(Comp comp | comp = loopNode |\n      comp.getElt() = capturedFunc or\n      comp.getElt().(Tuple).getAnElt() = capturedFunc\n    )\n  )\n}\n\n// Identify callable expressions that capture and escape loop variables\nfrom CallableExpr capturedFunc, AstNode loopNode, Variable loopVar\nwhere escapesLoopCapture(capturedFunc, loopNode, loopVar)\nselect capturedFunc, \"Capture of loop variable $@.\", loopNode, loopVar.getId()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/unmatchable-caret]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Regular expressions containing a caret '^' in the middle cannot be matched, whatever the input.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unmatchable caret in regular expression\n * @description Regular expressions containing a caret '^' in the middle cannot be matched, whatever the input.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/regex/unmatchable-caret\n */\n\nimport python\nimport semmle.python.regex\n\n// Identify regular expressions with unmatchable caret characters\nfrom RegExp regex, int caretPosition\nwhere \n  // Exclude regex patterns that enable MULTILINE mode (where ^ matches line start)\n  not regex.getAMode() = \"MULTILINE\" and\n  // Exclude regex patterns that enable VERBOSE mode (where whitespace is ignored)\n  not regex.getAMode() = \"VERBOSE\" and\n  // Verify caret character exists at the specified position\n  regex.specialCharacter(caretPosition, caretPosition + 1, \"^\") and\n  // Ensure caret is not at the start of the regex pattern\n  not regex.firstItem(caretPosition, caretPosition + 1)\nselect regex,\n  \"This regular expression includes an unmatchable caret at offset \" + caretPosition.toString() + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/clear-text-logging-sensitive-data]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when sensitive data is logged without encryption,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Clear-text logging of sensitive information\n * @description Detects when sensitive data is logged without encryption,\n *              potentially exposing confidential information to unauthorized parties.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 7.5\n * @precision high\n * @id py/clear-text-logging-sensitive-data\n * @tags security\n *       external/cwe/cwe-312\n *       external/cwe/cwe-359\n *       external/cwe/cwe-532\n */\n\n// Import Python analysis framework\nimport python\n// Import data flow analysis capabilities\nprivate import semmle.python.dataflow.new.DataFlow\n// Import path graph visualization utilities\nimport CleartextLoggingFlow::PathGraph\n// Import specialized query for cleartext logging detection\nimport semmle.python.security.dataflow.CleartextLoggingQuery\n\n// Define query components for data flow analysis\nfrom\n  CleartextLoggingFlow::PathNode sensitiveDataNode,  // Source of sensitive data\n  CleartextLoggingFlow::PathNode logSinkNode,        // Logging destination\n  string classificationType                          // Data classification label\nwhere\n  // Verify data flows from sensitive source to logging sink\n  CleartextLoggingFlow::flowPath(sensitiveDataNode, logSinkNode)\n  and\n  // Extract classification from the sensitive data source\n  classificationType = sensitiveDataNode.getNode().(Source).getClassification()\nselect \n  // Report findings with sink location, flow path, and classification\n  logSinkNode.getNode(), \n  sensitiveDataNode, \n  logSinkNode, \n  \"This expression logs $@ as clear text.\", \n  sensitiveDataNode.getNode(),\n  \"sensitive data (\" + classificationType + \")\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/unkown-iv-sources]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别块密码操作中缺少初始化向量或nonce配置的安全隐患",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 未知初始化向量 (IV) 或 nonce\n * @description 识别块密码操作中缺少初始化向量或nonce配置的安全隐患\n * @kind problem\n * @id py/quantum-readiness/cbom/unkown-iv-sources\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找所有使用块密码模式的加密操作\nfrom BlockMode insecureBlockMode\nwhere \n    // 检查块密码模式是否缺少必要的初始化向量或nonce配置\n    not insecureBlockMode.hasIVorNonce()\nselect \n    // 返回存在安全风险的块模式实例\n    insecureBlockMode, \n    // 描述检测到的安全问题\n    \"Block mode with unknown IV or Nonce configuration\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unfinished task marker in comments\n * @description Identifies code comments containing 'TODO' or 'TO DO' markers,\n *              indicating incomplete code segments that may accumulate over time\n *              and impact maintainability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       documentation\n *       external/cwe/cwe-546\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/todo-comment\n */\n\nimport python  // Python language library for code analysis\n\n_______________ // 补全条件\nwhere \n  // Extract and analyze comment text content\n  exists(string commentContent | \n    commentContent = unfinishedTaskComment.getText() and\n    // Match common unfinished task patterns\n    (commentContent.matches(\"%TODO%\") or commentContent.matches(\"%TO DO%\"))\n  )\nselect unfinishedTaskComment, unfinishedTaskComment.getText()  // Output matching comments and their content",
    "output": "from Comment unfinishedTaskComment  // Source comment nodes"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/ineffectual-statement]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies statements that have no effect during program execution",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Statement has no effect\n * @description Identifies statements that have no effect during program execution\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/ineffectual-statement\n */\n\nimport python\n\n// Determines if an attribute is well-understood in terms of its source and target classes\npredicate is_attribute_understood(Attribute attr, ClassValue sourceCls, ClassValue attrCls) {\n  exists(string attrName | attr.getName() = attrName |\n    attr.getObject().pointsTo().getClass() = sourceCls and\n    sourceCls.attr(attrName).getClass() = attrCls\n  )\n}\n\n/* Conservatively determines if attribute access might have side effects */\npredicate has_side_effecting_attr(Attribute attr) {\n  exists(ClassValue attrCls |\n    is_attribute_understood(attr, _, attrCls) and\n    is_descriptor_type_side_effecting(attrCls)\n  )\n}\n\n// Identifies attributes that might potentially have side effects\npredicate might_have_side_effect_attr(Attribute attr) {\n  // Case 1: Attribute is not understood or doesn't point to a concrete value\n  (not is_attribute_understood(attr, _, _) and not attr.pointsTo(_))\n  or\n  // Case 2: Attribute is already identified as having side effects\n  has_side_effecting_attr(attr)\n}\n\n// Checks if a descriptor type has side effects when accessed\npredicate is_descriptor_type_side_effecting(ClassValue descriptorCls) {\n  descriptorCls.isDescriptorType() and\n  // Technically all descriptor accesses have side effects, but some represent missing calls\n  // which we want to treat as having no effect\n  not descriptorCls = ClassValue::functionType() and\n  not descriptorCls = ClassValue::staticmethod() and\n  not descriptorCls = ClassValue::classmethod()\n}\n\n/**\n * Binary operators with side effects are rare, so we assume they have no side effects\n * unless we know otherwise\n */\npredicate is_binary_side_effecting(Expr binaryExpr) {\n  exists(Expr subExpr, ClassValue exprCls, string methodName |\n    // Handle binary operator special methods\n    is_special_binary_operator(binaryExpr, subExpr, exprCls, methodName)\n    or\n    // Handle comparison operator special methods\n    is_special_comparison_operator(binaryExpr, subExpr, exprCls, methodName)\n  |\n    methodName = get_special_method_name() and\n    exprCls.hasAttribute(methodName) and\n    // Exclude inherited methods from built-in types (except object)\n    not exists(ClassValue declaring |\n      declaring.declaresAttribute(methodName) and\n      declaring = exprCls.getASuperType() and\n      declaring.isBuiltin() and\n      not declaring = ClassValue::object()\n    )\n  )\n}\n\npragma[nomagic]\nprivate predicate is_special_binary_operator(\n  BinaryExpr binaryExpr, Expr subExpr, ClassValue exprCls, string methodName\n) {\n  methodName = get_special_method_name() and\n  subExpr = binaryExpr.getLeft() and\n  methodName = binaryExpr.getOp().getSpecialMethodName() and\n  subExpr.pointsTo().getClass() = exprCls\n}\n\npragma[nomagic]\nprivate predicate is_special_comparison_operator(Compare binaryExpr, Expr subExpr, ClassValue exprCls, string methodName) {\n  exists(Cmpop op |\n    binaryExpr.compares(subExpr, op, _) and\n    methodName = op.getSpecialMethodName()\n  ) and\n  subExpr.pointsTo().getClass() = exprCls\n}\n\nprivate string get_special_method_name() {\n  result = any(Cmpop c).getSpecialMethodName()\n  or\n  result = any(BinaryExpr b).getOp().getSpecialMethodName()\n}\n\n// Determines if a file is a Jupyter/IPython notebook\npredicate is_notebook_file(File file) {\n  exists(Comment comment | comment.getLocation().getFile() = file |\n    comment.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\n/** Expressions (statements) within Jupyter/IPython notebooks */\npredicate expr_in_notebook(Expr expr) { \n  is_notebook_file(expr.getScope().(Module).getFile()) \n}\n\n// Retrieves the FunctionValue object for unittest.TestCase's assertRaises method\nFunctionValue get_assert_raises_method() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\n/** True if expression `expr` is within a `with` block that tests exception raising */\npredicate expr_in_raises_test(Expr expr) {\n  exists(With withStmt |\n    withStmt.contains(expr) and\n    withStmt.getContextExpr() = get_assert_raises_method().getACall().getNode()\n  )\n}\n\n/** True if expression has the form of Python 2 `print >> out, ...` statement */\npredicate is_python2_print_stmt(Expr expr) {\n  // Handle print >> syntax\n  (expr.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n   expr.(BinaryExpr).getOp() instanceof RShift)\n  or\n  // Recursively handle first element in tuple\n  is_python2_print_stmt(expr.(Tuple).getElt(0))\n}\n\n// Determines if an expression has no effect\npredicate expression_has_no_effect(Expr expr) {\n  // String literals can serve as comments\n  not expr instanceof StringLiteral and\n  not expr.hasSideEffects() and\n  // Check all sub-expressions\n  forall(Expr subExpr | subExpr = expr.getASubExpression*() |\n    not is_binary_side_effecting(subExpr) and\n    not might_have_side_effect_attr(subExpr)\n  ) and\n  // Exclude special cases\n  not expr_in_notebook(expr) and\n  not expr_in_raises_test(expr) and\n  not is_python2_print_stmt(expr)\n}\n\n// Select statements with no effect and report the issue\nfrom ExprStmt stmt\nwhere expression_has_no_effect(stmt.getValue())\nselect stmt, \"This statement has no effect.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Provides details about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import CodeQL's alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing utilities\nprivate import semmle.python.Comment as P\n\n// Represents a Python AST node that can track its location\nclass AstNode instanceof P::AstNode {\n  // Check if node has specific location information\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Verify location matches parent class location data\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Get string representation of the node\n  string toString() { result = super.toString() }\n}\n\n// Represents a single-line Python comment with location tracking\nclass SingleLineComment instanceof P::Comment {\n  // Check if comment has specific location information\n  predicate hasLocationInfo(\n    string sourceFile, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Verify location matches parent class location data\n    super.getLocation().hasLocationInfo(sourceFile, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Get the text content of the comment\n  string getText() { result = super.getContents() }\n\n  // Get string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships between AST nodes and comments\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Represents a noqa-style suppression comment that can suppress alerts\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Initialize by checking comment matches noqa pattern\n  NoqaSuppressionComment() {\n    // Match case-insensitive noqa with optional suffix\n    super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n_______________ // 补全条件\n  // Get the annotation identifier for this suppression\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define the code range covered by this suppression\n  override predicate covers(\n    string sourceFile, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Get comment location and verify it starts at column 1\n    this.hasLocationInfo(sourceFile, beginLine, _, finishLine, finishColumn) and\n    beginColumn = 1\n  }\n}",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/signing-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all potential usages of cryptographic signing algorithms",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cryptographic Signing Algorithms Detection\n * @description Identifies all potential usages of cryptographic signing algorithms\n *              within supported cryptographic libraries in the codebase.\n * @kind problem\n * @id py/quantum-readiness/cbom/signing-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python module for analyzing Python source code\nimport python\n\n// Import experimental cryptography concepts for handling cryptographic operations\nimport experimental.cryptography.Concepts\n\n// Select all instances of signing algorithms from the SigningAlgorithm class\nfrom SigningAlgorithm cryptoAlgorithm\n\n// Query statement: select the algorithm instance and its name with a descriptive prefix\nselect cryptoAlgorithm, \"Use of algorithm \" + cryptoAlgorithm.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Analysis of Alert Suppression\n * @description Identifies and analyzes alert suppression mechanisms in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression handling utilities\nprivate import codeql.util.suppression.AlertSuppression as AlertSuppressionUtils\n// Import Python comment processing functionality\nprivate import semmle.python.Comment as PythonCommentProcessor\n\n// Represents a Python AST node with location information\nclass AstNode instanceof PythonCommentProcessor::AstNode {\n  // Obtain string representation of the AST node\n  string toString() { result = super.toString() }\n\n  // Determine if node has detailed location information\n  predicate hasLocationInfo(\n    string sourcePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Validate that location coordinates match parent class data\n    super.getLocation().hasLocationInfo(sourcePath, beginLine, beginColumn, finishLine, finishColumn)\n  }\n}\n\n// Denotes a single-line comment in Python source code\nclass SingleLineComment instanceof PythonCommentProcessor::Comment {\n  // Obtain string representation of the comment\n  string toString() { result = super.toString() }\n\n  // Determine if comment has detailed location information\n  predicate hasLocationInfo(\n    string sourcePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Validate that location coordinates match parent class data\n    super.getLocation().hasLocationInfo(sourcePath, beginLine, beginColumn, finishLine, finishColumn)\n  }\n\n  // Retrieve the textual content of the comment\n  string getText() { result = super.getContents() }\n}\n\n// Establish suppression associations between AST nodes and comments\nimport AlertSuppressionUtils::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression marker. Respected by both pylint and pyflakes, \n * and therefore should be supported by lgtm as well.\n */\n// Denotes a suppression comment that uses the noqa notation\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Constructor validates comment conforms to noqa pattern\n  NoqaSuppressionComment() {\n    // Match case-insensitive noqa with optional trailing content\n    super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n_______________ // 补全条件\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define the scope of code affected by this suppression\n  override predicate covers(\n    string sourcePath, int beginLine, int beginColumn, int finishLine, int finishColumn\n  ) {\n    // Extract comment location and verify it begins at column 1\n    this.hasLocationInfo(sourcePath, beginLine, _, finishLine, finishColumn) and\n    beginColumn = 1\n  }\n}",
    "output": "// Retrieve the annotation identifier for this suppression"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 调用exit()或quit()函数\n * @description 识别代码中对exit()或quit()函数的调用。这些函数在Python解释器使用-S选项启动时可能导致执行失败，\n *              因为它们依赖于site模块，而-S选项会禁用site模块的自动导入。\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/use-of-exit-or-quit\n_______________ // 补全条件\n\nimport python\n\nfrom CallNode terminationCall, string quitFuncName\nwhere \n  // 验证函数调用是否指向site模块中的Quitter对象（exit或quit）\n  terminationCall.getFunction().pointsTo(Value::siteQuitter(quitFuncName))\nselect \n  terminationCall,\n  \"调用 '\" + quitFuncName + \"' 可能存在问题：当'site'模块未加载或被修改时，site.Quitter对象可能不可用。\"",
    "output": "*/"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Comprehensive analysis of alert suppression mechanisms in Python code\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL's alert suppression utilities for managing suppression logic\nprivate import codeql.util.suppression.AlertSuppression as SuppressionUtils\n// Import Python comment processing utilities for comment analysis\nprivate import semmle.python.Comment as PythonComment\n\n// Represents AST nodes with enhanced location tracking capabilities\nclass AstNode instanceof PythonComment::AstNode {\n  // Generate string representation of the AST node\n  string toString() { result = super.toString() }\n\n  // Verify if the node's location matches specified coordinates\n_______________ // 补全条件\n    string sourcePath, int beginLine, int beginColumn, int conclusionLine, int conclusionColumn\n  ) {\n    super.getLocation().hasLocationInfo(sourcePath, beginLine, beginColumn, conclusionLine, conclusionColumn)\n  }\n}\n\n// Represents single-line comments with precise location tracking\nclass SingleLineComment instanceof PythonComment::Comment {\n  // Generate string representation of the comment\n  string toString() { result = super.toString() }\n\n  // Retrieve the textual content of the comment\n  string getText() { result = super.getContents() }\n\n  // Verify if the comment's location matches specified coordinates\n  predicate hasLocationInfo(\n    string sourcePath, int beginLine, int beginColumn, int conclusionLine, int conclusionColumn\n  ) {\n    super.getLocation().hasLocationInfo(sourcePath, beginLine, beginColumn, conclusionLine, conclusionColumn)\n  }\n}\n\n// Generate suppression relationships using the AlertSuppUtil template\nimport SuppressionUtils::Make<AstNode, SingleLineComment>\n\n/**\n * Represents a noqa suppression comment. Recognized by both pylint and pyflakes,\n * and therefore should be respected by lgtm.\n */\n// Denotes suppression comments following the noqa standard\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Constructor identifying noqa comment patterns\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Provides the suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Defines the code coverage range for this suppression annotation\n  override predicate covers(\n    string sourcePath, int beginLine, int beginColumn, int conclusionLine, int conclusionColumn\n  ) {\n    // Ensure the comment's location matches and starts at line beginning\n    this.hasLocationInfo(sourcePath, beginLine, _, conclusionLine, conclusionColumn) and\n    beginColumn = 1\n  }\n}",
    "output": "predicate hasLocationInfo("
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent equality and hashing\n * @description Classes defining equality without hashability (or vice-versa) violate object model contracts\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-581\n * @problem.severity warning\n * @sub-severity high\n_______________ // 补全条件\n * @id py/equals-hash-mismatch\n */\n\nimport python\n\n// Checks if a class implements equality comparison methods\nCallableValue checkEqualityMethod(ClassValue targetClass, string equalityMethodName) {\n  // Verify __eq__ implementation or __cmp__ in Python 2\n  (\n    equalityMethodName = \"__eq__\"\n    or\n    major_version() = 2 and equalityMethodName = \"__cmp__\"\n  ) and\n  result = targetClass.declaredAttribute(equalityMethodName)\n}\n\n// Retrieves implemented equality or hashing methods\nCallableValue findImplementedMethod(ClassValue targetClass, string methodCategory) {\n  // Get equality methods or __hash__ implementation\n  result = checkEqualityMethod(targetClass, methodCategory)\n  or\n  result = targetClass.declaredAttribute(\"__hash__\") and methodCategory = \"__hash__\"\n}\n\n// Determines missing methods in class implementation\nstring determineMissingMethod(ClassValue targetClass) {\n  // Identify missing equality methods based on Python version\n  not exists(checkEqualityMethod(targetClass, _)) and\n  (\n    result = \"__eq__\" and major_version() = 3\n    or\n    major_version() = 2 and result = \"__eq__ or __cmp__\"\n  )\n  or\n  // Identify missing __hash__ in Python 2 (Python 3 handles automatically)\n  not targetClass.declaresAttribute(result) and result = \"__hash__\" and major_version() = 2\n}\n\n// Checks if a class is explicitly unhashable\npredicate isExplicitlyUnhashable(ClassValue targetClass) {\n  // Verify __hash__ is set to None or never returns\n  targetClass.lookup(\"__hash__\") = Value::named(\"None\")\n  or\n  targetClass.lookup(\"__hash__\").(CallableValue).neverReturns()\n}\n\n// Main query: Find classes with inconsistent equality/hash implementations\nfrom ClassValue targetClass, string implementedMethod, string missingMethod, CallableValue methodRef\nwhere\n  // Combine violation conditions from original violatesHashContract\n  not isExplicitlyUnhashable(targetClass) and\n  missingMethod = determineMissingMethod(targetClass) and\n  methodRef = findImplementedMethod(targetClass, implementedMethod) and\n  not targetClass.failedInference(_) and\n  exists(targetClass.getScope()) // Filter out non-source classes\nselect methodRef, \"Class $@ implements \" + implementedMethod + \" but does not define \" + missingMethod + \".\", targetClass,\n  targetClass.getName()",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name CSRF protection weakened or disabled\n * @description Disabling or weakening CSRF protection may make the application\n *              vulnerable to a Cross-Site Request Forgery (CSRF) attack.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/csrf-protection-disabled\n * @tags security\n *       external/cwe/cwe-352\n */\n\nimport python\nimport semmle.python.Concepts\n\n// Predicate to identify CSRF configurations from production environments (excluding test files)\npredicate isNonTestConfiguration(Http::Server::CsrfProtectionSetting csrfConfig) {\n  // Exclude test files (files containing \"test\" in their path)\n  not csrfConfig.getLocation().getFile().getAbsolutePath().matches(\"%test%\")\n}\n\n// Predicate to identify CSRF configurations with security vulnerabilities\npredicate hasSecurityRisk(Http::Server::CsrfProtectionSetting csrfConfig) {\n  // Check if CSRF verification is disabled and no local CSRF protection is enabled\n  csrfConfig.getVerificationSetting() = false and\n  not exists(Http::Server::CsrfLocalProtectionSetting localCsrfProtection | \n             localCsrfProtection.csrfEnabled()) and\n_______________ // 补全条件\n}\n\n// Main query to find vulnerable CSRF configurations while ensuring consistent analysis\n// This approach minimizes false positives by requiring all production configs to be vulnerable\nfrom Http::Server::CsrfProtectionSetting vulnerableCsrfConfig\nwhere\n  // Current configuration is vulnerable\n  hasSecurityRisk(vulnerableCsrfConfig) and\n  // Ensure all production configurations are vulnerable to exclude false positives from virtual projects\n  forall(Http::Server::CsrfProtectionSetting nonTestCsrfConfig | \n         isNonTestConfiguration(nonTestCsrfConfig) | \n         hasSecurityRisk(nonTestCsrfConfig))\nselect vulnerableCsrfConfig, \"Potential CSRF vulnerability due to forgery protection being disabled or weakened.\"",
    "output": "isNonTestConfiguration(csrfConfig)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Block cipher mode detection\n * @description Identifies all potential block cipher modes of operations implemented through supported cryptographic libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/block-cipher-mode\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python language modules and Semmle's cryptographic concepts\nimport python\nimport semmle.python.Concepts\n_______________ // 补全条件\n// Identify cryptographic operations and their corresponding block modes\nfrom Cryptography::CryptographicOperation cryptoOp, string modeName\nwhere modeName = cryptoOp.getBlockMode() // Extract block mode from cryptographic operation\nselect cryptoOp, \"Detected algorithm using mode: \" + modeName // Output operation and algorithm mode description",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/signature-mismatch]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a subclass method overrides a superclass method",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Signature mismatch in overriding method\n * @description Detects when a subclass method overrides a superclass method\n *              with incompatible parameter counts, potentially causing runtime errors.\n * @kind problem\n * @problem.severity warning\n * @tags reliability\n *       correctness\n * @sub-severity high\n * @precision very-high\n * @id py/inheritance/signature-mismatch\n */\n\nimport python\nimport Expressions.CallArgs\n\n// Identifying methods with signature mismatches in inheritance hierarchies\nfrom FunctionValue parentMethod, PythonFunctionValue childMethod\nwhere\n  // Verify override relationship exists\n  childMethod.overrides(parentMethod) and\n  // Focus only on regular instance methods\n  childMethod.isNormalMethod() and\n  // Exclude special methods and constructors from analysis\n  not childMethod.getScope().isSpecialMethod() and\n  childMethod.getName() != \"__init__\" and\n  // Filter out cases where the superclass method is called\n  not exists(parentMethod.getACall()) and\n  // Ensure no other overriding subclass methods are being called\n  not exists(FunctionValue otherOverridingMethod |\n    otherOverridingMethod.overrides(parentMethod) and\n    exists(otherOverridingMethod.getACall())\n  ) and\n  // Check for parameter count incompatibility\n  (\n    // Case 1: Subclass requires more parameters than superclass provides\n    childMethod.minParameters() > parentMethod.maxParameters()\n    or\n    // Case 2: Subclass accepts fewer parameters than superclass requires\n    childMethod.maxParameters() < parentMethod.minParameters()\n  )\nselect childMethod, \"Overriding method '\" + childMethod.getName() + \"' has signature mismatch with $@.\",\n  parentMethod, \"overridden method\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/insecure-protocol]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of deprecated SSL/TLS protocol versions that may expose connections to security vulnerabilities.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of insecure SSL/TLS version\n * @description Detects usage of deprecated SSL/TLS protocol versions that may expose connections to security vulnerabilities.\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n/* Represents configuration nodes that enable insecure SSL/TLS protocol versions */\nclass InsecureProtocolConfig extends DataFlow::Node {\n  InsecureProtocolConfig() {\n    /* Case 1: Insecure connections with context */\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    /* Case 2: Insecure connections without context */\n    unsafe_connection_creation_without_context(this, _)\n    or\n    /* Case 3: Insecure context creation */\n    unsafe_context_creation(this, _)\n  }\n\n  /* Retrieves the function associated with this configuration */\n  DataFlow::Node getAssociatedFunction() { \n    result = this.(DataFlow::CallCfgNode).getFunction() \n  }\n}\n\n/* Represents nodes that can be named (function calls or attribute references) */\nclass IdentifiableNode extends DataFlow::Node {\n  IdentifiableNode() {\n    /* Case 1: Function from protocol configuration */\n    this = any(InsecureProtocolConfig ipc).getAssociatedFunction()\n    or\n    /* Case 2: Attribute reference chain */\n    this = any(IdentifiableNode attr).(DataFlow::AttrRef).getObject()\n  }\n}\n\n/* Constructs fully qualified name for identifiable nodes */\nstring getFullyQualifiedName(IdentifiableNode node) {\n  /* Case 1: Direct function name */\n  result = node.asExpr().(Name).getId()\n  or\n  /* Case 2: Attribute access path */\n  exists(DataFlow::AttrRef attrRef | \n    attrRef = node and\n    result = getFullyQualifiedName(attrRef.getObject()) + \".\" + attrRef.getAttributeName()\n  )\n}\n\n/* Generates descriptive label for protocol configuration */\nstring getConfigDescription(InsecureProtocolConfig configNode) {\n  /* Case 1: Function call configuration */\n  exists(DataFlow::CallCfgNode call | \n    call = configNode and\n    result = \"call to \" + getFullyQualifiedName(call.getFunction())\n  )\n  or\n  /* Case 2: Non-call context modification */\n  not configNode instanceof DataFlow::CallCfgNode and\n  not configNode instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n/* Selects appropriate verb based on configuration specificity */\nstring getAppropriateVerb(boolean isExplicit) {\n  isExplicit = true and result = \"specified\"\n  or\n  isExplicit = false and result = \"allowed\"\n}\n\n/* Main query: Detects insecure SSL/TLS protocol usage */\nfrom\n  DataFlow::Node vulnNode, string protoVer, \n  InsecureProtocolConfig cfgNode, boolean explicitFlag\nwhere\n  /* Case 1: Insecure connection with context */\n  unsafe_connection_creation_with_context(vulnNode, protoVer, cfgNode, explicitFlag)\n  or\n  /* Case 2: Insecure connection without context */\n  (\n    unsafe_connection_creation_without_context(vulnNode, protoVer) and\n    cfgNode = vulnNode and\n    explicitFlag = true\n  )\n  or\n  /* Case 3: Insecure context creation */\n  (\n    unsafe_context_creation(cfgNode, protoVer) and\n    vulnNode = cfgNode and\n    explicitFlag = true\n  )\nselect vulnNode,\n  \"Insecure SSL/TLS protocol version \" + protoVer + \" \" + getAppropriateVerb(explicitFlag) + \" by $@.\",\n  cfgNode, getConfigDescription(cfgNode)"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'import *' may pollute namespace\n * @description Importing a module using 'import *' may unintentionally pollute the global\n *              namespace if the module does not define `__all__`\n * @kind problem\n * @tags maintainability\n *       modularity\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/polluting-import\n */\n\n// 导入Python库，用于分析Python代码\nimport python\n\n// 定义谓词函数 import_star，用于检查是否使用了 'import *' 语法\npredicate import_star(ImportStar imp, ModuleValue exporter) {\n  // 检查导出模块的名称是否与导入的模块名称匹配\n  exporter.importedAs(imp.getImportedModuleName())\n}\n\n// 定义谓词函数 all_defined，用于检查模块是否定义了 '__all__'\npredicate all_defined(ModuleValue exporter) {\n  // 如果模块是内建模块，则返回 true\n  exporter.isBuiltin()\n  or\n  // 如果模块的作用域定义了 '__all__'，则返回 true\n  exporter.getScope().(ImportTimeScope).definesName(\"__all__\")\n  or\n  // 如果模块的初始化模块定义了 '__all__'，则返回 true\n  exporter.getScope().getInitModule().(ImportTimeScope).definesName(\"__all__\")\n}\n_______________ // 补全条件\n// 从所有使用 'import *' 语法的导入语句和模块中进行查询\nfrom ImportStar imp, ModuleValue exporter\nwhere import_star(imp, exporter) and not all_defined(exporter) and not exporter.isAbsent()\nselect imp,\n  \"Import pollutes the enclosing namespace, as the imported module $@ does not define '__all__'.\",\n  exporter, exporter.getName()",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/slots-in-old-style-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：In Python, old-style classes (those not inheriting from object) do not properly support",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name `__slots__` in old-style class\n * @description In Python, old-style classes (those not inheriting from object) do not properly support\n *              the `__slots__` attribute. When `__slots__` is used in an old-style class, it simply\n *              creates a regular class attribute named `__slots__` instead of restricting instance\n *              attributes as intended.\n * @kind problem\n * @problem.severity error\n * @tags portability\n *       correctness\n * @sub-severity low\n * @precision very-high\n * @id py/slots-in-old-style-class\n */\n\nimport python\n\nfrom ClassObject cls\nwhere \n  // Identify old-style classes (not inheriting from object)\n  not cls.isNewStyle()\n  // Verify that the class declares the __slots__ attribute\n  and cls.declaresAttribute(\"__slots__\")\n  // Ensure that the class inference did not fail\n  and not cls.failedInference()\nselect cls, \n  \"Using '__slots__' in an old style class just creates a class attribute called '__slots__'.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unsafe-unpacking]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies potentially dangerous tar extraction operations that lack",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Arbitrary file write during tarball extraction from user-controlled source\n * @description Identifies potentially dangerous tar extraction operations that lack\n *              proper path validation, enabling attackers to write files outside\n *              the intended destination directory. This vulnerability manifests\n *              when tar archives are obtained from untrusted sources such as\n *              network downloads or user-provided inputs.\n * @kind path-problem\n * @id py/unsafe-unpacking\n * @problem.severity error\n * @security-severity 7.5\n * @precision medium\n * @tags security\n *       experimental\n *       external/cwe/cwe-022\n */\n\nimport python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\n// Detect vulnerable extraction flows originating from untrusted sources\nfrom UnsafeUnpackFlow::PathNode taintedOrigin, UnsafeUnpackFlow::PathNode dangerousSink\nwhere \n  // Establish data flow from untrusted source to vulnerable extraction point\n  UnsafeUnpackFlow::flowPath(taintedOrigin, dangerousSink)\nselect dangerousSink.getNode(), taintedOrigin, dangerousSink,\n  \"Potentially unsafe tarball extraction from untrusted source may lead to directory traversal\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/summary/lines-of-user-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：此查询计算代码库中由用户编写的Python代码总行数，排除自动生成的文件。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python用户代码行数统计\n * @description 此查询计算代码库中由用户编写的Python代码总行数，排除自动生成的文件。\n *   仅统计实际代码行，不包括空白行和注释。注意：当前实现会将代码库中的外部依赖\n *   （如签入的虚拟环境或第三方库）视为用户代码进行统计。\n * @kind metric\n * @tags summary\n *       代码行数\n *       调试\n * @id py/summary/lines-of-user-code\n */\n\nimport python // 导入Python分析支持模块\nimport semmle.python.filters.GeneratedCode // 导入生成代码识别过滤器\n\nfrom Module nonGeneratedModule\n// 筛选条件：模块位于源代码目录且非自动生成\nwhere \n  exists(nonGeneratedModule.getFile().getRelativePath()) and\n  not nonGeneratedModule.getFile() instanceof GeneratedFile\n// 计算所有符合条件的源代码模块的代码行数总和\nselect sum(nonGeneratedModule.getMetrics().getNumberOfLinesOfCode())"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode IV or nonce\n * @description Detects insecure initialization vectors/nonces in block cipher modes.\n *              Flags IVs/nonces not generated via cryptographically secure methods (os.urandom).\n *\n *            NOTE: \n *              1. Simplified approach: Any IV/nonce not from os.urandom is flagged\n *              2. Special cases:\n *                 - GCM mode: Requires specific nonce handling (covered in separate query)\n *                 - Fernet: Explicitly excluded (handles IV generation internally)\n *              3. Functions inferring mode/IV may trigger false positives (user suppression required)\n * @id py/weak-block-mode-iv-or-nonce\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n_______________ // 补全条件\n// Identify block cipher operations with weak IV/nonce configuration\nfrom BlockMode blockCipherOp, string alertMsg, DataFlow::Node weakSource\nwhere\n  // Exclude Fernet (handles IV generation internally)\n  not blockCipherOp instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet\n  and (\n    // Case 1: Missing IV/Nonce initialization\n    (not blockCipherOp.hasIVorNonce() and \n     weakSource = blockCipherOp and \n     alertMsg = \"Block mode is missing IV/Nonce initialization\")\n    or\n    // Case 2: Non-os.urandom IV/Nonce source\n    (blockCipherOp.hasIVorNonce() and \n     not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = blockCipherOp.getIVorNonce() and\n     weakSource = blockCipherOp.getIVorNonce() and \n     alertMsg = \"Block mode uses non-cryptographic IV/Nonce source: $@\")\n  )\nselect blockCipherOp, alertMsg, weakSource, weakSource.toString()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 非对称加密算法\n * @description 查找所有使用受支持库的潜在非对称密钥进行加密或密钥交换的用法。\n_______________ // 补全条件\n * @id py/quantum-readiness/cbom/all-asymmetric-encryption-algorithms\n * @problem.severity 错误\n * @tags cbom\n *       密码学\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查找所有非对称加密算法实例\nfrom AsymmetricEncryptionAlgorithm cryptoAlgorithm\n// 生成警告消息，标识检测到的非对称加密算法\nselect cryptoAlgorithm, \"Use of algorithm \" + cryptoAlgorithm.getEncryptionName()",
    "output": "* @kind 问题"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unknown-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测在非对称密钥生成过程中使用了无法静态验证的密钥大小的安全漏洞。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 非对称密钥生成中使用未知密钥大小\n * @description 检测在非对称密钥生成过程中使用了无法静态验证的密钥大小的安全漏洞。\n *              此类情况可能导致系统使用弱密钥或不符合安全标准的密钥，从而增加被攻击的风险。\n * @id py/unknown-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 查询所有非对称密钥生成操作，其中密钥大小无法通过静态分析验证\nfrom AsymmetricKeyGen keyGenOperation, DataFlow::Node keyConfigSource, string algorithmName\nwhere\n  // 获取密钥配置来源节点和加密算法名称\n  keyConfigSource = keyGenOperation.getKeyConfigSrc()\n  and\n  algorithmName = keyGenOperation.getAlgorithm().getName()\n  and\n  // 检查密钥生成操作是否缺乏静态可验证的密钥大小\n  not keyGenOperation.hasKeySize(keyConfigSource)\nselect keyGenOperation,\n  // 构建告警信息，指明具体算法的密钥生成使用了无法静态验证的密钥大小\n  \"算法 \" + algorithmName.toString() + \" 的密钥生成使用了无法静态验证的密钥大小，配置源位于 $@\", keyConfigSource, keyConfigSource.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 'exec' used\n * @description Detects usage of the 'exec' statement or function which can lead to arbitrary code execution.\n_______________ // 补全条件\n * @tags security\n *       correctness\n * @problem.severity error\n * @security-severity 4.2\n * @sub-severity high\n * @precision low\n * @id py/use-of-exec\n */\n\n// Import Python library for code parsing and analysis\nimport python\n\n// Creates version-specific error message based on Python version\nstring getExecVersionSpecificMessage() {\n  // Python 2 uses exec as a statement\n  major_version() = 2 and result = \"The 'exec' statement is used.\"\n  // Python 3 uses exec as a function\n  or\n  major_version() = 3 and result = \"The 'exec' function is used.\"\n}\n\n// Detects invocations of the exec function\npredicate isExecFunctionCall(Call functionCall) {\n  // Verify the call references a global variable named 'exec'\n  exists(GlobalVariable globalExecVar | \n    globalExecVar = functionCall.getFunc().(Name).getVariable() and \n    globalExecVar.getId() = \"exec\"\n  )\n}\n\n// Identifies any dangerous usage of exec (either as statement or function)\npredicate isDangerousExecUsage(AstNode riskyExecUsage) {\n  isExecFunctionCall(riskyExecUsage) \n  or \n  riskyExecUsage instanceof Exec\n}\n\n// Select all AST nodes representing dangerous exec usage\nfrom AstNode riskyExecUsage\nwhere isDangerousExecUsage(riskyExecUsage)\n// Output the exec usage node with appropriate version-specific error message\nselect riskyExecUsage, getExecVersionSpecificMessage()",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Detects cryptographic operations that utilize asymmetric encryption padding schemes\n * which are considered insecure, deprecated, or not explicitly approved. The only\n * padding schemes recognized as secure for asymmetric cryptography are OAEP (Optimal\n * Asymmetric Encryption Padding), KEM (Key Encapsulation Mechanism), and PSS\n * (Probabilistic Signature Scheme). Implementation of other padding methods may\n * lead to cryptographic weaknesses and potential security vulnerabilities.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n_______________ // 补全条件\nimport python\nimport experimental.cryptography.Concepts\n\n// Define the list of approved secure padding schemes for asymmetric cryptography\nstring approvedSecurePaddingSchemes() { result = [\"OAEP\", \"KEM\", \"PSS\"] }\n\n// Find all asymmetric padding implementations that use non-approved schemes\nfrom AsymmetricPadding asymmetricPaddingImpl\nwhere\n  // Get the name of the padding scheme being used\n  exists(string paddingSchemeName |\n    paddingSchemeName = asymmetricPaddingImpl.getPaddingName() and\n    // Check if the padding scheme is not in the approved secure list\n    not paddingSchemeName = approvedSecurePaddingSchemes()\n  )\nselect asymmetricPaddingImpl, \"Use of unapproved, weak, or unknown asymmetric padding algorithm or API: \" + asymmetricPaddingImpl.getPaddingName()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Insufficient KDF Iteration Count Detection\n * @description Identifies key derivation functions with inadequate iteration counts.\n * \n * Cryptographic keys derived from user-provided inputs (such as passwords) must employ\n * a high iteration count (at least 100,000 iterations) to mitigate brute force attacks.\n * \n * This query detects two potential security issues:\n * 1. Iteration count explicitly set to a constant value below the recommended threshold\n * 2. Iteration count source that cannot be statically determined during analysis\n * \n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import standard Python analysis library\nimport python\n// Import experimental cryptography concepts for key derivation operations\nimport experimental.cryptography.Concepts\n// Import utility functions for cryptography analysis, aliased as CryptoUtils\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Select key derivation operations that may have insufficient iteration counts\nfrom KeyDerivationOperation kdfOperation, string securityWarning, DataFlow::Node iterationSource\nwhere\n  // Focus on operations that require iteration configuration\n  kdfOperation.requiresIteration() and\n  // Identify the source of the iteration count configuration\n  iterationSource = kdfOperation.getIterationSizeSrc() and\n  (\n    // Case 1: Check for explicitly defined iteration counts that are too low\n    exists(iterationSource.asExpr().(IntegerLiteral).getValue()) and\n    iterationSource.asExpr().(IntegerLiteral).getValue() < 10000 and\n    securityWarning = \"Insufficient iteration count detected. \"\n    // Case 2: Check for iteration counts that cannot be statically verified\n    or\n    not exists(iterationSource.asExpr().(IntegerLiteral).getValue()) and\n_______________ // 补全条件\n  )\nselect \n  // Report the key derivation operation with appropriate warning message\n  kdfOperation, securityWarning + \"Minimum required iteration count is 10000. Configuration source: $@\",\n  iterationSource.asExpr(), iterationSource.asExpr().toString()",
    "output": "securityWarning = \"Iteration count cannot be statically verified. \""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Vulnerable hostname regular expression patterns\n * @description Detects security issues in regular expressions used for URL or hostname validation where dots are not properly escaped, leading to overly permissive hostname matching.\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-hostname-regexp\n_______________ // 补全条件\n *       security\n *       external/cwe/cwe-020\n */\n\n// Import specialized module for analyzing security vulnerabilities in hostname regular expressions\nprivate import semmle.python.security.regexp.HostnameRegex as HostnameValidator\n\n// Define main query predicate to detect security flaws in hostname regular expression patterns\nquery predicate hostnameRegexFlaws = HostnameValidator::incompleteHostnameRegExp/4;",
    "output": "* @tags correctness"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak cryptographic hash algorithms\n * @description Detects the use of cryptographic hash functions that are either not approved \n *              or considered weak for security purposes.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import necessary Python libraries and experimental cryptography concepts\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify weak hash operations and generate appropriate security alerts\nfrom HashAlgorithm hashOp, string algoName, string alertMsg\nwhere\n  // Extract the name of the hash algorithm being used\n  algoName = hashOp.getHashName() and\n  // Filter out strong, approved hash algorithms\n  not algoName = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n_______________ // 补全条件\n  (\n    // Handle recognized but unapproved algorithms\n    algoName != \"\" and\n    alertMsg = \"Use of unapproved hash algorithm or API \" + algoName + \".\"\n  )\n  or\n  (\n    // Handle unrecognized algorithms\n    algoName = \"\" and\n    alertMsg = \"Use of unrecognized hash algorithm.\"\n  )\nselect hashOp, alertMsg",
    "output": "// Determine the appropriate security alert message based on algorithm recognition"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name All Cryptographic Algorithms\n * @description Identifies all cryptographic algorithm implementations and block modes across supported libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python and Semmle core libraries\nimport python\nimport semmle.python.Concepts\n\n// Identify cryptographic operations and extract algorithm identifiers\nfrom Cryptography::CryptographicOperation cryptoOperation, string algoName\nwhere \n  // Extract algorithm name from cryptographic operation\n  algoName = cryptoOperation.getAlgorithm().getName()\n  or\n  // Extract block mode from cryptographic operation\n_______________ // 补全条件\nselect cryptoOperation, \"Use of algorithm \" + algoName",
    "output": "algoName = cryptoOperation.getBlockMode()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/conflicting-attributes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes inheriting multiple base classes with identically named attributes, potentially causing unexpected behavior through attribute overriding.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Conflicting attributes in base classes\n * @description Identifies classes inheriting multiple base classes with identically named attributes, potentially causing unexpected behavior through attribute overriding.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n/**\n * Determines if a Python function contains only pass statements and docstrings.\n * Such functions represent empty or no-op implementations.\n */\npredicate is_no_op_function(PyFunctionObject fn) {\n  not exists(Stmt stmt | stmt.getScope() = fn.getFunction() |\n    not stmt instanceof Pass and \n    not stmt.(ExprStmt).getValue() = fn.getFunction().getDocString()\n  )\n}\n\n/**\n * Checks if a function explicitly calls super() to invoke parent class methods.\n * This indicates intentional method chaining in inheritance hierarchies.\n */\npredicate invokes_super_method(FunctionObject fn) {\n  exists(Call superCall, Call methodCall, Attribute attr, GlobalVariable superVar |\n    methodCall.getScope() = fn.getFunction() and\n    methodCall.getFunc() = attr and\n    attr.getObject() = superCall and\n    attr.getName() = fn.getName() and\n    superCall.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/**\n * Identifies attribute names exempt from conflict detection due to special cases.\n * These exemptions follow documented patterns or library recommendations.\n */\npredicate is_exempted_attribute(string attrName) {\n  /*\n   * Exemption for standard library recommendation:\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   */\n  attrName = \"process_request\"\n}\n\nfrom\n  ClassObject childClass, ClassObject base1, ClassObject base2, \n  string attrName, int idx1, int idx2, \n  Object attrInBase1, Object attrInBase2\nwhere\n  // Ensure distinct base classes with ordered inheritance positions\n  childClass.getBaseType(idx1) = base1 and\n  childClass.getBaseType(idx2) = base2 and\n  idx1 < idx2 and\n  \n  // Locate identically named attributes in both base classes\n  attrInBase1 = base1.lookupAttribute(attrName) and\n  attrInBase2 = base2.lookupAttribute(attrName) and\n  attrInBase1 != attrInBase2 and\n  \n  // Exclude special methods (dunder methods) which are expected to be overridden\n  not attrName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  \n  // Skip cases where first base class properly calls super() (safe overriding)\n  not invokes_super_method(attrInBase1) and\n  \n  // Ignore empty functions in second base class (no real conflict introduced)\n  not is_no_op_function(attrInBase2) and\n  \n  // Exclude exempted attributes with special handling patterns\n  not is_exempted_attribute(attrName) and\n  \n  // Ensure no override relationship exists between attributes\n  not attrInBase1.overrides(attrInBase2) and\n  not attrInBase2.overrides(attrInBase1) and\n  \n  // Verify child class doesn't explicitly declare the attribute\n  not childClass.declaresAttribute(attrName)\nselect childClass, \n  \"Base classes have conflicting values for attribute '\" + attrName + \"': $@ and $@.\", \n  attrInBase1, attrInBase1.toString(), \n  attrInBase2, attrInBase2.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects modules that import themselves directly",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description Detects modules that import themselves directly\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n/**\n * Identifies modules that directly import themselves\n * \n * This predicate detects Python modules that import themselves, which is typically\n * an unnecessary code pattern that can lead to circular dependencies and maintenance issues.\n * \n * Parameters:\n * - importDeclaration: The import statement being analyzed\n * - targetModule: The module being imported\n */\npredicate isSelfImport(ImportingStmt importDeclaration, ModuleValue targetModule) {\n  // Verify the importing module matches the imported module's scope\n  importDeclaration.getEnclosingModule() = targetModule.getScope() and\n  // Resolve the most specific module match using longest-name priority\n  targetModule = \n    max(string moduleName, ModuleValue candidate |\n      // Extract module name referenced in the import statement\n      moduleName = importDeclaration.getAnImportedModuleName() and\n      // Verify candidate module is imported under this name\n      candidate.importedAs(moduleName)\n    |\n      // Prioritize longest matching names for correct relative import handling\n      candidate order by moduleName.length() desc\n    )\n}\n\n// Main query: Identify all self-importing module instances\n// \n// This query scans all import statements and uses the isSelfImport predicate\n// to filter statements where a module imports itself, generating warnings.\nfrom ImportingStmt importDeclaration, ModuleValue targetModule\nwhere isSelfImport(importDeclaration, targetModule)\nselect importDeclaration, \"The module '\" + targetModule.getName() + \"' imports itself.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Cors misconfiguration with credentials\n * @description Disabling or weakening SOP protection may make the application\n *              vulnerable to a CORS attack.\n * @kind problem\n * @problem.severity warning\n * @security-severity 8.8\n * @precision high\n * @id py/cors-misconfiguration-with-credentials\n * @tags security\n *       experimental\n *       external/cwe/cwe-942\n */\n\nimport python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\n// 检查中间件是否为CORS中间件\npredicate isCorsMiddleware(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getMiddlewareName() = \"CORSMiddleware\"\n}\n\n// 检查CORS中间件是否启用了凭证支持\npredicate credentialsAllowed(Http::Server::CorsMiddleware corsMiddleware) {\n  corsMiddleware.getCredentialsAllowed().asExpr() instanceof True\n}\n\n// 检查来源配置是否包含通配符或null值\npredicate containsWildcardOrigin(DataFlow::Node originNode) {\n_______________ // 补全条件\n  exists(List originList | \n    originList = originNode.asExpr() and\n    exists(StringLiteral literal |\n      literal = originList.getASubExpression() and\n      literal.getText() in [\"*\", \"null\"]\n    )\n  )\n  // 处理字符串形式的来源配置\n  or\n  exists(StringLiteral literal |\n    literal = originNode.asExpr() and\n    literal.getText() in [\"*\", \"null\"]\n  )\n}\n\n// 查询存在安全风险的CORS配置\nfrom Http::Server::CorsMiddleware corsMiddleware\nwhere\n  // 验证中间件类型\n  isCorsMiddleware(corsMiddleware) and\n  // 验证凭证启用状态\n  credentialsAllowed(corsMiddleware) and\n  // 验证来源配置安全性\n  containsWildcardOrigin(corsMiddleware.getOrigins().getALocalSource())\nselect corsMiddleware,\n  \"This CORS middleware uses a vulnerable configuration that allows arbitrary websites to make authenticated cross-site requests\"",
    "output": "// 处理列表形式的来源配置"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies usage of unapproved or weak cryptographic elliptic curve algorithms.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak elliptic curve\n * @description Identifies usage of unapproved or weak cryptographic elliptic curve algorithms.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define approved secure elliptic curve algorithms\nstring getApprovedEllipticCurve() {\n  result =\n    [\n      \"SECP256R1\", \"PRIME256V1\",  // NIST P-256 curves\n      \"SECP384R1\",               // NIST P-384 curve\n      \"SECP521R1\",               // NIST P-521 curve\n      \"ED25519\",                 // EdDSA Ed25519 curve\n      \"X25519\"                   // ECDH X25519 curve\n    ]\n}\n\n// Analyze elliptic curve implementations for security weaknesses\nfrom EllipticCurveAlgorithm curveAlgo, string warningMessage, string usedCurveName\nwhere\n  // Extract curve name from algorithm instance\n  usedCurveName = curveAlgo.getCurveName() and\n  (\n    // Case 1: Unrecognized curve algorithm\n    usedCurveName = unknownAlgorithm() and\n    warningMessage = \"Use of unrecognized curve algorithm.\"\n    or\n    // Case 2: Weak curve algorithm\n    usedCurveName != unknownAlgorithm() and\n    not usedCurveName = getApprovedEllipticCurve() and\n    warningMessage = \"Use of weak curve algorithm \" + usedCurveName + \".\"\n  )\nselect curveAlgo, warningMessage"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent method resolution order\n * @description Detects class definitions with inheritance hierarchies that violate method resolution order (MRO) consistency, potentially causing runtime type errors\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n_______________ // 补全条件\n// Identifies classes violating MRO consistency rules in their inheritance hierarchy\n// by detecting problematic base class sequences that would trigger runtime failures\npredicate has_mro_violation(ClassObject problematicClass, ClassObject baseA, ClassObject baseB) {\n  // Limit analysis to new-style classes (Python 3+ inheritance model)\n  problematicClass.isNewStyle() and\n  // Find consecutive base classes in the inheritance declaration\n  exists(int index | \n    index > 0 and \n    // baseB immediately follows baseA in the base class list\n    baseB = problematicClass.getBaseType(index) and \n    baseA = problematicClass.getBaseType(index - 1) and\n    // Verify MRO violation: baseA must be an improper supertype of baseB\n    baseA = baseB.getAnImproperSuperType()\n  )\n}\n\n// Main query: Identify classes with MRO violations and generate diagnostic reports\nfrom ClassObject problematicClass, ClassObject baseA, ClassObject baseB\nwhere has_mro_violation(problematicClass, baseA, baseB)\nselect problematicClass,\n  \"Construction of class \" + problematicClass.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", baseA,\n  baseA.getName(), baseB, baseB.getName()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description 识别代码中使用非对称加密算法的所有位置。这些算法在量子计算时代可能变得不安全，\n *               本查询旨在标记所有通过受支持库执行非对称加密或密钥交换操作的代码位置，\n *               以评估代码的量子就绪状态。\n * @kind 问题\n * @id py/quantum-readiness/cbom/all-asymmetric-encryption-algorithms\n * @problem.severity 错误\n * @tags cbom\n *       密码学\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 遍历代码库中所有的非对称加密算法实例\nfrom AsymmetricEncryptionAlgorithm asymmetricAlgoInstance\n\n// 为每个检测到的非对称加密算法生成警告信息\nselect asymmetricAlgoInstance, \"Use of algorithm \" + asymmetricAlgoInstance.getEncryptionName()",
    "output": "* @name 非对称加密算法检测"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * 深度分析Python调用图的统计特性，包括事实总量、关系规模、上下文深度及其效率指标。\n * 通过计算事实数量与关系大小的比率，评估调用图的紧凑性，为代码优化提供数据支持。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 定义结果变量：totalFacts（事实总量）、totalRelations（关系规模）、contextDepth（上下文深度）和efficiencyMetric（效率指标）\n_______________ // 补全条件\nwhere\n  // 计算调用图中的事实总量：统计所有(ControlFlowNode, CallableValue)对的数量\n  totalFacts =\n    strictcount(ControlFlowNode callNode, CallableValue callable |\n      exists(PointsToContext analysisContext |\n        callNode = callable.getACall(analysisContext) and // 获取callable在analysisContext中的调用节点callNode\n        contextDepth = analysisContext.getDepth() // 记录analysisContext的深度\n      )\n    ) and\n  // 计算调用图关系的总规模：统计所有(ControlFlowNode, CallableValue, PointsToContext)三元组的数量\n  totalRelations =\n    strictcount(ControlFlowNode callNode, CallableValue callable, PointsToContext analysisContext |\n      callNode = callable.getACall(analysisContext) and // 获取callable在analysisContext中的调用节点callNode\n      contextDepth = analysisContext.getDepth() // 记录analysisContext的深度\n    ) and\n  // 计算效率指标：将事实总量转换为相对于关系总规模的百分比\n  efficiencyMetric = 100.0 * totalFacts / totalRelations\nselect contextDepth, totalFacts, totalRelations, efficiencyMetric // 返回上下文深度、事实总量、关系总规模和效率指标",
    "output": "from int totalFacts, int totalRelations, int contextDepth, float efficiencyMetric"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/type-metrics]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes statistics for Python type annotations across parameters,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Type metrics\n * @description Computes statistics for Python type annotations across parameters, \n *              return types, and variable assignments. Categorizes annotations\n *              as built-in, forward declarations, simple types, complex types,\n *              and optional types.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents a built-in type in Python (e.g., int, str, bool)\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr func) { exists(func.getReturns()) } or\n  TAnnotatedParameter(Parameter param) { exists(param.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign stmt) { exists(stmt.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr func;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(func) }\n  override Expr getAnnotation() { result = func.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter param;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(param) }\n  override Expr getAnnotation() { result = param.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assign;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assign) }\n  override Expr getAnnotation() { result = assign.getAnnotation() }\n}\n\n// Helper predicates for type annotation classification\n/** Holds if `expr` is a forward declaration (string literal) of a type. */\npredicate is_forward_declaration(Expr expr) { expr instanceof StringLiteral }\n\n/** Holds if `expr` is a type that may be difficult to analyze. */\npredicate is_complex_type(Expr expr) {\n  (expr instanceof Subscript and not is_optional_type(expr)) or\n  expr instanceof Tuple or\n  expr instanceof List\n}\n\n/** Holds if `expr` is a type of the form `Optional[...]`. */\npredicate is_optional_type(Subscript expr) { expr.getObject().(Name).getId() = \"Optional\" }\n\n/** Holds if `expr` is a simple type (non-built-in identifier or attribute chain). */\npredicate is_simple_type(Expr expr) {\n  (expr instanceof Name and not expr instanceof BuiltinType) or\n  is_simple_type(expr.(Attribute).getObject())\n}\n\n/** Holds if `expr` is a built-in type. */\npredicate is_builtin_type(Expr expr) { expr instanceof BuiltinType }\n\n// Computes type annotation metrics for different annotation categories\npredicate type_annotation_metrics(\n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\n) {\n  // Parameter annotation metrics\n  category = \"Parameter annotation\" and\n  totalCount = count(AnnotatedParameter annotatedParam) and\n  builtinCount = count(AnnotatedParameter annotatedParam | is_builtin_type(annotatedParam.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedParameter annotatedParam | is_forward_declaration(annotatedParam.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedParameter annotatedParam | is_simple_type(annotatedParam.getAnnotation())) and\n  complexTypeCount = count(AnnotatedParameter annotatedParam | is_complex_type(annotatedParam.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedParameter annotatedParam | is_optional_type(annotatedParam.getAnnotation()))\n  or\n  // Return type annotation metrics\n  category = \"Return type annotation\" and\n  totalCount = count(AnnotatedFunction annotatedFunc) and\n  builtinCount = count(AnnotatedFunction annotatedFunc | is_builtin_type(annotatedFunc.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedFunction annotatedFunc | is_forward_declaration(annotatedFunc.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedFunction annotatedFunc | is_simple_type(annotatedFunc.getAnnotation())) and\n  complexTypeCount = count(AnnotatedFunction annotatedFunc | is_complex_type(annotatedFunc.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedFunction annotatedFunc | is_optional_type(annotatedFunc.getAnnotation()))\n  or\n  // Annotated assignment metrics\n  category = \"Annotated assignment\" and\n  totalCount = count(AnnotatedAssignment annotatedAssign) and\n  builtinCount = count(AnnotatedAssignment annotatedAssign | is_builtin_type(annotatedAssign.getAnnotation())) and\n  forwardDeclCount = count(AnnotatedAssignment annotatedAssign | is_forward_declaration(annotatedAssign.getAnnotation())) and\n  simpleTypeCount = count(AnnotatedAssignment annotatedAssign | is_simple_type(annotatedAssign.getAnnotation())) and\n  complexTypeCount = count(AnnotatedAssignment annotatedAssign | is_complex_type(annotatedAssign.getAnnotation())) and\n  optionalTypeCount = count(AnnotatedAssignment annotatedAssign | is_optional_type(annotatedAssign.getAnnotation()))\n}\n\n// Query execution and output\nfrom \n  string category, int totalCount, int builtinCount, int forwardDeclCount, \n  int simpleTypeCount, int complexTypeCount, int optionalTypeCount\nwhere \n  type_annotation_metrics(category, totalCount, builtinCount, forwardDeclCount, \n                         simpleTypeCount, complexTypeCount, optionalTypeCount)\nselect \n  category, totalCount, builtinCount, forwardDeclCount, \n  simpleTypeCount, complexTypeCount, optionalTypeCount"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/shell-command-constructed-from-input]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Building shell commands using external string inputs",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unsafe shell command constructed from library input\n * @description Building shell commands using external string inputs\n *              can lead to command injection vulnerabilities.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 6.3\n * @precision medium\n * @id py/shell-command-constructed-from-input\n * @tags correctness\n *       security\n *       external/cwe/cwe-078\n *       external/cwe/cwe-088\n *       external/cwe/cwe-073\n */\n\n// Core Python language support\nimport python\n\n// Security analysis for dangerous shell command construction\nimport semmle.python.security.dataflow.UnsafeShellCommandConstructionQuery\n\n// Data flow path visualization framework\nimport UnsafeShellCommandConstructionFlow::PathGraph\n\n// Identify vulnerable command construction flows\nfrom\n  Sink commandSink,                                         // Command execution details\n  UnsafeShellCommandConstructionFlow::PathNode inputOrigin, // Untrusted input source\n  UnsafeShellCommandConstructionFlow::PathNode executionPoint // Command execution point\nwhere\n  // Map execution point to detailed sink representation\n  commandSink = executionPoint.getNode()\n  and\n  // Trace data flow from input to command execution\n  UnsafeShellCommandConstructionFlow::flowPath(inputOrigin, executionPoint)\nselect \n  // Vulnerability context: string construction details\n  commandSink.getStringConstruction(), \n  inputOrigin, \n  executionPoint,\n  // Security impact: input source and command execution context\n  \"This \" + commandSink.describe() + \n  \" which depends on $@ is subsequently used in a $@.\", \n  inputOrigin.getNode(), \"library input\", \n  commandSink.getCommandExecution(), \"shell command\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Key points-to fails for expression.\n * @description Identifies expressions that fail to point-to any object, preventing further points-to analysis.\n * @kind problem\n * @problem.severity info\n * @id py/key-points-to-failure\n * @deprecated\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n * Determines if an expression fails to point-to any object.\n * @param expr The expression to check.\n */\npredicate expressionPointsToFailure(Expr expr) {\n  exists(ControlFlowNode flowNode | \n    flowNode = expr.getAFlowNode() and \n    not PointsTo::pointsTo(flowNode, _, _, _)\n  )\n}\n\n/**\n * Identifies key expressions that fail points-to analysis.\n * A key expression is one that fails points-to analysis itself,\n * but all its sources (sub-expressions) do not.\n * @param expr The expression to check.\n */\npredicate isKeyPointsToFailure(Expr expr) {\n_______________ // 补全条件\n  expressionPointsToFailure(expr) and\n  // None of its sub-expressions fail points-to analysis\n  not expressionPointsToFailure(expr.getASubExpression()) and\n  // There is no SSA variable using this expression's flow node\n  // whose definition node also fails points-to analysis\n  not exists(SsaVariable ssaVar | \n    ssaVar.getAUse() = expr.getAFlowNode() and\n    expressionPointsToFailure(ssaVar.getAnUltimateDefinition().getDefinition().getNode())\n  ) and\n  // The expression is not the target of an assignment\n  not exists(Assign assignment | assignment.getATarget() = expr)\n}\n\n// Query to find all Attribute expressions that are key points-to failures\n// and are not part of a call expression\nfrom Attribute attrExpr\nwhere \n  isKeyPointsToFailure(attrExpr) and \n  not exists(Call call | call.getFunc() = attrExpr)\nselect attrExpr, \"Expression does not 'point-to' any object, but all its sources do.\"",
    "output": "// The expression itself fails points-to analysis"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Socket bound to all network interfaces\n * @description Detects sockets bound to all network interfaces (0.0.0.0, ::, etc.),\n * which exposes services to all network traffic and creates significant security risks.\n * @kind problem\n * @tags security\n *       external/cwe/cwe-200\n * @problem.severity error\n * @security-severity 6.5\n * @sub-severity low\n * @precision high\n * @id py/bind-socket-all-network-interfaces\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n/** Defines all wildcard addresses representing all network interfaces */\nprivate string getWildcardAddress() {\n  result in [\n      // IPv4 wildcards\n      \"0.0.0.0\", \"\",\n      // IPv6 wildcards\n      \"::\", \"::0\"\n    ]\n}\n\n/**\n * Tracks wildcard address propagation through data flow.\n * Handles both literal values and propagated references.\n */\nprivate DataFlow::TypeTrackingNode trackWildcardAddress(DataFlow::TypeTracker t, string wildcard) {\n  // Base case: Match literal wildcard addresses\n  t.start() and\n  exists(StringLiteral addrLiteral | \n    wildcard = getWildcardAddress() and\n    addrLiteral.getText() = wildcard and\n    result.asExpr() = addrLiteral\n  )\n  or\n  // Recursive case: Track through data flow\n  exists(DataFlow::TypeTracker prev | \n    result = trackWildcardAddress(prev, wildcard).track(prev, t)\n  )\n}\n\n/** Retrieves data flow nodes containing wildcard address references */\nDataFlow::Node getWildcardNode(string wildcard) {\n  trackWildcardAddress(DataFlow::TypeTracker::end(), wildcard).flowsTo(result)\n}\n\n/**\n * Tracks address tuples containing wildcard addresses as first element.\n * Handles both direct tuples and propagated references.\n */\nprivate DataFlow::TypeTrackingNode trackWildcardTuple(DataFlow::TypeTracker t, string wildcard) {\n  // Base case: Match tuples with wildcard at first position\n  t.start() and\n  exists(Tuple addrTuple | \n    addrTuple.getElt(0) = getWildcardNode(wildcard).asExpr() and\n    result.asExpr() = addrTuple\n_______________ // 补全条件\n  or\n  // Recursive case: Track through data flow\n  exists(DataFlow::TypeTracker prev | \n    result = trackWildcardTuple(prev, wildcard).track(prev, t)\n  )\n}\n\n/** Retrieves data flow nodes containing address tuples with wildcard addresses */\nDataFlow::Node getWildcardTupleNode(string wildcard) {\n  trackWildcardTuple(DataFlow::TypeTracker::end(), wildcard).flowsTo(result)\n}\n\n/**\n * Identifies socket creation nodes for specific address families.\n * Reference: https://docs.python.org/3/library/socket.html\n */\nAPI::Node getSocketCreationNode() { \n  result = API::moduleImport(\"socket\").getMember(\"socket\").getReturn() \n}\n\nfrom DataFlow::CallCfgNode bindCall, DataFlow::Node addressArg, string wildcard\nwhere\n  // Match socket.bind() calls\n  bindCall = getSocketCreationNode().getMember(\"bind\").getACall() and\n  // First argument is the address tuple\n  addressArg = bindCall.getArg(0) and\n  // Address tuple contains wildcard address\n  addressArg = getWildcardTupleNode(wildcard)\nselect bindCall.asExpr(), \"Socket bound to all interfaces using '\" + wildcard + \"'.\"",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Number of commits\n * @description Computes the aggregate count of authentic commits in the repository, disregarding synthetic commits\n * @kind treemap\n * @id py/historical-number-of-commits\n * @treemap.warnOn highValues\n * @metricType commit\n * @metricAggregate sum\n */\n\n// Import necessary CodeQL libraries for Python code analysis and version control system tracking\nimport python\nimport external.VCS\n\n// Fetch all legitimate commits from the version control history,\n// excluding those that are artificially generated or automated\nfrom Commit commitEntry\n_______________ // 补全条件\n// Emit the revision identifier and a count value of 1 for each qualifying commit\nselect commitEntry.getRevisionName(), 1",
    "output": "where not artificialChange(commitEntry)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/repeated-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies redundant module imports that impair code readability",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module is imported more than once\n * @description Identifies redundant module imports that impair code readability\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/repeated-import\n */\n\nimport python\n\n// Determines if an import is a simple module import (without attribute access)\npredicate isSimpleModuleImport(Import importNode) { \n  not exists(Attribute attr | importNode.contains(attr)) \n}\n\n// Identifies duplicate imports of the same module within the same code scope\npredicate isDuplicateImport(Import firstImportNode, Import secondImportNode, Module importedModule) {\n  // Ensure imports are distinct statements\n  firstImportNode != secondImportNode and\n  // Both must be simple module imports\n  isSimpleModuleImport(firstImportNode) and\n  isSimpleModuleImport(secondImportNode) and\n  /* Both imports reference the same target module */\n  exists(ImportExpr firstImportExpr, ImportExpr secondImportExpr |\n    firstImportExpr.getName() = importedModule.getName() and\n    secondImportExpr.getName() = importedModule.getName() and\n    firstImportExpr = firstImportNode.getAName().getValue() and\n    secondImportExpr = secondImportNode.getAName().getValue()\n  ) and\n  // Both imports use identical aliases\n  firstImportNode.getAName().getAsname().(Name).getId() = secondImportNode.getAName().getAsname().(Name).getId() and\n  exists(Module enclosingModule |\n    firstImportNode.getScope() = enclosingModule and\n    secondImportNode.getEnclosingModule() = enclosingModule and\n    (\n      /* Redundant import is in nested scope (function/class) */\n      secondImportNode.getScope() != enclosingModule\n      or\n      /* First import appears before second import in source code */\n      firstImportNode.getAnEntryNode().dominates(secondImportNode.getAnEntryNode())\n    )\n  )\n}\n\n// Query to detect and report duplicate module imports\nfrom Import firstImportNode, Import secondImportNode, Module importedModule\nwhere isDuplicateImport(firstImportNode, secondImportNode, importedModule)\nselect secondImportNode,\n  \"This import of module \" + importedModule.getName() + \" is redundant, as it was previously imported $@.\",\n  firstImportNode, \"on line \" + firstImportNode.getLocation().getStartLine().toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Symmetric Encryption Algorithm Identification\n * @description Detects implementations of symmetric encryption algorithms within Python codebases\n *              by examining cryptographic library usage patterns and supported algorithm types.\n *              This query helps identify cryptographic components for CBOM (Cryptographic Bill of Materials) analysis.\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-encryption-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricEncryptionAlgorithm symmetricCipher\nselect symmetricCipher, \"Identified symmetric encryption algorithm: \" + symmetricCipher.getEncryptionName()",
    "output": "/**"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/multiple-imports-on-line]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query identifies import statements that violate PEP 8's recommendation",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Multiple imports on one line\n * @description This query identifies import statements that violate PEP 8's recommendation\n *              of placing each import on a separate line. Multiple imports on a single line\n *              reduce code readability and maintainability.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/multiple-imports-on-line\n */\n\nimport python\n\n// This query detects import statements that import multiple modules on a single line,\n// which violates PEP 8's one-import-per-line guideline. Note that 'from ... import ...'\n// style imports are excluded from this check as they follow different conventions.\nfrom Import importDeclaration\nwhere \n    // Check if the statement imports multiple modules\n    count(importDeclaration.getAName()) > 1 and\n    // Exclude 'from ... import ...' constructs\n    not importDeclaration.isFromImport()\nselect importDeclaration, \"Multiple imports on one line.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/regex/backspace-escape]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects the use of '\\b' to escape the backspace character in regular expressions,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Backspace escape in regular expression\n * @description Detects the use of '\\b' to escape the backspace character in regular expressions,\n *              which is confusing as it could be mistaken for a word boundary assertion.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int backslashPos\nwhere\n  // Find a backslash character that serves as an escape at the given position\n  regexPattern.escapingChar(backslashPos) and\n  // Check if the character immediately following the backslash is 'b'\n  regexPattern.getChar(backslashPos + 1) = \"b\" and\n  // Verify this escape sequence is contained within a character set definition\n  exists(int charSetStart, int charSetEnd | \n    regexPattern.charSet(charSetStart, charSetEnd) and\n    charSetStart < backslashPos and \n    charSetEnd > backslashPos\n  )\nselect regexPattern, \"Backspace escape in regular expression at offset \" + backslashPos + \".\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/useless-except]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects exception handlers that use non-exception types which are incapable of catching actual exceptions",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-exception in 'except' clause\n * @description Detects exception handlers that use non-exception types which are incapable of catching actual exceptions\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/useless-except\n */\n\nimport python\n\nfrom ExceptFlowNode exceptionHandler,\n     Value caughtType,\n     ClassValue caughtClass,\n     ControlFlowNode typeSource,\n     string typeInfo\nwhere\n  // Establish the relationship between exception handler and caught exception\n  exceptionHandler.handledException(caughtType, caughtClass, typeSource) and\n  (\n    // Scenario 1: Exception type is a class that doesn't inherit from BaseException\n    exists(ClassValue invalidExceptionClass | \n      invalidExceptionClass = caughtType and\n      not invalidExceptionClass.isLegalExceptionType() and\n      not invalidExceptionClass.failedInference(_) and\n      typeInfo = \"class '\" + invalidExceptionClass.getName() + \"'\"\n    )\n    or\n    // Scenario 2: Exception type is not a class (e.g., an instance)\n    not caughtType instanceof ClassValue and\n    typeInfo = \"instance of '\" + caughtClass.getName() + \"'\"\n  )\nselect exceptionHandler.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", \n  typeSource, \n  typeInfo"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Module imports itself\n * @description Detects modules that perform self-import operations\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n/**\n * Identifies modules that perform self-import operations.\n * This predicate detects when a module references itself through import statements\n * by comparing the importing module's context with the imported module's scope.\n */\npredicate isSelfImporting(ImportingStmt importStmt, ModuleValue moduleVal) {\n  // Verify the importing module's context matches the imported module's scope\n  importStmt.getEnclosingModule() = moduleVal.getScope() and\n_______________ // 补全条件\n  // This approach ensures proper handling of relative import paths\n  moduleVal = \n    max(string importedName, ModuleValue candidateModule |\n      importedName = importStmt.getAnImportedModuleName() and\n      candidateModule.importedAs(importedName)\n    |\n      candidateModule order by importedName.length()\n    )\n}\n\n// Query to locate all instances of self-importing modules\nfrom ImportingStmt importStmt, ModuleValue moduleVal\nwhere isSelfImporting(importStmt, moduleVal)\nselect importStmt, \"The module '\" + moduleVal.getName() + \"' imports itself.\"",
    "output": "// Resolve the most specific module reference using longest-name matching"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Generates information about alert suppressions in Python code.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions in Python code.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import required modules for alert suppression functionality\nprivate import codeql.util.suppression.AlertSuppression as AlertSuppression\nprivate import semmle.python.Comment as PythonComment\n\n/**\n * Wrapper class for AST nodes to provide location information\n * Extends the base AST node from Python comment module\n */\nclass AstNode instanceof PythonComment::AstNode {\n  /**\n   * Get detailed location information for the node\n   * @param filepath - The file path containing the node\n   * @param startline - Starting line number\n   * @param startcolumn - Starting column number\n   * @param endline - Ending line number\n   * @param endcolumn - Ending column number\n   */\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    // Delegate to parent class to retrieve location information\n    super.getLocation().hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n\n  /**\n   * Get string representation of the AST node\n   * @return String representation of the node\n   */\n  string toString() { result = super.toString() }\n}\n\n/**\n * Wrapper class for single-line comments in Python code\n * Extends the base Comment class from Python comment module\n */\nclass SingleLineComment instanceof PythonComment::Comment {\n  /**\n   * Get detailed location information for the comment\n   * @param filepath - The file path containing the comment\n   * @param startline - Starting line number\n   * @param startcolumn - Starting column number\n   * @param endline - Ending line number\n   * @param endcolumn - Ending column number\n   */\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    // Delegate to parent class to retrieve location information\n    super.getLocation().hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n\n  /**\n   * Get the text content of the comment\n   * @return The actual comment text\n   */\n  string getText() { result = super.getContents() }\n\n  /**\n   * Get string representation of the comment\n   * @return String representation of the comment\n   */\n  string toString() { result = super.toString() }\n}\n\n// Establish suppression relationship between nodes and comments using AlertSuppression template\nimport AlertSuppression::Make<AstNode, SingleLineComment>\n\n/**\n * Represents a noqa suppression comment that is recognized by both pylint and pyflakes\n * This comment type is also respected by LGTM analysis\n */\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  /**\n   * Constructor that validates the noqa comment format\n   * The comment must match the noqa pattern (case-insensitive)\n   */\n  NoqaSuppressionComment() {\n    // Verify that the comment text follows the noqa format pattern\n    // Pattern allows optional whitespace and optional content after noqa\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  /**\n   * Get the annotation identifier for this suppression comment\n   * @return The string \"lgtm\" as the annotation identifier\n   */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /**\n   * Define the code range covered by this suppression comment\n   * The comment covers the entire line where it appears\n   * @param filepath - The file path containing the comment\n   * @param startline - Starting line number (same as comment line)\n   * @param startcolumn - Starting column number (always 1 for line coverage)\n   * @param endline - Ending line number (same as comment line)\n   * @param endcolumn - Ending column number\n   */\n  override predicate covers(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    // Get comment location and ensure it starts at the beginning of the line\n    this.hasLocationInfo(filepath, startline, _, endline, endcolumn) and\n    startcolumn = 1\n  }\n}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/symmetric-encryption-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all occurrences of symmetric encryption algorithms",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Symmetric Encryption Algorithms Detection\n * @description Identifies all occurrences of symmetric encryption algorithms\n *              being utilized in the Python codebase through supported\n *              cryptographic libraries. This helps assess cryptographic\n *              posture for quantum readiness.\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-encryption-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricEncryptionAlgorithm symmetricAlgoUsage\nselect symmetricAlgoUsage, \n       \"Use of algorithm \" + symmetricAlgoUsage.getEncryptionName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name LDAP query built from user-controlled sources\n * @description Detects LDAP queries constructed from untrusted input,\n *              which could enable injection of malicious LDAP commands.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.8\n * @precision high\n * @id py/ldap-injection\n * @tags security\n *       external/cwe/cwe-090\n */\n\nimport python\nimport semmle.python.security.dataflow.LdapInjectionQuery\nimport LdapInjectionFlow::PathGraph\n\n// Define variables for tracking data flow paths and parameter types\nfrom LdapInjectionFlow::PathNode untrustedSource, LdapInjectionFlow::PathNode ldapSink, string parameterType\nwhere\n  // Check for data flow to DN parameter\n  (\n_______________ // 补全条件\n    and parameterType = \"DN\"\n  )\n  or\n  // Check for data flow to filter parameter\n  (\n    LdapInjectionFilterFlow::flowPath(untrustedSource.asPathNode2(), ldapSink.asPathNode2())\n    and parameterType = \"filter\"\n  )\nselect ldapSink.getNode(), untrustedSource, ldapSink,\n  \"LDAP query parameter (\" + parameterType + \") depends on a $@.\", untrustedSource.getNode(),\n  \"user-provided value\"",
    "output": "LdapInjectionDnFlow::flowPath(untrustedSource.asPathNode1(), ldapSink.asPathNode1())"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unreachable 'except' block\n * @description Detects exception handlers that can never execute due to incorrect ordering.\n_______________ // 补全条件\n *              exception inherits from the general one), the specific handler becomes unreachable.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @external/cwe/cwe-561\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unreachable-except\n */\n\nimport python\n\n/**\n * Maps an exception handler statement to its handled exception class.\n * @param handler - The exception handler statement to analyze\n * @return - The ClassValue representing the exception type handled by the handler\n */\nClassValue getHandledExceptionClass(ExceptStmt handler) { \n  handler.getType().pointsTo(result) \n}\n\n/**\n * Identifies incorrectly ordered exception handlers where a general handler\n * precedes a specific handler that inherits from the general exception type.\n * @param generalHandler - The handler for the general exception type\n * @param generalException - The general exception type handled first\n * @param specificHandler - The handler for the specific exception type\n * @param specificException - The specific exception type handled later\n */\npredicate hasIncorrectHandlerOrder(ExceptStmt generalHandler, ClassValue generalException, \n                                 ExceptStmt specificHandler, ClassValue specificException) {\n  // Verify both handlers belong to the same try block with correct ordering\n  exists(int generalIndex, int specificIndex, Try tryBlock |\n    generalHandler = tryBlock.getHandler(generalIndex) and\n    specificHandler = tryBlock.getHandler(specificIndex) and\n    generalIndex < specificIndex\n  ) and\n  // Establish exception type relationships\n  generalException = getHandledExceptionClass(generalHandler) and\n  specificException = getHandledExceptionClass(specificHandler) and\n  // Confirm inheritance relationship (specific exception inherits from general)\n  generalException = specificException.getASuperType()\n}\n\n// Main query to detect unreachable exception handlers\nfrom ExceptStmt specificHandler, ClassValue specificException, \n     ExceptStmt generalHandler, ClassValue generalException\nwhere hasIncorrectHandlerOrder(generalHandler, generalException, \n                              specificHandler, specificException)\nselect specificHandler,\n  \"Except block for $@ is unreachable; the more general $@ for $@ will always be executed in preference.\",\n  specificException, specificException.getName(), generalHandler, \"except block\", generalException, generalException.getName()",
    "output": "*              When a general exception handler precedes a specific one (where the specific"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name `__iter__` method returns non-iterator type\n * @description Identifies classes returned by `__iter__` methods that fail to implement \n *              the iterator protocol, which would trigger TypeErrors in iteration contexts\n *              such as for-loops.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iter-returns-non-iterator\n */\n\nimport python\n\nfrom ClassValue containerClass, FunctionValue iteratorMethod, ClassValue returnType\nwhere\n  // Locate the __iter__ method within the container class\n  iteratorMethod = containerClass.lookup(\"__iter__\") and\n  // Extract the inferred return type from the __iter__ method\n  returnType = iteratorMethod.getAnInferredReturnType() and\n  // Confirm the return type violates iterator protocol requirements\n_______________ // 补全条件\nselect \n  returnType,\n  \"Class \" + returnType.getName() + \n    \" is returned as an iterator (by $@) but doesn't implement the iterator protocol.\",\n  iteratorMethod, iteratorMethod.getName()",
    "output": "not returnType.isIterator()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unused-exception-object]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies code locations where an exception object is instantiated",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unused exception object\n * @description Identifies code locations where an exception object is instantiated\n *              but never utilized, indicating potential programming errors or dead code.\n * @kind problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/unused-exception-object\n */\n\nimport python  // 导入Python库，用于分析Python代码\n\n// 查找创建了异常对象但没有使用的代码\nfrom Call exceptionInstanceCreation, ClassValue exceptionType\nwhere\n  // 验证调用是创建一个异常类的实例\n  exceptionInstanceCreation.getFunc().pointsTo(exceptionType) and\n  // 确保该类是Exception类或其子类\n  exceptionType.getASuperType() = ClassValue::exception() and\n  // 检查异常对象被创建后未被使用（仅作为独立语句存在）\n  exists(ExprStmt standaloneStatement | \n    standaloneStatement.getValue() = exceptionInstanceCreation\n  )\nselect exceptionInstanceCreation, \"Exception object created but not used. Consider raising the exception or removing this statement.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Exception block catches 'BaseException'\n * @description Detects exception handlers that catch BaseException without re-raising,\n *              which may improperly handle system exits and keyboard interrupts.\n * @kind problem\n_______________ // 补全条件\n *       readability\n *       convention\n *       external/cwe/cwe-396\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/catch-base-exception\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// Main query: Identify exception handlers catching BaseException without re-raising\nfrom ExceptStmt exceptionHandler\nwhere\n  // Check if exception handler catches BaseException or unspecified exception type\n  (\n    exceptionHandler.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n    or\n    not exists(exceptionHandler.getType())\n  )\n  and\n  // Verify exception handler doesn't re-raise the exception\n  exceptionHandler.getAFlowNode().getBasicBlock().reachesExit()\nselect exceptionHandler, \"Except block directly handles BaseException.\"",
    "output": "* @tags reliability"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Alert suppression\n * @description Identifies and processes alert suppressions in Python code, specifically focusing on noqa-style comments.\n * @kind alert-suppression\n * @id py/alert-suppression */\n\n// Import CodeQL alert suppression utilities for handling suppression mechanisms\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing module for analyzing code comments\nprivate import semmle.python.Comment as P\n\n// Generate suppression relationships using AS template\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * Represents AST nodes with location tracking capabilities.\n * This class extends the basic AST node to provide location information.\n */\nclass AstNode instanceof P::AstNode {\n  /**\n   * Checks if the node is located at the specified coordinates.\n   * @param filePath The path of the file containing the node.\n   * @param startLine The starting line number of the node.\n   * @param startCol The starting column number of the node.\n   * @param endLine The ending line number of the node.\n   * @param endCol The ending column number of the node.\n   */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  /**\n   * Provides a string representation of the AST node.\n   * @return A string describing the node.\n   */\n  string toString() { result = super.toString() }\n}\n\n/**\n * Represents single-line comments with location tracking.\n * This class extends the basic comment to provide location and text information.\n */\nclass SingleLineComment instanceof P::Comment {\n  /**\n   * Checks if the comment is located at the specified coordinates.\n   * @param filePath The path of the file containing the comment.\n   * @param startLine The starting line number of the comment.\n   * @param startCol The starting column number of the comment.\n   * @param endLine The ending line number of the comment.\n   * @param endCol The ending column number of the comment.\n   */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(filePath, startLine, startCol, endLine, endCol)\n  }\n\n  /**\n   * Retrieves the text content of the comment.\n   * @return The text content of the comment.\n   */\n  string getText() { result = super.getContents() }\n\n  /**\n   * Provides a string representation of the comment.\n   * @return A string describing the comment.\n   */\n  string toString() { result = super.toString() }\n}\n\n/**\n * Represents a noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n * This class identifies and processes noqa-style suppression comments in Python code.\n */\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  /**\n   * Initializes the noqa suppression comment by matching the noqa comment pattern.\n   * The pattern matches comments that start with \"noqa\" (case-insensitive),\n   * optionally followed by additional text (but not a colon).\n   */\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  /**\n   * Returns the suppression annotation identifier.\n   * @return The string \"lgtm\" as the annotation identifier.\n   */\n  override string getAnnotation() { result = \"lgtm\" }\n\n  /**\n   * Defines the code coverage scope for this suppression.\n   * The suppression applies to the entire line where the comment appears.\n   * @param filePath The path of the file containing the suppression.\n_______________ // 补全条件\n   * @param startCol The starting column number of the suppression.\n   * @param endLine The ending line number of the suppression.\n   * @param endCol The ending column number of the suppression.\n   */\n  override predicate covers(\n    string filePath, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Match comment location and enforce line-start position\n    this.hasLocationInfo(filePath, startLine, _, endLine, endCol) and\n    startCol = 1\n  }\n}",
    "output": "* @param startLine The starting line number of the suppression."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unicode-dos]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when user-controlled input reaches costly Unicode normalization (NFKC/NFKD).",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Denial of Service using Unicode Characters\n * @description Detects when user-controlled input reaches costly Unicode normalization (NFKC/NFKD). \n *              On Windows, this can cause DoS via \"One Million Unicode Characters\" attack. \n *              Special characters like U+2100 (℀) can triple payload size during normalization.\n * @kind path-problem\n * @id py/unicode-dos\n * @precision high\n * @problem.severity error\n * @tags security\n *       experimental\n *       external/cwe/cwe-770\n */\n\nimport python\nimport semmle.python.ApiGraphs\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n// Represents Unicode normalization calls that could cause DoS\nclass UnicodeCompatibilityNormalize extends API::CallNode {\n  int normalizedArgIndex; // Index of argument being normalized\n\n  UnicodeCompatibilityNormalize() {\n    // Handle unicodedata.normalize() and pyunormalize.normalize() calls\n    (\n      this = API::moduleImport(\"unicodedata\").getMember(\"normalize\").getACall() and\n      this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember(\"normalize\").getACall() and\n      this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n    ) and\n    normalizedArgIndex = 1 // Normalization is second argument\n    or\n    // Handle textnorm.normalize_unicode(), unidecode.unidecode(), and direct pyunormalize calls\n    (\n      this = API::moduleImport(\"textnorm\").getMember(\"normalize_unicode\").getACall() and\n      this.getParameter(1).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"unidecode\").getMember(\"unidecode\").getACall()\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember([\"NFKC\", \"NFKD\"]).getACall()\n    ) and\n    normalizedArgIndex = 0 // Normalization is first argument\n  }\n\n  // Returns the node containing the normalized input\n  DataFlow::Node getPathArg() { result = this.getArg(normalizedArgIndex) }\n}\n\n// Checks if a string length is constrained by a comparison\npredicate isLengthConstrained(DataFlow::GuardNode guardNode, ControlFlowNode checkedNode, boolean branch) {\n  exists(CompareNode comparison | comparison = guardNode |\n    exists(API::CallNode lengthCall, Cmpop operator, Node lengthNode |\n      lengthCall = lengthNode.getALocalSource() and\n      (\n        // Cases where length is considered limited: arg <= LIMIT or arg < LIMIT\n        (operator instanceof LtE or operator instanceof Lt) and\n        branch = true and\n        comparison.operands(lengthNode.asCfgNode(), operator, _)\n        or\n        // Cases where length is considered limited: LIMIT >= arg or LIMIT > arg\n        (operator instanceof GtE or operator instanceof Gt) and\n        branch = true and\n        comparison.operands(_, operator, lengthNode.asCfgNode())\n        or\n        // Cases where length is NOT limited: not arg >= LIMIT or not arg > LIMIT\n        (operator instanceof GtE or operator instanceof Gt) and\n        branch = false and\n        comparison.operands(lengthNode.asCfgNode(), operator, _)\n        or\n        // Cases where length is NOT limited: not LIMIT <= arg or not LIMIT < arg\n        (operator instanceof LtE or operator instanceof Lt) and\n        branch = false and\n        comparison.operands(_, operator, lengthNode.asCfgNode())\n      )\n    |\n      lengthCall = API::builtin(\"len\").getACall() and\n      checkedNode = lengthCall.getArg(0).asCfgNode() // Ensure we're checking len() argument\n    )\n  )\n}\n\n// Configuration for Unicode DoS data flow analysis\nprivate module UnicodeDoSConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node taintSource) { \n    taintSource instanceof RemoteFlowSource // Sources are remote user inputs\n  }\n\n  predicate isBarrier(DataFlow::Node barrierNode) {\n    // Barriers are length checks that constrain input size\n    barrierNode = DataFlow::BarrierGuard<isLengthConstrained/3>::getABarrierNode()\n  }\n\n  predicate isSink(DataFlow::Node taintSink) {\n    // Sinks are Unicode normalization operations\n    taintSink = any(UnicodeCompatibilityNormalize normalizeCall).getPathArg()\n    or\n    // werkzeug's secure_filename() uses Unicode normalization internally\n    taintSink = API::moduleImport(\"werkzeug\").getMember(\"secure_filename\").getACall().getArg(_)\n    or\n    taintSink =\n      API::moduleImport(\"werkzeug\")\n          .getMember(\"utils\")\n          .getMember(\"secure_filename\")\n          .getACall()\n          .getArg(_)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() } // Enable incremental analysis\n}\n\n// Global taint tracking using our configuration\nmodule UnicodeDoSFlow = TaintTracking::Global<UnicodeDoSConfig>;\n\nimport UnicodeDoSFlow::PathGraph\n\nfrom UnicodeDoSFlow::PathNode source, UnicodeDoSFlow::PathNode sink\nwhere UnicodeDoSFlow::flowPath(source, sink) // Find paths from source to sink\nselect sink.getNode(), source, sink, \"This $@ can reach a $@.\", source.getNode(),\n  \"user-provided value\", sink.getNode(), \"costly Unicode normalization operation\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call-to-non-callable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects invocations of objects that are not callable,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Non-callable object invocation\n * @description Detects invocations of objects that are not callable,\n *              which would result in a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom \n  Call callSite, \n  Value resolvedValue, \n  ClassValue valueClass, \n  Expr calleeExpr, \n  AstNode sourceNode\nwhere\n  // Identify the expression being invoked at the call site\n  calleeExpr = callSite.getFunc() and\n  \n  // Resolve the invoked expression to its concrete value and trace its origin\n  calleeExpr.pointsTo(resolvedValue, sourceNode) and\n  \n  // Determine the class type of the resolved value\n  valueClass = resolvedValue.getClass() and\n  \n  // Verify the class is not callable and type inference was successful\n  not valueClass.isCallable() and\n  not valueClass.failedInference(_) and\n  \n  // Exclude descriptor objects with __get__ method (callable via descriptor protocol)\n  not valueClass.hasAttribute(\"__get__\") and\n  \n  // Exclude explicit None values (known non-callable)\n  not resolvedValue = Value::named(\"None\") and\n  \n  // Exclude special case of NotImplemented in raise statements\n  not use_of_not_implemented_in_raise(_, calleeExpr)\nselect \n  callSite, \n  \"Call to a $@ of $@.\", \n  sourceNode, \n  \"non-callable\", \n  valueClass, \n  valueClass.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/repeated-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects duplicate module imports within the same scope",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module is imported more than once\n * @description Detects duplicate module imports within the same scope\n *              that unnecessarily increase code size and decrease maintainability.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/repeated-import\n */\n\nimport python\n\n// Check if an import statement is simple (i.e., doesn't access module attributes)\npredicate is_simple_import(Import importStatement) { \n  not exists(Attribute attr | importStatement.contains(attr)) \n}\n\n// Identify pairs of duplicate imports within the same scope\npredicate double_import(Import initialImport, Import duplicateImport, Module targetModule) {\n  // Basic validation: imports must be distinct and both must be simple imports\n  initialImport != duplicateImport and\n  is_simple_import(initialImport) and\n  is_simple_import(duplicateImport) and\n  \n  // Verify both imports reference the same module\n  exists(ImportExpr firstModExpr, ImportExpr secondModExpr |\n    firstModExpr = initialImport.getAName().getValue() and\n    secondModExpr = duplicateImport.getAName().getValue() and\n    firstModExpr.getName() = targetModule.getName() and\n    secondModExpr.getName() = targetModule.getName()\n  ) and\n  \n  // Ensure alias consistency between imports\n  (if exists(initialImport.getAName().getAsname())\n   then \n     // When both imports have aliases, they must match\n     exists(Name firstAlias, Name secondAlias |\n       firstAlias = initialImport.getAName().getAsname() and\n       secondAlias = duplicateImport.getAName().getAsname() and\n       firstAlias.getId() = secondAlias.getId()\n     )\n   else \n     // If the first import has no alias, the second shouldn't either\n     not exists(duplicateImport.getAName().getAsname())\n  ) and\n  \n  // Validate scope and positioning constraints\n  exists(Module parentModule |\n    // Both imports must be in the same parent module\n    initialImport.getScope() = parentModule and\n    duplicateImport.getEnclosingModule() = parentModule and\n    \n    // Position validation: either the duplicate is not in top-level scope\n    // or the initial import appears before the duplicate\n    (duplicateImport.getScope() != parentModule or\n     initialImport.getAnEntryNode().dominates(duplicateImport.getAnEntryNode()))\n  )\n}\n\n// Query to find and report redundant import statements\nfrom Import initialImport, Import duplicateImport, Module targetModule\nwhere double_import(initialImport, duplicateImport, targetModule)\nselect duplicateImport,\n  \"This import of module \" + targetModule.getName() + \" is redundant, as it was previously imported $@.\",\n  initialImport, \"on line \" + initialImport.getLocation().getStartLine().toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/class-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：识别并定位 Python 代码中定义的所有类，提供其源文件的完整路径信息",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 类的源链接\n * @description 识别并定位 Python 代码中定义的所有类，提供其源文件的完整路径信息\n * @kind source-link\n * @id py/class-source-links\n * @metricType reftype\n */\n\nimport python\n\n// 查找所有 Python 类并获取其源文件位置\nfrom Class cls\n// 提取类对象及其源文件路径\nselect cls, cls.getLocation().getFile()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Duplicate key in dict literal\n * @description Identifies dictionary literals containing duplicate keys, where all but the final occurrence are overwritten\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-561\n_______________ // 补全条件\n * @sub-severity high\n * @precision very-high\n * @id py/duplicate-key-dict-literal\n */\n\nimport python\nimport semmle.python.strings\n\n/**\n * Converts dictionary keys to standardized string representations for comparison.\n * Handles numeric keys and string literals (Unicode and byte strings).\n */\npredicate dictKeyToString(Dict targetDict, Expr keyExpr, string keyStr) {\n  keyExpr = targetDict.getAKey() and\n  (\n    // Handle numeric keys by converting their value to string\n    keyStr = keyExpr.(Num).getN()\n    or\n    // Handle string keys, including Unicode and byte string representations\n    // Note: '�' indicates characters that cannot be properly represented\n    not \"�\" = keyStr.charAt(_) and\n    exists(StringLiteral stringLiteral | stringLiteral = keyExpr |\n      keyStr = \"u\\\"\" + stringLiteral.getText() + \"\\\"\" and stringLiteral.isUnicode()\n      or\n      keyStr = \"b\\\"\" + stringLiteral.getText() + \"\\\"\" and not stringLiteral.isUnicode()\n    )\n  )\n}\n\nfrom Dict targetDict, Expr firstKey, Expr secondKey, string keyStr\nwhere\n  // Identify two distinct keys with identical string representations\n  dictKeyToString(targetDict, firstKey, keyStr) and \n  dictKeyToString(targetDict, secondKey, keyStr) and \n  firstKey != secondKey and\n  // Verify that firstKey appears before secondKey in the control flow\n  (\n    // Scenario 1: Keys reside in the same basic block with firstKey at a lower index\n    exists(BasicBlock codeBlock, int firstIndex, int secondIndex |\n      firstKey.getAFlowNode() = codeBlock.getNode(firstIndex) and\n      secondKey.getAFlowNode() = codeBlock.getNode(secondIndex) and\n      firstIndex < secondIndex\n    )\n    or\n    // Scenario 2: The basic block containing firstKey strictly dominates the block containing secondKey\n    firstKey.getAFlowNode().getBasicBlock().strictlyDominates(\n      secondKey.getAFlowNode().getBasicBlock()\n    )\n  )\n// Report the overwritten key with location information\nselect firstKey, \n  \"Dictionary key \" + repr(firstKey) + \" is subsequently $@.\", \n  secondKey, \n  \"overwritten\"",
    "output": "* @problem.severity warning"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Result of integer division may be truncated\n * @description Detects division operations where both arguments are integers,\n *              which may cause the result to be truncated in Python 2.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// 查找在Python 2中可能导致结果被截断的整数除法操作\nfrom BinaryExpr truncatingDivision, ControlFlowNode leftIntOperand, ControlFlowNode rightIntOperand\nwhere\n  // 仅在Python 2中需要检查，因为后续版本实现了真除法\n  major_version() = 2 and\n  exists(BinaryExprNode divisionNode, Value leftIntValue, Value rightIntValue |\n    // 获取除法表达式节点并确保操作符是除法\n    divisionNode = truncatingDivision.getAFlowNode() and\n    divisionNode.getNode().getOp() instanceof Div and\n    \n    // 检查左操作数是否为整数\n    divisionNode.getLeft().pointsTo(leftIntValue, leftIntOperand) and\n    leftIntValue.getClass() = ClassValue::int_() and\n    \n    // 检查右操作数是否为整数\n_______________ // 补全条件\n    rightIntValue.getClass() = ClassValue::int_() and\n    \n    // 排除整除没有余数的情况，因为这种情况下截断不会影响结果\n    not leftIntValue.(NumericValue).getIntValue() % rightIntValue.(NumericValue).getIntValue() = 0 and\n    \n    // 排除包含`from __future__ import division`的模块，因为它们使用真正的除法\n    not divisionNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // 排除结果被显式转换为整数的情况，因为这可能是预期的行为\n    not exists(CallNode intConversionCall |\n      intConversionCall = ClassValue::int_().getACall() and\n      intConversionCall.getAnArg() = divisionNode\n    )\n  )\nselect truncatingDivision, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftIntOperand, \"left\", rightIntOperand, \"right\"",
    "output": "divisionNode.getRight().pointsTo(rightIntValue, rightIntOperand) and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/super-in-old-style]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies super() calls in old-style classes that lack proper inheritance support",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'super' in old style class\n * @description Identifies super() calls in old-style classes that lack proper inheritance support\n * @kind problem\n * @tags portability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/super-in-old-style\n */\n\nimport python\n\n// Query targeting super() invocations that will fail in old-style classes\nfrom Call superInvocation\nwhere \n  // Check for existence of a method within an old-style class\n  exists(Function classMethod, ClassObject legacyClass |\n    // The super call must be scoped within a method\n    superInvocation.getScope() = classMethod and\n    // The method must be defined inside a class context\n    classMethod.getScope() = legacyClass.getPyClass() and\n    // Verify the class was properly inferred during analysis\n    not legacyClass.failedInference() and\n    // Confirm this is an old-style class (non-new-style)\n    not legacyClass.isNewStyle() and\n    // Ensure the call is targeting the built-in super function\n    superInvocation.getFunc().(Name).getId() = \"super\"\n  )\n// Report the problematic super() call with an informative message\nselect superInvocation, \"'super()' will not work in old-style classes.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/member-test-non-container]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects membership operations (e.g., 'item in sequence') where the right-hand operand",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Membership test with non-container object\n * @description Detects membership operations (e.g., 'item in sequence') where the right-hand operand \n *              is a non-container object, causing runtime 'TypeError'.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n/**\n * Identifies right-hand operands in membership comparison operations.\n * @param rhsNode - Control flow node representing the right operand\n * @param compNode - Comparison expression containing the membership test\n */\npredicate isRhsOfInTest(ControlFlowNode rhsNode, Compare compNode) {\n  exists(Cmpop op, int idx |\n    compNode.getOp(idx) = op and \n    compNode.getComparator(idx) = rhsNode.getNode() and\n    (op instanceof In or op instanceof NotIn)\n  )\n}\n\nfrom \n  ControlFlowNode rightOperand, \n  Compare comparisonExpr, \n  Value pointedToValue, \n  ClassValue valueClass, \n  ControlFlowNode sourceNode\nwhere\n  // Identify membership test right operand\n  isRhsOfInTest(rightOperand, comparisonExpr) and\n  \n  // Resolve value and type information\n  rightOperand.pointsTo(_, pointedToValue, sourceNode) and\n  pointedToValue.getClass() = valueClass and\n  \n  // Exclude cases with incomplete type analysis\n  not Types::failedInference(valueClass, _) and\n  \n  // Verify absence of container interface methods\n  (\n    not valueClass.hasAttribute(\"__contains__\") and\n    not valueClass.hasAttribute(\"__iter__\") and\n    not valueClass.hasAttribute(\"__getitem__\")\n  ) and\n  \n  // Exclude special container-like types\n  (\n    not valueClass = ClassValue::nonetype() and\n    not valueClass = Value::named(\"types.MappingProxyType\")\n  )\nselect \n  comparisonExpr, \n  \"This membership test may raise an Exception because the $@ is of non-container type $@.\", \n  sourceNode, \"target\", valueClass, valueClass.getName()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Timing attack against Hash\n * @description 当验证消息哈希值时，必须使用恒定时间算法。\n *              否则攻击者可通过响应时间差异伪造有效哈希值，\n *              成功攻击可能导致身份验证机制被绕过。\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/possible-timing-attack-against-hash\n * @tags security\n *       external/cwe/cwe-208\n *       experimental\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * 配置模块：跟踪从加密操作到非恒定时间比较的数据流\n */\nprivate module TimingAttackHashConfig implements DataFlow::ConfigSig {\n  // 源节点定义：加密操作调用\n  predicate isSource(DataFlow::Node cryptoOp) { \n    cryptoOp instanceof ProduceCryptoCall \n  }\n\n  // 汇节点定义：非恒定时间比较操作\n  predicate isSink(DataFlow::Node comparison) { \n    comparison instanceof NonConstantTimeComparisonSink \n  }\n}\n\n// 全局污点跟踪模块，基于上述配置\nmodule TimingAttackHashFlow = TaintTracking::Global<TimingAttackHashConfig>;\n\nimport TimingAttackHashFlow::PathGraph\n\n// 查询主逻辑：检测从加密操作到非恒定时间比较的数据流路径\nfrom\n  TimingAttackHashFlow::PathNode srcNode,\n  TimingAttackHashFlow::PathNode sinkNode\nwhere \n  TimingAttackHashFlow::flowPath(srcNode, sinkNode)\nselect \n_______________ // 补全条件\n  srcNode, \n  sinkNode, \n  \"可能存在针对$@验证的时间攻击。\",\n  srcNode.getNode().(ProduceCryptoCall).getResultType(), \n  \"message\"",
    "output": "sinkNode.getNode(),"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/redundant-else]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies 'for' or 'while' loops containing an 'else' clause that never serves its purpose",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unnecessary 'else' clause in loop\n * @description Identifies 'for' or 'while' loops containing an 'else' clause that never serves its purpose\n *              because the loop body lacks a 'break' statement, making the 'else' clause redundant.\n *              In Python, the else clause of a loop executes only if the loop completes normally\n *              (without encountering a break statement). If there's no break in the loop body,\n *              the else clause will always execute, making it redundant.\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity warning\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-else\n */\n\nimport python\n\nfrom Stmt loopStmt, StmtList loopBody, StmtList elseClause, string loopType\nwhere\n  // Identify for loops with an else clause\n  (exists(For forLoop | \n      loopStmt = forLoop and \n      loopBody = forLoop.getBody() and \n      elseClause = forLoop.getOrelse() and \n      loopType = \"for\")\n   // Identify while loops with an else clause\n   or\n   exists(While whileLoop | \n      loopStmt = whileLoop and \n      loopBody = whileLoop.getBody() and \n      elseClause = whileLoop.getOrelse() and \n      loopType = \"while\"))\n  and\n  // Ensure no break statements exist in the loop body\n  not exists(Break breakStmt | loopBody.contains(breakStmt))\nselect loopStmt,\n  \"This '\" + loopType + \"' statement has a redundant 'else' as no 'break' is present in the body.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description Identifies class instantiations using keyword arguments that don't match \n *              any parameter in the class's __init__ method, leading to runtime TypeErrors.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-named-class-argument\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call classInstantiation, ClassValue instantiatedClass, string mismatchedParam, FunctionValue classInitializer\nwhere\n  // Find class instantiations with invalid keyword arguments\n  illegally_named_parameter(classInstantiation, instantiatedClass, mismatchedParam) and\n  // Retrieve the initializer method (__init__) of the target class\n  classInitializer = get_function_or_initializer(instantiatedClass)\nselect classInstantiation, \n       \"Keyword argument '\" + mismatchedParam + \"' is not a supported parameter name of $@.\", \n       classInitializer,\n       classInitializer.getQualifiedName()",
    "output": "* @name Wrong name for an argument in a class instantiation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Superclass attribute shadows subclass method\n * @description 定义在超类方法中的一个属性，其名称与子类方法匹配，会隐藏子类的方法。\n * @kind problem\n * @problem.severity error\n * @tags maintainability\n *       correctness\n * @sub-severity low\n * @precision high\n * @id py/attribute-shadows-method\n */\n\n/* \n * 检测场景：子类中定义的方法被超类中定义的属性遮蔽\n * 关键逻辑：\n * 1. 确定子类与超类的继承关系\n * 2. 验证超类在初始化方法中定义了同名属性\n * 3. 确保超类本身未定义同名方法\n */\n\nimport python\n\n// 检测子类方法是否被超类属性遮蔽\npredicate shadowed_by_super_class(\n  ClassObject subcls, ClassObject superclass, Assign shadowingAssign, FunctionObject shadowedMethod\n) {\n  // 验证继承关系：subcls 继承自 superclass\n  subcls.getASuperType() = superclass and\n  // 确认子类中存在被遮蔽的方法\n  subcls.declaredAttribute(_) = shadowedMethod and\n  // 检查超类初始化方法中的属性定义\n  exists(FunctionObject superInit, Attribute attr, string methodName |\n    // 超类必须定义 __init__ 方法\n    superclass.declaredAttribute(\"__init__\") = superInit and\n    // 赋值语句的目标属性\n    attr = shadowingAssign.getATarget() and\n    // 属性必须属于 self 对象\n    attr.getObject().(Name).getId() = \"self\" and\n    // 属性名与方法名匹配\n    methodName = shadowedMethod.getName() and\n    attr.getName() = methodName and\n    // 赋值操作必须发生在超类的 __init__ 作用域内\n_______________ // 补全条件\n  ) and\n  // 排除超类已定义同名方法的情况（避免误报）\n  not superclass.hasAttribute(shadowedMethod.getName())\n}\n\n// 主查询：定位被遮蔽的方法\nfrom ClassObject subcls, ClassObject superclass, Assign shadowingAssign, FunctionObject shadowedMethod\nwhere shadowed_by_super_class(subcls, superclass, shadowingAssign, shadowedMethod)\n// 输出格式保持不变：方法位置 + 描述信息 + 遮蔽赋值位置 + 属性类型\nselect shadowedMethod.getOrigin(),\n  \"Method \" + shadowedMethod.getName() + \" is shadowed by an $@ in super class '\" + superclass.getName() +\n    \"'.\", shadowingAssign, \"attribute\"",
    "output": "shadowingAssign.getScope() = superInit.getOrigin().(FunctionExpr).getInnerScope()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-callable invoked\n * @description Identifies code that attempts to invoke objects which are not callable,\n *              potentially resulting in TypeError exceptions during execution.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/call-to-non-callable\n */\n\nimport python\nimport Exceptions.NotImplemented\n\nfrom \n  Call callNode, \n  Value targetObject, \n_______________ // 补全条件\n  Expr calleeExpr, \n  AstNode sourceNode\nwhere\n  // Extract the callee expression from the call node\n  calleeExpr = callNode.getFunc() and\n  \n  // Resolve the callee to its underlying value and trace its origin\n  calleeExpr.pointsTo(targetObject, sourceNode) and\n  \n  // Obtain the class of the target object being invoked\n  targetClass = targetObject.getClass() and\n  \n  // Core check: verify the object's class is not callable\n  not targetClass.isCallable() and\n  \n  // Ensure type inference was successful for accurate analysis\n  not targetClass.failedInference(_) and\n  \n  // Exclude descriptor objects implementing __get__ method\n  // These objects can be callable through the descriptor protocol\n  not targetClass.hasAttribute(\"__get__\") and\n  \n  // Filter out None values as they are explicitly non-callable\n  not targetObject = Value::named(\"None\") and\n  \n  // Special case: exclude NotImplemented when used in raise statements\n  not use_of_not_implemented_in_raise(_, calleeExpr)\nselect \n  callNode, \n  \"Call to a $@ of $@.\", \n  sourceNode, \n  \"non-callable\", \n  targetClass, \n  targetClass.toString()",
    "output": "ClassValue targetClass,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of insecure SSL/TLS version\n * @description Identifies code utilizing deprecated SSL/TLS protocol versions that are susceptible to security vulnerabilities.\n * @id py/insecure-protocol\n_______________ // 补全条件\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n// Represents nodes that configure insecure protocol settings\nclass InsecureProtocolConfiguration extends DataFlow::Node {\n  InsecureProtocolConfiguration() {\n    // Detects connections established with security context\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    // Detects connections established without security context\n    unsafe_connection_creation_without_context(this, _)\n    or\n    // Detects direct creation of insecure security contexts\n    unsafe_context_creation(this, _)\n  }\n\n  // Retrieves the associated function node\n  DataFlow::Node getFunctionNode() { result = this.(DataFlow::CallCfgNode).getFunction() }\n}\n\n// Represents nodes that can have qualified names (functions or attribute accesses)\nclass QualifiedNode extends DataFlow::Node {\n  QualifiedNode() {\n    // Matches function nodes from protocol configurations\n    this = any(InsecureProtocolConfiguration cfg).getFunctionNode()\n    or\n    // Matches attribute access objects\n    this = any(QualifiedNode attr).(DataFlow::AttrRef).getObject()\n  }\n}\n\n// Builds qualified names for callable nodes by traversing attribute chains\nstring buildQualifiedName(QualifiedNode node) {\n  // Base case: direct function name\n  result = node.asExpr().(Name).getId()\n  or\n  // Recursive case: attribute access chains\n  exists(DataFlow::AttrRef attrRef | attrRef = node |\n    result = buildQualifiedName(attrRef.getObject()) + \".\" + attrRef.getAttributeName()\n  )\n}\n\n// Generates human-readable descriptions for protocol configurations\nstring generateConfigDescription(InsecureProtocolConfiguration config) {\n  // Case 1: Configuration via function call\n  result = \"call to \" + buildQualifiedName(config.(DataFlow::CallCfgNode).getFunction())\n  or\n  // Case 2: Configuration via context modification (non-callable)\n  not config instanceof DataFlow::CallCfgNode and\n  not config instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n// Determines appropriate verb based on configuration specificity\nstring determineVerb(boolean isSpecificConfiguration) {\n  isSpecificConfiguration = true and result = \"specified\"\n  or\n  isSpecificConfiguration = false and result = \"allowed\"\n}\n\n// Main query logic to detect insecure protocol usage\nfrom\n  DataFlow::Node insecureConnectionNode, string insecureProtocolVersion, \n  InsecureProtocolConfiguration protocolConfiguration, boolean isSpecificConfiguration\nwhere\n  // Scenario 1: Insecure connection created with security context\n  unsafe_connection_creation_with_context(insecureConnectionNode, insecureProtocolVersion, protocolConfiguration, isSpecificConfiguration)\n  or\n  // Scenario 2: Insecure connection created without security context\n  unsafe_connection_creation_without_context(insecureConnectionNode, insecureProtocolVersion) and\n  protocolConfiguration = insecureConnectionNode and\n  isSpecificConfiguration = true\n  or\n  // Scenario 3: Insecure security context created directly\n  unsafe_context_creation(protocolConfiguration, insecureProtocolVersion) and\n  insecureConnectionNode = protocolConfiguration and\n  isSpecificConfiguration = true\nselect insecureConnectionNode,\n  \"Insecure SSL/TLS protocol version \" + insecureProtocolVersion + \" \" + determineVerb(isSpecificConfiguration) + \" by $@.\",\n  protocolConfiguration, generateConfigDescription(protocolConfiguration)",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of a print statement at module level\n * @description Detects print statements at module scope that are not guarded by `if __name__ == '__main__'`.\n *              Such statements will produce output when the module is imported, which is often unintended.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/print-during-import\n */\n\nimport python\n\n// Identifies if statements checking for __name__ == '__main__'\npredicate isMainGuard(If ifNode) {\n  exists(Name nameNode, StringLiteral mainLiteral, Compare comparisonExpr |\n    ifNode.getTest() = comparisonExpr and          // Get the condition of the if statement\n    comparisonExpr.getLeft() = nameNode and        // Left operand is __name__\n    comparisonExpr.getAComparator() = mainLiteral and // Right operand is \"__main__\"\n    nameNode.getId() = \"__name__\" and              // Confirm left operand is __name__\n    mainLiteral.getText() = \"__main__\"             // Confirm right operand is \"__main__\"\n  )\n}\n\n// Identifies print statements (both Python 2 print statements and Python 3 print function calls)\n_______________ // 补全条件\n  statement instanceof Print  // Python 2 print statement\n  or\n  exists(ExprStmt exprStatement, Call functionCall, Name functionName |\n    exprStatement = statement and                  // Statement is an expression statement\n    functionCall = exprStatement.getValue() and    // Get the call part of the expression\n    functionName = functionCall.getFunc() and      // Get the function name being called\n    functionName.getId() = \"print\"                 // Confirm function name is print\n  )\n}\n\n// Find print statements that execute during module import\nfrom Stmt printStatement\nwhere\n  isPrintOperation(printStatement) and             // Confirm the statement is a print statement\n  // TODO: Need to discuss how we would like to handle ModuleObject.getKind in the glorious future\n  exists(ModuleValue moduleValue | \n    moduleValue.getScope() = printStatement.getScope() and \n    moduleValue.isUsedAsModule()                   // Check if the statement is in a module that is used as an imported module\n  ) and\n  not exists(If ifNode | \n    isMainGuard(ifNode) and \n    ifNode.getASubStatement().getASubStatement*() = printStatement  // Ensure the print statement is not inside an if __name__ == '__main__' block\n  )\nselect printStatement, \"Print statement may execute during import.\"",
    "output": "predicate isPrintOperation(Stmt statement) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Timing attack against secret\n * @description Identifies non-constant-time verification routines for secret values,\n *              potentially enabling timing attacks that expose sensitive information.\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/possible-timing-attack-sensitive-info\n * @tags security\n *       external/cwe/cwe-208\n *       experimental\n */\n\n// Import core Python language analysis modules\nimport python\n// Import data flow analysis framework\nimport semmle.python.dataflow.new.DataFlow\n// Import taint propagation capabilities\nimport semmle.python.dataflow.new.TaintTracking\n// Import experimental timing attack detection utilities\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * Configuration for tracking data flow from secret origins to non-constant-time comparisons.\n * This setup identifies potential timing attack vulnerabilities in code.\n */\nprivate module TimingAttackConfig implements DataFlow::ConfigSig {\n  // Enable differential observation mode for all scenarios\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  // Define origins: nodes representing secret sources\n  predicate isSource(DataFlow::Node sourceNode) { sourceNode instanceof SecretSource }\n\n  // Define targets: nodes representing non-constant-time comparison operations\n  predicate isSink(DataFlow::Node sinkNode) { sinkNode instanceof NonConstantTimeComparisonSink }\n}\n\n// Establish global taint tracking using the timing attack configuration\n_______________ // 补全条件\n\n// Import path visualization module for flow paths\nimport TimingAttackFlow::PathGraph\n\n// Primary query to detect timing attack vulnerabilities\nfrom\n  TimingAttackFlow::PathNode secretSourceNode,  // Origin of the secret data\n  TimingAttackFlow::PathNode comparisonSinkNode // Target comparison operation\nwhere \n  // Verify existence of flow path from secret origin to comparison target\n  TimingAttackFlow::flowPath(secretSourceNode, comparisonSinkNode)\nselect \n  comparisonSinkNode.getNode(),      // Location where vulnerability manifests\n  secretSourceNode,                  // Origin of the flow\n  comparisonSinkNode,                // Termination point of the flow\n  \"Timing attack against $@ verification.\", // Security alert\n  secretSourceNode.getNode(),        // Reference point for alert\n  \"client-provided secret\"           // Description of the sensitive source",
    "output": "module TimingAttackFlow = TaintTracking::Global<TimingAttackConfig>;"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/key-points-to-failure]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies expressions that fail to point-to any object, blocking further points-to analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Critical expression points-to analysis failure.\n * @description Identifies expressions that fail to point-to any object, blocking further points-to analysis.\n * @kind problem\n * @problem.severity info\n * @id py/key-points-to-failure\n * @deprecated\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\n// Predicate to identify expressions that cannot point to any object\npredicate exprPointsToFailure(Expr problematicExpr) {\n  // Check if any control flow node associated with the expression lacks points-to relationships\n  exists(ControlFlowNode controlFlowNode | \n    controlFlowNode = problematicExpr.getAFlowNode() | \n    not PointsTo::pointsTo(controlFlowNode, _, _, _)\n  )\n}\n\n// Predicate to identify critical points-to analysis failures in expressions\npredicate isKeyPointsToFailure(Expr problematicExpr) {\n  // The expression itself experiences points-to failure\n  exprPointsToFailure(problematicExpr) and\n  // All sub-expressions have successful points-to analysis\n  not exprPointsToFailure(problematicExpr.getASubExpression()) and\n  // The expression is not involved in any points-to failure propagation through SSA variables\n  not exists(SsaVariable ssaVar | \n    ssaVar.getAUse() = problematicExpr.getAFlowNode() |\n    exprPointsToFailure(ssaVar.getAnUltimateDefinition().getDefinition().getNode())\n  ) and\n  // The expression is not the target of an assignment operation\n  not exists(Assign assignStmt | assignStmt.getATarget() = problematicExpr)\n}\n\n// Query to find all critical points-to failure expressions, excluding those used as function calls\nfrom Attribute problematicExpr\nwhere isKeyPointsToFailure(problematicExpr) and not exists(Call call | call.getFunc() = problematicExpr)\nselect problematicExpr, \"Expression does not 'point-to' any object, but all its sources do.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mostly-duplicate-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes where over 80% of methods are duplicated in another class.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Mostly duplicate class\n * @description Identifies classes where over 80% of methods are duplicated in another class. \n *              Consider refactoring by creating a common supertype to enhance code reuse.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/mostly-duplicate-class\n */\n\nimport python\n\n// 分析类实例 `sourceClass`、潜在重复类 `targetClass` 及描述信息\n// 当前实现为占位逻辑，实际检测逻辑需后续补充\nfrom Class sourceClass, Class targetClass, string description\nwhere none()\nselect sourceClass, description, targetClass, targetClass.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/alert-suppression]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Generates information about alert suppressions.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Alert suppression\n * @description Generates information about alert suppressions.\n * @kind alert-suppression\n * @id py/alert-suppression\n */\n\n// Import CodeQL alert suppression utilities\nprivate import codeql.util.suppression.AlertSuppression as AS\n// Import Python comment processing module\nprivate import semmle.python.Comment as P\n\n// Represents AST nodes with location tracking\nclass AstNode instanceof P::AstNode {\n  // Check if node matches specified location coordinates\n  predicate hasLocationInfo(\n    string file, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(file, startLine, startCol, endLine, endCol)\n  }\n\n  // Return string representation of the node\n  string toString() { result = super.toString() }\n}\n\n// Represents single-line comments with location tracking\nclass SingleLineComment instanceof P::Comment {\n  // Check if comment matches specified location coordinates\n  predicate hasLocationInfo(\n    string file, int startLine, int startCol, int endLine, int endCol\n  ) {\n    super.getLocation().hasLocationInfo(file, startLine, startCol, endLine, endCol)\n  }\n\n  // Retrieve comment text content\n  string getText() { result = super.getContents() }\n\n  // Return string representation of the comment\n  string toString() { result = super.toString() }\n}\n\n// Generate suppression relationships using AS template\nimport AS::Make<AstNode, SingleLineComment>\n\n/**\n * A noqa suppression comment. Both pylint and pyflakes respect this, so lgtm ought to too.\n */\n// Represents noqa-style suppression comments\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  // Initialize by matching noqa comment pattern\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  // Return suppression annotation identifier\n  override string getAnnotation() { result = \"lgtm\" }\n\n  // Define code coverage scope for this suppression\n  override predicate covers(\n    string file, int startLine, int startCol, int endLine, int endCol\n  ) {\n    // Extract location details from comment\n    exists(int commentStartLine, int commentEndLine, int commentEndCol |\n      this.hasLocationInfo(file, commentStartLine, _, commentEndLine, commentEndCol) and\n      // Enforce line-start position and match boundaries\n      startLine = commentStartLine and\n      endLine = commentEndLine and\n      startCol = 1 and\n      endCol = commentEndCol\n    )\n  }\n}"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-complex-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：This query identifies Python `__del__` methods with high cyclomatic complexity.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly complex `__del__` method\n * @description This query identifies Python `__del__` methods with high cyclomatic complexity.\n *              The `__del__` method is invoked during object destruction, a process that\n *              can occur at unpredictable times or may be skipped entirely in certain scenarios.\n *              Methods with high complexity in `__del__` can cause performance issues and\n *              unpredictable behavior during garbage collection. Best practice suggests\n *              keeping these methods as straightforward as possible.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python\n\nfrom FunctionValue destructorMethod\nwhere\n  exists(ClassValue containingClass |\n    // The method must be the __del__ method of a class\n    containingClass.declaredAttribute(\"__del__\") = destructorMethod and\n    // The method's cyclomatic complexity must exceed the threshold of 3\n    destructorMethod.getScope().getMetrics().getCyclomaticComplexity() > 3\n  )\nselect destructorMethod, \"Overly complex '__del__' method.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak Elliptic Curve Cryptography Usage\n * @description Identifies cryptographic operations that employ elliptic curve algorithms\n *              which are either unapproved or deemed cryptographically insecure, potentially\n *              leading to security weaknesses in the implementation.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm cryptoImplementation, string securityWarning, string curveName\nwhere\n  // Define the set of cryptographically secure elliptic curve algorithms\n  exists(string secureCurve |\n    secureCurve = [\n      \"SECP256R1\", \"PRIME256V1\", // P-256 curves\n      \"SECP384R1\",              // P-384 curve\n      \"SECP521R1\",              // P-521 curve\n      \"ED25519\",                // Ed25519 curve\n      \"X25519\"                  // X25519 curve\n    ]\n  |\n    // Retrieve the curve name from the cryptographic implementation\n_______________ // 补全条件\n    (\n      // First condition: Unrecognized curve algorithm detected\n      curveName = unknownAlgorithm() and\n      securityWarning = \"Use of unrecognized curve algorithm.\"\n      or\n      // Second condition: Recognized but cryptographically weak curve algorithm detected\n      curveName != unknownAlgorithm() and\n      not curveName = secureCurve and\n      securityWarning = \"Use of weak curve algorithm \" + curveName + \".\"\n    )\n  )\nselect cryptoImplementation, securityWarning",
    "output": "curveName = cryptoImplementation.getCurveName() and"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/diagnostics/extraction-warnings]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and reports extraction warnings encountered during Python code analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python extraction warnings\n * @description Identifies and reports extraction warnings encountered during Python code analysis.\n * @kind diagnostic\n * @id py/diagnostics/extraction-warnings\n */\n\nimport python\n\n/**\n * Computes the SARIF severity level for extraction warnings.\n * \n * Reference: https://docs.oasis-open.org/sarif/sarif/v2.1.0/csprd01/sarif-v2.1.0-csprd01.html#_Toc10541338\n */\nint getWarningSeverity() { result = 1 }\n\n// SARIF severity levels:\n// - \"error\": Critical issue causing analysis failure or invalid results\n// - \"warning\": Non-critical issue where analysis may be partial but results remain valid\n//\n// SyntaxErrors are classified as warnings because:\n// 1. Parsing issues may cause incomplete analysis\n// 2. Results remain valid for unaffected code regions\n\nfrom SyntaxError error, File affectedFile\nwhere \n  // Ensure file has valid relative path in project context\n  affectedFile = error.getFile() and\n  exists(affectedFile.getRelativePath())\nselect \n  error, \n  \"Extraction failed in \" + affectedFile + \" with error \" + error.getMessage(),\n  getWarningSeverity()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Statement has no effect\n * @description Identifies statements that do not produce any effect during program execution\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/ineffectual-statement\n */\n\nimport python\n\n// Helper predicates for descriptor analysis\n/**\n * Determines if an attribute is properly defined by checking its source and target classes\n */\npredicate attribute_is_well_defined(Attribute attr, ClassValue sourceClass, ClassValue attrClass) {\n  exists(string attrName | attr.getName() = attrName |\n    attr.getObject().pointsTo().getClass() = sourceClass and\n    sourceClass.attr(attrName).getClass() = attrClass\n  )\n}\n\n/**\n * Checks if a descriptor type access results in side effects\n */\n_______________ // 补全条件\n  descriptorClass.isDescriptorType() and\n  // All descriptor accesses technically have side effects, but some represent missing calls\n  // which we want to treat as having no effect\n  not descriptorClass = ClassValue::functionType() and\n  not descriptorClass = ClassValue::staticmethod() and\n  not descriptorClass = ClassValue::classmethod()\n}\n\n/**\n * Conservatively assesses whether an attribute access might produce side effects\n */\npredicate attribute_has_side_effects(Attribute attr) {\n  exists(ClassValue attrClass |\n    attribute_is_well_defined(attr, _, attrClass) and\n    descriptor_type_has_side_effects(attrClass)\n  )\n}\n\n/**\n * Identifies attributes that could potentially have side effects\n */\npredicate attribute_might_have_side_effects(Attribute attr) {\n  // Case 1: Attribute is not well-defined or doesn't point to a concrete value\n  (not attribute_is_well_defined(attr, _, _) and not attr.pointsTo(_))\n  or\n  // Case 2: Attribute is already identified as having side effects\n  attribute_has_side_effects(attr)\n}\n\n// Helper predicates for binary operator analysis\n/**\n * Retrieves the special method name for comparison or binary operators\n */\nprivate string get_special_method_name() {\n  result = any(Cmpop comparisonOp).getSpecialMethodName()\n  or\n  result = any(BinaryExpr binaryExpr).getOp().getSpecialMethodName()\n}\n\n/**\n * Identifies binary expressions that utilize special operator methods\n */\npragma[nomagic]\nprivate predicate is_special_binary_operator(\n  BinaryExpr binaryExpr, Expr subExpr, ClassValue exprClass, string methodName\n) {\n  methodName = get_special_method_name() and\n  subExpr = binaryExpr.getLeft() and\n  methodName = binaryExpr.getOp().getSpecialMethodName() and\n  subExpr.pointsTo().getClass() = exprClass\n}\n\n/**\n * Identifies comparison expressions that utilize special operator methods\n */\npragma[nomagic]\nprivate predicate is_special_comparison_operator(Compare binaryExpr, Expr subExpr, ClassValue exprClass, string methodName) {\n  exists(Cmpop op |\n    binaryExpr.compares(subExpr, op, _) and\n    methodName = op.getSpecialMethodName()\n  ) and\n  subExpr.pointsTo().getClass() = exprClass\n}\n\n/**\n * Binary operators with side effects are uncommon, so we assume they have no side effects\n * unless we have evidence to the contrary\n */\npredicate binary_expr_has_side_effects(Expr binaryExpr) {\n  exists(Expr subExpr, ClassValue exprClass, string methodName |\n    // Handle binary operator special methods\n    is_special_binary_operator(binaryExpr, subExpr, exprClass, methodName)\n    or\n    // Handle comparison operator special methods\n    is_special_comparison_operator(binaryExpr, subExpr, exprClass, methodName)\n  |\n    methodName = get_special_method_name() and\n    exprClass.hasAttribute(methodName) and\n    // Exclude inherited methods from built-in types (except object)\n    not exists(ClassValue declaring |\n      declaring.declaresAttribute(methodName) and\n      declaring = exprClass.getASuperType() and\n      declaring.isBuiltin() and\n      not declaring = ClassValue::object()\n    )\n  )\n}\n\n// Helper predicates for special context analysis\n/**\n * Determines if a file is a Jupyter/IPython notebook\n */\npredicate file_is_notebook(File notebookFile) {\n  exists(Comment comment | comment.getLocation().getFile() = notebookFile |\n    comment.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\n/**\n * Checks if an expression is within a Jupyter/IPython notebook\n */\npredicate expression_in_notebook(Expr expr) { \n  file_is_notebook(expr.getScope().(Module).getFile()) \n}\n\n/**\n * Retrieves the FunctionValue for unittest.TestCase's assertRaises method\n */\nFunctionValue get_unittest_assert_raises_method() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\n/**\n * Checks if an expression is within a `with` block that tests exception raising\n */\npredicate expression_in_raises_test(Expr expr) {\n  exists(With withStmt |\n    withStmt.contains(expr) and\n    withStmt.getContextExpr() = get_unittest_assert_raises_method().getACall().getNode()\n  )\n}\n\n/**\n * Checks if an expression is a Python 2 print statement (e.g., print >> out, ...)\n */\npredicate is_python2_print_expression(Expr expr) {\n  // Handle print >> syntax\n  (expr.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n   expr.(BinaryExpr).getOp() instanceof RShift)\n  or\n  // Recursively handle first element in tuple\n  is_python2_print_expression(expr.(Tuple).getElt(0))\n}\n\n// Main analysis predicate\n/**\n * Determines if an expression has no effect by checking various conditions\n */\npredicate expression_is_ineffectual(Expr expr) {\n  // String literals can serve as comments\n  not expr instanceof StringLiteral and\n  not expr.hasSideEffects() and\n  // Check all sub-expressions\n  forall(Expr subExpr | subExpr = expr.getASubExpression*() |\n    not binary_expr_has_side_effects(subExpr) and\n    not attribute_might_have_side_effects(subExpr)\n  ) and\n  // Exclude special cases\n  not expression_in_notebook(expr) and\n  not expression_in_raises_test(expr) and\n  not is_python2_print_expression(expr)\n}\n\n// Query execution\nfrom ExprStmt stmt\nwhere expression_is_ineffectual(stmt.getValue())\nselect stmt, \"This statement has no effect.\"",
    "output": "predicate descriptor_type_has_side_effects(ClassValue descriptorClass) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of insecure SSL/TLS version\n * @description Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.\n * @id py/insecure-protocol\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @tags security\n *       external/cwe/cwe-327\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n// Represents protocol configuration nodes in data flow\nclass ProtocolConfigNode extends DataFlow::Node {\n  ProtocolConfigNode() {\n    // Case 1: Unsafe connection with context\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    // Case 2: Unsafe connection without context\n    unsafe_connection_creation_without_context(this, _)\n    or\n    // Case 3: Unsafe context creation\n    unsafe_context_creation(this, _)\n  }\n\n  // Get the associated function node\n  DataFlow::Node getFunctionNode() { result = this.(DataFlow::CallCfgNode).getFunction() }\n}\n\n// Represents nodes that can be named (functions or attributes)\nclass NameableNode extends DataFlow::Node {\n  NameableNode() {\n    // Function node from protocol configuration\n    this = any(ProtocolConfigNode pc).getFunctionNode()\n    or\n    // Attribute reference on nameable objects\n    this = any(NameableNode attr).(DataFlow::AttrRef).getObject()\n  }\n}\n\n// Get the qualified name of a nameable node\nstring getNodeName(NameableNode node) {\n  // Direct name for simple nodes\n  result = node.asExpr().(Name).getId()\n  or\n  // Composed name for attribute references\n  exists(DataFlow::AttrRef attr | attr = node |\n    result = getNodeName(attr.getObject()) + \".\" + attr.getAttributeName()\n  )\n}\n\n// Get descriptive name for protocol configuration\nstring getConfigDescription(ProtocolConfigNode config) {\n  // Call-based configuration\n  exists(DataFlow::CallCfgNode call | call = config |\n    result = \"call to \" + getNodeName(call.getFunction())\n_______________ // 补全条件\n  or\n  // Non-call configuration\n  not config instanceof DataFlow::CallCfgNode and\n  not config instanceof ContextCreation and\n  result = \"context modification\"\n}\n\n// Get verb based on configuration specificity\nstring getVerb(boolean isSpecific) {\n  isSpecific = true and result = \"specified\"\n  or\n  isSpecific = false and result = \"allowed\"\n}\n\n// Main query detecting insecure protocol usage\nfrom\n  DataFlow::Node connNode, string version, ProtocolConfigNode configNode,\n  boolean isSpecific\nwhere\n  // Case 1: Context-based insecure connection\n  unsafe_connection_creation_with_context(connNode, version, configNode, isSpecific)\n  or\n  // Case 2: Direct insecure connection\n  unsafe_connection_creation_without_context(connNode, version) and\n  configNode = connNode and\n  isSpecific = true\n  or\n  // Case 3: Insecure context creation\n  unsafe_context_creation(configNode, version) and\n  connNode = configNode and\n  isSpecific = true\nselect connNode,\n  \"Insecure SSL/TLS protocol version \" + version + \" \" + getVerb(isSpecific) + \" by $@.\",\n  configNode, getConfigDescription(configNode)",
    "output": ")"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Nested loops with same variable\n * @description Identifies nested loops where the same variable is used as the iteration target\n *              in both loops, making the control flow confusing and error-prone.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\n// Checks if a for loop uses a specific variable as its iteration target\npredicate usesVariableAsTarget(For loop, Variable targetVar) {\n  loop.getTarget().defines(targetVar)\n}\n\n// Identifies problematic nested loops where:\n// 1. Inner loop is directly nested within outer loop's body\n// 2. Both loops use the same iteration variable\n// 3. The variable is referenced in the outer loop (excluding inner loop scope)\npredicate hasNestedLoopWithSameVariable(For innerLoop, For outerLoop, Variable sharedVar) {\n_______________ // 补全条件\n  outerLoop.getBody().contains(innerLoop) and\n  // Verify both loops use the same variable as iteration target\n  usesVariableAsTarget(innerLoop, sharedVar) and\n  usesVariableAsTarget(outerLoop, sharedVar) and\n  // Confirm the variable is actually used in the outer loop scope\n  exists(Name nameNode |\n    nameNode.uses(sharedVar) and\n    outerLoop.contains(nameNode) and\n    not innerLoop.contains(nameNode)\n  )\n}\n\n// Main query: Find all instances of problematic nested loops\nfrom For innerLoop, For outerLoop, Variable sharedVar\nwhere hasNestedLoopWithSameVariable(innerLoop, outerLoop, sharedVar)\nselect innerLoop, \n  \"Nested for loop reuses iteration variable '\" + sharedVar.getId() + \n  \"' from enclosing $@.\", \n  outerLoop, \n  \"outer for loop\"",
    "output": "// Ensure inner loop is contained within outer loop's body (not else clause)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/mismatched-multiple-assignment]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Assigning multiple variables without ensuring that you define a",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Mismatch in multiple assignment\n * @description Assigning multiple variables without ensuring that you define a\n *              value for each variable causes an exception at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       types\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mismatched-multiple-assignment\n */\n\nimport python\n\n// 计算表达式列表中的元素总数\nprivate int countExprListItems(ExprList expressionList) { \n  result = count(expressionList.getAnItem()) \n}\n\n// 检测赋值语句中左右两侧元素数量不匹配的情况\npredicate mismatchedAssignment(Assign assignStmt, int lhsCount, int rhsCount, Location loc, string containerKind) {\n  exists(ExprList leftExprList | \n    // 获取赋值左侧的元组或列表元素\n    (\n      assignStmt.getATarget().(Tuple).getElts() = leftExprList or\n      assignStmt.getATarget().(List).getElts() = leftExprList\n    ) and\n    lhsCount = countExprListItems(leftExprList) and\n    // 处理右侧为显式容器的情况\n    (exists(ExprList rightExprList |\n      (\n        assignStmt.getValue().(Tuple).getElts() = rightExprList and containerKind = \"tuple\"\n        or\n        assignStmt.getValue().(List).getElts() = rightExprList and containerKind = \"list\"\n      ) and\n      loc = assignStmt.getValue().getLocation() and\n      rhsCount = countExprListItems(rightExprList) and\n      lhsCount != rhsCount and\n      // 确保两侧均无星号表达式\n      not exists(Starred s | \n        leftExprList.getAnItem() = s or rightExprList.getAnItem() = s\n      )\n    )\n    or\n    // 处理右侧为元组值引用的情况\n    exists(TupleValue tupleValue, AstNode originNode |\n      assignStmt.getValue().pointsTo(tupleValue, originNode) and\n      containerKind = \"tuple\" and\n      loc = originNode.getLocation() and\n      rhsCount = tupleValue.length() and\n      lhsCount != rhsCount and\n      // 确保左侧无星号表达式\n      not leftExprList.getAnItem() instanceof Starred\n    ))\n  )\n}\n\n// 查询所有存在元素数量不匹配的赋值语句\nfrom Assign assignStmt, int lhsCount, int rhsCount, Location loc, string containerKind\nwhere mismatchedAssignment(assignStmt, lhsCount, rhsCount, loc, containerKind)\nselect assignStmt,\n  \"Left hand side of assignment contains \" + lhsCount +\n    \" variables, but right hand side is a $@ of length \" + rhsCount + \".\", \n  loc, containerKind"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/string-concatenation-in-loop]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects inefficient string concatenation inside loops that causes quadratic performance.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name String concatenation in loop\n * @description Detects inefficient string concatenation inside loops that causes quadratic performance.\n * @kind problem\n * @tags efficiency\n *       maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision low\n * @id py/string-concatenation-in-loop\n */\n\nimport python\n\n/**\n * Identifies inefficient string concatenation operations within loops.\n * This predicate detects binary addition expressions where strings are concatenated\n * in a loop context, causing quadratic performance degradation due to repeated\n * string recreation. The pattern involves a variable being repeatedly updated\n * through concatenation operations.\n */\npredicate string_concat_in_loop(BinaryExpr concatOp) {\n  // Verify the operation is string concatenation (addition)\n  concatOp.getOp() instanceof Add and\n  \n  // Analyze SSA variables involved in the concatenation\n  exists(SsaVariable originalVar, SsaVariable updatedVar, BinaryExprNode opNode |\n    // Connect the expression node to our binary operation\n    opNode.getNode() = concatOp and \n    // Establish SSA variable relationship: originalVar is the source definition\n    originalVar = updatedVar.getAnUltimateDefinition()\n  |\n    // Verify the operation defines the target string variable\n    originalVar.getDefinition().(DefinitionNode).getValue() = opNode and\n    // Confirm the variable is used as an operand in concatenation\n    updatedVar.getAUse() = opNode.getAnOperand() and\n    // Ensure at least one operand is of string type\n    opNode.getAnOperand().pointsTo().getClass() = ClassValue::str()\n  )\n}\n\n// Identify and report inefficient string concatenation patterns\nfrom BinaryExpr concatOp, Stmt loopContainer\nwhere \n  // Match inefficient concatenation pattern\n  string_concat_in_loop(concatOp) and\n  // Find the loop statement containing this operation\n  loopContainer.getASubExpression() = concatOp\n// Generate alert with performance impact information\nselect loopContainer, \"String concatenation in a loop is quadratic in the number of iterations.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Redundant comparison\n * @description Identifies comparisons whose outcome is predetermined by preceding control flow conditions.\n * @kind problem\n * @tags useless-code\n *       external/cwe/cwe-561\n *       external/cwe/cwe-570\n_______________ // 补全条件\n * @problem.severity warning\n * @sub-severity high\n * @precision high\n * @id py/redundant-comparison\n */\n\nimport python\nimport semmle.python.Comparisons\n\n/**\n * Determines if a comparison expression has a complex structure involving multiple operators.\n * This includes chained comparisons (e.g., 'a < x < y') or nested unary expressions.\n */\nprivate predicate hasComplexStructure(Expr comparisonExpr) {\n  // Check for multiple comparison operators (chained comparisons)\n  exists(comparisonExpr.(Compare).getOp(1))\n  or\n  // Recursively check operands of unary expressions for complexity\n  hasComplexStructure(comparisonExpr.(UnaryExpr).getOperand())\n}\n\n/**\n * Identifies redundant comparisons where a more restrictive condition already determines\n * the outcome in the same control block. Excludes complex chained comparisons due to\n * potential flow analysis limitations.\n */\nprivate predicate isRedundantComparison(Comparison comparisonNode, ComparisonControlBlock controlBlock, boolean evaluationResult) {\n  // Control block implies the comparison result\n  controlBlock.impliesThat(comparisonNode.getBasicBlock(), comparisonNode, evaluationResult) and\n  // Exclude complex structures that might affect flow analysis accuracy\n  not hasComplexStructure(controlBlock.getTest().getNode())\n}\n\n/**\n * Associates AST nodes containing redundant comparisons with their controlling conditions.\n */\nprivate predicate hasRedundantComparisonInAST(AstNode astNode, AstNode conditionNode, boolean evaluationResult) {\n  exists(Comparison comparisonNode, ConditionBlock conditionBlock |\n    // Map AST node to comparison node\n    comparisonNode.getNode() = astNode and\n    // Map condition to last node in condition block\n    conditionBlock.getLastNode().getNode() = conditionNode and\n    // Verify redundancy relationship\n    isRedundantComparison(comparisonNode, conditionBlock, evaluationResult)\n  )\n}\n\nfrom Expr testExpression, Expr relatedCondition, boolean evaluatesToTrue\nwhere\n  // Identify redundant tests excluding child nodes\n  hasRedundantComparisonInAST(testExpression, relatedCondition, evaluatesToTrue) and \n  not hasRedundantComparisonInAST(testExpression.getAChildNode+(), relatedCondition, _)\nselect testExpression, \"Test is always \" + evaluatesToTrue + \", because of $@.\", relatedCondition, \"this condition\"",
    "output": "*       external/cwe/cwe-571"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Similar function detection\n * @description Identifies functions with high similarity suggesting potential code duplication. \n *              Consider refactoring by extracting common logic into shared functions.\n *              (Note: Current implementation returns no results - logic placeholder)\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision very-high\n * @id py/similar-function\n */\n\nimport python\n\n// Define analysis elements:\n// - Primary function under examination\n// - Secondary function for comparison\n// - Diagnostic message describing similarity\nfrom Function funcA, \n     Function funcB, \n     string similarityMessage\n_______________ // 补全条件\nwhere none()\n// Output analysis results with function details\nselect funcA, \n       similarityMessage, \n       funcB, \n       funcB.getName()",
    "output": "// Apply filtering conditions (currently inactive)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/percent-format/wrong-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies string formatting operations where the count of conversion specifiers",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Wrong number of arguments for format\n * @description Identifies string formatting operations where the count of conversion specifiers \n *              in the format string doesn't match the count of values to be formatted. \n *              This results in a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/percent-format/wrong-arguments\n */\n\nimport python\nimport semmle.python.strings\n\n/**\n * Detects string formatting operations utilizing the % operator.\n * @param binExpr - The binary expression containing the formatting operation\n * @param fmtString - The format string literal\n * @param argsToFormat - The values to be formatted\n * @param argsSource - The AST node where the arguments originate\n */\npredicate detectPercentFormatOperation(BinaryExpr binExpr, StringLiteral fmtString, Value argsToFormat, AstNode argsSource) {\n  // Confirm the operator is modulo (%)\n  binExpr.getOp() instanceof Mod and\n  exists(Context evalContext |\n    // Trace the left operand to the format string literal\n    binExpr.getLeft().pointsTo(evalContext, _, fmtString) and\n    // Trace the right operand to the argument values\n    binExpr.getRight().pointsTo(evalContext, argsToFormat, argsSource)\n  )\n}\n\n/**\n * Computes the effective length of the argument sequence.\n * @param argsValue - The value representing the arguments\n * @return The count of arguments in the sequence\n */\nint computeArgumentCount(Value argsValue) {\n  // Process tuple arguments (excluding starred expressions)\n  exists(Tuple argTuple | argTuple.pointsTo(argsValue, _) |\n    result = strictcount(argTuple.getAnElt()) and\n    not argTuple.getAnElt() instanceof Starred\n  )\n  or\n  // Process single literal arguments\n  exists(ImmutableLiteral singleLiteral | singleLiteral.getLiteralValue() = argsValue | result = 1)\n}\n\nfrom\n  BinaryExpr formatOperation, StringLiteral formatLiteral, Value formattingArguments, \n  int providedArgCount, int expectedFormatCount, AstNode argumentsSource, string pluralSuffix\nwhere\n  // Identify percent-style formatting operations\n  detectPercentFormatOperation(formatOperation, formatLiteral, formattingArguments, argumentsSource) and\n  // Calculate the number of provided arguments\n  providedArgCount = computeArgumentCount(formattingArguments) and\n  // Count the format specifiers in the string\n  expectedFormatCount = format_items(formatLiteral) and\n  // Detect mismatch between argument count and format specifiers\n  providedArgCount != expectedFormatCount and\n  // Generate appropriate message suffix based on argument count\n  (if providedArgCount = 1 then pluralSuffix = \" is provided.\" else pluralSuffix = \" are provided.\")\nselect formatOperation,\n  \"Incorrect number of $@ for string formatting. Format $@ expects \" + \n    expectedFormatCount.toString() + \" values, but \" + providedArgCount.toString() + pluralSuffix, \n  argumentsSource, \"arguments\", formatLiteral, formatLiteral.getText()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/summary/lines-of-code]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Calculates the aggregate count of Python code lines throughout the entire",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Total lines of Python code in the database\n * @description Calculates the aggregate count of Python code lines throughout the entire\n *   database, encompassing both external libraries and auto-generated files. This metric\n *   serves as an indicator of the database's overall code volume. The calculation\n *   specifically excludes blank lines and comments, focusing solely on actual code lines.\n * @kind metric\n * @tags summary\n *       telemetry\n * @id py/summary/lines-of-code\n */\n\nimport python // Import the Python analysis module for code metrics extraction\n\n// Calculate the total number of Python code lines across all modules in the database\nselect sum(Module pyModule | | pyModule.getMetrics().getNumberOfLinesOfCode())\n// Explanation of components:\n// - `Module`: Represents a Python module in the analyzed codebase\n// - `pyModule`: Variable that iterates over each Python module\n// - `getMetrics()`: Retrieves the metrics object containing code statistics\n// - `getNumberOfLinesOfCode()`: Extracts the count of non-blank, non-comment code lines\n// - `sum(...)`: Aggregation function that totals the code lines from all modules"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Import shadowed by loop variable\n * @description Detects when a loop variable name conflicts with an imported module alias,\n *              potentially causing confusion or bugs by obscuring the imported identifier.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n_______________ // 补全条件\n * @id py/import-shadowed-loop-variable\n */\n\n// Import Python analysis library for examining Python code structures\nimport python\n\n// Identify loop variables that shadow imported module aliases\nfrom Variable iterationVar, Name varNameNode\nwhere \n  // Verify the variable is defined as a loop iteration target\n  exists(For loopStmt | varNameNode = loopStmt.getTarget()) and\n  // Ensure the variable definition corresponds to our loop variable\n  varNameNode.defines(iterationVar) and\n  // Check for conflicting import alias within the same scope hierarchy\n  exists(Import moduleImport, Name importAliasNode |\n    // The imported alias must match the loop variable's identifier\n    importAliasNode.getId() = iterationVar.getId() and\n    // Alias must originate from an import statement's 'as' clause\n    importAliasNode = moduleImport.getAName().getAsname() and\n    // Import must be accessible in the loop variable's scope\n    moduleImport.getScope() = iterationVar.getScope().getScope*()\n  )\n// Report the variable definition with a descriptive shadowing warning\nselect varNameNode, \"Loop variable '\" + iterationVar.getId() + \"' shadows an imported module alias.\"",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name XML内部实体扩展漏洞\n * @description 识别将用户可控输入传递给XML解析器且未限制内部实体扩展的代码路径，此类路径可能导致拒绝服务攻击。\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @id py/xml-bomb\n * @tags security\n_______________ // 补全条件\n *       external/cwe/cwe-400\n */\n\nimport python\nimport semmle.python.security.dataflow.XmlBombQuery\nimport XmlBombFlow::PathGraph\n\n// 定义数据流分析的源节点和汇节点\nfrom XmlBombFlow::PathNode sourceNode, XmlBombFlow::PathNode sinkNode\n// 验证从用户输入源到XML解析器的数据流路径是否存在\nwhere XmlBombFlow::flowPath(sourceNode, sinkNode)\n// 输出分析结果：目标位置、源头位置、目标位置及安全警告信息\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"XML解析器处理了$@，但未实施适当的实体扩展限制措施。\",\n  sourceNode.getNode(), \"用户控制的输入源\"",
    "output": "*       external/cwe/cwe-776"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description This query facilitates navigation from expression references to their corresponding source definitions in Python code.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import the core Python analysis library for source code examination\nimport python\n\n// Import the definition tracking module to trace variable, function, and class definitions\nimport analysis.DefinitionTracking\n\n// Locate expressions with position details, their associated definitions, and definition types\nfrom NiceLocationExpr referencedExpr, Definition sourceDefinition, string definitionType\n// Ensure the definition correctly corresponds to the usage and preserves type consistency\nwhere \n  sourceDefinition = definitionOf(referencedExpr, definitionType)\n// Display the reference position, definition position, and definition type for navigation purposes\nselect referencedExpr, sourceDefinition, definitionType",
    "output": "* @name Definition Navigator"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/number-of-parameters-without-default-per-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the quantity of function parameters that do not have default values.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Number of parameters without defaults\n * @description Measures the quantity of function parameters that do not have default values.\n *              Callables with numerous parameters lacking defaults might be difficult to test\n *              and comprehend, possibly suggesting a design problem.\n * @kind treemap\n * @id py/number-of-parameters-without-default-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg max\n * @tags testability\n *       complexity\n */\n\nimport python  // Import Python library for analyzing Python source code\n\n// Analysis to identify functions and compute their parameters without default values\nfrom FunctionMetrics callableMetric\nselect \n    callableMetric, \n    callableMetric.getNumberOfParametersWithoutDefault() as nonDefaultParamCount \norder by \n    nonDefaultParamCount desc\n// Results display functions ordered by the count of parameters without defaults in descending order"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Classes per file\n_______________ // 补全条件\n * @kind treemap\n * @id py/classes-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python\n\n// 计算每个Python模块文件中定义的类的数量\nfrom Module fileModule, int classCount\n\n// 统计每个模块文件内定义的类总数\nwhere classCount = count(Class definedClass | \n       definedClass.getEnclosingModule() = fileModule)\n\n// 输出结果：模块文件及其对应的类数量，按类数量降序排列\nselect fileModule, classCount order by classCount desc",
    "output": "* @description Measures the number of classes in a file"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/redundant-assignment]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects assignments where a variable is assigned to itself,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Redundant self-assignment\n * @description Detects assignments where a variable is assigned to itself,\n *              which typically indicates a coding error or useless code.\n * @kind problem\n * @tags reliability\n *       useless-code\n *       external/cwe/cwe-563\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/redundant-assignment\n */\n\nimport python\n\n// Extracts the components (left-hand side and right-hand side) from an assignment statement\npredicate extractAssignmentComponents(AssignStmt assignmentStmt, Expr leftSide, Expr rightSide) {\n  assignmentStmt.getATarget() = leftSide and assignmentStmt.getValue() = rightSide\n}\n\n// Recursively verifies if two expressions are equivalent, including nested attribute access\npredicate checkExpressionEquivalence(Expr firstExpr, Expr secondExpr) {\n  extractAssignmentComponents(_, firstExpr, secondExpr)\n  or\n  exists(Attribute firstAttr, Attribute secondAttr |\n    checkExpressionEquivalence(firstAttr, secondAttr) and\n    firstExpr = firstAttr.getObject() and\n    secondExpr = secondAttr.getObject()\n  )\n}\n\n// Determines if two expressions evaluate to the same value (either identical names or attributes)\npredicate evaluateExpressionEquality(Expr firstExpr, Expr secondExpr) {\n  areNamesIdentical(firstExpr, secondExpr) or areAttributesIdentical(firstExpr, secondExpr)\n}\n\n// Checks if a name might be undefined in an outer scope\npredicate checkOuterScopeUndefinedStatus(Name name) {\n  exists(SsaVariable var | var.getAUse().getNode() = name | var.maybeUndefined())\n}\n\n/*\n * Protection against false positives in projects offering Python 2/3 compatibility,\n * as they often contain assignments like:\n *\n * if PY2:\n *     bytes = str\n * else:\n *     bytes = bytes\n */\n\n// Verifies if a string corresponds to a built-in object name\npredicate isBuiltinIdentifier(string name) { exists(Value val | val = Value::named(name) and val.isBuiltin()) }\n\n// Determines if two names are identical and meet specific conditions\npredicate areNamesIdentical(Name firstName, Name secondName) {\n  checkExpressionEquivalence(firstName, secondName) and\n  firstName.getVariable() = secondName.getVariable() and\n  not isBuiltinIdentifier(firstName.getId()) and\n  not checkOuterScopeUndefinedStatus(secondName)\n}\n\n// Retrieves the class value of an attribute's object\nClassValue determineAttributeClass(Attribute attr) { attr.getObject().pointsTo().getClass() = result }\n\n// Checks if an attribute represents a property access\npredicate isPropertyAccess(Attribute attr) {\n  determineAttributeClass(attr).lookup(attr.getName()) instanceof PropertyValue\n}\n\n// Determines if two attributes are identical and meet specific conditions\npredicate areAttributesIdentical(Attribute firstAttr, Attribute secondAttr) {\n  checkExpressionEquivalence(firstAttr, secondAttr) and\n  firstAttr.getName() = secondAttr.getName() and\n  evaluateExpressionEquality(firstAttr.getObject(), secondAttr.getObject()) and\n  exists(determineAttributeClass(firstAttr)) and\n  not isPropertyAccess(firstAttr)\n}\n\n// Prevents interference from magic comments in analysis\npragma[nomagic]\nComment locatePyflakesDirective() { result.getText().toLowerCase().matches(\"%pyflakes%\") }\n\n// Gets the line number of a file containing a Pyflakes directive\nint getPyflakesDirectiveLine(File f) {\n  locatePyflakesDirective().getLocation().hasLocationInfo(f.getAbsolutePath(), result, _, _, _)\n}\n\n// Checks if an assignment statement is marked with a Pyflakes directive\npredicate isMarkedWithPyflakesDirective(AssignStmt assignmentStmt) {\n  exists(Location loc |\n    assignmentStmt.getLocation() = loc and\n    loc.getStartLine() = getPyflakesDirectiveLine(loc.getFile())\n  )\n}\n\n// Checks if the left-hand side attribute expression has side effects\npredicate hasLeftHandSideSideEffects(Attribute lhsAttr) {\n  exists(ClassValue cls, ClassValue superType |\n    lhsAttr.getObject().pointsTo().getClass() = cls and\n    superType = cls.getASuperType() and\n    not superType.isBuiltin()\n  |\n    superType.declaresAttribute(\"__setattr__\")\n  )\n}\n\n// Main query: Finds self-assignments without Pyflakes directives and without side effects\nfrom AssignStmt assignmentStmt, Expr leftSide, Expr rightSide\nwhere\n  extractAssignmentComponents(assignmentStmt, leftSide, rightSide) and\n  evaluateExpressionEquality(leftSide, rightSide) and\n  not isMarkedWithPyflakesDirective(assignmentStmt) and\n  not hasLeftHandSideSideEffects(leftSide)\nselect assignmentStmt, \"This assignment assigns a variable to itself.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name All Cryptographic Algorithms\n * @description Finds all potential usage of cryptographic algorithms usage using the supported libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n_______________ // 补全条件\n */\n\n// 导入Python分析框架，提供Python代码解析和分析能力\nimport python\n// 导入加密算法概念库，包含加密算法的抽象定义和识别方法\nimport experimental.cryptography.Concepts\n\n// 查询所有已识别的加密算法实例\nfrom CryptographicAlgorithm cryptoAlgo\n// 返回加密算法对象及其使用描述\nselect cryptoAlgo, \"Use of algorithm \" + cryptoAlgo.getName()",
    "output": "*       cryptography"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all cryptographic algorithm implementations and block modes across supported libraries.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name All Cryptographic Algorithms\n * @description Identifies all cryptographic algorithm implementations and block modes across supported libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python and Semmle core libraries\nimport python\nimport semmle.python.Concepts\n\n// Identify cryptographic operations and extract algorithm identifiers\nfrom Cryptography::CryptographicOperation cryptoOp, string algorithmIdentifier\nwhere \n  // Case 1: Extract algorithm name from cryptographic operation\n  algorithmIdentifier = cryptoOp.getAlgorithm().getName()\n  or\n  // Case 2: Extract block mode from cryptographic operation\n  algorithmIdentifier = cryptoOp.getBlockMode()\nselect cryptoOp, \"Use of algorithm \" + algorithmIdentifier"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/conflicting-attributes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects classes that inherit from multiple base classes where more than one base class defines the same attribute. Such conflicts can lead to unexpected behavior due to attribute resolution ambiguity.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Conflicting attributes in base classes\n * @description Detects classes that inherit from multiple base classes where more than one base class defines the same attribute. Such conflicts can lead to unexpected behavior due to attribute resolution ambiguity.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n/**\n * Determines if a Python function implementation is effectively empty.\n * A function is considered empty if its body contains only pass statements or docstrings.\n */\npredicate is_empty_implementation(PyFunctionObject func) {\n  // Verify function body contains only pass statements or docstring expressions\n  not exists(Stmt statement | statement.getScope() = func.getFunction() |\n    not statement instanceof Pass and \n    not statement.(ExprStmt).getValue() = func.getFunction().getDocString()\n  )\n}\n\n/**\n * Checks if a function explicitly invokes super() for method resolution.\n * This indicates that the function is designed to work in a multiple inheritance scenario\n * by properly calling the parent class implementation.\n */\npredicate invokes_super(FunctionObject func) {\n  // Identify super() method call pattern within function body\n  exists(Call superInvocation, Call methodInvocation, Attribute attribute, GlobalVariable superGlobal |\n    methodInvocation.getScope() = func.getFunction() and\n    methodInvocation.getFunc() = attribute and\n    attribute.getObject() = superInvocation and\n    attribute.getName() = func.getName() and\n    superInvocation.getFunc() = superGlobal.getAnAccess() and\n    superGlobal.getId() = \"super\"\n  )\n}\n\n/**\n * Identifies attribute names that are exempt from conflict detection.\n * These attributes have known patterns of usage in multiple inheritance scenarios\n * where conflicts are expected and handled appropriately.\n */\npredicate is_exempt_attribute(string attrName) {\n  /*\n   * Exemption for process_request as documented in Python's socketserver module:\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   * This attribute is intentionally overridden in multiple inheritance patterns\n   * and does not represent a problematic conflict.\n   */\n  attrName = \"process_request\"\n}\n\nfrom\n  ClassObject childClass, \n  ClassObject parentA, \n  ClassObject parentB, \n  string conflictAttrName, \n  int orderA, \n  int orderB, \n  Object attrInParentA, \n  Object attrInParentB\nwhere\n  // Establish inheritance relationships between child class and its parents\n  childClass.getBaseType(orderA) = parentA and\n  childClass.getBaseType(orderB) = parentB and\n  // Ensure distinct parent classes with ordered inheritance positions\n  orderA < orderB and\n  \n  // Identify conflicting attributes in different parent classes\n  attrInParentA = parentA.lookupAttribute(conflictAttrName) and\n  attrInParentB = parentB.lookupAttribute(conflictAttrName) and\n  attrInParentA != attrInParentB and\n  \n  // Filter out non-problematic conflicts\n  not conflictAttrName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and             // Exclude special methods\n  not is_exempt_attribute(conflictAttrName) and                // Exclude known exempt attributes\n  not childClass.declaresAttribute(conflictAttrName) and        // Ensure child doesn't override\n  not attrInParentA.overrides(attrInParentB) and               // No override relationship\n  not attrInParentB.overrides(attrInParentA) and\n  not invokes_super(attrInParentA) and                         // Skip if first parent handles resolution\n  not is_empty_implementation(attrInParentB)                    // Ignore trivial implementations in second parent\nselect childClass, \n  \"Base classes have conflicting values for attribute '\" + conflictAttrName + \"': $@ and $@.\", \n  attrInParentA, attrInParentA.toString(), \n  attrInParentB, attrInParentB.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/similar-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：There is another function that is very similar this one. Extract the common code to a common function to improve sharing.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @deprecated\n * @name Similar function\n * @description There is another function that is very similar this one. Extract the common code to a common function to improve sharing.\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision very-high\n * @id py/similar-function\n */\n\nimport python\n\n// 从函数 m, 函数 other 和字符串 message 中选择数据\nfrom Function m, Function other, string message\n// 条件为空，即不过滤任何结果\nwhere none()\n// 选择函数 m, 消息 message, 其他函数 other 以及 other 函数的名称\nselect m, message, other, other.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/conflicting-attributes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes inheriting from multiple base classes where identical attributes are defined in more than one base. This ambiguity can cause unexpected behavior during attribute resolution.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Conflicting attributes in base classes\n * @description Identifies classes inheriting from multiple base classes where identical attributes are defined in more than one base. This ambiguity can cause unexpected behavior during attribute resolution.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n// Evaluates whether a Python function contains only trivial implementation elements\npredicate is_empty_implementation(PyFunctionObject func) {\n  // Checks if function body consists solely of pass statements or docstrings\n  not exists(Stmt stmt | stmt.getScope() = func.getFunction() |\n    not stmt instanceof Pass and \n    not stmt.(ExprStmt).getValue() = func.getFunction().getDocString()\n  )\n}\n\n// Determines if a method properly utilizes super() for method resolution order\npredicate invokes_super(FunctionObject func) {\n  // Detects super() calls targeting the current method name\n  exists(Call superCall, Call methodCall, Attribute attr, GlobalVariable superVar |\n    methodCall.getScope() = func.getFunction() and\n    methodCall.getFunc() = attr and\n    attr.getObject() = superCall and\n    attr.getName() = func.getName() and\n    superCall.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/** Defines attributes excluded from conflict analysis */\npredicate is_exempt_attribute(string attrName) {\n  /*\n   * Exemption for process_request per Python socketserver documentation:\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   */\n  attrName = \"process_request\"\n}\n\nfrom\n  ClassObject derivedClass, \n  ClassObject firstBase, \n  ClassObject secondBase, \n  string conflictingAttr, \n  int idx1, \n  int idx2, \n  Object attrInFirstBase, \n  Object attrInSecondBase\nwhere\n  // Establish inheritance relationships with distinct base classes\n  derivedClass.getBaseType(idx1) = firstBase and\n  derivedClass.getBaseType(idx2) = secondBase and\n  // Ensure base classes are ordered by inheritance position\n  idx1 < idx2 and\n  // Locate identical attributes in different base classes\n  attrInFirstBase = firstBase.lookupAttribute(conflictingAttr) and\n  attrInSecondBase = secondBase.lookupAttribute(conflictingAttr) and\n  // Verify attributes are distinct objects\n  attrInFirstBase != attrInSecondBase and\n  // Exclude special double-underscore methods\n  not conflictingAttr.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  // Skip conflicts where first base handles method resolution\n  not invokes_super(attrInFirstBase) and\n  // Ignore trivial implementations in second base\n  not is_empty_implementation(attrInSecondBase) and\n  // Exclude known exempt attributes\n  not is_exempt_attribute(conflictingAttr) and\n  // Ensure no override relationship between attributes\n  not attrInFirstBase.overrides(attrInSecondBase) and\n  not attrInSecondBase.overrides(attrInFirstBase) and\n  // Confirm derived class doesn't explicitly declare attribute\n  not derivedClass.declaresAttribute(conflictingAttr)\nselect derivedClass, \n  \"Base classes have conflicting values for attribute '\" + conflictingAttr + \"': $@ and $@.\", \n  attrInFirstBase, attrInFirstBase.toString(), \n  attrInSecondBase, attrInSecondBase.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/callable-extents]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies and enumerates all callable functions in Python codebase",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @description Identifies and enumerates all callable functions in Python codebase\n * @kind metrics\n * @id py/callable-extents\n * @metricType function\n */\n\n// Import the foundational Python analysis library to access code elements\nimport python\n\n// Define the scope of analysis: all Python callable functions\nfrom Function callableObj\n\n// Output source location and the function object for each identified callable\nselect callableObj.getLocation(), callableObj"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incorrect super() first argument\n * @description Identifies super() invocations where the first parameter\n *              does not correspond to the enclosing class name. This\n *              mismatch can result in improper initialization within\n *              object inheritance hierarchies.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-687\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/super-not-enclosing-class\n */\n\nimport python  // 导入Python库，用于分析Python代码\nimport semmle.python.dataflow.new.DataFlow  // 导入数据流分析模块\nimport semmle.python.ApiGraphs  // 导入API图模块\n\n// 定义查询的输入变量：super()调用节点和封闭类的名称\nfrom DataFlow::CallCfgNode superCallNode, string enclosingClassName\nwhere\n  // 确认是对super内置函数的调用\n  superCallNode = API::builtin(\"super\").getACall()\n  and\n  // 获取包含当前调用的类名\n  enclosingClassName = superCallNode.getScope().getScope().(Class).getName()\n  and\n_______________ // 补全条件\n  exists(DataFlow::Node firstArgument |\n    firstArgument = superCallNode.getArg(0)\n    and\n    firstArgument.getALocalSource().asExpr().(Name).getId() != enclosingClassName\n  )\n// 选择问题节点并生成报告消息\nselect superCallNode.getNode(), \"First argument to super() should be \" + enclosingClassName + \".\"",
    "output": "// 验证第一个参数存在且与类名不匹配"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=UNKNOWN]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：未知任务",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * 计算指向关系分析的有效性度量。该指标通过分析\"有效分析结果\"在\"总体分析结果\"中的占比，\n * 评估分析过程的精确度和信息密度。\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\n// 识别控制流节点是否为低分析价值的谓词\npredicate isLowValueNode(ControlFlowNode cfgNode) {\n  // 以下节点类型被认为具有较低的分析价值：函数参数、名称常量或不可变字面量\n  cfgNode.getNode() instanceof Parameter\n  or\n  cfgNode instanceof NameConstantNode\n  or\n  cfgNode.getNode() instanceof ImmutableLiteral\n}\n\n// 计算指向关系分析的有效性指标\nfrom int effectiveAnalysisCount, int sourceEffectiveAnalysisCount, int totalAnalysisCount, float effectivenessMetric\nwhere\n  // 计算有效分析结果总数（排除低价值节点）\n  effectiveAnalysisCount =\n    strictcount(ControlFlowNode cfgNode, Object referencedObject, ClassObject targetClass |\n      cfgNode.refersTo(referencedObject, targetClass, _) and not isLowValueNode(cfgNode)\n    ) and\n  // 计算源文件中的有效分析结果数量\n  sourceEffectiveAnalysisCount =\n    strictcount(ControlFlowNode cfgNode, Object referencedObject, ClassObject targetClass |\n      cfgNode.refersTo(referencedObject, targetClass, _) and\n      not isLowValueNode(cfgNode) and\n      exists(cfgNode.getScope().getEnclosingModule().getFile().getRelativePath())\n    ) and\n  // 计算所有指向关系分析结果的总数\n  totalAnalysisCount =\n    strictcount(ControlFlowNode cfgNode, PointsToContext ptContext, Object referencedObject, \n      ClassObject targetClass, ControlFlowNode originalCfgNode | \n      PointsTo::points_to(cfgNode, ptContext, referencedObject, targetClass, originalCfgNode)\n    ) and\n  // 计算有效性指标：源文件有效分析结果占总体分析结果的百分比\n  effectivenessMetric = 100.0 * sourceEffectiveAnalysisCount / totalAnalysisCount\nselect effectiveAnalysisCount, sourceEffectiveAnalysisCount, totalAnalysisCount, effectivenessMetric"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-complex-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies `__del__` methods with high cyclomatic complexity.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly complex `__del__` method\n * @description Identifies `__del__` methods with high cyclomatic complexity.\n *              These special methods execute at unpredictable times during\n *              garbage collection and should remain simple to avoid performance\n *              issues and maintenance challenges.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python\n\nfrom FunctionValue delMethod\nwhere\n  exists(ClassValue cls |\n    cls.declaredAttribute(\"__del__\") = delMethod and\n    delMethod.getScope().getMetrics().getCyclomaticComplexity() > 3\n  )\nselect delMethod, \"Overly complex '__del__' method.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name First argument to super() is not enclosing class\n * @description Calling super with something other than the enclosing class may cause incorrect object initialization.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n *       external/cwe/cwe-687\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/super-not-enclosing-class\n */\n\nimport python  // 导入Python库，用于分析Python代码\nimport semmle.python.dataflow.new.DataFlow  // 导入数据流分析模块\nimport semmle.python.ApiGraphs  // 导入API图模块\n\n// 定义查询的输入变量：super()调用节点和包围类的名称\nfrom DataFlow::CallCfgNode superCallNode, string enclosingClassName\nwhere\n  // 查找对内置函数super的调用\n  superCallNode = API::builtin(\"super\").getACall() and\n  // 获取调用super()的作用域的名称（即包围类的名称）\n  enclosingClassName = superCallNode.getScope().getScope().(Class).getName() and\n_______________ // 补全条件\n  exists(DataFlow::Node firstArg |\n    firstArg = superCallNode.getArg(0) and\n    // 获取第一个参数的源表达式并检查其标识符是否与包围类名不同\n    firstArg.getALocalSource().asExpr().(Name).getId() != enclosingClassName\n  )\n// 选择调用节点并报告问题\nselect superCallNode.getNode(), \"First argument to super() should be \" + enclosingClassName + \".\"",
    "output": "// 检查第一个参数是否存在且不是当前类名"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/syntax-error]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python syntax errors that lead to runtime failures and obstruct comprehensive code analysis.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Syntax error\n * @description Detects Python syntax errors that lead to runtime failures and obstruct comprehensive code analysis.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/syntax-error\n */\n\n// Import the Python analysis module to enable code querying and syntax error detection\nimport python\n\n// Query to identify syntax issues in Python source code\nfrom SyntaxError syntaxIssue\nwhere \n  // Filter out encoding-related errors to focus on genuine syntax problems\n  not syntaxIssue instanceof EncodingError\nselect \n  syntaxIssue, \n  syntaxIssue.getMessage() + \" (in Python \" + major_version() + \").\"\n// Output the syntax error details combined with the major version of Python being analyzed"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/truncated-division]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies division operations where both operands are integers,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Integer division result truncation risk\n * @description Identifies division operations where both operands are integers,\n *              which may lead to truncated results in Python 2.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/truncated-division\n */\n\nimport python\n\n// Find division expressions with integer operands that might truncate the result\nfrom BinaryExpr divisionOperation, ControlFlowNode leftValueNode, ControlFlowNode rightValueNode\nwhere\n  // Only applicable in Python 2 (true division was introduced in later versions)\n  major_version() = 2 and\n  exists(BinaryExprNode binaryNode, Value leftIntValue, Value rightIntValue |\n    // Confirm division operator\n    binaryNode = divisionOperation.getAFlowNode() and\n    binaryNode.getNode().getOp() instanceof Div and\n    \n    // Check left operand type\n    binaryNode.getLeft().pointsTo(leftIntValue, leftValueNode) and\n    leftIntValue.getClass() = ClassValue::int_() and\n    \n    // Check right operand type\n    binaryNode.getRight().pointsTo(rightIntValue, rightValueNode) and\n    rightIntValue.getClass() = ClassValue::int_() and\n    \n    // Exclude cases where division results in no remainder (exact division)\n    not leftIntValue.(NumericValue).getIntValue() % rightIntValue.(NumericValue).getIntValue() = 0 and\n    \n    // Exclude modules that have imported future division\n    not binaryNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    \n    // Exclude explicit integer type conversions of the division result\n    not exists(CallNode intTypeConversion |\n      intTypeConversion = ClassValue::int_().getACall() and\n      intTypeConversion.getAnArg() = binaryNode\n    )\n  )\nselect divisionOperation, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftValueNode, \"left\", rightValueNode, \"right\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/call/wrong-number-class-arguments]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测类构造函数调用时参数数量不匹配的问题，当传递给类__init__方法的参数过多或过少时，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 错误的类实例化参数数量\n * @description 检测类构造函数调用时参数数量不匹配的问题，当传递给类__init__方法的参数过多或过少时，\n *              将在运行时引发TypeError异常。\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-685\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/call/wrong-number-class-arguments\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call invocation, ClassValue targetClass, string argIssue, string expected, int paramLimit, FunctionValue initializerMethod\nwhere\n  // 确定初始化方法\n  initializerMethod = get_function_or_initializer(targetClass) and\n  // 检查参数数量问题\n  (\n    // 处理参数过多的情况\n    too_many_args(invocation, targetClass, paramLimit) and\n    argIssue = \"too many arguments\" and\n    expected = \"no more than \"\n    or\n    // 处理参数过少的情况\n    too_few_args(invocation, targetClass, paramLimit) and\n    argIssue = \"too few arguments\" and\n    expected = \"no fewer than \"\n  )\nselect invocation, \"Call to $@ with \" + argIssue + \"; should be \" + expected + paramLimit.toString() + \".\", initializerMethod,\n  initializerMethod.getQualifiedName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/should-be-context-manager]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Making a class a context manager allows instances to be used in a 'with' statement.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class should be a context manager\n * @description Making a class a context manager allows instances to be used in a 'with' statement.\n *              This improves resource handling and code readability.\n * @kind problem\n * @tags maintainability\n *       readability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision medium\n * @id py/should-be-context-manager\n */\n\nimport python\n\n// 从ClassValue类中选择所有不是内建类且不是上下文管理器的类，并且存在__del__方法的类\nfrom ClassValue c\nwhere not c.isBuiltin() // 过滤掉内建类\n  and not c.isContextManager() // 过滤掉已经是上下文管理器的类\n  and exists(c.declaredAttribute(\"__del__\")) // 检查是否存在__del__方法\nselect c, // 选择符合条件的类\n  \"Class \" + c.getName() + // 获取类的名称\n    \" implements __del__ (presumably to release some resource). Consider making it a context manager.\" // 提示信息，建议将该类改为上下文管理器"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n_______________ // 补全条件\n * @description The application does not verify the JWT payload with a cryptographic secret or public key.\n * @kind problem\n * @problem.severity warning\n * @id py/jwt-missing-verification\n * @tags security\n *       experimental\n *       external/cwe/cwe-347\n */\n\n// 引入Python代码分析的基础库和安全概念模块\nimport python\nimport experimental.semmle.python.Concepts\n\n// 识别所有缺乏签名验证机制的JWT解码操作\nfrom JwtDecoding unverifiedJwtDecode\nwhere \n    // 过滤条件：确保JWT解码操作未通过密钥或公钥验证签名\n    not unverifiedJwtDecode.verifiesSignature()\nselect \n    // 结果输出：展示未经验证的JWT有效载荷及安全风险描述\n    unverifiedJwtDecode.getPayload(), \n    \"is not verified with a cryptographic secret or public key.\"",
    "output": "* @name JWT missing secret or public key verification"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/ineffectual-statement]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies statements that do not produce any effect during program execution",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Statement has no effect\n * @description Identifies statements that do not produce any effect during program execution\n * @kind problem\n * @tags maintainability\n *       useless-code\n *       external/cwe/cwe-561\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/ineffectual-statement\n */\n\nimport python\n\n/* Determines if an attribute access is well-defined by examining its source and target classes */\npredicate is_attribute_understood(Attribute attributeAccess, ClassValue sourceCls, ClassValue attrCls) {\n  exists(string attributeName | attributeAccess.getName() = attributeName |\n    attributeAccess.getObject().pointsTo().getClass() = sourceCls and\n    sourceCls.attr(attributeName).getClass() = attrCls\n  )\n}\n\n/* Checks if an attribute access could potentially cause side effects */\npredicate has_side_effecting_attr(Attribute attributeAccess) {\n  exists(ClassValue attrCls |\n    is_attribute_understood(attributeAccess, _, attrCls) and\n    is_descriptor_type_side_effecting(attrCls)\n  )\n}\n\n// Determines if an attribute access might have side effects\npredicate might_have_side_effect_attr(Attribute attributeAccess) {\n  // Case 1: Attribute is not understood or doesn't point to a concrete value\n  (not is_attribute_understood(attributeAccess, _, _) and not attributeAccess.pointsTo(_))\n  or\n  // Case 2: Attribute is already identified as having side effects\n  has_side_effecting_attr(attributeAccess)\n}\n\n// Evaluates if a descriptor type has side effects when accessed\npredicate is_descriptor_type_side_effecting(ClassValue descriptorCls) {\n  descriptorCls.isDescriptorType() and\n  // All descriptor accesses technically have side effects, but some represent missing calls\n  // which we treat as having no effect\n  not descriptorCls = ClassValue::functionType() and\n  not descriptorCls = ClassValue::staticmethod() and\n  not descriptorCls = ClassValue::classmethod()\n}\n\n/**\n * Binary operators rarely have side effects, so we assume they have no side effects\n * unless there's evidence to the contrary\n */\npredicate is_binary_side_effecting(Expr binaryExpr) {\n  exists(Expr subExpr, ClassValue exprCls, string methodName |\n    // Handle binary operator special methods\n    is_special_binary_operator(binaryExpr, subExpr, exprCls, methodName)\n    or\n    // Handle comparison operator special methods\n    is_special_comparison_operator(binaryExpr, subExpr, exprCls, methodName)\n  |\n    methodName = get_special_method_name() and\n    exprCls.hasAttribute(methodName) and\n    // Exclude inherited methods from built-in types (except object)\n    not exists(ClassValue declaring |\n      declaring.declaresAttribute(methodName) and\n      declaring = exprCls.getASuperType() and\n      declaring.isBuiltin() and\n      not declaring = ClassValue::object()\n    )\n  )\n}\n\n// Identifies binary expressions that utilize special operator methods\npragma[nomagic]\nprivate predicate is_special_binary_operator(\n  BinaryExpr binaryExpr, Expr subExpr, ClassValue exprCls, string methodName\n) {\n  methodName = get_special_method_name() and\n  subExpr = binaryExpr.getLeft() and\n  methodName = binaryExpr.getOp().getSpecialMethodName() and\n  subExpr.pointsTo().getClass() = exprCls\n}\n\n// Identifies comparison expressions that utilize special operator methods\npragma[nomagic]\nprivate predicate is_special_comparison_operator(Compare binaryExpr, Expr subExpr, ClassValue exprCls, string methodName) {\n  exists(Cmpop op |\n    binaryExpr.compares(subExpr, op, _) and\n    methodName = op.getSpecialMethodName()\n  ) and\n  subExpr.pointsTo().getClass() = exprCls\n}\n\n// Retrieves the special method name for comparison or binary operators\nprivate string get_special_method_name() {\n  result = any(Cmpop comparisonOp).getSpecialMethodName()\n  or\n  result = any(BinaryExpr binaryExpr).getOp().getSpecialMethodName()\n}\n\n// Determines if a file is a Jupyter/IPython notebook\npredicate is_notebook_file(File notebook) {\n  exists(Comment comment | comment.getLocation().getFile() = notebook |\n    comment.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\n// Checks if an expression is located within a Jupyter/IPython notebook\npredicate expr_in_notebook(Expr expr) { \n  is_notebook_file(expr.getScope().(Module).getFile()) \n}\n\n// Retrieves the FunctionValue for unittest.TestCase's assertRaises method\nFunctionValue get_assert_raises_method() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\n// Checks if an expression is within a `with` block that tests exception raising\npredicate expr_in_raises_test(Expr expr) {\n  exists(With withStatement |\n    withStatement.contains(expr) and\n    withStatement.getContextExpr() = get_assert_raises_method().getACall().getNode()\n  )\n}\n\n// Checks if an expression is a Python 2 print statement (e.g., print >> out, ...)\npredicate is_python2_print_stmt(Expr expr) {\n  // Handle print >> syntax\n  (expr.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n   expr.(BinaryExpr).getOp() instanceof RShift)\n  or\n  // Recursively handle first element in tuple\n  is_python2_print_stmt(expr.(Tuple).getElt(0))\n}\n\n// Determines if an expression has no effect\npredicate expression_has_no_effect(Expr expr) {\n  // String literals can serve as documentation\n  not expr instanceof StringLiteral and\n  not expr.hasSideEffects() and\n  // Check all sub-expressions\n  forall(Expr subExpr | subExpr = expr.getASubExpression*() |\n    not is_binary_side_effecting(subExpr) and\n    not might_have_side_effect_attr(subExpr)\n  ) and\n  // Exclude special cases\n  not expr_in_notebook(expr) and\n  not expr_in_raises_test(expr) and\n  not is_python2_print_stmt(expr)\n}\n\n// Select statements with no effect and report the issue\nfrom ExprStmt stmt\nwhere expression_has_no_effect(stmt.getValue())\nselect stmt, \"This statement has no effect.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/iteration-string-and-sequence]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects loops that iterate over both string and sequence types,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Iterable can be either a string or a sequence\n * @description Detects loops that iterate over both string and sequence types, \n * which can cause hard-to-diagnose runtime errors due to inconsistent iteration behavior\n * @kind problem\n * @tags reliability\n *       maintainability\n *       non-local\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iteration-string-and-sequence\n */\n\nimport python\nimport semmle.python.filters.Tests\n\n// Identifies string types (str or Python 2 unicode)\npredicate is_string_type(Value value) {\n  value.getClass() = ClassValue::str() \n  or \n  value.getClass() = ClassValue::unicode() and major_version() = 2\n}\n\nfrom \n  For loop, \n  ControlFlowNode iterNode, \n  Value strValue, \n  Value seqValue, \n  ControlFlowNode seqOrigin,\n  ControlFlowNode strOrigin\nwhere \n  // Connect loop iterator to both string and sequence values\n  loop.getIter().getAFlowNode() = iterNode and\n  iterNode.pointsTo(strValue, strOrigin) and\n  iterNode.pointsTo(seqValue, seqOrigin) and\n  \n  // Type validation: string and non-string iterable\n  is_string_type(strValue) and\n  seqValue.getClass().isIterable() and\n  not is_string_type(seqValue) and\n  \n  // Exclude test-related code paths\n  not seqOrigin.getScope().getScope*() instanceof TestScope and\n  not strOrigin.getScope().getScope*() instanceof TestScope\nselect loop,\n  \"Iteration over $@, of class \" + seqValue.getClass().getName() + \n  \", may also iterate over $@.\",\n  seqOrigin, \"sequence\", strOrigin, \"string\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/direct-imports-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Measures the quantity of modules directly imported by each Python file.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Direct imports per file\n * @description Measures the quantity of modules directly imported by each Python file.\n *              Elevated counts may signal excessive coupling, potentially undermining modularity and maintainability.\n * @kind treemap\n * @id py/direct-imports-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg max\n * @tags modularity\n *       maintainability\n */\n\n// Leverage Python analysis framework for AST traversal and module inspection\nimport python\n\n// For each Python module, determine the count of its direct module dependencies\nfrom ModuleValue sourceModule, int importQuantity\nwhere \n  // Calculate the number of unique modules directly imported by the analyzed source module\n  importQuantity = count(ModuleValue dependency | \n                       dependency = sourceModule.getAnImportedModule())\n// Emit the source module's scope along with its corresponding direct import count\nselect sourceModule.getScope(), importQuantity"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/procedure-return-value-used]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects usage of return values from procedures (functions that return None).",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of the return value of a procedure\n * @description Detects usage of return values from procedures (functions that return None). \n *              Such usage is misleading since the returned value (None) typically has no meaningful purpose.\n * @kind problem\n * @tags maintainability\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/procedure-return-value-used\n */\n\nimport python\nimport Testing.Mox\n\n/**\n * Determines if a call expression's result is utilized in the code.\n * A call is considered used if it is part of another expression or statement\n * that expects a value, excluding certain common patterns like standalone returns.\n */\npredicate is_used(Call funcCall) {\n  // Case 1: The call is nested within another value-requiring expression\n  exists(Expr parentExpr | \n    parentExpr != funcCall and \n    parentExpr.containsInScope(funcCall) and\n    (parentExpr instanceof Call or \n     parentExpr instanceof Attribute or \n     parentExpr instanceof Subscript)\n  )\n  // Case 2: The call is a sub-expression in non-expression statements\n  or\n  exists(Stmt stmtParent |\n    funcCall = stmtParent.getASubExpression() and\n    not stmtParent instanceof ExprStmt and\n    /* Exclude single return statements (common pattern like 'def f(): return g()').\n       Also covers implicit returns in lambda functions. */\n    not (stmtParent instanceof Return and \n         strictcount(Return r | r.getScope() = stmtParent.getScope()) = 1)\n  )\n}\n\nfrom Call funcCall, FunctionValue calledFunction\nwhere\n  /* The call result is used, but the callee is a procedure */\n  is_used(funcCall) and\n  funcCall.getFunc().pointsTo(calledFunction) and\n  calledFunction.getScope().isProcedure() and\n  /* Ensure all possible callees are procedures */\n  forall(FunctionValue possibleCallee | \n    funcCall.getFunc().pointsTo(possibleCallee) | \n    possibleCallee.getScope().isProcedure()\n  ) and\n  /* Exclude Mox mock objects with `AndReturn` method */\n  not useOfMoxInModule(funcCall.getEnclosingModule())\nselect funcCall, \"The result of $@ is used even though it is always None.\", calledFunction, calledFunction.getQualifiedName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/incomplete-url-substring-sanitization]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Security checks on substrings of unparsed URLs are vulnerable to bypass",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Incomplete URL substring sanitization\n * @description Security checks on substrings of unparsed URLs are vulnerable to bypass\n * @kind problem\n * @problem.severity warning\n * @security-severity 7.8\n * @precision high\n * @id py/incomplete-url-substring-sanitization\n * @tags correctness\n *       security\n *       external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.regex\n\n// Helper function providing regex pattern for common top-level domains\nprivate string getTldPattern() { result = \"com|org|edu|gov|uk|net|io\" }\n\n// Determines if a string literal exhibits URL-like characteristics\npredicate isUrlLike(StringLiteral urlLiteral) {\n  exists(string urlText | urlText = urlLiteral.getText() |\n    urlText.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + getTldPattern() +\n        \")(:[0-9]+)?/?\")\n    or\n    urlText.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\n// Detects insecure startswith method calls for URL validation\npredicate containsUnsafeStartswith(Call methodCall, StringLiteral urlLiteral) {\n  methodCall.getFunc().(Attribute).getName() = \"startswith\" and\n  methodCall.getArg(0) = urlLiteral and\n  not urlLiteral.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n}\n\n// Detects insecure endswith method calls for URL validation\npredicate containsUnsafeEndswith(Call methodCall, StringLiteral urlLiteral) {\n  methodCall.getFunc().(Attribute).getName() = \"endswith\" and\n  methodCall.getArg(0) = urlLiteral and\n  not urlLiteral.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n}\n\n// Identifies incomplete URL sanitization operations with potential vulnerabilities\npredicate hasIncompleteUrlSanitization(Expr sanitExpr, StringLiteral urlLiteral) {\n  isUrlLike(urlLiteral) and\n  (\n    sanitExpr.(Compare).compares(urlLiteral, any(In i), _)\n    or\n    containsUnsafeStartswith(sanitExpr, urlLiteral)\n    or\n    containsUnsafeEndswith(sanitExpr, urlLiteral)\n  )\n}\n\n// Main query detecting expressions with incomplete URL substring sanitization\nfrom Expr sanitExpr, StringLiteral urlLiteral\nwhere hasIncompleteUrlSanitization(sanitExpr, urlLiteral)\nselect sanitExpr, \"The string $@ may be at an arbitrary position in the sanitized URL.\", urlLiteral,\n  urlLiteral.getText()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Backspace escape in regular expression\n * @description Identifies regular expressions using '\\b' for backspace character,\n *              which conflicts with its common usage as word boundary assertion.\n * @kind problem\n * @tags maintainability\n_______________ // 补全条件\n * @sub-severity high\n * @precision very-high\n * @id py/regex/backspace-escape\n */\n\nimport python\nimport semmle.python.regex\n\nfrom RegExp regexPattern, int backslashPos\nwhere\n  // Locate backslash escape sequence followed by 'b'\n  regexPattern.escapingChar(backslashPos) and\n  regexPattern.getChar(backslashPos + 1) = \"b\" and\n  // Validate escape sequence occurs within character class\n  exists(int charSetStart, int charSetEnd | \n    charSetStart < backslashPos and \n    charSetEnd > backslashPos and\n    regexPattern.charSet(charSetStart, charSetEnd)\n  )\nselect regexPattern, \"Backspace escape in regular expression at offset \" + backslashPos + \".\"",
    "output": "* @problem.severity recommendation"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Default Parameter Mutation Detection\n * @description Detects mutations of parameters initialized with default values, \n *              which may cause unexpected behavior due to shared mutable state \n *              across multiple function invocations.\n * @kind path-problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/modification-of-default-value\n */\n\nimport python\nimport semmle.python.functions.ModificationOfParameterWithDefault\nimport ModificationOfParameterWithDefault::Flow::PathGraph\n\nfrom\n  ModificationOfParameterWithDefault::Flow::PathNode defaultValueNode,\n  ModificationOfParameterWithDefault::Flow::PathNode modificationPoint\nwhere \n  ModificationOfParameterWithDefault::Flow::flowPath(defaultValueNode, modificationPoint)\nselect \n  modificationPoint.getNode(), \n  defaultValueNode, \n  modificationPoint, \n  \"This expression mutates a $@.\", \n  defaultValueNode.getNode(),\n_______________ // 补全条件",
    "output": "\"default value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/overly-complex-delete]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects Python classes containing destructor methods (`__del__`) with",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Overly complex `__del__` method\n * @description Detects Python classes containing destructor methods (`__del__`) with \n *              excessive cyclomatic complexity. Destructor methods in Python are executed\n *              during object cleanup, a process that can happen unpredictably or may be\n *              bypassed under certain conditions. Destructors with high complexity can\n *              lead to performance degradation and unpredictable behavior during garbage\n *              collection. It's recommended to keep these special methods as simple as possible.\n * @kind problem\n * @tags efficiency\n *       maintainability\n *       complexity\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision high\n * @id py/overly-complex-delete\n */\n\nimport python  // 导入Python分析库，用于代码分析\n\nfrom FunctionValue destructorFunc, ClassValue ownerClass\nwhere\n  // 确认该函数是类的析构方法\n  ownerClass.declaredAttribute(\"__del__\") = destructorFunc\n  and\n  // 检查析构方法的圈复杂度是否超过阈值3\n  destructorFunc.getScope().getMetrics().getCyclomaticComplexity() > 3\nselect destructorFunc, \"Overly complex '__del__' method.\"  // 选择符合条件的destructorFunc并标记为\"过于复杂的`__del__`方法\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-using-is]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects comparisons using 'is'/'is not' where equivalence differs from identity",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Comparison using 'is' when operands support `__eq__`\n * @description Detects comparisons using 'is'/'is not' where equivalence differs from identity\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/comparison-using-is\n */\n\nimport python\n\n/** Identifies comparisons using 'is'/'is not' operators between specified operands */\npredicate comparison_using_is(Compare comparison, ControlFlowNode leftNode, Cmpop operator, ControlFlowNode rightNode) {\n  exists(CompareNode flowNode | flowNode = comparison.getAFlowNode() |\n    flowNode.operands(leftNode, operator, rightNode) and\n    (operator instanceof Is or operator instanceof IsNot)\n  )\n}\n\n/**\n * @brief Determines if an expression represents a CPython-interned value\n * @param expr The expression to evaluate\n * @return true if the expression is a CPython-interned value, false otherwise\n */\nprivate predicate cpython_interned_value(Expr expr) {\n  // Check for empty string or single-character ASCII strings\n  exists(string strText | strText = expr.(StringLiteral).getText() |\n    strText.length() = 0\n    or\n    strText.length() = 1 and strText.regexpMatch(\"[U+0000-U+00ff]\")\n  )\n  // Check for integers in the range [-5, 256]\n  or\n  exists(int intValue | intValue = expr.(IntegerLiteral).getN().toInt() | -5 <= intValue and intValue <= 256)\n  // Check for empty tuples\n  or\n  exists(Tuple tuple | tuple = expr and not exists(tuple.getAnElt()))\n}\n\n/**\n * @brief Identifies non-interned literal expressions\n * @param expr The expression to evaluate\n * @return true if the expression is a non-interned literal, false otherwise\n */\npredicate uninterned_literal(Expr expr) {\n  (\n    expr instanceof StringLiteral  // String literals\n    or\n    expr instanceof IntegerLiteral  // Integer literals\n    or\n    expr instanceof FloatLiteral  // Floating-point literals\n    or\n    expr instanceof Dict  // Dictionary literals\n    or\n    expr instanceof List  // List literals\n    or\n    expr instanceof Tuple  // Tuple literals\n  ) and\n  not cpython_interned_value(expr)  // Exclude CPython-interned values\n}\n\nfrom Compare comparison, Cmpop operator, string alternative\nwhere\n  exists(ControlFlowNode leftNode, ControlFlowNode rightNode |\n    comparison_using_is(comparison, leftNode, operator, rightNode) and\n    (\n      operator instanceof Is and alternative = \"==\"\n      or\n      operator instanceof IsNot and alternative = \"!=\"\n    )\n  |\n    uninterned_literal(leftNode.getNode())  // Left operand is a non-interned literal\n    or\n    uninterned_literal(rightNode.getNode())  // Right operand is a non-interned literal\n  )\nselect comparison,\n  \"Values compared using '\" + operator.getSymbol() +\n    \"' when equivalence is not the same as identity. Use '\" + alternative + \"' instead.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Empty except\n * @description Identifies except clauses that contain only pass statements without explanatory comments\n * @kind problem\n * @tags reliability\n *       maintainability\n * @external/cwe/cwe-390\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/empty-except\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\n// 检查异常处理块是否仅包含 pass 语句\npredicate isExceptBlockEmpty(ExceptStmt handler) {\n  // 确保异常处理程序中没有非 pass 语句\n  not exists(Stmt statement | \n    statement = handler.getAStmt() and \n    not statement instanceof Pass\n  )\n}\n\n// 检查 try 语句是否没有 else 子句\npredicate hasNoElseClause(ExceptStmt handler) { \n  // 确认 try 语句不存在 else 块\n  not exists(handler.getTry().getOrelse()) \n}\n\n// 检查异常处理程序是否缺少注释\npredicate lacksComment(ExceptStmt handler) {\n  // 验证异常处理块范围内没有注释\n  not exists(Comment cmt |\n    cmt.getLocation().getFile() = handler.getLocation().getFile() and\n    cmt.getLocation().getStartLine() >= handler.getLocation().getStartLine() and\n    cmt.getLocation().getEndLine() <= handler.getBody().getLastItem().getLocation().getEndLine()\n  )\n}\n\n// 识别处理非本地控制流异常的处理器\npredicate catchesNonLocalControlFlow(ExceptStmt handler) {\n  // 检查是否处理 StopIteration 异常\n  handler.getType() = API::builtin(\"StopIteration\").getAValueReachableFromSource().asExpr()\n}\n\n// 验证 try 块中存在正常执行路径\npredicate containsNormalExecutionPath(Try tryStatement) {\n  // 查找非异常控制流转换\n  exists(ControlFlowNode predecessor, ControlFlowNode successor |\n    /* 存在有效的非异常边 */\n    predecessor.getASuccessor() = successor and\n    not predecessor.getAnExceptionalSuccessor() = successor\n  |\n    /* 后继节点不是返回节点 */\n    not exists(Scope s | s.getReturnNode() = successor) and\n    /* 前驱节点在 try 块内，后继节点在 try 块外 */\n    predecessor.getNode().getParentNode*() = tryStatement.getAStmt() and\n    not successor.getNode().getParentNode*() = tryStatement.getAStmt()\n  )\n}\n\n// 检测语句是否涉及属性访问\npredicate usesAttributeAccess(Stmt statement) {\n  // 表达式语句中的属性访问\n  statement.(ExprStmt).getValue() instanceof Attribute\n  or\n  // 通过内置函数的属性访问\n  exists(string funcName | \n    statement.(ExprStmt).getValue().(Call).getFunc().(Name).getId() = funcName |\n    funcName in [\"getattr\", \"setattr\", \"delattr\"]\n  )\n  or\n  // 属性删除操作\n  statement.(Delete).getATarget() instanceof Attribute\n}\n\n// 识别带有下标操作的语句\npredicate usesSubscriptOperation(Stmt statement) {\n  // 表达式中的下标访问\n  statement.(ExprStmt).getValue() instanceof Subscript\n  or\n  // 下标删除操作\n  statement.(Delete).getATarget() instanceof Subscript\n}\n\n// 检测特定异常的编码/解码操作\npredicate isEncodingOrDecodingOperation(Call call, Expr exceptionType) {\n  // 验证函数名称并匹配相应的异常类型\n  exists(string operation | \n_______________ // 补全条件\n    (operation = \"encode\" and\n     exceptionType = API::builtin(\"UnicodeEncodeError\").getAValueReachableFromSource().asExpr())\n    or\n    (operation = \"decode\" and\n     exceptionType = API::builtin(\"UnicodeDecodeError\").getAValueReachableFromSource().asExpr())\n  )\n}\n\n// 识别特定类型的最小异常处理器\npredicate isSimplifiedExceptionHandler(ExceptStmt handler, Stmt statement, Expr exceptionType) {\n  // 单语句 try 块与特定异常类型\n  not exists(handler.getTry().getStmt(1)) and\n  statement = handler.getTry().getStmt(0) and\n  handler.getType() = exceptionType\n}\n\n// 检测针对特定场景的专门异常处理器\npredicate isSpecializedHandler(ExceptStmt handler) {\n  // 检查有针对性的异常处理模式\n  exists(Stmt statement, Expr exceptionType | \n    isSimplifiedExceptionHandler(handler, statement, exceptionType) |\n    // 下标操作的 IndexError\n    (usesSubscriptOperation(statement) and\n     exceptionType = API::builtin(\"IndexError\").getASubclass*().getAValueReachableFromSource().asExpr())\n    or\n    // 属性访问的 AttributeError\n    (usesAttributeAccess(statement) and\n     exceptionType = API::builtin(\"AttributeError\").getAValueReachableFromSource().asExpr())\n    or\n    // 名称引用的 NameError\n    (statement.(ExprStmt).getValue() instanceof Name and\n     exceptionType = API::builtin(\"NameError\").getAValueReachableFromSource().asExpr())\n    or\n    // 编码/解码错误\n    isEncodingOrDecodingOperation(statement.(ExprStmt).getValue(), exceptionType)\n  )\n}\n\n// 识别包含 return 语句的 try 块\npredicate containsReturnStatement(Try tryStatement) {\n  exists(Return retStmt | retStmt.getParentNode*() = tryStatement)\n}\n\n// 主查询：检测有问题的空 except 块\nfrom ExceptStmt handler\nwhere\n  // 识别没有解释的空 except 块\n  isExceptBlockEmpty(handler) and\n  hasNoElseClause(handler) and\n  lacksComment(handler) and\n  // 排除非本地控制流处理器\n  not catchesNonLocalControlFlow(handler) and\n  // 排除 try-return 构造\n  not containsReturnStatement(handler.getTry()) and\n  // 验证存在正常执行路径\n  containsNormalExecutionPath(handler.getTry()) and\n  // 排除专门的异常处理器\n  not isSpecializedHandler(handler)\nselect handler, \"'except' clause does nothing but pass and there is no explanatory comment.\"",
    "output": "call.getFunc().(Attribute).getName() = operation |"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/untrusted-cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies data flow paths where untrusted user inputs are used to construct cookie values,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Untrusted Data Propagation to Cookie Construction\n * @description Identifies data flow paths where untrusted user inputs are used to construct cookie values,\n *              potentially enabling injection attacks that compromise cookie integrity.\n * @id py/untrusted-cookie-injection\n * @kind path-problem\n * @precision low\n * @problem.severity error\n * @security-severity 8.7\n * @tags security external/cwe/cwe-20\n */\n\nimport python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\nfrom \n  CookieInjectionFlow::PathNode untrustedSource, \n  CookieInjectionFlow::PathNode cookieSink, \n  int configurationId\nwhere \n  configurationId = 1 and\n  CookieInjectionFlow::flowPath(untrustedSource, cookieSink)\nselect \n  cookieSink.getNode(), \n  untrustedSource, \n  cookieSink, \n  \"Cookie value constructed from $@.\", \n  untrustedSource.getNode(), \n  \"untrusted user input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unused-parameter]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：参数已定义但未使用",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unused parameter\n * @description 参数已定义但未使用\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision medium\n * @id py/unused-parameter\n */\n\nimport python\nimport Definition\n\n// 谓词：检查参数是否未被使用\npredicate unused_parameter(FunctionValue f, LocalVariable v) {\n  // 检查变量是否是参数\n  v.isParameter() and\n  // 检查变量的作用域是否与函数的作用域相同\n  v.getScope() = f.getScope() and\n  // 检查变量名是否符合未使用变量的命名规范\n  not name_acceptable_for_unused_variable(v) and\n  // 检查变量是否没有被任何名称节点使用\n  not exists(NameNode u | u.uses(v)) and\n  // 检查变量是否没有在内部作用域中被使用\n  not exists(Name inner, LocalVariable iv |\n    inner.uses(iv) and iv.getId() = v.getId() and inner.getScope().getScope() = v.getScope()\n  )\n}\n\n// 谓词：检查函数是否是抽象函数\npredicate is_abstract(FunctionValue func) {\n  // 检查函数是否有装饰器，并且装饰器的名称匹配\"abstract\"\n  func.getScope().getADecorator().(Name).getId().matches(\"%abstract%\")\n}\n\n// 从Python函数和值中选择未使用的参数\nfrom PythonFunctionValue f, LocalVariable v\nwhere\n  // 排除self参数\n  v.getId() != \"self\" and\n  // 检查参数是否未被使用\n  unused_parameter(f, v) and\n  // 排除重写方法的情况\n  not f.isOverridingMethod() and\n  // 排除被重写的方法的情况\n  not f.isOverriddenMethod() and\n  // 排除抽象函数的情况\n  not is_abstract(f)\nselect f, \"The parameter '\" + v.getId() + \"' is never used.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Classes per file\n * @description Provides a statistical overview of class definitions across Python source files,\n *              helping identify files with high class density that may need refactoring.\n * @kind treemap\n * @id py/classes-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n * @tags maintainability\n */\n\nimport python\n\n_______________ // 补全条件\nfrom Module pyModule, int classCount\n\n// Calculate the total number of classes defined within each module\nwhere classCount = count(Class classDef | classDef.getEnclosingModule() = pyModule)\n\n// Display modules and their class counts in descending order\nselect pyModule, classCount order by classCount desc",
    "output": "// For each Python module, determine the count of contained class definitions"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/misnamed-function]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies functions that start with a capital letter and are the only such function in their file,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Misnamed function\n * @description Identifies functions that start with a capital letter and are the only such function in their file,\n *              which violates Python naming conventions.\n * @kind problem\n * @problem.severity recommendation\n * @id py/misnamed-function\n * @tags maintainability\n */\n\nimport python\n\n// Predicate to check if a function's name begins with a capital letter\npredicate isCapitalStart(Function func) {\n  // Extract the first character of the function name and verify it's uppercase\n  exists(string initialChar |\n    initialChar = func.getName().prefix(1) and\n    initialChar != initialChar.toLowerCase()\n  )\n}\n\n// Identify functions violating naming conventions\nfrom Function func\nwhere\n  // Function must be defined in source code\n  func.inSource() and\n  // Function name starts with capital letter\n  isCapitalStart(func) and\n  // No other function in the same file starts with capital letter\n  not exists(Function other |\n    // Exclude current function from comparison\n    other != func and\n    // Ensure functions are in the same file\n    other.getLocation().getFile() = func.getLocation().getFile() and\n    // Other function also violates naming convention\n    isCapitalStart(other)\n  )\nselect func, \"Function names should start in lowercase.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 重写方法签名与使用不匹配\n * @description 检测方法重写场景下，派生类方法签名与基类方法签名不一致，且调用时参数不匹配的情况，\n *              这种不匹配可能导致运行时错误或未定义行为。\n * @kind problem\n * @tags maintainability\n_______________ // 补全条件\n * @sub-severity high\n * @precision high\n * @id py/inheritance/incorrect-overridden-signature\n */\n\nimport python  // 导入Python库，用于处理Python代码的查询\nimport Expressions.CallArgs  // 导入表达式调用参数库，用于处理函数调用参数\n\nfrom Call methodCall, FunctionValue baseMethod, FunctionValue derivedMethod, string issueDescription  // 从方法调用、基类方法、派生类方法和问题描述字符串中选择数据\nwhere\n  // 基础验证：排除构造函数并确保存在重写关系\n  not baseMethod.getName() = \"__init__\" and  // 排除构造函数 '__init__'\n  derivedMethod.overrides(baseMethod) and  // 确保 'derivedMethod' 是 'baseMethod' 的重写方法\n  \n  // 调用验证：获取派生类方法的调用节点并验证参数合法性\n  methodCall = derivedMethod.getAMethodCall().getNode() and  // 获取派生类方法的调用节点\n  correct_args_if_called_as_method(methodCall, derivedMethod) and  // 验证作为方法调用时参数是否正确\n  \n  // 参数不匹配检测：检查参数数量或名称的不一致\n  (\n    // 参数数量不匹配的情况\n    (\n      arg_count(methodCall) + 1 < baseMethod.minParameters() and issueDescription = \"too few arguments\"  // 当参数数量少于最小要求时标记为\"参数过少\"\n      or\n      arg_count(methodCall) >= baseMethod.maxParameters() and issueDescription = \"too many arguments\"  // 当参数数量超过最大限制时标记为\"参数过多\"\n    )\n    or\n    // 参数名称不匹配的情况\n    exists(string parameterName |\n      methodCall.getAKeyword().getArg() = parameterName and  // 获取调用中的关键字参数名称\n      derivedMethod.getScope().getAnArg().(Name).getId() = parameterName and  // 验证派生类方法中存在该参数\n      not baseMethod.getScope().getAnArg().(Name).getId() = parameterName and  // 确认基类方法中不存在该参数\n      issueDescription = \"an argument named '\" + parameterName + \"'\"  // 标记为\"存在名为 'parameterName' 的参数\"\n    )\n  )\nselect baseMethod,  // 选择基类方法作为主要输出\n  \"Overridden method signature does not match $@, where it is passed \" + issueDescription +\n    \". Overriding method $@ matches the call.\", methodCall, \"call\", derivedMethod,  // 生成问题描述，指出签名不匹配和参数问题\n  derivedMethod.descriptiveString()  // 提供派生类方法的描述性字符串",
    "output": "* @problem.severity recommendation"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/conflicting-attributes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies classes inheriting from multiple base classes where identical attributes are defined in more than one base. This creates ambiguity in attribute resolution and may cause unexpected runtime behavior.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Conflicting attributes in base classes\n * @description Identifies classes inheriting from multiple base classes where identical attributes are defined in more than one base. This creates ambiguity in attribute resolution and may cause unexpected runtime behavior.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n// Determines if a function implementation contains only pass statements or docstrings\npredicate is_empty_implementation(PyFunctionObject func) {\n  // Checks that function body contains no meaningful statements beyond pass/docstring\n  not exists(Stmt stmt | stmt.getScope() = func.getFunction() |\n    not stmt instanceof Pass and \n    not stmt.(ExprStmt).getValue() = func.getFunction().getDocString()\n  )\n}\n\n// Verifies if a function contains explicit super() calls for method resolution\npredicate invokes_super(FunctionObject method) {\n  // Detects super() method calls matching the current function name\n  exists(Call superCall, Call methodCall, Attribute attr, GlobalVariable superVar |\n    methodCall.getScope() = method.getFunction() and\n    methodCall.getFunc() = attr and\n    attr.getObject() = superCall and\n    attr.getName() = method.getName() and\n    superCall.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/** Defines attributes exempt from conflict detection rules */\npredicate is_exempt_attribute(string attrName) {\n  /*\n   * Exemption for process_request per Python socketserver documentation:\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   */\n  attrName = \"process_request\"\n}\n\nfrom\n  ClassObject derivedClass, \n  ClassObject firstBaseClass, \n  ClassObject secondBaseClass, \n  string attrName, \n  int firstBaseIndex, \n  int secondBaseIndex, \n  Object firstBaseAttr, \n  Object secondBaseAttr\nwhere\n  // Establish inheritance hierarchy with distinct base classes\n  derivedClass.getBaseType(firstBaseIndex) = firstBaseClass and\n  derivedClass.getBaseType(secondBaseIndex) = secondBaseClass and\n  firstBaseIndex < secondBaseIndex and\n  firstBaseAttr != secondBaseAttr and\n  // Identify conflicting attributes across base classes\n  firstBaseAttr = firstBaseClass.lookupAttribute(attrName) and\n  secondBaseAttr = secondBaseClass.lookupAttribute(attrName) and\n  // Exclude special methods from analysis\n  not attrName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  // Filter cases where method resolution is properly handled\n  not invokes_super(firstBaseAttr) and\n  // Ignore trivial implementations in second base class\n  not is_empty_implementation(secondBaseAttr) and\n  // Skip known exempt attributes\n  not is_exempt_attribute(attrName) and\n  // Verify no override relationship exists between attributes\n  not firstBaseAttr.overrides(secondBaseAttr) and\n  not secondBaseAttr.overrides(firstBaseAttr) and\n  // Ensure derived class doesn't explicitly declare the attribute\n  not derivedClass.declaresAttribute(attrName)\nselect derivedClass, \n  \"Base classes have conflicting values for attribute '\" + attrName + \"': $@ and $@.\", \n  firstBaseAttr, firstBaseAttr.toString(), \n  secondBaseAttr, secondBaseAttr.toString()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type metrics\n * @description Analyzes and categorizes type annotations in Python code, providing metrics\n *              on parameter annotations, return types, and annotated assignments.\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Represents Python built-in types (e.g., int, str, bool)\nclass BuiltinPythonType extends Name {\n  BuiltinPythonType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements that can have type annotations\nnewtype ElementWithTypeAnnotation =\n  TFunctionWithReturnAnnotation(FunctionExpr funcExpr) { exists(funcExpr.getReturns()) } or\n  TParameterWithAnnotation(Parameter param) { exists(param.getAnnotation()) } or\n  TAssignmentWithAnnotation(AnnAssign assign) { exists(assign.getAnnotation()) }\n\n// Abstract base class for elements with type annotations\nabstract class AnnotatedElement extends ElementWithTypeAnnotation {\n  string toString() { result = \"AnnotatedElement\" }\n  abstract Expr getAnnotation();\n}\n\n// Function expressions with return type annotations\n_______________ // 补全条件\n  FunctionExpr funcExpr;\n\n  FunctionWithReturnAnnotation() { this = TFunctionWithReturnAnnotation(funcExpr) }\n  override Expr getAnnotation() { result = funcExpr.getReturns() }\n}\n\n// Parameters with type annotations\nclass ParameterWithAnnotation extends TParameterWithAnnotation, AnnotatedElement {\n  Parameter param;\n\n  ParameterWithAnnotation() { this = TParameterWithAnnotation(param) }\n  override Expr getAnnotation() { result = param.getAnnotation() }\n}\n\n// Assignment statements with type annotations\nclass AssignmentWithAnnotation extends TAssignmentWithAnnotation, AnnotatedElement {\n  AnnAssign assign;\n\n  AssignmentWithAnnotation() { this = TAssignmentWithAnnotation(assign) }\n  override Expr getAnnotation() { result = assign.getAnnotation() }\n}\n\n// Type classification predicates\n\n/** Holds if `typeAnnotation` is a forward-declared type (string literal). */\npredicate isForwardDeclaration(Expr typeAnnotation) { typeAnnotation instanceof StringLiteral }\n\n/** Holds if `typeAnnotation` is a complex type that may be difficult to analyze. */\npredicate isComplexType(Expr typeAnnotation) {\n  (typeAnnotation instanceof Subscript and not isOptionalType(typeAnnotation)) or\n  typeAnnotation instanceof Tuple or\n  typeAnnotation instanceof List\n}\n\n/** Holds if `typeAnnotation` is an Optional type (e.g., Optional[...]). */\npredicate isOptionalType(Subscript typeAnnotation) { typeAnnotation.getObject().(Name).getId() = \"Optional\" }\n\n/** Holds if `typeAnnotation` is a simple type (non-built-in identifier or attribute chain). */\npredicate isSimpleType(Expr typeAnnotation) {\n  (typeAnnotation instanceof Name and not typeAnnotation instanceof BuiltinPythonType) or\n  isSimpleType(typeAnnotation.(Attribute).getObject())\n}\n\n/** Holds if `typeAnnotation` is a built-in type. */\npredicate isBuiltinType(Expr typeAnnotation) { typeAnnotation instanceof BuiltinPythonType }\n\n// Helper predicates for counting different types of annotations\n\npredicate computeParameterAnnotationMetrics(\n  int totalAnnotations, int builtinTypeAnnotations, int forwardDeclarationAnnotations, \n  int simpleTypeAnnotations, int complexTypeAnnotations, int optionalTypeAnnotations\n) {\n  totalAnnotations = count(ParameterWithAnnotation parameterWithAnnotation) and\n  builtinTypeAnnotations = count(ParameterWithAnnotation parameterWithAnnotation | \n    isBuiltinType(parameterWithAnnotation.getAnnotation())) and\n  forwardDeclarationAnnotations = count(ParameterWithAnnotation parameterWithAnnotation | \n    isForwardDeclaration(parameterWithAnnotation.getAnnotation())) and\n  simpleTypeAnnotations = count(ParameterWithAnnotation parameterWithAnnotation | \n    isSimpleType(parameterWithAnnotation.getAnnotation())) and\n  complexTypeAnnotations = count(ParameterWithAnnotation parameterWithAnnotation | \n    isComplexType(parameterWithAnnotation.getAnnotation())) and\n  optionalTypeAnnotations = count(ParameterWithAnnotation parameterWithAnnotation | \n    isOptionalType(parameterWithAnnotation.getAnnotation()))\n}\n\npredicate computeReturnAnnotationMetrics(\n  int totalAnnotations, int builtinTypeAnnotations, int forwardDeclarationAnnotations, \n  int simpleTypeAnnotations, int complexTypeAnnotations, int optionalTypeAnnotations\n) {\n  totalAnnotations = count(FunctionWithReturnAnnotation functionWithAnnotation) and\n  builtinTypeAnnotations = count(FunctionWithReturnAnnotation functionWithAnnotation | \n    isBuiltinType(functionWithAnnotation.getAnnotation())) and\n  forwardDeclarationAnnotations = count(FunctionWithReturnAnnotation functionWithAnnotation | \n    isForwardDeclaration(functionWithAnnotation.getAnnotation())) and\n  simpleTypeAnnotations = count(FunctionWithReturnAnnotation functionWithAnnotation | \n    isSimpleType(functionWithAnnotation.getAnnotation())) and\n  complexTypeAnnotations = count(FunctionWithReturnAnnotation functionWithAnnotation | \n    isComplexType(functionWithAnnotation.getAnnotation())) and\n  optionalTypeAnnotations = count(FunctionWithReturnAnnotation functionWithAnnotation | \n    isOptionalType(functionWithAnnotation.getAnnotation()))\n}\n\npredicate computeAssignmentAnnotationMetrics(\n  int totalAnnotations, int builtinTypeAnnotations, int forwardDeclarationAnnotations, \n  int simpleTypeAnnotations, int complexTypeAnnotations, int optionalTypeAnnotations\n) {\n  totalAnnotations = count(AssignmentWithAnnotation assignmentWithAnnotation) and\n  builtinTypeAnnotations = count(AssignmentWithAnnotation assignmentWithAnnotation | \n    isBuiltinType(assignmentWithAnnotation.getAnnotation())) and\n  forwardDeclarationAnnotations = count(AssignmentWithAnnotation assignmentWithAnnotation | \n    isForwardDeclaration(assignmentWithAnnotation.getAnnotation())) and\n  simpleTypeAnnotations = count(AssignmentWithAnnotation assignmentWithAnnotation | \n    isSimpleType(assignmentWithAnnotation.getAnnotation())) and\n  complexTypeAnnotations = count(AssignmentWithAnnotation assignmentWithAnnotation | \n    isComplexType(assignmentWithAnnotation.getAnnotation())) and\n  optionalTypeAnnotations = count(AssignmentWithAnnotation assignmentWithAnnotation | \n    isOptionalType(assignmentWithAnnotation.getAnnotation()))\n}\n\n// Computes metrics for different categories of type annotations\npredicate computeAnnotationMetrics(\n  string annotationCategory, int totalAnnotations, int builtinTypeAnnotations, \n  int forwardDeclarationAnnotations, int simpleTypeAnnotations, int complexTypeAnnotations, \n  int optionalTypeAnnotations\n) {\n  // Parameter annotation metrics\n  (annotationCategory = \"Parameter annotation\" and\n   computeParameterAnnotationMetrics(totalAnnotations, builtinTypeAnnotations, \n                                    forwardDeclarationAnnotations, simpleTypeAnnotations, \n                                    complexTypeAnnotations, optionalTypeAnnotations))\n  or\n  // Return type annotation metrics\n  (annotationCategory = \"Return type annotation\" and\n   computeReturnAnnotationMetrics(totalAnnotations, builtinTypeAnnotations, \n                                 forwardDeclarationAnnotations, simpleTypeAnnotations, \n                                 complexTypeAnnotations, optionalTypeAnnotations))\n  or\n  // Annotated assignment metrics\n  (annotationCategory = \"Annotated assignment\" and\n   computeAssignmentAnnotationMetrics(totalAnnotations, builtinTypeAnnotations, \n                                     forwardDeclarationAnnotations, simpleTypeAnnotations, \n                                     complexTypeAnnotations, optionalTypeAnnotations))\n}\n\n// Query execution and results output\nfrom \n  string annotationCategory, int totalAnnotations, int builtinTypeAnnotations, \n  int forwardDeclarationAnnotations, int simpleTypeAnnotations, int complexTypeAnnotations, \n  int optionalTypeAnnotations\nwhere \n  computeAnnotationMetrics(annotationCategory, totalAnnotations, builtinTypeAnnotations, \n                          forwardDeclarationAnnotations, simpleTypeAnnotations, \n                          complexTypeAnnotations, optionalTypeAnnotations)\nselect \n  annotationCategory, totalAnnotations, builtinTypeAnnotations, forwardDeclarationAnnotations, \n  simpleTypeAnnotations, complexTypeAnnotations, optionalTypeAnnotations",
    "output": "class FunctionWithReturnAnnotation extends TFunctionWithReturnAnnotation, AnnotatedElement {"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/comparison-missing-self]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies comparisons where identical values are compared,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Potential missing 'self' reference in comparison\n * @description Identifies comparisons where identical values are compared, \n *              which often indicates a missing 'self' reference in class methods.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-570\n *       external/cwe/cwe-571\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/comparison-missing-self\n */\n\nimport python  // 提供Python代码的静态分析基础功能\nimport Expressions.RedundantComparison  // 专门用于识别冗余或可能有问题的比较表达式\n\nfrom RedundantComparison redundantExpr  // 从冗余比较表达式中筛选出潜在的问题代码\nwhere \n  // 检查比较表达式是否可能缺少'self'引用\n  // 这种情况通常发生在类方法中，开发者忘记使用self引用实例变量\n  redundantExpr.maybeMissingSelf()\nselect \n  redundantExpr, \n  \"Detected comparison between identical values; this may indicate a missing 'self' reference in a class method.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/historical-churn]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Number of churned lines per file, across the revision history in the database.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Churned lines per file\n * @description Number of churned lines per file, across the revision history in the database.\n * @kind treemap\n * @id py/historical-churn\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\n// Import the Python language module for code analysis\nimport python\n// Import the external Version Control System (VCS) module for change tracking\nimport external.VCS\n\n// Analyze each source module and calculate its total churn\nfrom Module sourceModule, int totalChurn\nwhere\n  // Calculate the total churn for each module by summing up changes across all commits\n  totalChurn =\n    sum(Commit revision, int changeCount |\n      // Get the churn for the current file in this commit, excluding artificial changes\n      changeCount = revision.getRecentChurnForFile(sourceModule.getFile()) and\n      not artificialChange(revision)\n    |\n      changeCount  // Accumulate the change count\n    ) and\n  // Only consider modules that have measurable lines of code\n  exists(sourceModule.getMetrics().getNumberOfLinesOfCode())\n// Select the module and its total churn, ordered by churn in descending order\nselect sourceModule, totalChurn order by totalChurn desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/inheritance/incorrect-overridden-signature]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects methods whose signatures differ from both their overridden base methods",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Mismatch between signature and use of an overridden method\n * @description Detects methods whose signatures differ from both their overridden base methods\n *              and the actual call arguments. Such mismatches can lead to runtime errors\n *              when the base method is called instead of the derived one.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity high\n * @precision high\n * @id py/inheritance/incorrect-overridden-signature\n */\n\nimport python\nimport Expressions.CallArgs\n\nfrom Call methodInvocation, FunctionValue baseFunc, FunctionValue derivedFunc, string mismatchReason\nwhere\n  // Exclude constructor methods due to special initialization behavior\n  not baseFunc.getName() = \"__init__\" and\n  \n  // Verify inheritance relationship: derivedFunc overrides baseFunc\n  derivedFunc.overrides(baseFunc) and\n  \n  // Identify the call site invoking the derived method\n  methodInvocation = derivedFunc.getAMethodCall().getNode() and\n  \n  // Confirm call arguments match derived method's signature\n  correct_args_if_called_as_method(methodInvocation, derivedFunc) and\n  \n  // Detect signature mismatches between call and base method\n  (\n    // Case 1: Insufficient arguments for base method\n    arg_count(methodInvocation) + 1 < baseFunc.minParameters() and \n    mismatchReason = \"too few arguments\"\n    \n    or\n    \n    // Case 2: Excessive arguments for base method\n    arg_count(methodInvocation) >= baseFunc.maxParameters() and \n    mismatchReason = \"too many arguments\"\n    \n    or\n    \n    // Case 3: Keyword argument present in derived but absent in base\n    exists(string keywordArgName |\n      // Keyword argument exists in method call\n      methodInvocation.getAKeyword().getArg() = keywordArgName and\n      \n      // Parameter exists in derived method's signature\n      derivedFunc.getScope().getAnArg().(Name).getId() = keywordArgName and\n      \n      // Parameter missing from base method's signature\n      not baseFunc.getScope().getAnArg().(Name).getId() = keywordArgName and\n      \n      // Format mismatch description with parameter name\n      mismatchReason = \"an argument named '\" + keywordArgName + \"'\"\n    )\n  )\nselect baseFunc,\n  \"Overridden method signature does not match $@, where it is passed \" + mismatchReason +\n    \". Overriding method $@ matches the call.\", methodInvocation, \"call\", derivedFunc,\n  derivedFunc.descriptiveString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all cryptographic algorithm implementations across supported libraries.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name All Cryptographic Algorithms\n * @description Identifies all cryptographic algorithm implementations across supported libraries.\n * @kind problem\n * @id py/quantum-readiness/cbom/classic-model/all-cryptographic-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python and Semmle core libraries\nimport python\nimport semmle.python.Concepts\n\n// Identify cryptographic operations and extract algorithm identifiers\nfrom Cryptography::CryptographicOperation cryptoOp, string algorithmName\nwhere \n  // Extract algorithm name from cryptographic operation\n  (algorithmName = cryptoOp.getAlgorithm().getName())\n  or\n  // Extract block mode from cryptographic operation\n  (algorithmName = cryptoOp.getBlockMode())\nselect cryptoOp, \"Use of algorithm \" + algorithmName"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Symmetric Encryption Algorithms Detection\n * @description Detects symmetric encryption algorithm usage in Python codebases\n_______________ // 补全条件\n * @kind problem\n * @id py/quantum-readiness/cbom/symmetric-encryption-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricEncryptionAlgorithm symmetricAlgo\nselect symmetricAlgo, \"Use of algorithm \" + symmetricAlgo.getEncryptionName()",
    "output": "*              through supported cryptographic libraries."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/missing-docstring]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Public classes, functions, or methods without docstrings reduce code maintainability.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Missing docstring\n * @description Public classes, functions, or methods without docstrings reduce code maintainability.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @precision medium\n * @id py/missing-docstring\n */\n\n/*\n * Note: The 'medium' precision reflects the imprecision in the underlying rule.\n * The requirement for a docstring often depends on the intended audience.\n */\n\nimport python\n\n// Determines if a scope requires a docstring\npredicate requires_docstring(Scope currentScope) {\n  currentScope.isPublic() and\n  (\n    not currentScope instanceof Function\n    or\n    function_requires_docstring(currentScope)\n  )\n}\n\n// Determines if a function requires a docstring\npredicate function_requires_docstring(Function functionObj) {\n  functionObj.getName() != \"lambda\" and\n  (functionObj.getMetrics().getNumberOfLinesOfCode() - count(functionObj.getADecorator())) > 2 and\n  not exists(PythonPropertyObject propertyObj |\n    propertyObj.getGetter().getFunction() = functionObj or\n    propertyObj.getSetter().getFunction() = functionObj\n  ) and\n  not exists(FunctionValue overridingFunction, FunctionValue baseFunction | \n    overridingFunction.overrides(baseFunction) and overridingFunction.getScope() = functionObj |\n    not function_requires_docstring(baseFunction.getScope())\n  )\n}\n\n// Returns the type of a scope (Module, Class, or Function)\nstring get_scope_type(Scope currentScope) {\n  result = \"Module\" and currentScope instanceof Module and not currentScope.(Module).isPackage()\n  or\n  result = \"Class\" and currentScope instanceof Class\n  or\n  result = \"Function\" and currentScope instanceof Function\n}\n\n// Select scopes requiring docstrings but missing them\nfrom Scope currentScope\nwhere requires_docstring(currentScope) and not exists(currentScope.getDocString())\nselect currentScope, get_scope_type(currentScope) + \" \" + currentScope.getName() + \" does not have a docstring.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use iteration count at least 100k to prevent brute force attacks\n * @description Identifies key derivation functions with inadequate iteration counts.\n_______________ // 补全条件\n * a sufficiently high iteration count (at least 100,000) must be used to mitigate\n * brute force attack risks.\n *\n * This query flags two potential security issues:\n * 1. Iteration counts explicitly configured below the recommended threshold\n * 2. Iteration counts that cannot be determined through static analysis\n * \n * Note: This query uses a threshold of 10,000 iterations, which may be lower than\n * the 100,000 mentioned in the description. Adjust according to your security requirements.\n * \n * @kind problem\n * @id py/kdf-low-iteration-count\n * @problem.severity error\n * @precision high\n */\n\n// Import standard Python analysis library\nimport python\n// Import experimental cryptography concepts for key derivation operations\nimport experimental.cryptography.Concepts\n// Import utility functions for cryptography analysis, aliased as CryptoUtils\nprivate import experimental.cryptography.utils.Utils as CryptoUtils\n\n// Identify key derivation operations with potentially insecure iteration configurations\nfrom KeyDerivationOperation kdfOperation, string alertMessage, DataFlow::Node iterationCountSource\nwhere\n  // Focus on key derivation functions that require iteration parameter configuration\n  kdfOperation.requiresIteration() and\n  // Locate the source node providing the iteration count value\n  iterationCountSource = kdfOperation.getIterationSizeSrc() and\n  (\n    // Scenario 1: Detect explicitly set iteration counts below security threshold\n    exists(iterationCountSource.asExpr().(IntegerLiteral).getValue()) and\n    iterationCountSource.asExpr().(IntegerLiteral).getValue() < 10000 and\n    alertMessage = \"Inadequate iteration count detected. \"\n    // Scenario 2: Flag iteration counts that cannot be statically validated\n    or\n    not exists(iterationCountSource.asExpr().(IntegerLiteral).getValue()) and\n    alertMessage = \"Unable to statically verify iteration count. \"\n  )\nselect \n  // Report the key derivation operation with appropriate security alert\n  kdfOperation, alertMessage + \"Minimum secure iteration count is 10000. Configuration source: $@\",\n  iterationCountSource.asExpr(), iterationCountSource.asExpr().toString()",
    "output": "* When deriving cryptographic keys from user-provided inputs (e.g., passwords),"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Computes and displays the total line count for each Python module in the codebase.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Python Module Line Count Analysis\n * @description Computes and displays the total line count for each Python module in the codebase.\n * @kind treemap\n * @id py/lines-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg sum max\n */\n\nimport python // Import Python module for code analysis capabilities\n\n// Define source variable representing Python modules\nfrom Module pythonModule\n// Filter modules that have line metrics available\nwhere exists(pythonModule.getMetrics().getNumberOfLines())\n// Output the module and its line count, sorted by line count in descending order\nselect pythonModule, pythonModule.getMetrics().getNumberOfLines() as totalLines \norder by totalLines desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Detects asymmetric encryption padding methods that are considered\n * cryptographically insecure or not explicitly recognized as secure\n * by established security guidelines. This check specifically filters out\n * approved padding techniques (OAEP, KEM, PSS) and highlights\n * any other padding methods as potential security risks.\n * @id py/weak-asymmetric-padding\n * @kind problem\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n_______________ // 补全条件\nstring approvedPaddingSchemes() {\n  result = [\"OAEP\", \"KEM\", \"PSS\"]\n}\n\n// Find all asymmetric padding implementations and check if they use approved schemes\nfrom AsymmetricPadding paddingImpl, string schemeName\nwhere\n  // Extract the name of the padding scheme from the implementation\n  schemeName = paddingImpl.getPaddingName()\n  // Filter out implementations that use approved padding schemes\n  and schemeName != approvedPaddingSchemes()\nselect paddingImpl, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + schemeName",
    "output": "// List of cryptographically secure padding schemes that are considered safe"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Importing value of mutable attribute\n * @description Detects direct imports of mutable attribute values, which can cause inconsistencies\n *              because local copies won't reflect subsequent changes in the global state.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity high\n * @precision medium\n * @id py/import-of-mutable-attribute\n_______________ // 补全条件\n\n// Import necessary Python libraries and test filters\nimport python\nimport semmle.python.filters.Tests\n\n// Identify cases where a mutable attribute is imported and then modified\nfrom ImportMember importedMember, ModuleValue sourceModule, AttrNode attrAssignment, string attrName\nwhere\n  // Verify the imported module matches the source module and the names match\n  sourceModule.importedAs(importedMember.getModule().(ImportExpr).getImportedModuleName()) and\n  importedMember.getName() = attrName and\n  \n  // Check scope conditions: attribute modified in function, imported at module level\n  attrAssignment.getScope() instanceof Function and\n  not importedMember.getScope() instanceof Function and\n  \n  // Verify this is a store operation and the attribute points to the imported module\n  attrAssignment.isStore() and\n  attrAssignment.getObject(attrName).pointsTo(sourceModule) and\n  \n  // Ensure import and modification are in different modules and not in test code\n  not importedMember.getEnclosingModule() = attrAssignment.getScope().getEnclosingModule() and\n  not attrAssignment.getScope().getScope*() instanceof TestScope\nselect importedMember,\n  \"Importing the value of '\" + attrName +\n    \"' from $@ means that any change made to $@ will not be observed locally.\", sourceModule,\n  \"module \" + sourceModule.getName(), attrAssignment, sourceModule.getName() + \".\" + attrAssignment.getName()",
    "output": "*/"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-elliptic-curve]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies cryptographic operations using elliptic curve algorithms that are",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak elliptic curve\n * @description Identifies cryptographic operations using elliptic curve algorithms that are\n *              either unrecognized or considered weak based on security standards.\n * @id py/weak-elliptic-curve\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define a list of approved secure elliptic curves based on security standards\nstring approvedSecureCurve() {\n  result = [\"SECP256R1\", \"PRIME256V1\", // P-256 curves\n            \"SECP384R1\",              // P-384 curve\n            \"SECP521R1\",              // P-521 curve\n            \"ED25519\",                // Ed25519 curve\n            \"X25519\"]                 // X25519 curve\n}\n\nfrom EllipticCurveAlgorithm ellipticCurveOperation, string securityWarning\nwhere\n  // Extract the curve name from the elliptic curve operation\n  exists(string curveName |\n    curveName = ellipticCurveOperation.getCurveName() and\n    (\n      // Check for unrecognized curve algorithms\n      curveName = unknownAlgorithm() and\n      securityWarning = \"Use of unrecognized curve algorithm.\"\n      or\n      // Check for recognized but weak curve algorithms\n      curveName != unknownAlgorithm() and\n      not curveName = approvedSecureCurve() and\n      securityWarning = \"Use of weak curve algorithm \" + curveName + \".\"\n    )\n  )\nselect ellipticCurveOperation, securityWarning"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/authenticated-encryption-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all authenticated encryption implementations within supported cryptographic libraries",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Authenticated Encryption Algorithms\n * @description Identifies all authenticated encryption implementations within supported cryptographic libraries\n * @kind problem\n * @id py/quantum-readiness/cbom/authenticated-encryption-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python analysis framework\nimport python\n\n// Import experimental cryptography concepts for encryption analysis\nimport experimental.cryptography.Concepts\n\n// Target authenticated encryption algorithm implementations\nfrom AuthenticatedEncryptionAlgorithm encryptionScheme\n\n// Generate alert for detected algorithm with implementation details\nselect encryptionScheme, \"Algorithm implementation detected: \" + encryptionScheme.getAuthticatedEncryptionName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-hashes]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies the usage of cryptographic hash algorithms that are either unapproved or considered weak for security-sensitive applications.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak cryptographic hash algorithms detection\n * @description Identifies the usage of cryptographic hash algorithms that are either unapproved or considered weak for security-sensitive applications.\n * @id py/weak-hashes\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\n// Import required Python analysis libraries and experimental cryptography concepts\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify weak hash algorithm usage and generate corresponding security warnings\nfrom HashAlgorithm hashUsage, string hashAlgorithmName, string warningMessage\nwhere\n  // Extract the algorithm name from the hash operation\n  hashAlgorithmName = hashUsage.getHashName() and\n  \n  // Filter out cryptographically strong hash algorithms\n  not hashAlgorithmName = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  \n  // Generate appropriate security warning based on algorithm recognition status\n  (\n    // Case 1: Algorithm is recognized but not approved for secure use\n    hashAlgorithmName != \"\" and\n    warningMessage = \"Use of unapproved hash algorithm or API \" + hashAlgorithmName + \".\"\n  )\n  or\n  (\n    // Case 2: Algorithm is not recognized, potentially indicating a custom or obscure implementation\n    hashAlgorithmName = \"\" and\n    warningMessage = \"Use of unrecognized hash algorithm.\"\n  )\nselect hashUsage, warningMessage"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Classes per file\n * @description Statistical analysis of class distribution across Python source files\n * @kind treemap\n * @id py/classes-per-file\n * @treemap.warnOn highValues\n * @metricType file\n_______________ // 补全条件\n * @tags maintainability\n */\n\nimport python\n\n// For each Python module, calculate and store its class definition count\nfrom Module moduleFile, int classCount\n\n// The class count is derived from all class definitions within the module\nwhere classCount = count(Class classDef | classDef.getEnclosingModule() = moduleFile)\n\n// Display results with modules having the most classes listed first\nselect moduleFile, classCount order by classCount desc",
    "output": "* @metricAggregate avg sum max"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Points-to analysis failure for expressions\n * @description Identifies expressions that cannot be resolved to any object reference,\n *              which impedes type inference and static analysis effectiveness.\n * @kind problem\n * @id py/points-to-failure\n_______________ // 补全条件\n * @tags debug\n * @deprecated\n */\n\n// Import Python analysis framework\nimport python\n\n// Find expressions lacking object references in their control flow nodes\nfrom Expr problematicExpr\nwhere \n  // Verify existence of control flow nodes associated with this expression\n  exists(ControlFlowNode flowNode | \n    // Link expression to its corresponding control flow node\n    flowNode = problematicExpr.getAFlowNode() and\n    // Confirm the control flow node fails to reference any concrete object\n    not flowNode.refersTo(_)\n  )\n// Output the problematic expression with diagnostic message\nselect problematicExpr, \"Expression does not 'point-to' any object.\"",
    "output": "* @problem.severity info"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects cookie construction using untrusted user input,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cookie Construction from User-Supplied Input\n * @description Detects cookie construction using untrusted user input,\n *              which may enable Cookie Poisoning attacks.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// Import core Python analysis libraries\nimport python\n\n// Import specialized cookie injection detection modules\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Import path graph representation for data flow tracking\nimport CookieInjectionFlow::PathGraph\n\n// Define path nodes for tainted input sources and cookie construction sinks\nfrom CookieInjectionFlow::PathNode untrustedInputSource, \n     CookieInjectionFlow::PathNode cookieConstructionSink\n// Ensure data flows from untrusted source to cookie sink\nwhere CookieInjectionFlow::flowPath(untrustedInputSource, cookieConstructionSink)\n// Report results with sink location, source node, path details, and descriptive message\nselect cookieConstructionSink.getNode(), \n       untrustedInputSource, \n       cookieConstructionSink, \n       \"Cookie is constructed from a $@.\", \n       untrustedInputSource.getNode(),\n       \"user-supplied input\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/afferent-coupling-per-class]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Quantifies the number of external classes that depend on each subject class.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Class Dependency Inflow Analysis\n * @description Quantifies the number of external classes that depend on each subject class.\n *              Higher values indicate classes with greater incoming dependencies, which impacts\n *              modularity and increases the risk of changes causing ripple effects throughout the codebase.\n * @kind treemap\n * @id py/afferent-coupling-per-class\n * @treemap.warnOn highValues\n * @metricType reftype\n * @metricAggregate avg max\n * @tags changeability\n *       modularity\n */\n\nimport python\n\n// Analyze classes and their inbound dependency metrics\nfrom ClassMetrics subjectClass, int dependencyCount\nwhere \n  // Calculate the afferent coupling (incoming dependencies) for each class\n  dependencyCount = subjectClass.getAfferentCoupling() and\n  // Ensure the dependency count is measurable (not null)\n  exists(dependencyCount)\n  \n// Select each class with its corresponding dependency count,\n// ordered from highest to lowest to identify highly coupled components\nselect subjectClass, \n       dependencyCount \norder by dependencyCount desc"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Timing attack against secret\n * @description Identifies verification routines that don't operate in constant time when processing secret values,\n *              which could create timing attack vectors exposing sensitive information.\n * @kind path-problem\n * @problem.severity error\n * @precision low\n * @id py/possible-timing-attack-sensitive-info\n * @tags security\n *       external/cwe/cwe-208\n *       experimental\n */\n\n// Import core Python language analysis modules\nimport python\n// Import data flow analysis framework\nimport semmle.python.dataflow.new.DataFlow\n// Import taint propagation capabilities\nimport semmle.python.dataflow.new.TaintTracking\n// Import experimental timing attack detection utilities\nimport experimental.semmle.python.security.TimingAttack\n\n/**\n * Configuration for tracking confidential data flow to non-constant-time comparison operations.\n * This module helps identify timing vulnerabilities by analyzing how sensitive data moves through the code.\n */\nprivate module ConfidentialDataFlowConfig implements DataFlow::ConfigSig {\n  // Define origins: nodes representing sources of confidential data\n  predicate isSource(DataFlow::Node secretOrigin) { secretOrigin instanceof SecretSource }\n\n  // Define targets: nodes representing comparison operations vulnerable to timing attacks\n  predicate isSink(DataFlow::Node vulnerableComparison) { vulnerableComparison instanceof NonConstantTimeComparisonSink }\n\n  // Enable differential observation mode for thorough analysis\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// Establish global taint tracking using the confidential data flow configuration\nmodule ConfidentialDataFlowTracking = TaintTracking::Global<ConfidentialDataFlowConfig>;\n\n// Import path visualization module for representing data flow paths\nimport ConfidentialDataFlowTracking::PathGraph\n\n// Main query to detect timing attack vulnerability paths\nfrom\n  ConfidentialDataFlowTracking::PathNode secretOrigin,     // Starting point of the secret data\n  ConfidentialDataFlowTracking::PathNode vulnerableComparison  // Vulnerable comparison operation\nwhere \n  // Ensure there's a data flow path from the secret source to the vulnerable comparison\n  ConfidentialDataFlowTracking::flowPath(secretOrigin, vulnerableComparison)\nselect \n  vulnerableComparison.getNode(),  // Location where the vulnerability is manifested\n  secretOrigin,                    // Origin point of the data flow\n_______________ // 补全条件\n  \"Timing attack against $@ verification.\", // Security warning message\n  secretOrigin.getNode(),          // Reference point for the warning context\n  \"client-provided secret\"         // Description of the sensitive data source",
    "output": "vulnerableComparison,            // End point of the data flow"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/weak-asymmetric-key-gen-size]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：* Detects cryptographic implementations generating asymmetric keys",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Weak asymmetric key generation (key size < 2048 bits)\n * @description\n * Detects cryptographic implementations generating asymmetric keys\n * with insufficient bit length vulnerable to brute-force attacks.\n * Keys below 2048 bits are considered weak for most asymmetric algorithms.\n * @id py/weak-asymmetric-key-gen-size\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-326\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Identify weak asymmetric key generation operations\nfrom AsymmetricKeyGen keyGenOp, DataFlow::Node sizeConfigNode, int keyBitLength, string algoName\nwhere\n  // Extract configured key size in bits\n  keyBitLength = keyGenOp.getKeySizeInBits(sizeConfigNode) and\n  // Retrieve cryptographic algorithm identifier\n  algoName = keyGenOp.getAlgorithm().getName() and\n  // Verify key meets minimum security threshold\n  keyBitLength < 2048 and\n  // Exclude elliptic curve algorithms (different security model)\n  not isEllipticCurveAlgorithm(algoName, _)\n// Report findings with configuration context\nselect keyGenOp,\n  \"Weak asymmetric key size (\" + keyBitLength.toString() + \" bits) for algorithm \" +\n    algoName + \" configured at $@\", sizeConfigNode, sizeConfigNode.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/command-line-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects execution of system commands that incorporate user-controlled input,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Uncontrolled command line\n * @description Detects execution of system commands that incorporate user-controlled input,\n *              which could allow attackers to inject malicious commands.\n * @kind path-problem\n * @problem.severity error\n * @security-severity 9.8\n * @sub-severity high\n * @precision high\n * @id py/command-line-injection\n * @tags correctness\n *       security\n *       external/cwe/cwe-078\n *       external/cwe/cwe-088\n */\n\n// Import core Python language analysis capabilities\nimport python\n\n// Import specialized security dataflow framework for detecting command injection vulnerabilities\nimport semmle.python.security.dataflow.CommandInjectionQuery\n\n// Import path graph utilities for visualizing data flow paths from source to sink\nimport CommandInjectionFlow::PathGraph\n\n// Identify potential command injection by tracking data flow from malicious input to command execution\nfrom CommandInjectionFlow::PathNode maliciousInput, CommandInjectionFlow::PathNode commandExecutionTarget\n// Ensure there exists a complete data flow path connecting the malicious input source to the command execution target\nwhere CommandInjectionFlow::flowPath(maliciousInput, commandExecutionTarget)\n// Report the vulnerability with detailed context about the data flow\nselect commandExecutionTarget.getNode(), maliciousInput, commandExecutionTarget, \n       \"This command line depends on a $@.\", maliciousInput.getNode(),\n       \"user-provided value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/lines-of-comments-in-files]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Counts the total lines of comments in each Python file (including docstrings,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Lines of comments in files\n * @kind treemap\n * @description Counts the total lines of comments in each Python file (including docstrings,\n *              while excluding lines containing only code or blank lines).\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg sum max\n * @id py/lines-of-comments-in-files\n */\n\nimport python // Import Python module for analyzing Python code structure\n\n// Extract each Python module and calculate the combined count of comment and docstring lines\nfrom Module pyModule, int commentLineCount\nwhere\n  // Compute the total comment lines for the file (including both regular comments and docstrings)\n  commentLineCount = \n    pyModule.getMetrics().getNumberOfLinesOfComments() + \n    pyModule.getMetrics().getNumberOfLinesOfDocStrings()\nselect pyModule, commentLineCount order by commentLineCount desc"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/polynomial-redos]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：检测具有多项式时间复杂度的正则表达式在处理特定输入时可能导致拒绝服务攻击",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 多项式时间复杂度正则表达式应用于不可控数据\n * @description 检测具有多项式时间复杂度的正则表达式在处理特定输入时可能导致拒绝服务攻击\n * @kind path-problem\n * @problem.severity warning\n * @security-severity 7.5\n * @precision high\n * @id py/polynomial-redos\n * @tags security\n *       external/cwe/cwe-1333\n *       external/cwe/cwe-730\n *       external/cwe/cwe-400\n */\n\n// 引入Python代码分析基础模块\nimport python\n// 引入多项式ReDoS安全查询模块，用于识别正则表达式中的复杂度问题\nimport semmle.python.security.dataflow.PolynomialReDoSQuery\n// 引入路径图模块，用于追踪数据流传播路径\nimport PolynomialReDoSFlow::PathGraph\n\n// 定义查询所需的核心变量和组件\nfrom\n  // 存在回溯问题的正则表达式，可能导致性能问题\n  PolynomialBackTrackingTerm vulnerableRegex,\n  // 数据流接收器节点，即正则表达式使用点\n  Sink sinkNode,\n  // 数据流路径的起点，通常为用户输入源\n  PolynomialReDoSFlow::PathNode sourceNode,\n  // 数据流路径的终点，即数据到达接收器的位置\n  PolynomialReDoSFlow::PathNode destinationNode\n// 设置查询条件，确保数据流路径存在且关联到易受攻击的正则表达式\nwhere\n  // 检查从源节点到目标节点的完整数据流路径\n  PolynomialReDoSFlow::flowPath(sourceNode, destinationNode) and\n  // 确认目标节点与接收器节点对应\n  sinkNode = destinationNode.getNode() and\n  // 从接收器节点中提取存在回溯问题的正则表达式\n  vulnerableRegex = sinkNode.getABacktrackingTerm()\n// 输出查询结果，包含路径信息和警告消息\nselect\n  // 高亮显示接收器节点位置\n  sinkNode.getHighlight(), sourceNode, destinationNode,\n  // 构建详细的警告消息，说明潜在的性能风险\n  \"This $@ that depends on a $@ may run slow on strings \" + vulnerableRegex.getPrefixMessage() +\n    \"with many repetitions of '\" + vulnerableRegex.getPumpString() + \"'.\",\n  // 标识易受攻击的正则表达式对象\n  vulnerableRegex, \"regular expression\",\n  // 标识用户提供的输入源\n  sourceNode.getNode(), \"user-provided value\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent equality and hashing\n * @description Detects classes violating object contract by implementing equality without hashability (or vice versa)\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-581\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/equals-hash-mismatch\n */\n\nimport python\n\n// Determines if a class implements equality comparison methods (__eq__ or __cmp__)\nCallableValue has_equality_method(ClassValue classObj, string methodName) {\n  (\n    methodName = \"__eq__\"\n    or\n    major_version() = 2 and methodName = \"__cmp__\"\n  ) and\n  result = classObj.declaredAttribute(methodName)\n}\n\n// Checks if a class implements a specific method (equality or hash)\nCallableValue get_implemented_method(ClassValue classObj, string methodName) {\n  result = has_equality_method(classObj, methodName)\n  or\n  result = classObj.declaredAttribute(\"__hash__\") and methodName = \"__hash__\"\n}\n\n// Identifies which critical method is missing in a class\nstring get_missing_method(ClassValue classObj) {\n  // Case 1: Missing equality methods\n  not exists(has_equality_method(classObj, _)) and\n  (\n    result = \"__eq__\" and major_version() = 3\n    or\n    major_version() = 2 and result = \"__eq__ or __cmp__\"\n  )\n  or\n  // Case 2: Missing hash method (Python 2 specific)\n  not classObj.declaresAttribute(result) and result = \"__hash__\" and major_version() = 2\n}\n\n/** Indicates if a class is explicitly marked as unhashable */\n_______________ // 补全条件\n  classObj.lookup(\"__hash__\") = Value::named(\"None\")\n  or\n  classObj.lookup(\"__hash__\").(CallableValue).neverReturns()\n}\n\n// Detects classes violating the hash contract by implementing only one of equality/hash\npredicate has_hash_contract_violation(ClassValue classObj, string existingMethod, string missingMethod, CallableValue implementedMethod) {\n  not is_unhashable(classObj) and\n  missingMethod = get_missing_method(classObj) and\n  implementedMethod = get_implemented_method(classObj, existingMethod) and\n  not classObj.failedInference(_)\n}\n\nfrom ClassValue cls, string existingMethod, string missingMethod, CallableValue implementedMethod\nwhere\n  has_hash_contract_violation(cls, existingMethod, missingMethod, implementedMethod) and\n  exists(cls.getScope()) // Filter results from source code\nselect implementedMethod, \"Class $@ implements \" + existingMethod + \" but does not define \" + missingMethod + \".\", cls,\n  cls.getName()",
    "output": "predicate is_unhashable(ClassValue classObj) {"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Lines of comments in files\n * @kind treemap\n * @description Calculates the total comment lines across Python files, encompassing both\n *              standard comments and docstrings, while excluding pure code lines and blank spaces.\n * @treemap.warnOn lowValues\n * @metricType file\n * @metricAggregate avg sum max\n * @id py/lines-of-comments-in-files\n */\n\nimport python // Import the Python module for analyzing Python source code\n\n// Select each Python module and compute its total comment lines (comments + docstrings)\n_______________ // 补全条件\nwhere\n  // Calculate the sum of comment lines and docstring lines for the module\n  totalCommentLines = \n    fileModule.getMetrics().getNumberOfLinesOfComments() + \n    fileModule.getMetrics().getNumberOfLinesOfDocStrings()\nselect fileModule, totalCommentLines order by totalCommentLines desc // Return modules with their comment counts, sorted in descending order",
    "output": "from Module fileModule, int totalCommentLines"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unresolved import\n * @description Identifies imports that cannot be resolved and are not handled by fallback mechanisms\n *              or OS-specific guards. These unresolved imports may impact analysis coverage and accuracy.\n * @kind problem\n * @problem.severity info\n * @id py/import-failure\n */\n\n// Import the Python analysis library\nimport python\n\n/**\n * Retrieves a fallback import expression for a specified primary import.\n * The fallback import is located in an alternative branch (else or except) of a conditional or try-except block.\n */\nImportExpr findFallbackImport(ImportExpr mainImport) {\n  // Ensure aliases exist for both the main and fallback imports\n  exists(Alias mainAlias, Alias fallbackAlias |\n    // Main alias mapping\n    (mainAlias.getValue() = mainImport or mainAlias.getValue().(ImportMember).getModule() = mainImport) and\n    // Fallback alias mapping\n    (fallbackAlias.getValue() = result or fallbackAlias.getValue().(ImportMember).getModule() = result) and\n    (\n      // Verify imports are in different branches of conditional statements\n      exists(If conditionalStmt | \n        (conditionalStmt.getBody().contains(mainImport) and conditionalStmt.getOrelse().contains(result)) or\n        (conditionalStmt.getBody().contains(result) and conditionalStmt.getOrelse().contains(mainImport))\n      )\n      or\n      // Verify imports are in try and except blocks\n      exists(Try exceptionHandler | \n        (exceptionHandler.getBody().contains(mainImport) and exceptionHandler.getAHandler().contains(result)) or\n        (exceptionHandler.getBody().contains(result) and exceptionHandler.getAHandler().contains(mainImport))\n      )\n    )\n  )\n}\n\n/**\n * Determines the operating system associated with an import expression, if it is OS-specific.\n_______________ // 补全条件\n */\nstring identifyOSSpecificImport(ImportExpr importExpr) {\n  // Check if the imported module name matches OS-specific patterns\n  exists(string moduleName | moduleName = importExpr.getImportedModuleName() |\n    // Java-related imports\n    (moduleName.matches(\"org.python.%\") or moduleName.matches(\"java.%\")) and result = \"java\"\n    or\n    // macOS imports\n    moduleName.matches(\"Carbon.%\") and result = \"darwin\"\n    or\n    // Windows imports\n    result = \"win32\" and\n    (\n      moduleName = \"_winapi\" or\n      moduleName = \"_win32api\" or\n      moduleName = \"_winreg\" or\n      moduleName = \"nt\" or\n      moduleName.matches(\"win32%\") or\n      moduleName = \"ntpath\"\n    )\n    or\n    // Linux imports\n    result = \"linux2\" and\n    (moduleName = \"posix\" or moduleName = \"posixpath\")\n    or\n    // Unsupported platform imports\n    result = \"unsupported\" and\n    (moduleName = \"__pypy__\" or moduleName = \"ce\" or moduleName.matches(\"riscos%\"))\n  )\n}\n\n/**\n * Retrieves the current platform identifier from the Python interpreter's sys.platform.\n */\nstring getRuntimePlatform() { \n  py_flags_versioned(\"sys.platform\", result, major_version().toString()) \n}\n\n/**\n * Determines if an unresolved import is acceptable (i.e., not a problem) because it has a fallback alternative\n * or is intended for a different operating system than the current one.\n */\npredicate isUnresolvedImportAcceptable(ImportExpr importExpr) {\n  // Check if there's a working fallback import\n  findFallbackImport(importExpr).refersTo(_)\n  or\n  // Check if the import is OS-specific but not for the current OS\n  identifyOSSpecificImport(importExpr) != getRuntimePlatform()\n}\n\n/**\n * Represents a control flow node that checks the Python interpreter version.\n * These nodes are used to conditionally import modules based on version compatibility.\n */\nclass PythonVersionCheckNode extends ControlFlowNode {\n  PythonVersionCheckNode() {\n    exists(string versionAttr |\n      versionAttr.matches(\"%version%\") and\n      this.(CompareNode).getAChild+().pointsTo(Module::named(\"sys\").attr(versionAttr))\n    )\n  }\n\n  override string toString() { result = \"VersionTest\" }\n}\n\n/**\n * Represents a condition block that guards code based on the Python interpreter version.\n * This helps identify version-specific imports that should not be flagged as unresolved.\n */\nclass VersionGuardBlock extends ConditionBlock {\n  VersionGuardBlock() { this.getLastNode() instanceof PythonVersionCheckNode }\n}\n\n// Main query: Find unresolved imports that should be flagged as issues\nfrom ImportExpr unresolvedImport\nwhere\n  not unresolvedImport.refersTo(_) and // Import cannot be resolved\n  exists(Context context | context.appliesTo(unresolvedImport.getAFlowNode())) and // Import is in a valid context\n  not isUnresolvedImportAcceptable(unresolvedImport) and // Import is not allowed to fail\n  not exists(VersionGuardBlock versionGuard | versionGuard.controls(unresolvedImport.getAFlowNode().getBasicBlock(), _)) // Not protected by version guard\nselect unresolvedImport, \"Unable to resolve import of '\" + unresolvedImport.getImportedModuleName() + \"'.\"",
    "output": "* Returns the OS name (e.g., \"win32\", \"darwin\") for known OS-specific modules, otherwise no result."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name 未知初始化向量 (IV) 或 nonce\n * @description 检测块密码模式中未配置初始化向量或nonce的情况，这些参数可能来源于不可信的输入\n * @kind problem\n * @id py/quantum-readiness/cbom/unkown-iv-sources\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// 检索所有块密码模式实例\nfrom BlockMode blockCipherModeInstance\n// 筛选未配置IV或nonce参数的实例\n_______________ // 补全条件\n// 输出存在安全风险的块模式实例及描述\nselect blockCipherModeInstance, \"Block mode with unknown IV or Nonce configuration\"",
    "output": "where not blockCipherModeInstance.hasIVorNonce()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name 'import *' used\n * @description Detects Python files utilizing wildcard imports ('from ... import *').\n *              Such imports may cause namespace pollution and naming collisions,\n *              potentially compromising code maintainability.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/import-star-used\n */\n\nimport python\n\nfrom ImportStar starImportStmt\nselect starImportStmt, \"Wildcard import ('from ... import *') pollutes global namespace and reduces code clarity.\"",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @deprecated\n * @name Similar function detection\n * @description Identifies functions with high structural similarity that may indicate\n *              code duplication. Such functions should be refactored by extracting\n *              common logic into shared utilities.\n *              (Note: Implementation returns no results - placeholder logic)\n * @kind problem\n * @tags testability\n *       maintainability\n *       useless-code\n *       duplicate-code\n *       statistical\n *       non-attributable\n * @problem.severity recommendation\n * @sub-severity low\n * @precision very-high\n * @id py/similar-function\n */\n\nimport python\n\n// Analysis components:\n// - mainFunction: Primary function under examination\n// - comparisonFunction: Reference function for similarity comparison\n// - similarityMessage: Detailed description of detected similarity\nfrom Function mainFunction,\n     Function comparisonFunction,\n     string similarityMessage\n// Filtering conditions (currently disabled - no results returned)\nwhere none()\n// Results output with function identification and similarity details\nselect mainFunction,\n       similarityMessage,\n_______________ // 补全条件\n       comparisonFunction.getName()",
    "output": "comparisonFunction,"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Non-standard exception raised in special method\n * @description Raising a non-standard exception in a special method alters the expected interface of that method.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       convention\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/unexpected-raise-in-special-method\n */\n\nimport python\n\n// Helper predicates for special method categorization\nprivate predicate isAttributeMethod(string methodNameStr) {\n  methodNameStr = \"__getattribute__\" or \n  methodNameStr = \"__getattr__\" or \n  methodNameStr = \"__setattr__\"\n}\n\nprivate predicate isIndexingMethod(string methodNameStr) {\n  methodNameStr = \"__getitem__\" or \n  methodNameStr = \"__setitem__\" or \n  methodNameStr = \"__delitem__\"\n}\n\nprivate predicate isArithmeticMethod(string methodNameStr) {\n  methodNameStr in [\n      \"__add__\", \"__sub__\", \"__or__\", \"__xor__\", \"__rshift__\", \"__pow__\", \"__mul__\", \"__neg__\",\n      \"__radd__\", \"__rsub__\", \"__rdiv__\", \"__rfloordiv__\", \"__div__\", \"__rdiv__\", \"__rlshift__\",\n      \"__rand__\", \"__ror__\", \"__rxor__\", \"__rrshift__\", \"__rpow__\", \"__rmul__\", \"__truediv__\",\n      \"__rtruediv__\", \"__pos__\", \"__iadd__\", \"__isub__\", \"__idiv__\", \"__ifloordiv__\", \"__idiv__\",\n      \"__ilshift__\", \"__iand__\", \"__ior__\", \"__ixor__\", \"__irshift__\", \"__abs__\", \"__ipow__\",\n      \"__imul__\", \"__itruediv__\", \"__floordiv__\", \"__div__\", \"__divmod__\", \"__lshift__\", \"__and__\"\n    ]\n}\n\nprivate predicate isOrderingMethod(string methodNameStr) {\n  (methodNameStr = \"__lt__\" or \n   methodNameStr = \"__le__\" or \n   methodNameStr = \"__gt__\" or \n   methodNameStr = \"__ge__\") \n  or \n  (methodNameStr = \"__cmp__\" and major_version() = 2)\n}\n\nprivate predicate isCastMethod(string methodNameStr) {\n  (methodNameStr = \"__nonzero__\" and major_version() = 2)\n  or\n  methodNameStr = \"__int__\" or \n  methodNameStr = \"__float__\" or \n  methodNameStr = \"__long__\" or \n  methodNameStr = \"__trunc__\" or \n  methodNameStr = \"__complex__\"\n}\n\n// Exception type validation logic\npredicate isCorrectExceptionType(string methodNameStr, ClassObject exceptionClass) {\n  // Validate TypeError compatibility for specific method categories\n  exceptionClass.getAnImproperSuperType() = theTypeErrorType() and\n  (\n    methodNameStr = \"__copy__\" or \n    methodNameStr = \"__deepcopy__\" or \n    methodNameStr = \"__call__\" or \n    isIndexingMethod(methodNameStr) or \n    isAttributeMethod(methodNameStr)\n  )\n  or\n  // Validate preferred exception types\n  isPreferredExceptionType(methodNameStr, exceptionClass)\n  or\n  // Validate parent exception types\n  isPreferredExceptionType(methodNameStr, exceptionClass.getASuperType())\n}\n\n// Preferred exception type definitions\npredicate isPreferredExceptionType(string methodNameStr, ClassObject exceptionClass) {\n  // Attribute methods should raise AttributeError\n  isAttributeMethod(methodNameStr) and exceptionClass = theAttributeErrorType()\n  or\n  // Indexing methods should raise LookupError\n  isIndexingMethod(methodNameStr) and exceptionClass = Object::builtin(\"LookupError\")\n  or\n  // Ordering methods should raise TypeError\n  isOrderingMethod(methodNameStr) and exceptionClass = theTypeErrorType()\n  or\n  // Arithmetic methods should raise ArithmeticError\n  isArithmeticMethod(methodNameStr) and exceptionClass = Object::builtin(\"ArithmeticError\")\n  or\n  // __bool__ method should raise TypeError\n  methodNameStr = \"__bool__\" and exceptionClass = theTypeErrorType()\n}\n\n// Unnecessary exception handling detection\npredicate isUnnecessaryRaise(string methodNameStr, string suggestionMessage) {\n  // Hash method should use __hash__ = None instead\n  methodNameStr = \"__hash__\" and suggestionMessage = \"use __hash__ = None instead\"\n  or\n  // Cast methods don't need implementation\n  isCastMethod(methodNameStr) and suggestionMessage = \"there is no need to implement the method at all.\"\n}\n\n// Function behavior analysis predicates\npredicate isAbstractFunction(FunctionObject funcObj) {\n  // Check for decorators containing \"abstract\"\n  funcObj.getFunction().getADecorator().(Name).getId().matches(\"%abstract%\")\n}\n\npredicate alwaysRaisesException(FunctionObject funcObj, ClassObject exceptionClass) {\n  // Function raises exactly one exception type with no normal exits\n  exceptionClass = funcObj.getARaisedType() and\n  strictcount(funcObj.getARaisedType()) = 1 and\n  not exists(funcObj.getFunction().getANormalExit()) and\n  /* raising StopIteration is equivalent to a return in a generator */\n  not exceptionClass = theStopIterationType()\n}\n\n// Main query logic\nfrom FunctionObject functionObj, ClassObject exceptionClass, string suggestionMessage\nwhere\n  // Identify non-abstract special methods\n  functionObj.getFunction().isSpecialMethod() and\n  not isAbstractFunction(functionObj) and\n  alwaysRaisesException(functionObj, exceptionClass) and\n  (\n    // Check for unnecessary exception cases\n_______________ // 补全条件\n    not exceptionClass.getName() = \"NotImplementedError\"\n    or\n    // Check for incorrect exception types\n    not isCorrectExceptionType(functionObj.getName(), exceptionClass) and\n    not exceptionClass.getName() = \"NotImplementedError\" and\n    exists(ClassObject preferredException | \n      isPreferredExceptionType(functionObj.getName(), preferredException) |\n      suggestionMessage = \"raise \" + preferredException.getName() + \" instead\"\n    )\n  )\nselect functionObj, \"Function always raises $@; \" + suggestionMessage, exceptionClass, exceptionClass.toString()",
    "output": "isUnnecessaryRaise(functionObj.getName(), suggestionMessage) and"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Mutation of descriptor in `__get__` or `__set__` method.\n * @description Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision very-high\n * @id py/mutable-descriptor\n */\n\nimport python\n\n// Detects descriptor mutation within accessor methods by analyzing method calls and attribute modifications\npredicate mutates_descriptor(ClassObject descriptorType, SelfAttributeStore attributeMutation) {\n  // Validate class implements descriptor protocol\n  descriptorType.isDescriptorType() and\n  // Identify descriptor accessor methods (__get__/__/__set__/__delete__)\n  exists(PyFunctionObject accessorMethod |\n    exists(string methodName |\n      // Check standard descriptor method names\n      (methodName = \"__get__\" or \n       methodName = \"__set__\" or \n       methodName = \"__delete__\") and\n      // Confirm class contains this accessor method\n      descriptorType.lookupAttribute(methodName) = accessorMethod\n    ) and\n    // Locate mutation methods invoked by accessors\n    exists(PyFunctionObject mutatingMethod |\n      // Verify mutation method belongs to descriptor class\n      descriptorType.lookupAttribute(_) = mutatingMethod and\n      // Confirm mutation method is called by accessor\n      accessorMethod.getACallee*() = mutatingMethod and\n      // Exclude initialization methods from analysis\n      not mutatingMethod.getName() = \"__init__\" and\n      // Ensure attribute mutation occurs within mutation method scope\n      attributeMutation.getScope() = mutatingMethod.getFunction()\n    )\n  )\n}\n\n_______________ // 补全条件\nfrom ClassObject descriptorType, SelfAttributeStore attributeMutation\nwhere mutates_descriptor(descriptorType, attributeMutation)\nselect attributeMutation,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  descriptorType, descriptorType.getName()",
    "output": "// Query for descriptor mutations"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/polluting-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects star imports that can potentially pollute the namespace",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'import *' may pollute namespace\n * @description Detects star imports that can potentially pollute the namespace\n *              when the imported module does not define '__all__' attribute\n * @kind problem\n * @tags maintainability\n *       modularity\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/polluting-import\n */\n\n// Import Python analysis framework for code examination\nimport python\n\n// Identify star imports that pollute the namespace\nfrom ImportStar namespacePolluter, ModuleValue importedModule\nwhere \n  // Verify the imported module name matches the actual module\n  importedModule.importedAs(namespacePolluter.getImportedModuleName()) and\n  // Ensure the module exists in the codebase\n  not importedModule.isAbsent() and\n  // Check if the module is not a built-in module\n  not importedModule.isBuiltin() and\n  // Check if '__all__' is not defined in the module's main scope\n  not importedModule.getScope().(ImportTimeScope).definesName(\"__all__\") and\n  // Check if '__all__' is not defined in the module's initialization scope\n  not importedModule.getScope().getInitModule().(ImportTimeScope).definesName(\"__all__\")\nselect namespacePolluter,\n  \"Import pollutes the enclosing namespace, as the imported module $@ does not define '__all__'.\",\n  importedModule, importedModule.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/nested-loops-with-same-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies nested for loops that reuse identical iteration variables,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Nested loops with same variable\n * @description Identifies nested for loops that reuse identical iteration variables,\n *              potentially causing unexpected behavior and reducing code readability.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/nested-loops-with-same-variable\n */\n\nimport python\n\n// Checks whether a for loop employs the specified variable as its iteration target\npredicate loopUsesVariable(For iteration, Variable targetVariable) { \n  iteration.getTarget().defines(targetVariable) \n}\n\n// Detects nested loops where both outer and inner loops share the same iteration variable,\n// and the variable is referenced outside the inner loop's scope\npredicate sharedVariableInNestedLoops(For innerLoop, For outerLoop, Variable commonVariable) {\n  // Verify both loops utilize the same iteration variable\n  loopUsesVariable(innerLoop, commonVariable) and\n  loopUsesVariable(outerLoop, commonVariable) and\n  // Confirm inner loop is directly nested within outer loop's body (excluding else clauses)\n  outerLoop.getBody().contains(innerLoop) and\n  // Ensure the variable is used in the outer loop beyond the inner loop's context\n  exists(Name varUsage | \n    varUsage.uses(commonVariable) and \n    outerLoop.contains(varUsage) and \n    not innerLoop.contains(varUsage)\n  )\n}\n\n// Query: Locate all problematic nested loops with shared iteration variables\nfrom For innerLoop, For outerLoop, Variable commonVariable\nwhere sharedVariableInNestedLoops(innerLoop, outerLoop, commonVariable)\nselect innerLoop, \n  \"Nested for loop reuses iteration variable '\" + commonVariable.getId() + \n  \"' from enclosing $@.\", \n  outerLoop, \n  \"outer for loop\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/quantum-readiness/cbom/all-asymmetric-algorithms]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies all potential asymmetric cryptographic algorithm implementations (RSA & ECC)",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name All Asymmetric Algorithms\n * @description Identifies all potential asymmetric cryptographic algorithm implementations (RSA & ECC) \n *              across supported cryptographic libraries in the codebase.\n * @kind problem\n * @id py/quantum-readiness/cbom/all-asymmetric-algorithms\n * @problem.severity error\n * @tags cbom\n *       cryptography\n */\n\n// Import Python language support for code analysis\nimport python\n\n// Import experimental cryptographic concepts library for algorithm detection\nimport experimental.cryptography.Concepts\n\n// Define variable for asymmetric algorithm instances\nfrom AsymmetricAlgorithm asymmetricAlgorithm\n\n// Output algorithm instances with descriptive messages\nselect asymmetricAlgorithm, \"Detected asymmetric algorithm: \" + asymmetricAlgorithm.getName()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/call-graph]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Represents an edge in the call graph, showing a function call and its target.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Call graph edge\n * @description Represents an edge in the call graph, showing a function call and its target.\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/call-graph\n * @tags meta\n * @precision very-low\n */\n\n// 导入Python语言核心库\nimport python\n// 导入用于数据流分析的内部模块\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n// 导入元度量计算相关的库\nimport meta.MetaMetrics\n\n// 从数据流调用和可调用目标中选择边\nfrom DataFlowCall invocation, DataFlowCallable callableTarget\nwhere\n  // 目标必须是可行的可调用对象\n  (callableTarget = viableCallable(invocation)) and\n  // 排除忽略文件中的调用位置\n  (not invocation.getLocation().getFile() instanceof IgnoredFile) and\n  // 排除忽略文件中的目标作用域位置\n  (not callableTarget.getScope().getLocation().getFile() instanceof IgnoredFile)\nselect invocation, \"Call to $@\", callableTarget.getScope(), callableTarget.toString()"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cors-bypass]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：当使用弱字符串比较方法（如 'string.startswith'）验证用户提供的 Origin 头部时，",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 跨域资源共享（CORS）策略绕过漏洞\n * @description 当使用弱字符串比较方法（如 'string.startswith'）验证用户提供的 Origin 头部时，\n *              可能导致 CORS 安全策略被绕过，使攻击者能够执行跨域请求。\n * @kind path-problem\n * @problem.severity warning\n * @id py/cors-bypass\n * @tags security\n *       externa/cwe/CWE-346\n */\n\nimport python\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.Flow\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n/**\n * 检测字符串中是否包含 CORS 相关关键词\n * 用于启发式识别与 CORS 相关的变量和代码\n */\nbindingset[s]\npredicate containsCorsKeywords(string s) { s.matches([\"%origin%\", \"%cors%\"]) }\n\n/**\n * 表示调用字符串 startswith 方法的控制流节点\n * 此类调用模式常被错误地用于 Origin 头部验证\n */\nprivate class StrStartswithMethodCall extends ControlFlowNode {\n  StrStartswithMethodCall() { \n    this.(CallNode).getFunction().(AttrNode).getName() = \"startswith\" \n  }\n}\n\n/**\n * 检查变量名是否包含 CORS 相关关键词\n */\nprivate predicate hasCorsRelevantName(Variable var) { \n  containsCorsKeywords(var.getId()) \n}\n\n/**\n * 识别与 CORS 验证逻辑相关的控制流节点\n * 通过三种启发式规则检测潜在感兴趣的节点，降低误报率\n */\nprivate predicate isCorsRelevantNode(ControlFlowNode node) {\n  // 规则1：调用 startswith 方法的对象变量名包含 CORS 关键词\n  exists(string name | \n    containsCorsKeywords(name) and \n    node.(CallNode).getFunction().(AttrNode).getObject().(NameNode).getId() = name\n  )\n  or\n  // 规则2：作为 startswith 方法参数的变量名包含 CORS 关键词\n  exists(string name | \n    containsCorsKeywords(name) and \n    node.(CallNode).getArg(0).(NameNode).getId() = name\n  )\n  or\n  // 规则3：值被写入包含 CORS 关键词的变量（潜在源点）\n  exists(Variable var | \n    hasCorsRelevantName(var) and \n    node.getASuccessor*().getNode() = var.getAStore()\n  )\n}\n\n/**\n * 表示 CherryPy 框架中请求对象的成员访问\n * 这些成员被视为远程流源，因为它们包含用户提供的输入\n */\nclass CherryPyRequestMember extends RemoteFlowSource::Range {\n  CherryPyRequestMember() {\n    this =\n      API::moduleImport(\"cherrypy\")\n          .getMember(\"request\")\n          .getMember([\n              \"charset\", \"content_type\", \"filename\", \"fp\", \"name\", \"params\", \"headers\", \"length\"\n            ])\n          .asSource()\n  }\n\n  override string getSourceType() { result = \"cherrypy.request\" }\n}\n\n/**\n * CORS 策略绕过漏洞的数据流分析配置\n * 定义源、汇和额外的流步骤以识别不安全的 Origin 验证\n */\nmodule CorsBypassAnalysisConfig implements DataFlow::ConfigSig {\n  /**\n   * 定义数据流源：所有远程输入源\n   */\n  predicate isSource(DataFlow::Node node) { \n    node instanceof RemoteFlowSource \n  }\n\n  /**\n   * 定义数据流汇：字符串 startswith 方法的调用对象或参数\n   * 这些位置常用于不安全的 Origin 验证\n   */\n  predicate isSink(DataFlow::Node node) {\n    exists(StrStartswithMethodCall startswithCall |\n      node.asCfgNode() = startswithCall.(CallNode).getArg(0) or\n      node.asCfgNode() = startswithCall.(CallNode).getFunction().(AttrNode).getObject()\n    )\n  }\n\n  /**\n   * 定义额外的数据流步骤：处理 cherrypy.request.headers.get() 调用\n   * 这种调用模式常见于获取请求头部的场景\n   */\n  predicate isAdditionalFlowStep(DataFlow::Node srcNode, DataFlow::Node tgtNode) {\n    exists(API::CallNode callNode, API::Node headers |\n      headers = API::moduleImport(\"cherrypy\").getMember(\"request\").getMember(\"headers\") and\n      callNode = headers.getMember(\"get\").getACall()\n    |\n      callNode.getReturn().asSource() = tgtNode and \n      headers.asSource() = srcNode\n    )\n  }\n\n  // 启用增量模式差异观察以提高分析效率\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\n// 全局污点跟踪模块，用于追踪从源到汇的数据流\nmodule CorsTaintFlow = TaintTracking::Global<CorsBypassAnalysisConfig>;\n\nimport CorsTaintFlow::PathGraph\n\n/**\n * 查询潜在的 CORS 策略绕过漏洞\n * 识别从用户输入到不安全字符串比较的数据流路径\n */\nfrom CorsTaintFlow::PathNode sourcePathNode, CorsTaintFlow::PathNode sinkPathNode\nwhere\n  CorsTaintFlow::flowPath(sourcePathNode, sinkPathNode) and\n  (\n    isCorsRelevantNode(sourcePathNode.getNode().asCfgNode())\n    or\n    isCorsRelevantNode(sinkPathNode.getNode().asCfgNode())\n  )\nselect sinkPathNode, sourcePathNode, sinkPathNode,\n  \"使用弱字符串比较验证 Origin 头部可能导致 CORS 策略被绕过。\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Conflicting attributes in base classes\n * @description Detects when a class inherits from multiple base classes that define the same attribute, potentially causing unexpected behavior due to attribute overriding conflicts.\n * @kind problem\n * @tags reliability\n *       maintainability\n *       modularity\n * @problem.severity warning\n * @sub-severity low\n * @precision high\n * @id py/conflicting-attributes\n */\n\nimport python\n\n// Determines if a Python function contains only pass statements and docstrings\npredicate is_empty_function(PyFunctionObject f) {\n  // Verify function body contains no non-pass statements or expressions beyond docstrings\n  not exists(Stmt s | s.getScope() = f.getFunction() |\n    not s instanceof Pass and not s.(ExprStmt).getValue() = f.getFunction().getDocString()\n  )\n}\n\n// Checks if a method explicitly calls super() to invoke parent class implementation\npredicate invokes_super(FunctionObject f) {\n  // Identify super() calls within the function body\n  exists(Call supCall, Call methodCall, Attribute attrRef, GlobalVariable superVar |\n    methodCall.getScope() = f.getFunction() and\n    methodCall.getFunc() = attrRef and\n    attrRef.getObject() = supCall and\n    attrRef.getName() = f.getName() and\n    supCall.getFunc() = superVar.getAnAccess() and\n    superVar.getId() = \"super\"\n  )\n}\n\n/** Identifies attribute names exempt from conflict detection due to special framework requirements */\npredicate is_exempt_name(string name) {\n  /*\n   * Special case exemption for socketserver framework:\n   * https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   */\n  name = \"process_request\"\n}\n\nfrom\n  ClassObject derivedClass, ClassObject baseClass1, ClassObject baseClass2, \n  string attributeName, int baseIndex1, int baseIndex2, \n  Object attribute1, Object attribute2\nwhere\n  // Establish inheritance hierarchy with ordered base classes\n  derivedClass.getBaseType(baseIndex1) = baseClass1 and\n  derivedClass.getBaseType(baseIndex2) = baseClass2 and\n  baseIndex1 < baseIndex2 and\n  \n  // Verify conflicting attributes exist in different base classes\n  attribute1 = baseClass1.lookupAttribute(attributeName) and\n  attribute2 = baseClass2.lookupAttribute(attributeName) and\n  attribute1 != attribute2 and\n  \n  // Exclude special naming patterns and exempted attributes\n  not attributeName.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  not is_exempt_name(attributeName) and\n  \n  // Ensure derived class doesn't override the attribute\n  not derivedClass.declaresAttribute(attributeName) and\n  \n_______________ // 补全条件\n  not invokes_super(attribute1) and\n  not is_empty_function(attribute2) and\n  not attribute1.overrides(attribute2) and\n  not attribute2.overrides(attribute1)\nselect derivedClass, \n  \"Base classes have conflicting values for attribute '\" + attributeName + \"': $@ and $@.\", \n  attribute1, attribute1.toString(), \n  attribute2, attribute2.toString()",
    "output": "// Validate attribute implementations don't resolve conflicts"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Multiple imports on one line\n * @description Identifies import statements that import multiple modules on a single line,\n *              which contradicts PEP8's recommendation for placing imports on separate lines.\n * @kind problem\n * @tags maintainability\n * @problem.severity recommendation\n * @sub-severity low\n * @deprecated\n * @precision medium\n * @id py/multiple-imports-on-one-line\n */\n\n/*\n * This query targets import statements that import multiple modules in a single line\n * (e.g., \"import modA, modB\"). According to PEP8, imports should typically be on separate\n_______________ // 补全条件\n */\n\nimport python\n\nfrom Import stmt\nwhere \n  // Exclude \"from ... import ...\" style imports\n  not stmt.isFromImport()\n  // Check if the import statement contains multiple module names\n  and count(stmt.getAName()) > 1\nselect stmt, \"Multiple imports on one line.\"",
    "output": "* lines to enhance code readability and maintainability."
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name NotImplemented is not an Exception\n * @description Detects incorrect usage of 'NotImplemented' as an exception in raise statements,\n *              which will cause a type error at runtime.\n_______________ // 补全条件\n * @problem.severity warning\n * @sub-severity high\n * @precision very-high\n * @id py/raise-not-implemented\n * @tags reliability\n *       maintainability\n */\n\n// Import Python analysis framework\nimport python\n\n// Import module for NotImplemented exception handling\nimport Exceptions.NotImplemented\n\n// Identify expressions where NotImplemented is incorrectly used in raise contexts\nfrom Expr problematicExpr\n// Filter expressions to locate NotImplemented misuse in raise statements\nwhere use_of_not_implemented_in_raise(_, problematicExpr)\n// Output the problematic expression with corrective suggestion\nselect problematicExpr, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\"",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Incorrect usage of 'return' or 'yield' outside function scope\n * @description Identifies misplaced 'return', 'yield', or 'yield from' statements\n *              occurring outside function definitions, which would cause SyntaxError\n_______________ // 补全条件\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/return-or-yield-outside-function\n */\n\nimport python\n\n// Find statements that are invalid when used outside function contexts\nfrom AstNode illegalStmt, string stmtKind\nwhere\n  // Classify the statement type (return/yield/yield from)\n  exists(string type |\n    (\n      illegalStmt instanceof Return and type = \"return\"\n      or\n      illegalStmt instanceof Yield and type = \"yield\"\n      or\n      illegalStmt instanceof YieldFrom and type = \"yield from\"\n    ) and\n    stmtKind = type\n  )\n  and\n  // Ensure the statement is not nested within any function scope\n  not exists(Function func | illegalStmt.getScope() = func)\n// Report the problematic statement with contextual error message\nselect illegalStmt, \"Statement '\" + stmtKind + \"' is used outside a function definition.\"",
    "output": "*              during Python execution."
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/undefined-placeholder-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies instances where placeholder variables are used without proper initialization,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of an undefined placeholder variable\n * @description Identifies instances where placeholder variables are used without proper initialization,\n *              potentially leading to runtime errors.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/undefined-placeholder-variable\n */\n\nimport python\nimport Variables.MonkeyPatched\n\n// Determines if a placeholder reference is initialized within its local function scope\npredicate initializedInLocalScope(PlaceHolder placeholderRef) {\n  exists(SsaVariable ssaDefinition, Function funcContext | \n    funcContext = placeholderRef.getScope() and \n    ssaDefinition.getAUse() = placeholderRef.getAFlowNode() |\n    ssaDefinition.getVariable() instanceof LocalVariable and\n    not ssaDefinition.maybeUndefined()\n  )\n}\n\n// Retrieves the class that contains the placeholder reference\nClass findEnclosingClass(PlaceHolder placeholderRef) { \n  result.getAMethod() = placeholderRef.getScope() \n}\n\n// Checks if the placeholder is defined as a template attribute within its containing class\npredicate definedAsClassAttribute(PlaceHolder placeholderRef) {\n  exists(ImportTimeScope classContext | \n    classContext = findEnclosingClass(placeholderRef) | \n    classContext.definesName(placeholderRef.getId())\n  )\n}\n\n// Verifies that the placeholder is not defined globally, as a monkey-patched builtin, or as a global name\npredicate notGloballyAccessible(PlaceHolder placeholderRef) {\n  not exists(PythonModuleObject moduleEntity |\n    moduleEntity.hasAttribute(placeholderRef.getId()) and \n    moduleEntity.getModule() = placeholderRef.getEnclosingModule()\n  ) and\n  not globallyDefinedName(placeholderRef.getId()) and\n  not monkey_patched_builtin(placeholderRef.getId())\n}\n\n// Main query: Identifies and reports potentially undefined placeholder variable usages\nfrom PlaceHolder targetPlaceholder\nwhere\n  not initializedInLocalScope(targetPlaceholder) and\n  not definedAsClassAttribute(targetPlaceholder) and\n  notGloballyAccessible(targetPlaceholder)\nselect targetPlaceholder, \"This use of placeholder variable '\" + targetPlaceholder.getId() + \"' may be undefined.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name Definitions\n * @description Helper query to navigate from usage to definition locations in Python code.\n * @kind definitions\n * @id py/jump-to-definition\n */\n\n// Import the Python library for analyzing Python source code\nimport python\n\n// Import the definition tracking module to trace variable and function definitions\nimport analysis.DefinitionTracking\n\n// Select expressions with nice locations, their corresponding definitions, and definition types\nfrom NiceLocationExpr usage, Definition definition, string definitionType\n// Filter to ensure the definition matches the usage and the types are consistent\nwhere definition = definitionOf(usage, definitionType)\n// Return the usage location, definition location, and definition type\nselect usage, definition, definitionType",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Use of an undefined global variable\n * @description Using a global variable before it is initialized causes an exception.\n_______________ // 补全条件\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision low\n * @id py/undefined-global-variable\n */\n\nimport python  // 导入Python库，用于分析Python代码\nimport Variables.MonkeyPatched  // 导入处理猴子补丁的变量库\nimport Loop  // 导入循环处理库\nimport semmle.python.pointsto.PointsTo  // 导入指向分析库\n\n// 定义一个谓词，判断是否对NameError进行了防护\npredicate guarded_against_name_error(Name u) {\n  // 检查是否存在一个Try块，其内部包含u，并且异常处理器捕获了NameError\n  exists(Try t | t.getBody().getAnItem().contains(u) |\n    t.getAHandler().getType().(Name).getId() = \"NameError\"\n  )\n  or\n  // 或者检查是否存在一个条件块，其控制了一个基本块，该基本块包含全局变量的使用\n  exists(ConditionBlock guard, BasicBlock controlled, Call globals |\n    guard.getLastNode().getNode().contains(globals) or\n    guard.getLastNode().getNode() = globals\n  |\n    globals.getFunc().(Name).getId() = \"globals\" and\n    guard.controls(controlled, _) and\n    controlled.contains(u.getAFlowNode())\n  )\n}\n\n// 定义一个谓词，判断模块中是否包含未知的星号导入\npredicate contains_unknown_import_star(Module m) {\n  // 检查是否存在一个星号导入，其作用域为m，并且导入的模块没有完整的导出信息\n  exists(ImportStar imp | imp.getScope() = m |\n    exists(ModuleValue imported | imported.importedAs(imp.getImportedModuleName()) |\n      not imported.hasCompleteExportInfo()\n    )\n  )\n}\n\n// 定义一个谓词，判断在函数中是否使用了未定义的全局变量\npredicate undefined_use_in_function(Name u) {\n  // 检查是否存在一个函数f，其作用域包含u，并且u在该函数或其封闭作用域中没有被定义\n  exists(Function f |\n    u.getScope().getScope*() = f and\n    // 函数是一个方法或内部函数，或者它在模块作用域结束时是活跃的\n    (\n      not f.getScope() = u.getEnclosingModule() or\n      u.getEnclosingModule().(ImportTimeScope).definesName(f.getName())\n    ) and\n    // 存在对全局变量v的使用，但在函数或封闭作用域中没有定义\n    exists(GlobalVariable v | u.uses(v) |\n      not exists(Assign a, Scope defnScope |\n        a.getATarget() = v.getAnAccess() and a.getScope() = defnScope\n      |\n        defnScope = f\n        or\n        // 排除模块，因为下面会更准确处理这种情况\n        defnScope = f.getScope().getScope*() and not defnScope instanceof Module\n      )\n    )\n  ) and\n  // 确保u在其封闭模块中没有被定义，并且没有通过模块值属性进行定义\n  not u.getEnclosingModule().(ImportTimeScope).definesName(u.getId()) and\n  not exists(ModuleValue m | m.getScope() = u.getEnclosingModule() | m.hasAttribute(u.getId())) and\n  not globallyDefinedName(u.getId()) and\n  not exists(SsaVariable var | var.getAUse().getNode() = u and not var.maybeUndefined()) and\n  not guarded_against_name_error(u) and\n  not (u.getEnclosingModule().isPackageInit() and u.getId() = \"__path__\")\n}\n\n// 定义一个谓词，判断在类或模块中是否使用了未定义的全局变量\npredicate undefined_use_in_class_or_module(Name u) {\n  // 检查是否存在一个全局变量v，其使用包含u，并且u的作用域不是函数\n  exists(GlobalVariable v | u.uses(v)) and\n  not u.getScope().getScope*() instanceof Function and\n  exists(SsaVariable var | var.getAUse().getNode() = u | var.maybeUndefined()) and\n  not guarded_against_name_error(u) and\n  not exists(ModuleValue m | m.getScope() = u.getEnclosingModule() | m.hasAttribute(u.getId())) and\n  not (u.getEnclosingModule().isPackageInit() and u.getId() = \"__path__\") and\n  not globallyDefinedName(u.getId())\n}\n\n// 定义一个谓词，判断模块中是否使用了exec函数\npredicate use_of_exec(Module m) {\n  // 检查是否存在一个Exec节点，其作用域为m，或者存在一个名为exec或execfile的函数调用\n  exists(Exec exec | exec.getScope() = m)\n  or\n  exists(CallNode call, FunctionValue exec | exec.getACall() = call and call.getScope() = m |\n    exec = Value::named(\"exec\") or\n    exec = Value::named(\"execfile\")\n  )\n}\n\n// 定义一个谓词，判断是否使用了未定义的全局变量\npredicate undefined_use(Name u) {\n  // 检查在类或模块中或在函数中是否使用了未定义的全局变量，并且没有通过猴子补丁、星号导入、exec函数等方式定义\n  (\n    undefined_use_in_class_or_module(u)\n    or\n    undefined_use_in_function(u)\n  ) and\n  not monkey_patched_builtin(u.getId()) and\n  not contains_unknown_import_star(u.getEnclosingModule()) and\n  not use_of_exec(u.getEnclosingModule()) and\n  not exists(u.getVariable().getAStore()) and\n  not u.pointsTo(_) and\n  not probably_defined_in_loop(u)\n}\n\n// 定义一个私有谓词，判断是否是基本块中的第一个使用\nprivate predicate first_use_in_a_block(Name use) {\n  // 检查是否存在一个全局变量v和一个基本块b，使得b中的最小加载节点是use\n  exists(GlobalVariable v, BasicBlock b, int i |\n    i = min(int j | b.getNode(j).getNode() = v.getALoad()) and b.getNode(i) = use.getAFlowNode()\n  )\n}\n\n// 定义一个谓词，判断是否是第一个未定义的使用\npredicate first_undefined_use(Name use) {\n  // 检查是否是未定义的使用，并且是基本块中的第一个使用，且没有其他控制流节点严格支配它\n  undefined_use(use) and\n  exists(GlobalVariable v | v.getALoad() = use |\n    first_use_in_a_block(use) and\n    not exists(ControlFlowNode other |\n      other.getNode() = v.getALoad() and\n      other.getBasicBlock().strictlyDominates(use.getAFlowNode().getBasicBlock())\n    )\n  )\n}\n\n// 查询语句：选择所有第一个未定义使用的全局变量，并输出警告信息\nfrom Name u\nwhere first_undefined_use(u)\nselect u, \"This use of global variable '\" + u.getId() + \"' may be undefined.\"",
    "output": "* @kind problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects when a module imports itself, which is typically a code smell",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description Detects when a module imports itself, which is typically a code smell\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n// Predicate to identify modules that perform self-import\npredicate isSelfImportingModule(ImportingStmt importStmt, ModuleValue selfModule) {\n  // Condition 1: The import statement's enclosing module must match the imported module's scope\n  importStmt.getEnclosingModule() = selfModule.getScope() and\n  // Condition 2: Resolve the imported module name to its corresponding ModuleValue\n  // using the shortest module name to handle potential naming conflicts\n  selfModule = max(string moduleName, ModuleValue resolvedModule |\n      moduleName = importStmt.getAnImportedModuleName() and\n      resolvedModule.importedAs(moduleName)\n    | resolvedModule order by moduleName.length()\n  )\n}\n\n// Query to identify all instances of self-importing modules\nfrom ImportingStmt importStmt, ModuleValue selfModule\nwhere isSelfImportingModule(importStmt, selfModule)\nselect importStmt, \"The module '\" + selfModule.getName() + \"' imports itself.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/modification-of-default-value]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects code that modifies a parameter with a default value. This can cause unexpected behavior because the default value is shared across multiple function calls.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Modification of Parameter with Default Value\n * @description Detects code that modifies a parameter with a default value. This can cause unexpected behavior because the default value is shared across multiple function calls.\n * @kind path-problem\n * @tags reliability\n *       maintainability\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/modification-of-default-value\n */\n\nimport python\nimport semmle.python.functions.ModificationOfParameterWithDefault\nimport ModificationOfParameterWithDefault::Flow::PathGraph\n\nfrom\n  ModificationOfParameterWithDefault::Flow::PathNode sourceNode,\n  ModificationOfParameterWithDefault::Flow::PathNode sinkNode\nwhere \n  ModificationOfParameterWithDefault::Flow::flowPath(sourceNode, sinkNode)\nselect \n  sinkNode.getNode(), \n  sourceNode, \n  sinkNode, \n  \"This expression mutates a $@.\", \n  sourceNode.getNode(),\n  \"default value\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/exit-from-finally]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：在finally块中使用Break或Return语句会导致Try-finally块退出，并丢弃异常。",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name 'break' or 'return' statement in finally\n * @description 在finally块中使用Break或Return语句会导致Try-finally块退出，并丢弃异常。\n * @kind problem\n * @tags reliability\n *       maintainability\n *       external/cwe/cwe-584\n * @problem.severity warning\n * @sub-severity low\n * @precision medium\n * @id py/exit-from-finally\n */\n\nimport python\n\n// 查询主体：识别finally块中的问题语句\nfrom Stmt offendingStmt, string statementType\nwhere\n  // 情况1：finally块中的return语句\n  (\n    offendingStmt instanceof Return and \n    statementType = \"return\" and \n    exists(Try enclosingTryStmt | \n      enclosingTryStmt.getFinalbody().contains(offendingStmt)\n    )\n  )\n  or\n  // 情况2：finally块中的break语句（且不在循环内）\n  (\n    offendingStmt instanceof Break and \n    statementType = \"break\" and \n    exists(Try enclosingTryStmt | \n      enclosingTryStmt.getFinalbody().contains(offendingStmt) and\n      // 确保break语句不在任何循环内（既不在for循环也不在while循环中）\n      not exists(Stmt enclosingLoopStmt | \n        (enclosingLoopStmt instanceof For or enclosingLoopStmt instanceof While) and\n        enclosingLoopStmt.contains(offendingStmt) and \n        enclosingTryStmt.getFinalbody().contains(enclosingLoopStmt)\n      )\n    )\n  )\n// 输出结果：问题语句及其警告信息\nselect offendingStmt, \"'\" + statementType + \"' in a finally block will swallow any exceptions raised.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Partial server-side request forgery\n * @description Identifies potential SSRF vulnerabilities where user-controlled input\n *              partially influences the destination URL of network requests, allowing\n *              attackers to manipulate request targets.\n_______________ // 补全条件\n * @problem.severity error\n * @security-severity 9.1\n * @precision medium\n * @id py/partial-ssrf\n * @tags security\n *       external/cwe/cwe-918\n */\n\n// Import the standard Python analysis framework\nimport python\n// Import SSRF (Server-Side Request Forgery) data flow analysis components\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\n// Import the partial SSRF flow path graph for vulnerability tracking\nimport PartialServerSideRequestForgeryFlow::PathGraph\n\n// Detect partial SSRF vulnerabilities by analyzing data flow paths\nfrom\n  PartialServerSideRequestForgeryFlow::PathNode userInputSource,  // Source of user-controllable data\n  PartialServerSideRequestForgeryFlow::PathNode requestSink,       // Destination of tainted data in HTTP request\n  Http::Client::Request httpRequest                                // The vulnerable network request being analyzed\nwhere\n  // Establish relationship between the HTTP request and the sink node\n  httpRequest = requestSink.getNode().(Sink).getRequest() and\n  \n  // Verify that tainted data flows from the user input source to the request sink\n  PartialServerSideRequestForgeryFlow::flowPath(userInputSource, requestSink) and\n  \n  // Exclude requests that are fully controlled by the application (partial control only)\n  not fullyControlledRequest(httpRequest)\n  \nselect httpRequest, userInputSource, requestSink, \"Part of the URL of this request depends on a $@.\", userInputSource.getNode(),\n  \"user-provided value\"",
    "output": "* @kind path-problem"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/import-own-module]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects modules that import themselves directly",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Module imports itself\n * @description Detects modules that import themselves directly\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/import-own-module\n */\n\nimport python\n\n/**\n * Identifies self-importing modules by comparing import contexts\n * \n * This predicate finds Python modules that import themselves, which typically\n * indicates unnecessary code patterns that may cause circular dependencies.\n * \n * Parameters:\n * - importDeclaration: The import statement being analyzed\n * - targetModule: The module being imported\n */\npredicate isSelfImport(ImportingStmt importDeclaration, ModuleValue targetModule) {\n  // Verify the importing context matches the imported module's scope\n  importDeclaration.getEnclosingModule() = targetModule.getScope() and\n  // Resolve the most specific module match using longest-name priority\n  targetModule = \n    max(string moduleName, ModuleValue candidateMod |\n      moduleName = importDeclaration.getAnImportedModuleName() and\n      candidateMod.importedAs(moduleName)\n    |\n      candidateMod order by moduleName.length() desc\n    )\n}\n\n// Main query: Detect all self-importing module instances\n// \n// This query scans all import statements and identifies cases where\n// a module imports itself, generating maintainability warnings.\nfrom ImportingStmt importDeclaration, ModuleValue targetModule\nwhere isSelfImport(importDeclaration, targetModule)\nselect importDeclaration, \"The module '\" + targetModule.getName() + \"' imports itself.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Function Code Size Analysis\n * @description Measures and reports the line count for each function in the codebase,\n *              assisting developers in identifying functions that may be too large\n *              and potentially violating the single responsibility principle.\n * @kind treemap\n * @id py/lines-of-code-per-function\n * @treemap.warnOn highValues\n * @metricType callable\n * @metricAggregate avg sum max\n * @tags maintainability\n_______________ // 补全条件\n */\n\nimport python // Import Python module for analyzing Python source code\n\n// Retrieve all Python functions and compute their code size metrics\nfrom Function func\nselect func, \n       func.getMetrics().getNumberOfLinesOfCode() as lineCount \norder by lineCount desc",
    "output": "* @severity info"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/commit-source-links]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Source links of commits",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Source links of commits\n * @kind source-link\n * @id py/commit-source-links\n * @metricType commit\n */\n\n// Import Python module to enable Python code analysis capabilities\nimport python\n// Import external version control system module for accessing commit history and file modifications\nimport external.VCS\n\n// Retrieve commit entries and their associated source files from version control\nfrom Commit commitEntry, File sourceFile\n// Filter to include only source code files that were modified in the commit\nwhere sourceFile.fromSource() and sourceFile = commitEntry.getAnAffectedFile()\n// Return the commit revision identifier along with the affected source file\nselect commitEntry.getRevisionName(), sourceFile"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/transitive-imports-per-file]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：The number of modules imported by this file - either directly by an import statement,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Indirect imports per file\n * @description The number of modules imported by this file - either directly by an import statement,\n *              or indirectly (by being imported by an imported module).\n * @kind treemap\n * @id py/transitive-imports-per-file\n * @treemap.warnOn highValues\n * @metricType file\n * @metricAggregate avg\n * @tags modularity\n */\n\nimport python\n\n// Define the transitive import count for each module\nfrom ModuleValue moduleEntity, int transitiveImportCount\nwhere \n  // Calculate the total number of modules transitively imported by moduleEntity\n  transitiveImportCount = count(ModuleValue importedModule | \n    // Find all modules reachable through the import relation (transitive closure)\n    importedModule = moduleEntity.getAnImportedModule+() and \n    // Exclude the module itself from the count\n    importedModule != moduleEntity\n  )\nselect moduleEntity.getScope(), transitiveImportCount"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Inconsistent method resolution order\n * @description Identifies class definitions that are prone to runtime type errors caused by an inconsistent method resolution order (MRO) in their inheritance hierarchy\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision very-high\n * @id py/inconsistent-mro\n */\n\nimport python\n\n// Detects classes with problematic MRO by analyzing inheritance relationships\n// between consecutive base classes in the inheritance hierarchy\npredicate has_mro_conflict(ClassObject target, ClassObject baseA, ClassObject baseB) {\n  // Ensure the class is a new-style class (required for MRO analysis)\n  target.isNewStyle() and\n  // Find consecutive base classes in the inheritance list\n  exists(int position | \n    position > 0 and \n    target.getBaseType(position) = baseB and \n_______________ // 补全条件\n  ) and\n  // Verify the first base is an improper supertype of the second base\n  baseA = baseB.getAnImproperSuperType()\n}\n\n// Identify all classes with invalid MRO and generate diagnostic messages\nfrom ClassObject cls, ClassObject precedingBase, ClassObject followingBase\nwhere has_mro_conflict(cls, precedingBase, followingBase)\nselect cls,\n  \"Construction of class \" + cls.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", precedingBase,\n  precedingBase.getName(), followingBase, followingBase.getName()",
    "output": "baseA = target.getBaseType(position - 1)"
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/unused-import]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies imported modules that are never referenced in the codebase",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Unused import\n * @description Identifies imported modules that are never referenced in the codebase\n * @kind problem\n * @tags maintainability\n *       useless-code\n * @problem.severity recommendation\n * @sub-severity high\n * @precision very-high\n * @id py/unused-import\n */\n\n// Core Python analysis modules\nimport python\nimport Variables.Definition\nimport semmle.python.ApiGraphs\n\n// Determines if an import represents a pytest fixture\nprivate predicate is_pytest_fixture(Import importDecl, Variable fixtureVar) {\n  exists(Alias importAlias, API::Node fixtureNode, API::Node decoratorNode |\n    // Identify pytest.fixture decorator node\n    fixtureNode = API::moduleImport(\"pytest\").getMember(\"fixture\") and\n    // Consider both fixture node and its return value as decorators\n    decoratorNode in [fixtureNode, fixtureNode.getReturn()] and\n    // Get alias from import declaration\n    importAlias = importDecl.getAName() and\n    // Verify alias refers to fixture variable\n    importAlias.getAsname().(Name).getVariable() = fixtureVar and\n    // Confirm alias value derives from decorator node\n    importAlias.getValue() = decoratorNode.getReturn().getAValueReachableFromSource().asExpr()\n  )\n}\n\n// Checks if a global identifier is referenced within a module\npredicate global_name_used(Module mod, string idStr) {\n  // Case 1: Direct usage as global variable\n  exists(Name usage, GlobalVariable globalVar |\n    usage.uses(globalVar) and\n    globalVar.getId() = idStr and\n    usage.getEnclosingModule() = mod\n  )\n  or\n  // Case 2: Usage as local variable outside function scope\n  exists(Name usage, LocalVariable localVar |\n    usage.uses(localVar) and\n    localVar.getId() = idStr and\n    usage.getEnclosingModule() = mod and\n    // Ensure variable is not inside function scope\n    not localVar.getScope().getEnclosingScope*() instanceof Function\n  )\n}\n\n/** Holds if module has an incompletely analyzable `__all__` variable */\npredicate all_not_understood(Module mod) {\n  exists(GlobalVariable allVariable | \n    allVariable.getId() = \"__all__\" and \n    allVariable.getScope() = mod and\n    (\n      // Module's __all__ not defined as analyzable list\n      not mod.declaredInAll(_)\n      or\n      // __all__ variable is modified (e.g., via append)\n      exists(Call modifyingCall | \n        modifyingCall.getFunc().(Attribute).getObject() = allVariable.getALoad()\n      )\n    )\n  )\n}\n\n// Checks if imported module is referenced in doctest strings\npredicate imported_module_used_in_doctest(Import importDecl) {\n  exists(string modName, string docString |\n    // Extract imported module name from alias\n    importDecl.getAName().getAsname().(Name).getId() = modName and\n    // Retrieve doctest string in same scope\n    docString = doctest_in_scope(importDecl.getScope()) and\n    // Verify doctest contains module reference\n    docString.regexpMatch(\"[\\\\s\\\\S]*(>>>|\\\\.\\\\.\\\\.).*\" + modName + \"[\\\\s\\\\S]*\")\n  )\n}\n\n// pragma[noinline]: Extracts doctest string from given scope\npragma[noinline]\nprivate string doctest_in_scope(Scope scope) {\n  exists(StringLiteral docLiteralNode |\n    // Docstring must be in specified scope\n    docLiteralNode.getEnclosingModule() = scope and\n    docLiteralNode.isDocString() and\n    // Docstring text must contain doctest patterns\n    result = docLiteralNode.getText() and\n    result.regexpMatch(\"[\\\\s\\\\S]*(>>>|\\\\.\\\\.\\\\.)[\\\\s\\\\S]*\")\n  )\n}\n\n// pragma[noinline]: Extracts type hint annotations from module\npragma[noinline]\nprivate string typehint_annotation_in_module(Module mod) {\n  exists(StringLiteral typeHint |\n    // Type hints can come from arguments, annotated assignments, or function returns\n    (\n      typeHint = any(Arguments funcArgs).getAnAnnotation().getASubExpression*()\n      or\n      typeHint = any(AnnAssign annotatedAssign).getAnnotation().getASubExpression*()\n      or\n      typeHint = any(FunctionExpr functionExpr).getReturns().getASubExpression*()\n    ) and\n    // Annotation must point to string value (for forward references)\n    typeHint.pointsTo(Value::forString(result)) and\n    // Annotation must be in specified module\n    typeHint.getEnclosingModule() = mod\n  )\n}\n\n// pragma[noinline]: Retrieves type hint comments from file\npragma[noinline]\nprivate string typehint_comment_in_file(File sourceFile) {\n  exists(Comment hintComment |\n    // Comment must be in specified file\n    sourceFile = hintComment.getLocation().getFile() and\n    // Comment text must be type hint comment\n    result = hintComment.getText() and\n    result.matches(\"# type:%\")\n  )\n}\n\n/** Holds if imported alias is used in type hints within same file */\npredicate imported_alias_used_in_typehint(Import importDecl, Variable importedName) {\n  // Import alias must refer to specified variable\n  importDecl.getAName().getAsname().(Name).getVariable() = importedName and\n  exists(File sourceFile, Module mod |\n    // Get module and file from import declaration\n    mod = importDecl.getEnclosingModule() and\n    sourceFile = mod.getFile()\n  |\n    // Check if alias is used in type hint comment\n    typehint_comment_in_file(sourceFile).regexpMatch(\"# type:.*\" + importedName.getId() + \".*\")\n    or\n    // Check if alias is used in string annotation (forward references)\n    typehint_annotation_in_module(mod).regexpMatch(\".*\\\\b\" + importedName.getId() + \"\\\\b.*\")\n  )\n}\n\n// Identifies imports that are never referenced in the code\npredicate unused_import(Import importDecl, Variable importedName) {\n  // Import must have alias referring to specified variable\n  importDecl.getAName().getAsname().(Name).getVariable() = importedName and\n  // Exclude __future__ imports (special handling)\n  not importDecl.getAnImportedModuleName() = \"__future__\" and\n  // Import must be at module level\n  importDecl.getScope() = importDecl.getEnclosingModule() and\n  // Imported name not in module's __all__ (if analyzable)\n  not importDecl.getEnclosingModule().declaredInAll(importedName.getId()) and\n  // Name not used as global variable\n  not global_name_used(importDecl.getScope(), importedName.getId()) and\n  // Exclude imports in __init__.py files (package loading)\n  not importDecl.getEnclosingModule().isPackageInit() and\n  // Name not referenced in epytext documentation comments\n  not exists(Comment docComment | \n    docComment.getText().matches(\"%L{\" + importedName.getId() + \"}%\") and\n    docComment.getLocation().getFile() = importDecl.getLocation().getFile()\n  ) and\n  // Name not acceptable for unused variables (e.g., _)\n  not name_acceptable_for_unused_variable(importedName) and\n  // Module doesn't have unanalyzable __all__ (which might include name)\n  not all_not_understood(importDecl.getEnclosingModule()) and\n  // Imported module not used in doctests\n  not imported_module_used_in_doctest(importDecl) and\n  // Alias not used in type hints\n  not imported_alias_used_in_typehint(importDecl, importedName) and\n  // Import not a pytest fixture\n  not is_pytest_fixture(importDecl, importedName) and\n  // Import must resolve to something (not failed import)\n  importDecl.getAName().getValue().pointsTo(_)\n}\n\n// Query statement to identify unused imports\nfrom Stmt stmt, Variable importedName\nwhere unused_import(stmt, importedName)\nselect stmt, \"Import of '\" + importedName.getId() + \"' is not used.\""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/meta/alerts/remote-flow-sources]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Identifies sources of remote user input in Python code",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Remote flow sources\n * @description Identifies sources of remote user input in Python code\n * @kind problem\n * @problem.severity recommendation\n * @id py/meta/alerts/remote-flow-sources\n * @tags meta\n * @precision very-low\n */\n\n// Core Python analysis libraries\nprivate import python\n\n// Data flow tracking capabilities\nprivate import semmle.python.dataflow.new.DataFlow\n\n// Remote input source identification\nprivate import semmle.python.dataflow.new.RemoteFlowSources\n\n// Metadata collection and reporting\nprivate import meta.MetaMetrics\n\n// Identify all remote flow sources\nfrom RemoteFlowSource remoteSource\n\n// Exclude sources from ignored files\nwhere not remoteSource.getLocation().getFile() instanceof IgnoredFile\n\n// Report remote source with type description\nselect remoteSource, \"RemoteFlowSource: \" + remoteSource.getSourceType()"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak or unknown asymmetric padding\n * @description\n * Detects asymmetric encryption padding mechanisms that are either\n * cryptographically weak or not explicitly confirmed as secure.\n * \n * Proper padding is essential for asymmetric encryption security. This analysis\n * identifies padding schemes known to be vulnerable or not recognized as secure\n * methods. The query explicitly excludes approved padding techniques (OAEP, KEM, PSS)\n * which are cryptographically sound, and marks all other padding mechanisms as\n * potential security concerns.\n * \n * Employment of weak or unidentified padding schemes can result in security flaws\n * including padding oracle attacks, enabling attackers to decrypt encrypted data\n * without possessing the private key.\n * \n * @id py/weak-asymmetric-padding\n_______________ // 补全条件\n * @problem.severity error\n * @precision high\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Define the set of cryptographically approved padding methods\nstring approvedPaddingMethods() {\n  result = [\"OAEP\", \"KEM\", \"PSS\"]\n}\n\n// Identify asymmetric padding implementations using non-approved algorithms\nfrom AsymmetricPadding paddingImplementation, string paddingScheme\nwhere\n  // Extract the padding scheme name from the implementation\n  paddingScheme = paddingImplementation.getPaddingName()\n  // Verify the padding scheme is not in the approved methods list\n  and not paddingScheme = approvedPaddingMethods()\nselect paddingImplementation, \"Unapproved, weak, or unknown asymmetric padding algorithm detected: \" + paddingScheme",
    "output": "* @kind problem"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Unmatchable caret in regular expression\n * @description Detects regular expression patterns containing a caret ('^') \n *              symbol in positions other than the start of the pattern. \n *              Such carets are ineffective in standard regex matching modes.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/regex/unmatchable-caret\n */\n\nimport python\nimport semmle.python.regex\n_______________ // 补全条件\n// Define variables for the regex pattern and caret location\nfrom RegExp regexPattern, int caretLoc\n\n// Validate regex constraints and caret position\nwhere \n  // Exclude modes where caret has special meaning\n  not regexPattern.getAMode() = \"MULTILINE\" and\n  not regexPattern.getAMode() = \"VERBOSE\" and\n  // Verify caret presence and invalid position\n  regexPattern.specialCharacter(caretLoc, caretLoc + 1, \"^\") and\n  not regexPattern.firstItem(caretLoc, caretLoc + 1)\n\n// Generate diagnostic message with location details\nselect regexPattern,\n  \"Unmatchable caret found at position \" + caretLoc.toString() + \n  \" in this regular expression pattern.\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/undefined-placeholder-variable]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Detects placeholder variables used before initialization,",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Use of an undefined placeholder variable\n * @description Detects placeholder variables used before initialization,\n *              which may cause runtime exceptions when accessed.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision medium\n * @id py/undefined-placeholder-variable\n */\n\nimport python\nimport Variables.MonkeyPatched\n\n/**\n * Determines if a placeholder is properly initialized as a local variable\n * within its containing function scope.\n */\npredicate isInitializedAsLocal(PlaceHolder ph) {\n  exists(SsaVariable localVar, Function enclosingFunc |\n    enclosingFunc = ph.getScope() and\n    localVar.getAUse() = ph.getAFlowNode() and\n    localVar.getVariable() instanceof LocalVariable and\n    not localVar.maybeUndefined()\n  )\n}\n\n/**\n * Retrieves the class that contains the placeholder usage.\n */\nClass getEnclosingClass(PlaceHolder ph) {\n  result.getAMethod() = ph.getScope()\n}\n\n/**\n * Checks if a placeholder corresponds to a template attribute\n * defined within its enclosing class.\n */\npredicate isTemplateAttribute(PlaceHolder ph) {\n  exists(ImportTimeScope enclosingClassScope |\n    enclosingClassScope = getEnclosingClass(ph) and\n    enclosingClassScope.definesName(ph.getId())\n  )\n}\n\n/**\n * Verifies that a placeholder is neither a global variable,\n * monkey-patched builtin, nor globally defined name.\n */\npredicate isNotGlobalVariable(PlaceHolder ph) {\n  not exists(PythonModuleObject moduleObj |\n    moduleObj.hasAttribute(ph.getId()) and\n    moduleObj.getModule() = ph.getEnclosingModule()\n  ) and\n  not globallyDefinedName(ph.getId()) and\n  not monkey_patched_builtin(ph.getId())\n}\n\n// Main query identifying undefined placeholder variables\nfrom PlaceHolder ph\nwhere\n  not isInitializedAsLocal(ph) and\n  not isTemplateAttribute(ph) and\n  isNotGlobalVariable(ph)\nselect ph, \"This use of place-holder variable '\" + ph.getId() + \"' may be undefined.\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Result of integer division may be truncated\n * @description Detects division operations with integer operands that could truncate \n *              the result in Python 2 due to floor division behavior.\n * @kind problem\n * @tags maintainability\n *       correctness\n * @problem.severity warning\n * @sub-severity high\n_______________ // 补全条件\n * @id py/truncated-division\n */\n\nimport python\n\n// Find division operations that may truncate results in Python 2\nfrom BinaryExpr divExpr, ControlFlowNode leftOperand, ControlFlowNode rightOperand\nwhere\n  // Only applicable to Python 2 where integer division truncates\n  major_version() = 2 and\n  exists(BinaryExprNode divNode, Value leftInt, Value rightInt |\n    // Basic division operation identification\n    divNode = divExpr.getAFlowNode() and\n    divNode.getNode().getOp() instanceof Div and\n    \n    // Integer operand verification\n    divNode.getLeft().pointsTo(leftInt, leftOperand) and\n    leftInt.getClass() = ClassValue::int_() and\n    divNode.getRight().pointsTo(rightInt, rightOperand) and\n    rightInt.getClass() = ClassValue::int_() and\n    \n    // Filter out exact divisions (no remainder)\n    not leftInt.(NumericValue).getIntValue() % rightInt.(NumericValue).getIntValue() = 0 and\n    \n    // Exclusion criteria\n    not divNode.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    not exists(CallNode intCastCall |\n      intCastCall = ClassValue::int_().getACall() and\n      intCastCall.getAnArg() = divNode\n    )\n  )\nselect divExpr, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  leftOperand, \"left\", rightOperand, \"right\"",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Wrong name for an argument in a class instantiation\n * @description Using a named argument whose name does not correspond to a\n *              parameter of the __init__ method of the class being\n *              instantiated, will result in a TypeError at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n *       external/cwe/cwe-628\n * @problem.severity error\n * @sub-severity low\n_______________ // 补全条件\n * @id py/call/wrong-named-class-argument\n */\n\n// 导入Python库和表达式调用参数模块\nimport python\nimport Expressions.CallArgs\n\n// 从调用、类值、字符串名称和函数值中进行查询\nfrom Call call, ClassValue cls, string name, FunctionValue init\nwhere\n  // 检查是否存在非法命名的参数，并获取类的初始化方法\n  illegally_named_parameter(call, cls, name) and\n  init = get_function_or_initializer(cls)\nselect call, \"Keyword argument '\" + name + \"' is not a supported parameter name of $@.\", init,\n  // 选择调用、错误信息、初始化方法和其限定名\n  init.getQualifiedName()",
    "output": "* @precision very-high"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Type metrics\n * @description Quantifies different categories of type annotations in Python code\n * @kind table\n * @id py/type-metrics\n */\n\nimport python\n\n// Core Python built-in types\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\n// Union type for elements supporting type annotations\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr funcExpr) { exists(funcExpr.getReturns()) } or \n  TAnnotatedParameter(Parameter param) { exists(param.getAnnotation()) } or \n  TAnnotatedAssignment(AnnAssign annAssign) { exists(annAssign.getAnnotation()) }\n\n// Base class for elements with type annotations\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n  abstract Expr getAnnotation();\n}\n\n// Functions with return type annotations\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n_______________ // 补全条件\n  AnnotatedFunction() { this = TAnnotatedFunction(funcExpr) }\n  override Expr getAnnotation() { result = funcExpr.getReturns() }\n}\n\n// Parameters with type annotations\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter param;\n  AnnotatedParameter() { this = TAnnotatedParameter(param) }\n  override Expr getAnnotation() { result = param.getAnnotation() }\n}\n\n// Assignments with type annotations\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign annAssign;\n  AnnotatedAssignment() { this = TAnnotatedAssignment(annAssign) }\n  override Expr getAnnotation() { result = annAssign.getAnnotation() }\n}\n\n/** Check if annotation is a forward-declared type (string literal) */\npredicate is_forward_declaration(Expr annoExpr) { annoExpr instanceof StringLiteral }\n\n/** Check if annotation represents a complex type structure */\npredicate is_complex_type(Expr annoExpr) {\n  annoExpr instanceof Subscript and not is_optional_type(annoExpr)\n  or\n  annoExpr instanceof Tuple\n  or\n  annoExpr instanceof List\n}\n\n/** Check if annotation is an Optional type */\npredicate is_optional_type(Subscript annoExpr) { annoExpr.getObject().(Name).getId() = \"Optional\" }\n\n/** Check if annotation is a simple user-defined type */\npredicate is_simple_type(Expr annoExpr) {\n  annoExpr instanceof Name and not annoExpr instanceof BuiltinType\n  or\n  is_simple_type(annoExpr.(Attribute).getObject())\n}\n\n/** Check if annotation is a built-in type */\npredicate is_builtin_type(Expr annoExpr) { annoExpr instanceof BuiltinType }\n\n// Calculate type annotation metrics for different categories\npredicate type_count(\n  string category, int total, int builtin, int forward, \n  int simple, int complex, int optional\n) {\n  // Parameter annotations\n  category = \"Parameter annotation\" and\n  total = count(AnnotatedParameter annotatedParam) and\n  builtin = count(AnnotatedParameter annotatedParam | is_builtin_type(annotatedParam.getAnnotation())) and\n  forward = count(AnnotatedParameter annotatedParam | is_forward_declaration(annotatedParam.getAnnotation())) and\n  simple = count(AnnotatedParameter annotatedParam | is_simple_type(annotatedParam.getAnnotation())) and\n  complex = count(AnnotatedParameter annotatedParam | is_complex_type(annotatedParam.getAnnotation())) and\n  optional = count(AnnotatedParameter annotatedParam | is_optional_type(annotatedParam.getAnnotation()))\n  or\n  // Return type annotations\n  category = \"Return type annotation\" and\n  total = count(AnnotatedFunction annotatedFunc) and\n  builtin = count(AnnotatedFunction annotatedFunc | is_builtin_type(annotatedFunc.getAnnotation())) and\n  forward = count(AnnotatedFunction annotatedFunc | is_forward_declaration(annotatedFunc.getAnnotation())) and\n  simple = count(AnnotatedFunction annotatedFunc | is_simple_type(annotatedFunc.getAnnotation())) and\n  complex = count(AnnotatedFunction annotatedFunc | is_complex_type(annotatedFunc.getAnnotation())) and\n  optional = count(AnnotatedFunction annotatedFunc | is_optional_type(annotatedFunc.getAnnotation()))\n  or\n  // Annotated assignments\n  category = \"Annotated assignment\" and\n  total = count(AnnotatedAssignment annotatedAssign) and\n  builtin = count(AnnotatedAssignment annotatedAssign | is_builtin_type(annotatedAssign.getAnnotation())) and\n  forward = count(AnnotatedAssignment annotatedAssign | is_forward_declaration(annotatedAssign.getAnnotation())) and\n  simple = count(AnnotatedAssignment annotatedAssign | is_simple_type(annotatedAssign.getAnnotation())) and\n  complex = count(AnnotatedAssignment annotatedAssign | is_complex_type(annotatedAssign.getAnnotation())) and\n  optional = count(AnnotatedAssignment annotatedAssign | is_optional_type(annotatedAssign.getAnnotation()))\n}\n\n// Query execution and result projection\nfrom\n  string category, int total, int builtin, int forward, int simple, int complex, int optional\nwhere type_count(category, total, builtin, forward, simple, complex, optional)\nselect category, total, builtin, forward, simple, complex, optional",
    "output": "FunctionExpr funcExpr;"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Sub-optimal Pythagorean calculation with potential overflow\n * @description Detects hypotenuse calculations using standard formula (sqrt(a²+b²)) \n *              which may cause numerical overflow for large values\n * @kind problem\n * @tags accuracy\n * @problem.severity warning\n * @sub-severity low\n * @precision medium\n * @id py/pythagorean\n */\n\nimport python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n// Identifies expressions performing squaring operations\nDataFlow::ExprNode squareExprNode() {\n  exists(BinaryExpr binExpr | binExpr = result.asExpr() |\n    // Case 1: Exponentiation with power 2 (e.g., x**2)\n    (binExpr.getOp() instanceof Pow and binExpr.getRight().(IntegerLiteral).getN() = \"2\")\n    or\n    // Case 2: Self-multiplication (e.g., x*x)\n    (binExpr.getOp() instanceof Mult and \n     binExpr.getRight().(Name).getId() = binExpr.getLeft().(Name).getId())\n  )\n}\n_______________ // 补全条件\n// Main detection logic for vulnerable hypotenuse calculations\nfrom \n  DataFlow::CallCfgNode sqrtCall,       // math.sqrt() invocation site\n  BinaryExpr addExpr,                   // Addition expression within sqrt\n  DataFlow::ExprNode leftOperand,       // Left term of the addition\n  DataFlow::ExprNode rightOperand       // Right term of the addition\nwhere\n  // Verify math.sqrt call with addition argument\n  sqrtCall = API::moduleImport(\"math\").getMember(\"sqrt\").getACall() and\n  sqrtCall.getArg(0).asExpr() = addExpr and\n  \n  // Confirm addition operation between two squared terms\n  addExpr.getOp() instanceof Add and\n  leftOperand.asExpr() = addExpr.getLeft() and\n  rightOperand.asExpr() = addExpr.getRight() and\n  \n  // Both operands must originate from squaring operations\n  leftOperand.getALocalSource() = squareExprNode() and\n  rightOperand.getALocalSource() = squareExprNode()\nselect sqrtCall, \"Pythagorean calculation with sub-optimal numerics.\"",
    "output": ""
  },
  {
    "instruction": "[[TASK=GENERATE]] [[MODE=QL_ONLY]] [[LANG=python]] [[CWE=py/cookie-injection]] 你是一名资深 CodeQL 安全分析专家。目标：根据用户需求生成【可执行】的 CodeQL 查询。硬性规则：1) 仅输出 QL 代码，不要任何解释或注释；2) 代码需符合官方语义模型与模块导入；3) 语法正确、可直接执行。编写一个CodeQL查询：Constructing cookies using data from untrusted sources can lead to Cookie Poisoning vulnerabilities.",
    "input": "基于 CWE 的漏洞检测任务，请输出完整QL代码。",
    "output": "/**\n * @name Cookie creation with untrusted user input\n * @description Constructing cookies using data from untrusted sources can lead to Cookie Poisoning vulnerabilities.\n * @kind path-problem\n * @problem.severity warning\n * @precision high\n * @security-severity 5.0\n * @id py/cookie-injection\n * @tags security\n *       external/cwe/cwe-20\n */\n\n// Import core Python analysis libraries\nimport python\n\n// Import specialized security analysis module for Cookie injection detection\nimport semmle.python.security.dataflow.CookieInjectionQuery\n\n// Import path visualization module for data flow tracking\nimport CookieInjectionFlow::PathGraph\n\n// Identify data flow paths from untrusted inputs to cookie creation points\nfrom \n  CookieInjectionFlow::PathNode untrustedInputNode, \n  CookieInjectionFlow::PathNode cookieCreationNode\nwhere \n  // Verify data flow exists between untrusted source and cookie sink\n  CookieInjectionFlow::flowPath(untrustedInputNode, cookieCreationNode)\n// Report vulnerability with sink location, source location, flow path, and description\nselect \n  cookieCreationNode.getNode(), \n  untrustedInputNode, \n  cookieCreationNode, \n  \"Cookie is built using $@.\", \n  untrustedInputNode.getNode(), \n  \"untrusted user input\""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Membership test with a non-container\n * @description Identifies membership tests (e.g., 'item in sequence') where the right-hand side \n *              operand is a non-container object, which would result in a 'TypeError' at runtime.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity high\n * @precision high\n * @id py/member-test-non-container\n */\n\nimport python\nimport semmle.python.pointsto.PointsTo\n\nfrom \n  ControlFlowNode rightOperandNode, \n  Compare comparisonExpr, \n  Value targetValue, \n  ClassValue valueClass, \n  ControlFlowNode sourceNode\nwhere\n  // Identify right operand in membership test operations\n  exists(Cmpop op, int idx |\n    comparisonExpr.getOp(idx) = op and \n    comparisonExpr.getComparator(idx) = rightOperandNode.getNode() and\n    (op instanceof In or op instanceof NotIn)\n  ) and\n  \n  // Resolve the value and class of the right operand\n  rightOperandNode.pointsTo(_, targetValue, sourceNode) and\n  targetValue.getClass() = valueClass and\n_______________ // 补全条件\n  // Exclude cases where type inference failed\n  not Types::failedInference(valueClass, _) and\n  \n  // Verify the class lacks container capabilities\n  not valueClass.hasAttribute(\"__contains__\") and\n  not valueClass.hasAttribute(\"__iter__\") and\n  not valueClass.hasAttribute(\"__getitem__\") and\n  \n  // Exclude special container-like types\n  not valueClass = ClassValue::nonetype() and\n  not valueClass = Value::named(\"types.MappingProxyType\")\nselect \n  comparisonExpr, \n  \"This membership test may raise an Exception as the $@ might be of non-container class $@.\", \n  sourceNode, \"target\", valueClass, valueClass.getName()",
    "output": ""
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "_______________ // 补全条件\n * @name `__iter__` method returns a non-iterator\n * @description Detects classes returned by `__iter__` methods that don't implement the iterator protocol.\n *              Such classes cause 'TypeError' when used in iteration contexts like 'for' loops.\n * @kind problem\n * @tags reliability\n *       correctness\n * @problem.severity error\n * @sub-severity low\n * @precision high\n * @id py/iter-returns-non-iterator\n */\n\nimport python\n\nfrom ClassValue enclosingClass, FunctionValue iterMethod, ClassValue iterReturnType\nwhere\n  // Identify the __iter__ method in a container class\n  iterMethod = enclosingClass.lookup(\"__iter__\")\n  and\n  // Retrieve the inferred return type of the __iter__ method\n  iterReturnType = iterMethod.getAnInferredReturnType()\n  and\n  // Verify the return type lacks iterator implementation\n  not iterReturnType.isIterator()\nselect iterReturnType,\n  \"Class \" + iterReturnType.getName() + \n    \" is returned as an iterator (by $@) but does not fully implement the iterator interface.\",\n  iterMethod, iterMethod.getName()",
    "output": "/**"
  },
  {
    "instruction": "补全以下CodeQL查询。",
    "input": "/**\n * @name Weak block mode\n * @description Detects symmetric encryption using block modes that are considered weak, \n *              deprecated, or not approved for use in secure applications.\n * @id py/weak-block-mode\n * @kind problem\n * @problem.severity error\n * @precision high\n * @tags external/cwe/cwe-327\n */\n\nimport python\nimport experimental.cryptography.Concepts\n\n// Select encryption artifacts and their corresponding security alerts\nfrom CryptographicArtifact encryptionArtifact, string securityAlert\nwhere\n  // Exclude false positives from cryptography/hazmat paths\n  // Important: ECB mode is acceptable when used internally in keywrap operations\n  not encryptionArtifact.asExpr()\n      .getLocation()\n      .getFile()\n      .getAbsolutePath()\n      .toString()\n      .matches(\"%cryptography/hazmat/%\") and\n_______________ // 补全条件\n    // Check for BlockMode instances with security concerns\n    encryptionArtifact instanceof BlockMode and\n    // ECB mode is only permitted within KeyWrapOperation contexts\n    (encryptionArtifact.(BlockMode).getBlockModeName() = \"ECB\" implies \n     not encryptionArtifact instanceof KeyWrapOperation) and\n    exists(string modeName | \n      modeName = encryptionArtifact.(BlockMode).getBlockModeName() and\n      // Only CBC, CTS, and XTS modes are approved for general use\n      // Reference: https://liquid.microsoft.com/Web/Object/Read/MS.Security/Requirements/Microsoft.Security.Cryptography.10002\n      not modeName = [\"CBC\", \"CTS\", \"XTS\"] and\n      // Generate appropriate security alert based on the detected block mode\n      (\n        modeName = unknownAlgorithm() and\n        securityAlert = \"Use of unrecognized block mode algorithm.\"\n        or\n        modeName in [\"GCM\", \"CCM\"] and\n        securityAlert =\n          \"Use of block mode algorithm \" + modeName +\n            \" requires special crypto board approval/review.\"\n        or\n        securityAlert = \"Use of unapproved block mode algorithm or API \" + modeName + \".\"\n      )\n    )\n    or\n    // Check for SymmetricCipher instances lacking an explicit block mode specification\n    encryptionArtifact instanceof SymmetricCipher and\n    not encryptionArtifact.(SymmetricCipher).hasBlockMode() and\n    securityAlert = \"Cipher has unspecified block mode algorithm.\"\n  )\nselect encryptionArtifact, securityAlert",
    "output": "("
  }
]